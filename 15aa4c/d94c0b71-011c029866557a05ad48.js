(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[644],{9910:function(module,__unused_webpack_exports,__webpack_require__){eval('__webpack_require__(5438);\n\n/* MapLibre GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v1.15.0/LICENSE.txt */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  \'use strict\';\n  /* eslint-disable */\n\n  var shared, worker, maplibregl; // define gets called three times: one for each chunk. we rely on the order\n  // they\'re imported to know which is which\n\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \'var sharedChunk = {}; (\' + shared + \')(sharedChunk); (\' + worker + \')(sharedChunk);\';\n      var sharedChunk = {};\n      shared(sharedChunk);\n      maplibregl = chunk(sharedChunk);\n\n      if (typeof window !== \'undefined\') {\n        maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: \'text/javascript\'\n        }));\n      }\n    }\n  }\n\n  define(["exports"], function (t) {\n    "use strict";\n\n    function e(t, e) {\n      return t(e = {\n        exports: {}\n      }, e.exports), e.exports;\n    }\n\n    var r = n;\n\n    function n(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = r, this.p2y = n;\n    }\n\n    n.prototype.sampleCurveX = function (t) {\n      return ((this.ax * t + this.bx) * t + this.cx) * t;\n    }, n.prototype.sampleCurveY = function (t) {\n      return ((this.ay * t + this.by) * t + this.cy) * t;\n    }, n.prototype.sampleCurveDerivativeX = function (t) {\n      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n    }, n.prototype.solveCurveX = function (t, e) {\n      var r, n, i, a, o;\n\n      for (void 0 === e && (e = 1e-6), i = t, o = 0; o < 8; o++) {\n        if (a = this.sampleCurveX(i) - t, Math.abs(a) < e) return i;\n        var s = this.sampleCurveDerivativeX(i);\n        if (Math.abs(s) < 1e-6) break;\n        i -= a / s;\n      }\n\n      if ((i = t) < (r = 0)) return r;\n      if (i > (n = 1)) return n;\n\n      for (; r < n;) {\n        if (a = this.sampleCurveX(i), Math.abs(a - t) < e) return i;\n        t > a ? r = i : n = i, i = .5 * (n - r) + r;\n      }\n\n      return i;\n    }, n.prototype.solve = function (t, e) {\n      return this.sampleCurveY(this.solveCurveX(t, e));\n    };\n    var i = a;\n\n    function a(t, e) {\n      this.x = t, this.y = e;\n    }\n\n    a.prototype = {\n      clone: function clone() {\n        return new a(this.x, this.y);\n      },\n      add: function add(t) {\n        return this.clone()._add(t);\n      },\n      sub: function sub(t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function multByPoint(t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function divByPoint(t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function mult(t) {\n        return this.clone()._mult(t);\n      },\n      div: function div(t) {\n        return this.clone()._div(t);\n      },\n      rotate: function rotate(t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function rotateAround(t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function matMult(t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function unit() {\n        return this.clone()._unit();\n      },\n      perp: function perp() {\n        return this.clone()._perp();\n      },\n      round: function round() {\n        return this.clone()._round();\n      },\n      mag: function mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function equals(t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function dist(t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function distSqr(t) {\n        var e = t.x - this.x,\n            r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function angle() {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function angleTo(t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function angleWith(t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function angleWithSep(t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function _matMult(t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function _add(t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function _sub(t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function _mult(t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function _div(t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function _multByPoint(t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function _divByPoint(t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function _unit() {\n        return this._div(this.mag()), this;\n      },\n      _perp: function _perp() {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function _rotate(t) {\n        var e = Math.cos(t),\n            r = Math.sin(t),\n            n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function _rotateAround(t, e) {\n        var r = Math.cos(t),\n            n = Math.sin(t),\n            i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function _round() {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, a.convert = function (t) {\n      return t instanceof a ? t : Array.isArray(t) ? new a(t[0], t[1]) : t;\n    };\n    var o = "undefined" != typeof self ? self : {},\n        s = Math.pow(2, 53) - 1;\n\n    function u(t, e, n, i) {\n      var a = new r(t, e, n, i);\n      return function (t) {\n        return a.solve(t);\n      };\n    }\n\n    var l = u(.25, .1, .25, 1);\n\n    function p(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n\n    function c(t, e, r) {\n      var n = r - e,\n          i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n\n    function h(t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) {\n        e[r] = arguments[r + 1];\n      }\n\n      for (var n = 0, i = e; n < i.length; n += 1) {\n        var a = i[n];\n\n        for (var o in a) {\n          t[o] = a[o];\n        }\n      }\n\n      return t;\n    }\n\n    var f = 1;\n\n    function y() {\n      return f++;\n    }\n\n    function d() {\n      return function t(e) {\n        return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }\n\n    function m(t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }\n\n    function v(t, e) {\n      t.forEach(function (t) {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n\n    function g(t, e) {\n      return -1 !== t.indexOf(e, t.length - e.length);\n    }\n\n    function x(t, e, r) {\n      var n = {};\n\n      for (var i in t) {\n        n[i] = e.call(r || this, t[i], i, t);\n      }\n\n      return n;\n    }\n\n    function b(t, e, r) {\n      var n = {};\n\n      for (var i in t) {\n        e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n      }\n\n      return n;\n    }\n\n    function w(t) {\n      return Array.isArray(t) ? t.map(w) : "object" == typeof t && t ? x(t, w) : t;\n    }\n\n    var _ = {};\n\n    function A(t) {\n      _[t] || ("undefined" != typeof console && console.warn(t), _[t] = !0);\n    }\n\n    function S(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n\n    function k(t) {\n      for (var e = 0, r = 0, n = t.length, i = n - 1, a = void 0, o = void 0; r < n; i = r++) {\n        e += ((o = t[i]).x - (a = t[r]).x) * (a.y + o.y);\n      }\n\n      return e;\n    }\n\n    function I() {\n      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;\n    }\n\n    function z(t) {\n      var e = {};\n\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\"((?:[^"\\\\]|\\\\.)*)\\")))?/g, function (t, r, n, i) {\n        var a = n || i;\n        return e[r] = !a || a.toLowerCase(), "";\n      }), e["max-age"]) {\n        var r = parseInt(e["max-age"], 10);\n        isNaN(r) ? delete e["max-age"] : e["max-age"] = r;\n      }\n\n      return e;\n    }\n\n    var C = null;\n\n    function E(t) {\n      if (null == C) {\n        var e = t.navigator ? t.navigator.userAgent : null;\n        C = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match("Safari") && !e.match("Chrome")));\n      }\n\n      return C;\n    }\n\n    function P(t) {\n      try {\n        var e = o[t];\n        return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    var M,\n        B,\n        T,\n        V,\n        F = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date),\n        D = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame,\n        L = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame,\n        R = {\n      now: F,\n      frame: function frame(t) {\n        var e = D(t);\n        return {\n          cancel: function cancel() {\n            return L(e);\n          }\n        };\n      },\n      getImageData: function getImageData(t, e) {\n        void 0 === e && (e = 0);\n        var r = o.document.createElement("canvas"),\n            n = r.getContext("2d");\n        if (!n) throw new Error("failed to create canvas 2d context");\n        return r.width = t.width, r.height = t.height, n.drawImage(t, 0, 0, t.width, t.height), n.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);\n      },\n      resolveURL: function resolveURL(t) {\n        return M || (M = o.document.createElement("a")), M.href = t, M.href;\n      },\n      hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4,\n\n      get devicePixelRatio() {\n        return o.devicePixelRatio;\n      },\n\n      get prefersReducedMotion() {\n        return !!o.matchMedia && (null == B && (B = o.matchMedia("(prefers-reduced-motion: reduce)")), B.matches);\n      }\n\n    },\n        O = {\n      API_URL: "https://api.mapbox.com",\n\n      get EVENTS_URL() {\n        return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;\n      },\n\n      FEEDBACK_URL: "https://apps.mapbox.com/feedback",\n      REQUIRE_ACCESS_TOKEN: !0,\n      ACCESS_TOKEN: null,\n      MAX_PARALLEL_IMAGE_REQUESTS: 16,\n      REGISTERED_PROTOCOLS: {}\n    },\n        U = {\n      supported: !1,\n      testSupport: function testSupport(t) {\n        !j && V && (q ? N(t) : T = t);\n      }\n    },\n        j = !1,\n        q = !1;\n\n    function N(t) {\n      var e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, V), t.isContextLost()) return;\n        U.supported = !0;\n      } catch (t) {}\n\n      t.deleteTexture(e), j = !0;\n    }\n\n    o.document && ((V = o.document.createElement("img")).onload = function () {\n      T && N(T), T = null, q = !0;\n    }, V.onerror = function () {\n      j = !0, T = null;\n    }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");\n\n    var K = "01",\n        G = function G(t, e) {\n      this._transformRequestFn = t, this._customAccessToken = e, this._createSkuToken();\n    };\n\n    function Z(t) {\n      return 0 === t.indexOf("mapbox:");\n    }\n\n    G.prototype._createSkuToken = function () {\n      var t = function () {\n        for (var t = "", e = 0; e < 10; e++) {\n          t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];\n        }\n\n        return {\n          token: ["1", K, t].join(""),\n          tokenExpiresAt: Date.now() + 432e5\n        };\n      }();\n\n      this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;\n    }, G.prototype._isSkuTokenExpired = function () {\n      return Date.now() > this._skuTokenExpiresAt;\n    }, G.prototype.transformRequest = function (t, e) {\n      return this._transformRequestFn && this._transformRequestFn(t, e) || {\n        url: t\n      };\n    }, G.prototype.normalizeStyleURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/styles/v1" + r.path, this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeGlyphsURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/fonts/v1" + r.path, this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeSourceURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/v4/" + r.authority + ".json", r.params.push("secure"), this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeSpriteURL = function (t, e, r, n) {\n      var i = Y(t);\n      return Z(t) ? (i.path = "/styles/v1" + i.path + "/sprite" + e + r, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += "" + e + r, $(i));\n    }, G.prototype.normalizeTileURL = function (t, e) {\n      if (this._isSkuTokenExpired() && this._createSkuToken(), t && !Z(t)) return t;\n      var r = Y(t);\n      r.path = r.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, (R.devicePixelRatio >= 2 || 512 === e ? "@2x" : "") + (U.supported ? ".webp" : "$1")), r.path = r.path.replace(/^.+\\/v4\\//, "/"), r.path = "/v4" + r.path;\n\n      var n = this._customAccessToken || function (t) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          var n = r[e].match(/^access_token=(.*)$/);\n          if (n) return n[1];\n        }\n\n        return null;\n      }(r.params) || O.ACCESS_TOKEN;\n\n      return O.REQUIRE_ACCESS_TOKEN && n && this._skuToken && r.params.push("sku=" + this._skuToken), this._makeAPIURL(r, n);\n    }, G.prototype.canonicalizeTileURL = function (t, e) {\n      var r = Y(t);\n      if (!r.path.match(/(^\\/v4\\/)/) || !r.path.match(/\\.[\\w]+$/)) return t;\n      var n = "mapbox://tiles/";\n      n += r.path.replace("/v4/", "");\n      var i = r.params;\n      return e && (i = i.filter(function (t) {\n        return !t.match(/^access_token=/);\n      })), i.length && (n += "?" + i.join("&")), n;\n    }, G.prototype.canonicalizeTileset = function (t, e) {\n      for (var r = !!e && Z(e), n = [], i = 0, a = t.tiles || []; i < a.length; i += 1) {\n        var o = a[i];\n        J(o) ? n.push(this.canonicalizeTileURL(o, r)) : n.push(o);\n      }\n\n      return n;\n    }, G.prototype._makeAPIURL = function (t, e) {\n      var r = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",\n          n = Y(O.API_URL);\n\n      if (t.protocol = n.protocol, t.authority = n.authority, "http" === t.protocol) {\n        var i = t.params.indexOf("secure");\n        i >= 0 && t.params.splice(i, 1);\n      }\n\n      if ("/" !== n.path && (t.path = "" + n.path + t.path), !O.REQUIRE_ACCESS_TOKEN) return $(t);\n      if (!(e = e || O.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + r);\n      if ("s" === e[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + r);\n      return t.params = t.params.filter(function (t) {\n        return -1 === t.indexOf("access_token");\n      }), t.params.push("access_token=" + e), $(t);\n    }, G.prototype.setTransformRequest = function (t) {\n      this._transformRequestFn = t;\n    };\n    var X = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n\n    function J(t) {\n      return X.test(t);\n    }\n\n    var H = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n\n    function Y(t) {\n      var e = t.match(H);\n      if (!e) throw new Error("Unable to parse URL object");\n      return {\n        protocol: e[1],\n        authority: e[2],\n        path: e[3] || "/",\n        params: e[4] ? e[4].split("&") : []\n      };\n    }\n\n    function $(t) {\n      var e = t.params.length ? "?" + t.params.join("&") : "";\n      return t.protocol + "://" + t.authority + t.path + e;\n    }\n\n    function W(t) {\n      if (!t) return null;\n      var e = t.split(".");\n      if (!e || 3 !== e.length) return null;\n\n      try {\n        return JSON.parse(decodeURIComponent(o.atob(e[1]).split("").map(function (t) {\n          return "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2);\n        }).join("")));\n      } catch (t) {\n        return null;\n      }\n    }\n\n    var Q = function Q(t) {\n      this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n    };\n\n    Q.prototype.getStorageKey = function (t) {\n      var e,\n          r = W(O.ACCESS_TOKEN);\n      return e = r && r.u ? o.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, function (t, e) {\n        return String.fromCharCode(Number("0x" + e));\n      })) : O.ACCESS_TOKEN || "", t ? "mapbox.eventData." + t + ":" + e : "mapbox.eventData:" + e;\n    }, Q.prototype.fetchEventData = function () {\n      var t = P("localStorage"),\n          e = this.getStorageKey(),\n          r = this.getStorageKey("uuid");\n      if (t) try {\n        var n = o.localStorage.getItem(e);\n        n && (this.eventData = JSON.parse(n));\n        var i = o.localStorage.getItem(r);\n        i && (this.anonId = i);\n      } catch (t) {\n        A("Unable to read from LocalStorage");\n      }\n    }, Q.prototype.saveEventData = function () {\n      var t = P("localStorage"),\n          e = this.getStorageKey(),\n          r = this.getStorageKey("uuid");\n      if (t) try {\n        o.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e, JSON.stringify(this.eventData));\n      } catch (t) {\n        A("Unable to write to LocalStorage");\n      }\n    }, Q.prototype.processRequests = function (t) {}, Q.prototype.postEvent = function (t, e, r, n) {\n      var i = this;\n\n      if (O.EVENTS_URL) {\n        var a = Y(O.EVENTS_URL);\n        a.params.push("access_token=" + (n || O.ACCESS_TOKEN || ""));\n        var o = {\n          event: this.type,\n          created: new Date(t).toISOString(),\n          sdkIdentifier: "mapbox-gl-js",\n          sdkVersion: "1.15.0",\n          skuId: K,\n          userId: this.anonId\n        },\n            s = e ? h(o, e) : o,\n            u = {\n          url: $(a),\n          headers: {\n            "Content-Type": "text/plain"\n          },\n          body: JSON.stringify([s])\n        };\n        this.pendingRequest = _t(u, function (t) {\n          i.pendingRequest = null, r(t), i.saveEventData(), i.processRequests(n);\n        });\n      }\n    }, Q.prototype.queueRequest = function (t, e) {\n      this.queue.push(t), this.processRequests(e);\n    };\n\n    var tt,\n        et,\n        rt = function (t) {\n      function e() {\n        t.call(this, "map.load"), this.success = {}, this.skuToken = "";\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postMapLoadEvent = function (t, e, r, n) {\n        this.skuToken = r, (O.EVENTS_URL && n || O.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) {\n          return Z(t) || J(t);\n        })) && this.queueRequest({\n          id: e,\n          timestamp: Date.now()\n        }, n);\n      }, e.prototype.processRequests = function (t) {\n        var e = this;\n\n        if (!this.pendingRequest && 0 !== this.queue.length) {\n          var r = this.queue.shift(),\n              n = r.id,\n              i = r.timestamp;\n          n && this.success[n] || (this.anonId || this.fetchEventData(), m(this.anonId) || (this.anonId = d()), this.postEvent(i, {\n            skuToken: this.skuToken\n          }, function (t) {\n            t || n && (e.success[n] = !0);\n          }, t));\n        }\n      }, e;\n    }(Q),\n        nt = new (function (t) {\n      function e(e) {\n        t.call(this, "appUserTurnstile"), this._customAccessToken = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postTurnstileEvent = function (t, e) {\n        O.EVENTS_URL && O.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) {\n          return Z(t) || J(t);\n        }) && this.queueRequest(Date.now(), e);\n      }, e.prototype.processRequests = function (t) {\n        var e = this;\n\n        if (!this.pendingRequest && 0 !== this.queue.length) {\n          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n          var r = W(O.ACCESS_TOKEN),\n              n = r ? r.u : O.ACCESS_TOKEN,\n              i = n !== this.eventData.tokenU;\n          m(this.anonId) || (this.anonId = d(), i = !0);\n          var a = this.queue.shift();\n\n          if (this.eventData.lastSuccess) {\n            var o = new Date(this.eventData.lastSuccess),\n                s = new Date(a),\n                u = (a - this.eventData.lastSuccess) / 864e5;\n            i = i || u >= 1 || u < -1 || o.getDate() !== s.getDate();\n          } else i = !0;\n\n          if (!i) return this.processRequests();\n          this.postEvent(a, {\n            "enabled.telemetry": !1\n          }, function (t) {\n            t || (e.eventData.lastSuccess = a, e.eventData.tokenU = n);\n          }, t);\n        }\n      }, e;\n    }(Q))(),\n        it = nt.postTurnstileEvent.bind(nt),\n        at = new rt(),\n        ot = at.postMapLoadEvent.bind(at),\n        st = 500,\n        ut = 50;\n\n    function lt() {\n      o.caches && !tt && (tt = o.caches.open("mapbox-tiles"));\n    }\n\n    function pt(t) {\n      var e = t.indexOf("?");\n      return e < 0 ? t : t.slice(0, e);\n    }\n\n    var ct,\n        ht = 1 / 0;\n\n    function ft() {\n      return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct;\n    }\n\n    var yt = {\n      Unknown: "Unknown",\n      Style: "Style",\n      Source: "Source",\n      Tile: "Tile",\n      Glyphs: "Glyphs",\n      SpriteImage: "SpriteImage",\n      SpriteJSON: "SpriteJSON",\n      Image: "Image"\n    };\n    "function" == typeof Object.freeze && Object.freeze(yt);\n\n    var dt = function (t) {\n      function e(e, r, n) {\n        401 === r && J(n) && (e += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t.call(this, e), this.status = r, this.url = n, this.name = this.constructor.name, this.message = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.toString = function () {\n        return this.name + ": " + this.message + " (" + this.status + "): " + this.url;\n      }, e;\n    }(Error),\n        mt = I() ? function () {\n      return self.worker && self.worker.referrer;\n    } : function () {\n      return ("blob:" === o.location.protocol ? o.parent : o).location.href;\n    };\n\n    function vt(t, e) {\n      var r,\n          n = new o.AbortController(),\n          i = new o.Request(t.url, {\n        method: t.method || "GET",\n        body: t.body,\n        credentials: t.credentials,\n        headers: t.headers,\n        referrer: mt(),\n        signal: n.signal\n      }),\n          a = !1,\n          s = !1,\n          u = (r = i.url).indexOf("sku=") > 0 && J(r);\n      "json" === t.type && i.headers.set("Accept", "application/json");\n\n      var l = function l(r, n, a) {\n        if (!s) {\n          if (r && "SecurityError" !== r.message && A(r), n && a) return p(n);\n          var l = Date.now();\n          o.fetch(i).then(function (r) {\n            if (r.ok) {\n              var n = u ? r.clone() : null;\n              return p(r, n, l);\n            }\n\n            return e(new dt(r.statusText, r.status, t.url));\n          }).catch(function (t) {\n            20 !== t.code && e(new Error(t.message));\n          });\n        }\n      },\n          p = function p(r, n, u) {\n        ("arrayBuffer" === t.type ? r.arrayBuffer() : "json" === t.type ? r.json() : r.text()).then(function (t) {\n          s || (n && u && function (t, e, r) {\n            if (lt(), tt) {\n              var n = {\n                status: e.status,\n                statusText: e.statusText,\n                headers: new o.Headers()\n              };\n              e.headers.forEach(function (t, e) {\n                return n.headers.set(e, t);\n              });\n              var i = z(e.headers.get("Cache-Control") || "");\n              i["no-store"] || (i["max-age"] && n.headers.set("Expires", new Date(r + 1e3 * i["max-age"]).toUTCString()), new Date(n.headers.get("Expires")).getTime() - r < 42e4 || function (t, e) {\n                if (void 0 === et) try {\n                  new Response(new ReadableStream()), et = !0;\n                } catch (t) {\n                  et = !1;\n                }\n                et ? e(t.body) : t.blob().then(e);\n              }(e, function (e) {\n                var r = new o.Response(e, n);\n                lt(), tt && tt.then(function (e) {\n                  return e.put(pt(t.url), r);\n                }).catch(function (t) {\n                  return A(t.message);\n                });\n              }));\n            }\n          }(i, n, u), a = !0, e(null, t, r.headers.get("Cache-Control"), r.headers.get("Expires")));\n        }).catch(function (t) {\n          s || e(new Error(t.message));\n        });\n      };\n\n      return u ? function (t, e) {\n        if (lt(), !tt) return e(null);\n        var r = pt(t.url);\n        tt.then(function (t) {\n          t.match(r).then(function (n) {\n            var i = function (t) {\n              if (!t) return !1;\n              var e = new Date(t.headers.get("Expires") || 0),\n                  r = z(t.headers.get("Cache-Control") || "");\n              return e > Date.now() && !r["no-cache"];\n            }(n);\n\n            t.delete(r), i && t.put(r, n.clone()), e(null, n, i);\n          }).catch(e);\n        }).catch(e);\n      }(i, l) : l(null, null), {\n        cancel: function cancel() {\n          s = !0, a || n.abort();\n        }\n      };\n    }\n\n    var gt,\n        xt,\n        bt = function bt(t, e) {\n      if (/:\\/\\//.test(t.url) && !/^https?:|^file:/.test(t.url)) {\n        if (I() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e);\n\n        if (!I()) {\n          var r = t.url.substring(0, t.url.indexOf("://"));\n          return (O.REGISTERED_PROTOCOLS[r] || vt)(t, e);\n        }\n      }\n\n      if (!(/^file:/.test(n = t.url) || /^file:/.test(mt()) && !/^\\w+:/.test(n))) {\n        if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal")) return vt(t, e);\n        if (I() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0);\n      }\n\n      var n;\n      return function (t, e) {\n        var r = new o.XMLHttpRequest();\n\n        for (var n in r.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (r.responseType = "arraybuffer"), t.headers) {\n          r.setRequestHeader(n, t.headers[n]);\n        }\n\n        return "json" === t.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t.credentials, r.onerror = function () {\n          e(new Error(r.statusText));\n        }, r.onload = function () {\n          if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n            var n = r.response;\n            if ("json" === t.type) try {\n              n = JSON.parse(r.response);\n            } catch (t) {\n              return e(t);\n            }\n            e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));\n          } else e(new dt(r.statusText, r.status, t.url));\n        }, r.send(t.body), {\n          cancel: function cancel() {\n            return r.abort();\n          }\n        };\n      }(t, e);\n    },\n        wt = function wt(t, e) {\n      return bt(h(t, {\n        type: "arrayBuffer"\n      }), e);\n    },\n        _t = function _t(t, e) {\n      return bt(h(t, {\n        method: "POST"\n      }), e);\n    },\n        At = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";\n\n    gt = [], xt = 0;\n\n    var St = function St(t, e) {\n      if (U.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), xt >= O.MAX_PARALLEL_IMAGE_REQUESTS) {\n        var r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n          cancel: function cancel() {\n            this.cancelled = !0;\n          }\n        };\n        return gt.push(r), r;\n      }\n\n      xt++;\n\n      var n = !1,\n          i = function i() {\n        if (!n) for (n = !0, xt--; gt.length && xt < O.MAX_PARALLEL_IMAGE_REQUESTS;) {\n          var t = gt.shift();\n          t.cancelled || (t.cancel = St(t.requestParameters, t.callback).cancel);\n        }\n      },\n          a = wt(t, function (t, r, n, a) {\n        i(), t ? e(t) : r && (ft() ? function (t, e) {\n          var r = new o.Blob([new Uint8Array(t)], {\n            type: "image/png"\n          });\n          o.createImageBitmap(r).then(function (t) {\n            e(null, t);\n          }).catch(function (t) {\n            e(new Error("Could not load image because of " + t.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));\n          });\n        }(r, e) : function (t, e, r, n) {\n          var i = new o.Image(),\n              a = o.URL;\n          i.onload = function () {\n            e(null, i), a.revokeObjectURL(i.src), i.onload = null, o.requestAnimationFrame(function () {\n              i.src = At;\n            });\n          }, i.onerror = function () {\n            return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));\n          };\n          var s = new o.Blob([new Uint8Array(t)], {\n            type: "image/png"\n          });\n          i.cacheControl = r, i.expires = n, i.src = t.byteLength ? a.createObjectURL(s) : At;\n        }(r, e, n, a));\n      });\n\n      return {\n        cancel: function cancel() {\n          a.cancel(), i();\n        }\n      };\n    };\n\n    function kt(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n\n    function It(t, e, r) {\n      if (r && r[t]) {\n        var n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n\n    var zt = function zt(t, e) {\n      void 0 === e && (e = {}), h(this, e), this.type = t;\n    },\n        Ct = function (t) {\n      function e(e, r) {\n        void 0 === r && (r = {}), t.call(this, "error", h({\n          error: e\n        }, r));\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(zt),\n        Et = function Et() {};\n\n    Et.prototype.on = function (t, e) {\n      return this._listeners = this._listeners || {}, kt(t, e, this._listeners), this;\n    }, Et.prototype.off = function (t, e) {\n      return It(t, e, this._listeners), It(t, e, this._oneTimeListeners), this;\n    }, Et.prototype.once = function (t, e) {\n      return this._oneTimeListeners = this._oneTimeListeners || {}, kt(t, e, this._oneTimeListeners), this;\n    }, Et.prototype.fire = function (t, e) {\n      "string" == typeof t && (t = new zt(t, e || {}));\n      var r = t.type;\n\n      if (this.listens(r)) {\n        t.target = this;\n\n        for (var n = 0, i = this._listeners && this._listeners[r] ? this._listeners[r].slice() : []; n < i.length; n += 1) {\n          i[n].call(this, t);\n        }\n\n        for (var a = 0, o = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : []; a < o.length; a += 1) {\n          var s = o[a];\n          It(r, s, this._oneTimeListeners), s.call(this, t);\n        }\n\n        var u = this._eventedParent;\n        u && (h(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u.fire(t));\n      } else t instanceof Ct && console.error(t.error);\n\n      return this;\n    }, Et.prototype.listens = function (t) {\n      return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);\n    }, Et.prototype.setEventedParent = function (t, e) {\n      return this._eventedParent = t, this._eventedParentData = e, this;\n    };\n\n    var Pt = {\n      $version: 8,\n      $root: {\n        version: {\n          required: !0,\n          type: "enum",\n          values: [8]\n        },\n        name: {\n          type: "string"\n        },\n        metadata: {\n          type: "*"\n        },\n        center: {\n          type: "array",\n          value: "number"\n        },\n        zoom: {\n          type: "number"\n        },\n        bearing: {\n          type: "number",\n          default: 0,\n          period: 360,\n          units: "degrees"\n        },\n        pitch: {\n          type: "number",\n          default: 0,\n          units: "degrees"\n        },\n        light: {\n          type: "light"\n        },\n        sources: {\n          required: !0,\n          type: "sources"\n        },\n        sprite: {\n          type: "string"\n        },\n        glyphs: {\n          type: "string"\n        },\n        transition: {\n          type: "transition"\n        },\n        layers: {\n          required: !0,\n          type: "array",\n          value: "layer"\n        }\n      },\n      sources: {\n        "*": {\n          type: "source"\n        }\n      },\n      source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],\n      source_vector: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            vector: {}\n          }\n        },\n        url: {\n          type: "string"\n        },\n        tiles: {\n          type: "array",\n          value: "string"\n        },\n        bounds: {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        scheme: {\n          type: "enum",\n          values: {\n            xyz: {},\n            tms: {}\n          },\n          default: "xyz"\n        },\n        minzoom: {\n          type: "number",\n          default: 0\n        },\n        maxzoom: {\n          type: "number",\n          default: 22\n        },\n        attribution: {\n          type: "string"\n        },\n        promoteId: {\n          type: "promoteId"\n        },\n        volatile: {\n          type: "boolean",\n          default: !1\n        },\n        "*": {\n          type: "*"\n        }\n      },\n      source_raster: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            raster: {}\n          }\n        },\n        url: {\n          type: "string"\n        },\n        tiles: {\n          type: "array",\n          value: "string"\n        },\n        bounds: {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        minzoom: {\n          type: "number",\n          default: 0\n        },\n        maxzoom: {\n          type: "number",\n          default: 22\n        },\n        tileSize: {\n          type: "number",\n          default: 512,\n          units: "pixels"\n        },\n        scheme: {\n          type: "enum",\n          values: {\n            xyz: {},\n            tms: {}\n          },\n          default: "xyz"\n        },\n        attribution: {\n          type: "string"\n        },\n        volatile: {\n          type: "boolean",\n          default: !1\n        },\n        "*": {\n          type: "*"\n        }\n      },\n      source_raster_dem: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            "raster-dem": {}\n          }\n        },\n        url: {\n          type: "string"\n        },\n        tiles: {\n          type: "array",\n          value: "string"\n        },\n        bounds: {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        minzoom: {\n          type: "number",\n          default: 0\n        },\n        maxzoom: {\n          type: "number",\n          default: 22\n        },\n        tileSize: {\n          type: "number",\n          default: 512,\n          units: "pixels"\n        },\n        attribution: {\n          type: "string"\n        },\n        encoding: {\n          type: "enum",\n          values: {\n            terrarium: {},\n            mapbox: {}\n          },\n          default: "mapbox"\n        },\n        volatile: {\n          type: "boolean",\n          default: !1\n        },\n        "*": {\n          type: "*"\n        }\n      },\n      source_geojson: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            geojson: {}\n          }\n        },\n        data: {\n          type: "*"\n        },\n        maxzoom: {\n          type: "number",\n          default: 18\n        },\n        attribution: {\n          type: "string"\n        },\n        buffer: {\n          type: "number",\n          default: 128,\n          maximum: 512,\n          minimum: 0\n        },\n        filter: {\n          type: "*"\n        },\n        tolerance: {\n          type: "number",\n          default: .375\n        },\n        cluster: {\n          type: "boolean",\n          default: !1\n        },\n        clusterRadius: {\n          type: "number",\n          default: 50,\n          minimum: 0\n        },\n        clusterMaxZoom: {\n          type: "number"\n        },\n        clusterMinPoints: {\n          type: "number"\n        },\n        clusterProperties: {\n          type: "*"\n        },\n        lineMetrics: {\n          type: "boolean",\n          default: !1\n        },\n        generateId: {\n          type: "boolean",\n          default: !1\n        },\n        promoteId: {\n          type: "promoteId"\n        }\n      },\n      source_video: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            video: {}\n          }\n        },\n        urls: {\n          required: !0,\n          type: "array",\n          value: "string"\n        },\n        coordinates: {\n          required: !0,\n          type: "array",\n          length: 4,\n          value: {\n            type: "array",\n            length: 2,\n            value: "number"\n          }\n        }\n      },\n      source_image: {\n        type: {\n          required: !0,\n          type: "enum",\n          values: {\n            image: {}\n          }\n        },\n        url: {\n          required: !0,\n          type: "string"\n        },\n        coordinates: {\n          required: !0,\n          type: "array",\n          length: 4,\n          value: {\n            type: "array",\n            length: 2,\n            value: "number"\n          }\n        }\n      },\n      layer: {\n        id: {\n          type: "string",\n          required: !0\n        },\n        type: {\n          type: "enum",\n          values: {\n            fill: {},\n            line: {},\n            symbol: {},\n            circle: {},\n            heatmap: {},\n            "fill-extrusion": {},\n            raster: {},\n            hillshade: {},\n            background: {}\n          },\n          required: !0\n        },\n        metadata: {\n          type: "*"\n        },\n        source: {\n          type: "string"\n        },\n        "source-layer": {\n          type: "string"\n        },\n        minzoom: {\n          type: "number",\n          minimum: 0,\n          maximum: 24\n        },\n        maxzoom: {\n          type: "number",\n          minimum: 0,\n          maximum: 24\n        },\n        filter: {\n          type: "filter"\n        },\n        layout: {\n          type: "layout"\n        },\n        paint: {\n          type: "paint"\n        }\n      },\n      layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"],\n      layout_background: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_fill: {\n        "fill-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_circle: {\n        "circle-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_heatmap: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      "layout_fill-extrusion": {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_line: {\n        "line-cap": {\n          type: "enum",\n          values: {\n            butt: {},\n            round: {},\n            square: {}\n          },\n          default: "butt",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-join": {\n          type: "enum",\n          values: {\n            bevel: {},\n            round: {},\n            miter: {}\n          },\n          default: "miter",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-miter-limit": {\n          type: "number",\n          default: 2,\n          requires: [{\n            "line-join": "miter"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-round-limit": {\n          type: "number",\n          default: 1.05,\n          requires: [{\n            "line-join": "round"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_symbol: {\n        "symbol-placement": {\n          type: "enum",\n          values: {\n            point: {},\n            line: {},\n            "line-center": {}\n          },\n          default: "point",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "symbol-spacing": {\n          type: "number",\n          default: 250,\n          minimum: 1,\n          units: "pixels",\n          requires: [{\n            "symbol-placement": "line"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "symbol-avoid-edges": {\n          type: "boolean",\n          default: !1,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "symbol-sort-key": {\n          type: "number",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "symbol-z-order": {\n          type: "enum",\n          values: {\n            auto: {},\n            "viewport-y": {},\n            source: {}\n          },\n          default: "auto",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-allow-overlap": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-ignore-placement": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-optional": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image", "text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-rotation-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-size": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          units: "factor of the original icon size",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-text-fit": {\n          type: "enum",\n          values: {\n            none: {},\n            width: {},\n            height: {},\n            both: {}\n          },\n          default: "none",\n          requires: ["icon-image", "text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-text-fit-padding": {\n          type: "array",\n          value: "number",\n          length: 4,\n          default: [0, 0, 0, 0],\n          units: "pixels",\n          requires: ["icon-image", "text-field", {\n            "icon-text-fit": ["both", "width", "height"]\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-image": {\n          type: "resolvedImage",\n          tokens: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-rotate": {\n          type: "number",\n          default: 0,\n          period: 360,\n          units: "degrees",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-padding": {\n          type: "number",\n          default: 2,\n          minimum: 0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-keep-upright": {\n          type: "boolean",\n          default: !1,\n          requires: ["icon-image", {\n            "icon-rotation-alignment": "map"\n          }, {\n            "symbol-placement": ["line", "line-center"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-offset": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-anchor": {\n          type: "enum",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            "top-left": {},\n            "top-right": {},\n            "bottom-left": {},\n            "bottom-right": {}\n          },\n          default: "center",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-pitch-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-pitch-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-rotation-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: "auto",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-field": {\n          type: "formatted",\n          default: "",\n          tokens: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-font": {\n          type: "array",\n          value: "string",\n          default: ["Open Sans Regular", "Arial Unicode MS Regular"],\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-size": {\n          type: "number",\n          default: 16,\n          minimum: 0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-max-width": {\n          type: "number",\n          default: 10,\n          minimum: 0,\n          units: "ems",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-line-height": {\n          type: "number",\n          default: 1.2,\n          units: "ems",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-letter-spacing": {\n          type: "number",\n          default: 0,\n          units: "ems",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-justify": {\n          type: "enum",\n          values: {\n            auto: {},\n            left: {},\n            center: {},\n            right: {}\n          },\n          default: "center",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-radial-offset": {\n          type: "number",\n          units: "ems",\n          default: 0,\n          requires: ["text-field"],\n          "property-type": "data-driven",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          }\n        },\n        "text-variable-anchor": {\n          type: "array",\n          value: "enum",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            "top-left": {},\n            "top-right": {},\n            "bottom-left": {},\n            "bottom-right": {}\n          },\n          requires: ["text-field", {\n            "symbol-placement": ["point"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-anchor": {\n          type: "enum",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            "top-left": {},\n            "top-right": {},\n            "bottom-left": {},\n            "bottom-right": {}\n          },\n          default: "center",\n          requires: ["text-field", {\n            "!": "text-variable-anchor"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-max-angle": {\n          type: "number",\n          default: 45,\n          units: "degrees",\n          requires: ["text-field", {\n            "symbol-placement": ["line", "line-center"]\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-writing-mode": {\n          type: "array",\n          value: "enum",\n          values: {\n            horizontal: {},\n            vertical: {}\n          },\n          requires: ["text-field", {\n            "symbol-placement": ["point"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-rotate": {\n          type: "number",\n          default: 0,\n          period: 360,\n          units: "degrees",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-padding": {\n          type: "number",\n          default: 2,\n          minimum: 0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-keep-upright": {\n          type: "boolean",\n          default: !0,\n          requires: ["text-field", {\n            "text-rotation-alignment": "map"\n          }, {\n            "symbol-placement": ["line", "line-center"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-transform": {\n          type: "enum",\n          values: {\n            none: {},\n            uppercase: {},\n            lowercase: {}\n          },\n          default: "none",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-offset": {\n          type: "array",\n          value: "number",\n          units: "ems",\n          length: 2,\n          default: [0, 0],\n          requires: ["text-field", {\n            "!": "text-radial-offset"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-allow-overlap": {\n          type: "boolean",\n          default: !1,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-ignore-placement": {\n          type: "boolean",\n          default: !1,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-optional": {\n          type: "boolean",\n          default: !1,\n          requires: ["text-field", "icon-image"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_raster: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      layout_hillshade: {\n        visibility: {\n          type: "enum",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: "visible",\n          "property-type": "constant"\n        }\n      },\n      filter: {\n        type: "array",\n        value: "*"\n      },\n      filter_operator: {\n        type: "enum",\n        values: {\n          "==": {},\n          "!=": {},\n          ">": {},\n          ">=": {},\n          "<": {},\n          "<=": {},\n          in: {},\n          "!in": {},\n          all: {},\n          any: {},\n          none: {},\n          has: {},\n          "!has": {},\n          within: {}\n        }\n      },\n      geometry_type: {\n        type: "enum",\n        values: {\n          Point: {},\n          LineString: {},\n          Polygon: {}\n        }\n      },\n      function: {\n        expression: {\n          type: "expression"\n        },\n        stops: {\n          type: "array",\n          value: "function_stop"\n        },\n        base: {\n          type: "number",\n          default: 1,\n          minimum: 0\n        },\n        property: {\n          type: "string",\n          default: "$zoom"\n        },\n        type: {\n          type: "enum",\n          values: {\n            identity: {},\n            exponential: {},\n            interval: {},\n            categorical: {}\n          },\n          default: "exponential"\n        },\n        colorSpace: {\n          type: "enum",\n          values: {\n            rgb: {},\n            lab: {},\n            hcl: {}\n          },\n          default: "rgb"\n        },\n        default: {\n          type: "*",\n          required: !1\n        }\n      },\n      function_stop: {\n        type: "array",\n        minimum: 0,\n        maximum: 24,\n        value: ["number", "color"],\n        length: 2\n      },\n      expression: {\n        type: "array",\n        value: "*",\n        minimum: 1\n      },\n      light: {\n        anchor: {\n          type: "enum",\n          default: "viewport",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          "property-type": "data-constant",\n          transition: !1,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          }\n        },\n        position: {\n          type: "array",\n          default: [1.15, 210, 30],\n          length: 3,\n          value: "number",\n          "property-type": "data-constant",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          }\n        },\n        color: {\n          type: "color",\n          "property-type": "data-constant",\n          default: "#ffffff",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          transition: !0\n        },\n        intensity: {\n          type: "number",\n          "property-type": "data-constant",\n          default: .5,\n          minimum: 0,\n          maximum: 1,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          transition: !0\n        }\n      },\n      paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"],\n      paint_fill: {\n        "fill-antialias": {\n          type: "boolean",\n          default: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "fill-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-outline-color": {\n          type: "color",\n          transition: !0,\n          requires: [{\n            "!": "fill-pattern"\n          }, {\n            "fill-antialias": !0\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["fill-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "cross-faded-data-driven"\n        }\n      },\n      "paint_fill-extrusion": {\n        "fill-extrusion-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-extrusion-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "fill-extrusion-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-extrusion-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-extrusion-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["fill-extrusion-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "fill-extrusion-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "cross-faded-data-driven"\n        },\n        "fill-extrusion-height": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          units: "meters",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-extrusion-base": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          units: "meters",\n          transition: !0,\n          requires: ["fill-extrusion-height"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "fill-extrusion-vertical-gradient": {\n          type: "boolean",\n          default: !0,\n          transition: !1,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_line: {\n        "line-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "line-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["line-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "line-width": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-gap-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-offset": {\n          type: "number",\n          default: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-blur": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "line-dasharray": {\n          type: "array",\n          value: "number",\n          minimum: 0,\n          transition: !0,\n          units: "line widths",\n          requires: [{\n            "!": "line-pattern"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "cross-faded"\n        },\n        "line-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom", "feature"]\n          },\n          "property-type": "cross-faded-data-driven"\n        },\n        "line-gradient": {\n          type: "color",\n          transition: !1,\n          requires: [{\n            "!": "line-dasharray"\n          }, {\n            "!": "line-pattern"\n          }, {\n            source: "geojson",\n            has: {\n              lineMetrics: !0\n            }\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["line-progress"]\n          },\n          "property-type": "color-ramp"\n        }\n      },\n      paint_circle: {\n        "circle-radius": {\n          type: "number",\n          default: 5,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-blur": {\n          type: "number",\n          default: 0,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["circle-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-pitch-scale": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-pitch-alignment": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "viewport",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "circle-stroke-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-stroke-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "circle-stroke-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        }\n      },\n      paint_heatmap: {\n        "heatmap-radius": {\n          type: "number",\n          default: 30,\n          minimum: 1,\n          transition: !0,\n          units: "pixels",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "heatmap-weight": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "heatmap-intensity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "heatmap-color": {\n          type: "color",\n          default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: ["heatmap-density"]\n          },\n          "property-type": "color-ramp"\n        },\n        "heatmap-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_symbol: {\n        "icon-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-halo-color": {\n          type: "color",\n          default: "rgba(0, 0, 0, 0)",\n          transition: !0,\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-halo-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-halo-blur": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "icon-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          requires: ["icon-image"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "icon-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["icon-image", "icon-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          overridable: !0,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-halo-color": {\n          type: "color",\n          default: "rgba(0, 0, 0, 0)",\n          transition: !0,\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-halo-width": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-halo-blur": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom", "feature", "feature-state"]\n          },\n          "property-type": "data-driven"\n        },\n        "text-translate": {\n          type: "array",\n          value: "number",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: "pixels",\n          requires: ["text-field"],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "text-translate-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "map",\n          requires: ["text-field", "text-translate"],\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_raster: {\n        "raster-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-hue-rotate": {\n          type: "number",\n          default: 0,\n          period: 360,\n          transition: !0,\n          units: "degrees",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-brightness-min": {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-brightness-max": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-saturation": {\n          type: "number",\n          default: 0,\n          minimum: -1,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-contrast": {\n          type: "number",\n          default: 0,\n          minimum: -1,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-resampling": {\n          type: "enum",\n          values: {\n            linear: {},\n            nearest: {}\n          },\n          default: "linear",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "raster-fade-duration": {\n          type: "number",\n          default: 300,\n          minimum: 0,\n          transition: !1,\n          units: "milliseconds",\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_hillshade: {\n        "hillshade-illumination-direction": {\n          type: "number",\n          default: 335,\n          minimum: 0,\n          maximum: 359,\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-illumination-anchor": {\n          type: "enum",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: "viewport",\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-exaggeration": {\n          type: "number",\n          default: .5,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-shadow-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-highlight-color": {\n          type: "color",\n          default: "#FFFFFF",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "hillshade-accent-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      paint_background: {\n        "background-color": {\n          type: "color",\n          default: "#000000",\n          transition: !0,\n          requires: [{\n            "!": "background-pattern"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        },\n        "background-pattern": {\n          type: "resolvedImage",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: ["zoom"]\n          },\n          "property-type": "cross-faded"\n        },\n        "background-opacity": {\n          type: "number",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: ["zoom"]\n          },\n          "property-type": "data-constant"\n        }\n      },\n      transition: {\n        duration: {\n          type: "number",\n          default: 300,\n          minimum: 0,\n          units: "milliseconds"\n        },\n        delay: {\n          type: "number",\n          default: 0,\n          minimum: 0,\n          units: "milliseconds"\n        }\n      },\n      "property-type": {\n        "data-driven": {\n          type: "property-type"\n        },\n        "cross-faded": {\n          type: "property-type"\n        },\n        "cross-faded-data-driven": {\n          type: "property-type"\n        },\n        "color-ramp": {\n          type: "property-type"\n        },\n        "data-constant": {\n          type: "property-type"\n        },\n        constant: {\n          type: "property-type"\n        }\n      },\n      promoteId: {\n        "*": {\n          type: "string"\n        }\n      }\n    },\n        Mt = function Mt(t, e, r, n) {\n      this.message = (t ? t + ": " : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n    };\n\n    function Bt(t) {\n      var e = t.value;\n      return e ? [new Mt(t.key, e, "constants have been deprecated as of v8")] : [];\n    }\n\n    function Tt(t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) {\n        e[r] = arguments[r + 1];\n      }\n\n      for (var n = 0, i = e; n < i.length; n += 1) {\n        var a = i[n];\n\n        for (var o in a) {\n          t[o] = a[o];\n        }\n      }\n\n      return t;\n    }\n\n    function Vt(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n\n    function Ft(t) {\n      if (Array.isArray(t)) return t.map(Ft);\n\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        var e = {};\n\n        for (var r in t) {\n          e[r] = Ft(t[r]);\n        }\n\n        return e;\n      }\n\n      return Vt(t);\n    }\n\n    var Dt = function (t) {\n      function e(e, r) {\n        t.call(this, r), this.message = r, this.key = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(Error),\n        Lt = function Lt(t, e) {\n      void 0 === e && (e = []), this.parent = t, this.bindings = {};\n\n      for (var r = 0, n = e; r < n.length; r += 1) {\n        var i = n[r];\n        this.bindings[i[0]] = i[1];\n      }\n    };\n\n    Lt.prototype.concat = function (t) {\n      return new Lt(this, t);\n    }, Lt.prototype.get = function (t) {\n      if (this.bindings[t]) return this.bindings[t];\n      if (this.parent) return this.parent.get(t);\n      throw new Error(t + " not found in scope.");\n    }, Lt.prototype.has = function (t) {\n      return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n    };\n    var Rt = {\n      kind: "null"\n    },\n        Ot = {\n      kind: "number"\n    },\n        Ut = {\n      kind: "string"\n    },\n        jt = {\n      kind: "boolean"\n    },\n        qt = {\n      kind: "color"\n    },\n        Nt = {\n      kind: "object"\n    },\n        Kt = {\n      kind: "value"\n    },\n        Gt = {\n      kind: "collator"\n    },\n        Zt = {\n      kind: "formatted"\n    },\n        Xt = {\n      kind: "resolvedImage"\n    };\n\n    function Jt(t, e) {\n      return {\n        kind: "array",\n        itemType: t,\n        N: e\n      };\n    }\n\n    function Ht(t) {\n      if ("array" === t.kind) {\n        var e = Ht(t.itemType);\n        return "number" == typeof t.N ? "array<" + e + ", " + t.N + ">" : "value" === t.itemType.kind ? "array" : "array<" + e + ">";\n      }\n\n      return t.kind;\n    }\n\n    var Yt = [Rt, Ot, Ut, jt, qt, Zt, Nt, Jt(Kt), Xt];\n\n    function $t(t, e) {\n      if ("error" === e.kind) return null;\n\n      if ("array" === t.kind) {\n        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !$t(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if ("value" === t.kind) for (var r = 0, n = Yt; r < n.length; r += 1) {\n          if (!$t(n[r], e)) return null;\n        }\n      }\n\n      return "Expected " + Ht(t) + " but found " + Ht(e) + " instead.";\n    }\n\n    function Wt(t, e) {\n      return e.some(function (e) {\n        return e.kind === t.kind;\n      });\n    }\n\n    function Qt(t, e) {\n      return e.some(function (e) {\n        return "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t;\n      });\n    }\n\n    var te = e(function (t, e) {\n      var r = {\n        transparent: [0, 0, 0, 0],\n        aliceblue: [240, 248, 255, 1],\n        antiquewhite: [250, 235, 215, 1],\n        aqua: [0, 255, 255, 1],\n        aquamarine: [127, 255, 212, 1],\n        azure: [240, 255, 255, 1],\n        beige: [245, 245, 220, 1],\n        bisque: [255, 228, 196, 1],\n        black: [0, 0, 0, 1],\n        blanchedalmond: [255, 235, 205, 1],\n        blue: [0, 0, 255, 1],\n        blueviolet: [138, 43, 226, 1],\n        brown: [165, 42, 42, 1],\n        burlywood: [222, 184, 135, 1],\n        cadetblue: [95, 158, 160, 1],\n        chartreuse: [127, 255, 0, 1],\n        chocolate: [210, 105, 30, 1],\n        coral: [255, 127, 80, 1],\n        cornflowerblue: [100, 149, 237, 1],\n        cornsilk: [255, 248, 220, 1],\n        crimson: [220, 20, 60, 1],\n        cyan: [0, 255, 255, 1],\n        darkblue: [0, 0, 139, 1],\n        darkcyan: [0, 139, 139, 1],\n        darkgoldenrod: [184, 134, 11, 1],\n        darkgray: [169, 169, 169, 1],\n        darkgreen: [0, 100, 0, 1],\n        darkgrey: [169, 169, 169, 1],\n        darkkhaki: [189, 183, 107, 1],\n        darkmagenta: [139, 0, 139, 1],\n        darkolivegreen: [85, 107, 47, 1],\n        darkorange: [255, 140, 0, 1],\n        darkorchid: [153, 50, 204, 1],\n        darkred: [139, 0, 0, 1],\n        darksalmon: [233, 150, 122, 1],\n        darkseagreen: [143, 188, 143, 1],\n        darkslateblue: [72, 61, 139, 1],\n        darkslategray: [47, 79, 79, 1],\n        darkslategrey: [47, 79, 79, 1],\n        darkturquoise: [0, 206, 209, 1],\n        darkviolet: [148, 0, 211, 1],\n        deeppink: [255, 20, 147, 1],\n        deepskyblue: [0, 191, 255, 1],\n        dimgray: [105, 105, 105, 1],\n        dimgrey: [105, 105, 105, 1],\n        dodgerblue: [30, 144, 255, 1],\n        firebrick: [178, 34, 34, 1],\n        floralwhite: [255, 250, 240, 1],\n        forestgreen: [34, 139, 34, 1],\n        fuchsia: [255, 0, 255, 1],\n        gainsboro: [220, 220, 220, 1],\n        ghostwhite: [248, 248, 255, 1],\n        gold: [255, 215, 0, 1],\n        goldenrod: [218, 165, 32, 1],\n        gray: [128, 128, 128, 1],\n        green: [0, 128, 0, 1],\n        greenyellow: [173, 255, 47, 1],\n        grey: [128, 128, 128, 1],\n        honeydew: [240, 255, 240, 1],\n        hotpink: [255, 105, 180, 1],\n        indianred: [205, 92, 92, 1],\n        indigo: [75, 0, 130, 1],\n        ivory: [255, 255, 240, 1],\n        khaki: [240, 230, 140, 1],\n        lavender: [230, 230, 250, 1],\n        lavenderblush: [255, 240, 245, 1],\n        lawngreen: [124, 252, 0, 1],\n        lemonchiffon: [255, 250, 205, 1],\n        lightblue: [173, 216, 230, 1],\n        lightcoral: [240, 128, 128, 1],\n        lightcyan: [224, 255, 255, 1],\n        lightgoldenrodyellow: [250, 250, 210, 1],\n        lightgray: [211, 211, 211, 1],\n        lightgreen: [144, 238, 144, 1],\n        lightgrey: [211, 211, 211, 1],\n        lightpink: [255, 182, 193, 1],\n        lightsalmon: [255, 160, 122, 1],\n        lightseagreen: [32, 178, 170, 1],\n        lightskyblue: [135, 206, 250, 1],\n        lightslategray: [119, 136, 153, 1],\n        lightslategrey: [119, 136, 153, 1],\n        lightsteelblue: [176, 196, 222, 1],\n        lightyellow: [255, 255, 224, 1],\n        lime: [0, 255, 0, 1],\n        limegreen: [50, 205, 50, 1],\n        linen: [250, 240, 230, 1],\n        magenta: [255, 0, 255, 1],\n        maroon: [128, 0, 0, 1],\n        mediumaquamarine: [102, 205, 170, 1],\n        mediumblue: [0, 0, 205, 1],\n        mediumorchid: [186, 85, 211, 1],\n        mediumpurple: [147, 112, 219, 1],\n        mediumseagreen: [60, 179, 113, 1],\n        mediumslateblue: [123, 104, 238, 1],\n        mediumspringgreen: [0, 250, 154, 1],\n        mediumturquoise: [72, 209, 204, 1],\n        mediumvioletred: [199, 21, 133, 1],\n        midnightblue: [25, 25, 112, 1],\n        mintcream: [245, 255, 250, 1],\n        mistyrose: [255, 228, 225, 1],\n        moccasin: [255, 228, 181, 1],\n        navajowhite: [255, 222, 173, 1],\n        navy: [0, 0, 128, 1],\n        oldlace: [253, 245, 230, 1],\n        olive: [128, 128, 0, 1],\n        olivedrab: [107, 142, 35, 1],\n        orange: [255, 165, 0, 1],\n        orangered: [255, 69, 0, 1],\n        orchid: [218, 112, 214, 1],\n        palegoldenrod: [238, 232, 170, 1],\n        palegreen: [152, 251, 152, 1],\n        paleturquoise: [175, 238, 238, 1],\n        palevioletred: [219, 112, 147, 1],\n        papayawhip: [255, 239, 213, 1],\n        peachpuff: [255, 218, 185, 1],\n        peru: [205, 133, 63, 1],\n        pink: [255, 192, 203, 1],\n        plum: [221, 160, 221, 1],\n        powderblue: [176, 224, 230, 1],\n        purple: [128, 0, 128, 1],\n        rebeccapurple: [102, 51, 153, 1],\n        red: [255, 0, 0, 1],\n        rosybrown: [188, 143, 143, 1],\n        royalblue: [65, 105, 225, 1],\n        saddlebrown: [139, 69, 19, 1],\n        salmon: [250, 128, 114, 1],\n        sandybrown: [244, 164, 96, 1],\n        seagreen: [46, 139, 87, 1],\n        seashell: [255, 245, 238, 1],\n        sienna: [160, 82, 45, 1],\n        silver: [192, 192, 192, 1],\n        skyblue: [135, 206, 235, 1],\n        slateblue: [106, 90, 205, 1],\n        slategray: [112, 128, 144, 1],\n        slategrey: [112, 128, 144, 1],\n        snow: [255, 250, 250, 1],\n        springgreen: [0, 255, 127, 1],\n        steelblue: [70, 130, 180, 1],\n        tan: [210, 180, 140, 1],\n        teal: [0, 128, 128, 1],\n        thistle: [216, 191, 216, 1],\n        tomato: [255, 99, 71, 1],\n        turquoise: [64, 224, 208, 1],\n        violet: [238, 130, 238, 1],\n        wheat: [245, 222, 179, 1],\n        white: [255, 255, 255, 1],\n        whitesmoke: [245, 245, 245, 1],\n        yellow: [255, 255, 0, 1],\n        yellowgreen: [154, 205, 50, 1]\n      };\n\n      function n(t) {\n        return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n      }\n\n      function i(t) {\n        return n("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n      }\n\n      function a(t) {\n        return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n        var e;\n      }\n\n      function o(t, e, r) {\n        return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n      }\n\n      try {\n        e.parseCSSColor = function (t) {\n          var e,\n              s = t.replace(/ /g, "").toLowerCase();\n          if (s in r) return r[s].slice();\n          if ("#" === s[0]) return 4 === s.length ? (e = parseInt(s.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === s.length && (e = parseInt(s.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n          var u = s.indexOf("("),\n              l = s.indexOf(")");\n\n          if (-1 !== u && l + 1 === s.length) {\n            var p = s.substr(0, u),\n                c = s.substr(u + 1, l - (u + 1)).split(","),\n                h = 1;\n\n            switch (p) {\n              case "rgba":\n                if (4 !== c.length) return null;\n                h = a(c.pop());\n\n              case "rgb":\n                return 3 !== c.length ? null : [i(c[0]), i(c[1]), i(c[2]), h];\n\n              case "hsla":\n                if (4 !== c.length) return null;\n                h = a(c.pop());\n\n              case "hsl":\n                if (3 !== c.length) return null;\n                var f = (parseFloat(c[0]) % 360 + 360) % 360 / 360,\n                    y = a(c[1]),\n                    d = a(c[2]),\n                    m = d <= .5 ? d * (y + 1) : d + y - d * y,\n                    v = 2 * d - m;\n                return [n(255 * o(v, m, f + 1 / 3)), n(255 * o(v, m, f)), n(255 * o(v, m, f - 1 / 3)), h];\n\n              default:\n                return null;\n            }\n          }\n\n          return null;\n        };\n      } catch (t) {}\n    }).parseCSSColor,\n        ee = function ee(t, e, r, n) {\n      void 0 === n && (n = 1), this.r = t, this.g = e, this.b = r, this.a = n;\n    };\n\n    ee.parse = function (t) {\n      if (t) {\n        if (t instanceof ee) return t;\n\n        if ("string" == typeof t) {\n          var e = te(t);\n          if (e) return new ee(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]);\n        }\n      }\n    }, ee.prototype.toString = function () {\n      var t = this.toArray(),\n          e = t[1],\n          r = t[2],\n          n = t[3];\n      return "rgba(" + Math.round(t[0]) + "," + Math.round(e) + "," + Math.round(r) + "," + n + ")";\n    }, ee.prototype.toArray = function () {\n      var t = this.a;\n      return 0 === t ? [0, 0, 0, 0] : [255 * this.r / t, 255 * this.g / t, 255 * this.b / t, t];\n    }, ee.black = new ee(0, 0, 0, 1), ee.white = new ee(1, 1, 1, 1), ee.transparent = new ee(0, 0, 0, 0), ee.red = new ee(1, 0, 0, 1);\n\n    var re = function re(t, e, r) {\n      this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n        sensitivity: this.sensitivity,\n        usage: "search"\n      });\n    };\n\n    re.prototype.compare = function (t, e) {\n      return this.collator.compare(t, e);\n    }, re.prototype.resolvedLocale = function () {\n      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n    };\n\n    var ne = function ne(t, e, r, n, i) {\n      this.text = t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n    },\n        ie = function ie(t) {\n      this.sections = t;\n    };\n\n    ie.fromString = function (t) {\n      return new ie([new ne(t, null, null, null, null)]);\n    }, ie.prototype.isEmpty = function () {\n      return 0 === this.sections.length || !this.sections.some(function (t) {\n        return 0 !== t.text.length || t.image && 0 !== t.image.name.length;\n      });\n    }, ie.factory = function (t) {\n      return t instanceof ie ? t : ie.fromString(t);\n    }, ie.prototype.toString = function () {\n      return 0 === this.sections.length ? "" : this.sections.map(function (t) {\n        return t.text;\n      }).join("");\n    }, ie.prototype.serialize = function () {\n      for (var t = ["format"], e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        if (n.image) t.push(["image", n.image.name]);else {\n          t.push(n.text);\n          var i = {};\n          n.fontStack && (i["text-font"] = ["literal", n.fontStack.split(",")]), n.scale && (i["font-scale"] = n.scale), n.textColor && (i["text-color"] = ["rgba"].concat(n.textColor.toArray())), t.push(i);\n        }\n      }\n\n      return t;\n    };\n\n    var ae = function ae(t) {\n      this.name = t.name, this.available = t.available;\n    };\n\n    function oe(t, e, r, n) {\n      return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : "Invalid rgba value [" + [t, e, r, n].join(", ") + "]: \'a\' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ") + "]: \'r\', \'g\', and \'b\' must be between 0 and 255.";\n    }\n\n    function se(t) {\n      if (null === t) return !0;\n      if ("string" == typeof t) return !0;\n      if ("boolean" == typeof t) return !0;\n      if ("number" == typeof t) return !0;\n      if (t instanceof ee) return !0;\n      if (t instanceof re) return !0;\n      if (t instanceof ie) return !0;\n      if (t instanceof ae) return !0;\n\n      if (Array.isArray(t)) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          if (!se(r[e])) return !1;\n        }\n\n        return !0;\n      }\n\n      if ("object" == typeof t) {\n        for (var n in t) {\n          if (!se(t[n])) return !1;\n        }\n\n        return !0;\n      }\n\n      return !1;\n    }\n\n    function ue(t) {\n      if (null === t) return Rt;\n      if ("string" == typeof t) return Ut;\n      if ("boolean" == typeof t) return jt;\n      if ("number" == typeof t) return Ot;\n      if (t instanceof ee) return qt;\n      if (t instanceof re) return Gt;\n      if (t instanceof ie) return Zt;\n      if (t instanceof ae) return Xt;\n\n      if (Array.isArray(t)) {\n        for (var e, r = t.length, n = 0, i = t; n < i.length; n += 1) {\n          var a = ue(i[n]);\n\n          if (e) {\n            if (e === a) continue;\n            e = Kt;\n            break;\n          }\n\n          e = a;\n        }\n\n        return Jt(e || Kt, r);\n      }\n\n      return Nt;\n    }\n\n    function le(t) {\n      var e = typeof t;\n      return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof ee || t instanceof ie || t instanceof ae ? t.toString() : JSON.stringify(t);\n    }\n\n    ae.prototype.toString = function () {\n      return this.name;\n    }, ae.fromString = function (t) {\n      return t ? new ae({\n        name: t,\n        available: !1\n      }) : null;\n    }, ae.prototype.serialize = function () {\n      return ["image", this.name];\n    };\n\n    var pe = function pe(t, e) {\n      this.type = t, this.value = e;\n    };\n\n    pe.parse = function (t, e) {\n      if (2 !== t.length) return e.error("\'literal\' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");\n      if (!se(t[1])) return e.error("invalid value");\n      var r = t[1],\n          n = ue(r),\n          i = e.expectedType;\n      return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new pe(n, r);\n    }, pe.prototype.evaluate = function () {\n      return this.value;\n    }, pe.prototype.eachChild = function () {}, pe.prototype.outputDefined = function () {\n      return !0;\n    }, pe.prototype.serialize = function () {\n      return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ee ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ie ? this.value.serialize() : this.value;\n    };\n\n    var ce = function ce(t) {\n      this.name = "ExpressionEvaluationError", this.message = t;\n    };\n\n    ce.prototype.toJSON = function () {\n      return this.message;\n    };\n\n    var he = {\n      string: Ut,\n      number: Ot,\n      boolean: jt,\n      object: Nt\n    },\n        fe = function fe(t, e) {\n      this.type = t, this.args = e;\n    };\n\n    fe.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r,\n          n = 1,\n          i = t[0];\n\n      if ("array" === i) {\n        var a, o;\n\n        if (t.length > 2) {\n          var s = t[1];\n          if ("string" != typeof s || !(s in he) || "object" === s) return e.error(\'The item type argument of "array" must be one of string, number, boolean\', 1);\n          a = he[s], n++;\n        } else a = Kt;\n\n        if (t.length > 3) {\n          if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error(\'The length argument to "array" must be a positive integer literal\', 2);\n          o = t[2], n++;\n        }\n\n        r = Jt(a, o);\n      } else r = he[i];\n\n      for (var u = []; n < t.length; n++) {\n        var l = e.parse(t[n], n, Kt);\n        if (!l) return null;\n        u.push(l);\n      }\n\n      return new fe(r, u);\n    }, fe.prototype.evaluate = function (t) {\n      for (var e = 0; e < this.args.length; e++) {\n        var r = this.args[e].evaluate(t);\n        if (!$t(this.type, ue(r))) return r;\n        if (e === this.args.length - 1) throw new ce("Expected value to be of type " + Ht(this.type) + ", but found " + Ht(ue(r)) + " instead.");\n      }\n\n      return null;\n    }, fe.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, fe.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, fe.prototype.serialize = function () {\n      var t = this.type,\n          e = [t.kind];\n\n      if ("array" === t.kind) {\n        var r = t.itemType;\n\n        if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {\n          e.push(r.kind);\n          var n = t.N;\n          ("number" == typeof n || this.args.length > 1) && e.push(n);\n        }\n      }\n\n      return e.concat(this.args.map(function (t) {\n        return t.serialize();\n      }));\n    };\n\n    var ye = function ye(t) {\n      this.type = Zt, this.sections = t;\n    };\n\n    ye.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r = t[1];\n      if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");\n\n      for (var n = [], i = !1, a = 1; a <= t.length - 1; ++a) {\n        var o = t[a];\n\n        if (i && "object" == typeof o && !Array.isArray(o)) {\n          i = !1;\n          var s = null;\n          if (o["font-scale"] && !(s = e.parse(o["font-scale"], 1, Ot))) return null;\n          var u = null;\n          if (o["text-font"] && !(u = e.parse(o["text-font"], 1, Jt(Ut)))) return null;\n          var l = null;\n          if (o["text-color"] && !(l = e.parse(o["text-color"], 1, qt))) return null;\n          var p = n[n.length - 1];\n          p.scale = s, p.font = u, p.textColor = l;\n        } else {\n          var c = e.parse(t[a], 1, Kt);\n          if (!c) return null;\n          var h = c.type.kind;\n          if ("string" !== h && "value" !== h && "null" !== h && "resolvedImage" !== h) return e.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");\n          i = !0, n.push({\n            content: c,\n            scale: null,\n            font: null,\n            textColor: null\n          });\n        }\n      }\n\n      return new ye(n);\n    }, ye.prototype.evaluate = function (t) {\n      return new ie(this.sections.map(function (e) {\n        var r = e.content.evaluate(t);\n        return ue(r) === Xt ? new ne("", r, null, null, null) : new ne(le(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);\n      }));\n    }, ye.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor);\n      }\n    }, ye.prototype.outputDefined = function () {\n      return !1;\n    }, ye.prototype.serialize = function () {\n      for (var t = ["format"], e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        t.push(n.content.serialize());\n        var i = {};\n        n.scale && (i["font-scale"] = n.scale.serialize()), n.font && (i["text-font"] = n.font.serialize()), n.textColor && (i["text-color"] = n.textColor.serialize()), t.push(i);\n      }\n\n      return t;\n    };\n\n    var de = function de(t) {\n      this.type = Xt, this.input = t;\n    };\n\n    de.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected two arguments.");\n      var r = e.parse(t[1], 1, Ut);\n      return r ? new de(r) : e.error("No image name provided.");\n    }, de.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t),\n          r = ae.fromString(e);\n      return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n    }, de.prototype.eachChild = function (t) {\n      t(this.input);\n    }, de.prototype.outputDefined = function () {\n      return !1;\n    }, de.prototype.serialize = function () {\n      return ["image", this.input.serialize()];\n    };\n\n    var me = {\n      "to-boolean": jt,\n      "to-color": qt,\n      "to-number": Ot,\n      "to-string": Ut\n    },\n        ve = function ve(t, e) {\n      this.type = t, this.args = e;\n    };\n\n    ve.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r = t[0];\n      if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument.");\n\n      for (var n = me[r], i = [], a = 1; a < t.length; a++) {\n        var o = e.parse(t[a], a, Kt);\n        if (!o) return null;\n        i.push(o);\n      }\n\n      return new ve(n, i);\n    }, ve.prototype.evaluate = function (t) {\n      if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n\n      if ("color" === this.type.kind) {\n        for (var e, r, n = 0, i = this.args; n < i.length; n += 1) {\n          if (r = null, (e = i[n].evaluate(t)) instanceof ee) return e;\n\n          if ("string" == typeof e) {\n            var a = t.parseColor(e);\n            if (a) return a;\n          } else if (Array.isArray(e) && !(r = e.length < 3 || e.length > 4 ? "Invalid rbga value " + JSON.stringify(e) + ": expected an array containing either three or four numeric values." : oe(e[0], e[1], e[2], e[3]))) return new ee(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n        }\n\n        throw new ce(r || "Could not parse color from value \'" + ("string" == typeof e ? e : String(JSON.stringify(e))) + "\'");\n      }\n\n      if ("number" === this.type.kind) {\n        for (var o = null, s = 0, u = this.args; s < u.length; s += 1) {\n          if (null === (o = u[s].evaluate(t))) return 0;\n          var l = Number(o);\n          if (!isNaN(l)) return l;\n        }\n\n        throw new ce("Could not convert " + JSON.stringify(o) + " to number.");\n      }\n\n      return "formatted" === this.type.kind ? ie.fromString(le(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? ae.fromString(le(this.args[0].evaluate(t))) : le(this.args[0].evaluate(t));\n    }, ve.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, ve.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, ve.prototype.serialize = function () {\n      if ("formatted" === this.type.kind) return new ye([{\n        content: this.args[0],\n        scale: null,\n        font: null,\n        textColor: null\n      }]).serialize();\n      if ("resolvedImage" === this.type.kind) return new de(this.args[0]).serialize();\n      var t = ["to-" + this.type.kind];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n\n    var ge = ["Unknown", "Point", "LineString", "Polygon"],\n        xe = function xe() {\n      this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;\n    };\n\n    xe.prototype.id = function () {\n      return this.feature && "id" in this.feature ? this.feature.id : null;\n    }, xe.prototype.geometryType = function () {\n      return this.feature ? "number" == typeof this.feature.type ? ge[this.feature.type] : this.feature.type : null;\n    }, xe.prototype.geometry = function () {\n      return this.feature && "geometry" in this.feature ? this.feature.geometry : null;\n    }, xe.prototype.canonicalID = function () {\n      return this.canonical;\n    }, xe.prototype.properties = function () {\n      return this.feature && this.feature.properties || {};\n    }, xe.prototype.parseColor = function (t) {\n      var e = this._parseColorCache[t];\n      return e || (e = this._parseColorCache[t] = ee.parse(t)), e;\n    };\n\n    var be = function be(t, e, r, n) {\n      this.name = t, this.type = e, this._evaluate = r, this.args = n;\n    };\n\n    be.prototype.evaluate = function (t) {\n      return this._evaluate(t, this.args);\n    }, be.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, be.prototype.outputDefined = function () {\n      return !1;\n    }, be.prototype.serialize = function () {\n      return [this.name].concat(this.args.map(function (t) {\n        return t.serialize();\n      }));\n    }, be.parse = function (t, e) {\n      var r,\n          n = t[0],\n          i = be.definitions[n];\n      if (!i) return e.error(\'Unknown expression "\' + n + \'". If you wanted a literal array, use ["literal", [...]].\', 0);\n\n      for (var a = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, s = o.filter(function (e) {\n        var r = e[0];\n        return !Array.isArray(r) || r.length === t.length - 1;\n      }), u = null, l = 0, p = s; l < p.length; l += 1) {\n        var c = p[l],\n            h = c[0],\n            f = c[1];\n        u = new qe(e.registry, e.path, null, e.scope);\n\n        for (var y = [], d = !1, m = 1; m < t.length; m++) {\n          var v = t[m],\n              g = Array.isArray(h) ? h[m - 1] : h.type,\n              x = u.parse(v, 1 + y.length, g);\n\n          if (!x) {\n            d = !0;\n            break;\n          }\n\n          y.push(x);\n        }\n\n        if (!d) if (Array.isArray(h) && h.length !== y.length) u.error("Expected " + h.length + " arguments, but found " + y.length + " instead.");else {\n          for (var b = 0; b < y.length; b++) {\n            var w = Array.isArray(h) ? h[b] : h.type,\n                _ = y[b];\n            u.concat(b + 1).checkSubtype(w, _.type);\n          }\n\n          if (0 === u.errors.length) return new be(n, a, f, y);\n        }\n      }\n\n      if (1 === s.length) (r = e.errors).push.apply(r, u.errors);else {\n        for (var A = (s.length ? s : o).map(function (t) {\n          var e;\n          return e = t[0], Array.isArray(e) ? "(" + e.map(Ht).join(", ") + ")" : "(" + Ht(e.type) + "...)";\n        }).join(" | "), S = [], k = 1; k < t.length; k++) {\n          var I = e.parse(t[k], 1 + S.length);\n          if (!I) return null;\n          S.push(Ht(I.type));\n        }\n\n        e.error("Expected arguments of type " + A + ", but found (" + S.join(", ") + ") instead.");\n      }\n      return null;\n    }, be.register = function (t, e) {\n      for (var r in be.definitions = e, e) {\n        t[r] = be;\n      }\n    };\n\n    var we = function we(t, e, r) {\n      this.type = Gt, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n    };\n\n    function _e(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n\n    function Ae(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n\n    function Se(t, e) {\n      var r = (180 + t[0]) / 360,\n          n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n          i = Math.pow(2, e.z);\n      return [Math.round(r * i * 8192), Math.round(n * i * 8192)];\n    }\n\n    function ke(t, e, r) {\n      return e[1] > t[1] != r[1] > t[1] && t[0] < (r[0] - e[0]) * (t[1] - e[1]) / (r[1] - e[1]) + e[0];\n    }\n\n    function Ie(t, e) {\n      for (var r, n, i, a, o, s, u, l = !1, p = 0, c = e.length; p < c; p++) {\n        for (var h = e[p], f = 0, y = h.length; f < y - 1; f++) {\n          if ((a = (r = t)[0] - (n = h[f])[0]) * (u = r[1] - (i = h[f + 1])[1]) - (s = r[0] - i[0]) * (o = r[1] - n[1]) == 0 && a * s <= 0 && o * u <= 0) return !1;\n          ke(t, h[f], h[f + 1]) && (l = !l);\n        }\n      }\n\n      return l;\n    }\n\n    function ze(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        if (Ie(t, e[r])) return !0;\n      }\n\n      return !1;\n    }\n\n    function Ce(t, e, r, n) {\n      var i = n[0] - r[0],\n          a = n[1] - r[1],\n          o = (t[0] - r[0]) * a - i * (t[1] - r[1]),\n          s = (e[0] - r[0]) * a - i * (e[1] - r[1]);\n      return o > 0 && s < 0 || o < 0 && s > 0;\n    }\n\n    function Ee(t, e, r) {\n      for (var n = 0, i = r; n < i.length; n += 1) {\n        for (var a = i[n], o = 0; o < a.length - 1; ++o) {\n          if (0 != (c = [(p = a[o + 1])[0] - (l = a[o])[0], p[1] - l[1]])[0] * (h = [(u = e)[0] - (s = t)[0], u[1] - s[1]])[1] - c[1] * h[0] && Ce(s, u, l, p) && Ce(l, p, s, u)) return !0;\n        }\n      }\n\n      var s, u, l, p, c, h;\n      return !1;\n    }\n\n    function Pe(t, e) {\n      for (var r = 0; r < t.length; ++r) {\n        if (!Ie(t[r], e)) return !1;\n      }\n\n      for (var n = 0; n < t.length - 1; ++n) {\n        if (Ee(t[n], t[n + 1], e)) return !1;\n      }\n\n      return !0;\n    }\n\n    function Me(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        if (Pe(t, e[r])) return !0;\n      }\n\n      return !1;\n    }\n\n    function Be(t, e, r) {\n      for (var n = [], i = 0; i < t.length; i++) {\n        for (var a = [], o = 0; o < t[i].length; o++) {\n          var s = Se(t[i][o], r);\n          _e(e, s), a.push(s);\n        }\n\n        n.push(a);\n      }\n\n      return n;\n    }\n\n    function Te(t, e, r) {\n      for (var n = [], i = 0; i < t.length; i++) {\n        var a = Be(t[i], e, r);\n        n.push(a);\n      }\n\n      return n;\n    }\n\n    function Ve(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        var i = .5 * n,\n            a = t[0] - r[0] > i ? -n : r[0] - t[0] > i ? n : 0;\n        0 === a && (a = t[0] - r[2] > i ? -n : r[2] - t[0] > i ? n : 0), t[0] += a;\n      }\n\n      _e(e, t);\n    }\n\n    function Fe(t, e, r, n) {\n      for (var i = 8192 * Math.pow(2, n.z), a = [8192 * n.x, 8192 * n.y], o = [], s = 0, u = t; s < u.length; s += 1) {\n        for (var l = 0, p = u[s]; l < p.length; l += 1) {\n          var c = p[l],\n              h = [c.x + a[0], c.y + a[1]];\n          Ve(h, e, r, i), o.push(h);\n        }\n      }\n\n      return o;\n    }\n\n    function De(t, e, r, n) {\n      for (var i, a = 8192 * Math.pow(2, n.z), o = [8192 * n.x, 8192 * n.y], s = [], u = 0, l = t; u < l.length; u += 1) {\n        for (var p = [], c = 0, h = l[u]; c < h.length; c += 1) {\n          var f = h[c],\n              y = [f.x + o[0], f.y + o[1]];\n          _e(e, y), p.push(y);\n        }\n\n        s.push(p);\n      }\n\n      if (e[2] - e[0] <= a / 2) {\n        (i = e)[0] = i[1] = 1 / 0, i[2] = i[3] = -1 / 0;\n\n        for (var d = 0, m = s; d < m.length; d += 1) {\n          for (var v = 0, g = m[d]; v < g.length; v += 1) {\n            Ve(g[v], e, r, a);\n          }\n        }\n      }\n\n      return s;\n    }\n\n    we.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected one argument.");\n      var r = t[1];\n      if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");\n      var n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, jt);\n      if (!n) return null;\n      var i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, jt);\n      if (!i) return null;\n      var a = null;\n      return r.locale && !(a = e.parse(r.locale, 1, Ut)) ? null : new we(n, i, a);\n    }, we.prototype.evaluate = function (t) {\n      return new re(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n    }, we.prototype.eachChild = function (t) {\n      t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n    }, we.prototype.outputDefined = function () {\n      return !1;\n    }, we.prototype.serialize = function () {\n      var t = {};\n      return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];\n    };\n\n    var Le = function Le(t, e) {\n      this.type = jt, this.geojson = t, this.geometries = e;\n    };\n\n    function Re(t) {\n      if (t instanceof be) {\n        if ("get" === t.name && 1 === t.args.length) return !1;\n        if ("feature-state" === t.name) return !1;\n        if ("has" === t.name && 1 === t.args.length) return !1;\n        if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n\n      if (t instanceof Le) return !1;\n      var e = !0;\n      return t.eachChild(function (t) {\n        e && !Re(t) && (e = !1);\n      }), e;\n    }\n\n    function Oe(t) {\n      if (t instanceof be && "feature-state" === t.name) return !1;\n      var e = !0;\n      return t.eachChild(function (t) {\n        e && !Oe(t) && (e = !1);\n      }), e;\n    }\n\n    function Ue(t, e) {\n      if (t instanceof be && e.indexOf(t.name) >= 0) return !1;\n      var r = !0;\n      return t.eachChild(function (t) {\n        r && !Ue(t, e) && (r = !1);\n      }), r;\n    }\n\n    Le.parse = function (t, e) {\n      if (2 !== t.length) return e.error("\'within\' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");\n\n      if (se(t[1])) {\n        var r = t[1];\n        if ("FeatureCollection" === r.type) for (var n = 0; n < r.features.length; ++n) {\n          var i = r.features[n].geometry.type;\n          if ("Polygon" === i || "MultiPolygon" === i) return new Le(r, r.features[n].geometry);\n        } else if ("Feature" === r.type) {\n          var a = r.geometry.type;\n          if ("Polygon" === a || "MultiPolygon" === a) return new Le(r, r.geometry);\n        } else if ("Polygon" === r.type || "MultiPolygon" === r.type) return new Le(r, r);\n      }\n\n      return e.error("\'within\' expression requires valid geojson object that contains polygon geometry type.");\n    }, Le.prototype.evaluate = function (t) {\n      if (null != t.geometry() && null != t.canonicalID()) {\n        if ("Point" === t.geometryType()) return function (t, e) {\n          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n\n          if ("Polygon" === e.type) {\n            var a = Be(e.coordinates, n, i),\n                o = Fe(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n\n            for (var s = 0, u = o; s < u.length; s += 1) {\n              if (!Ie(u[s], a)) return !1;\n            }\n          }\n\n          if ("MultiPolygon" === e.type) {\n            var l = Te(e.coordinates, n, i),\n                p = Fe(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n\n            for (var c = 0, h = p; c < h.length; c += 1) {\n              if (!ze(h[c], l)) return !1;\n            }\n          }\n\n          return !0;\n        }(t, this.geometries);\n        if ("LineString" === t.geometryType()) return function (t, e) {\n          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n\n          if ("Polygon" === e.type) {\n            var a = Be(e.coordinates, n, i),\n                o = De(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n\n            for (var s = 0, u = o; s < u.length; s += 1) {\n              if (!Pe(u[s], a)) return !1;\n            }\n          }\n\n          if ("MultiPolygon" === e.type) {\n            var l = Te(e.coordinates, n, i),\n                p = De(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n\n            for (var c = 0, h = p; c < h.length; c += 1) {\n              if (!Me(h[c], l)) return !1;\n            }\n          }\n\n          return !0;\n        }(t, this.geometries);\n      }\n\n      return !1;\n    }, Le.prototype.eachChild = function () {}, Le.prototype.outputDefined = function () {\n      return !0;\n    }, Le.prototype.serialize = function () {\n      return ["within", this.geojson];\n    };\n\n    var je = function je(t, e) {\n      this.type = e.type, this.name = t, this.boundExpression = e;\n    };\n\n    je.parse = function (t, e) {\n      if (2 !== t.length || "string" != typeof t[1]) return e.error("\'var\' expression requires exactly one string literal argument.");\n      var r = t[1];\n      return e.scope.has(r) ? new je(r, e.scope.get(r)) : e.error(\'Unknown variable "\' + r + \'". Make sure "\' + r + \'" has been bound in an enclosing "let" expression before using it.\', 1);\n    }, je.prototype.evaluate = function (t) {\n      return this.boundExpression.evaluate(t);\n    }, je.prototype.eachChild = function () {}, je.prototype.outputDefined = function () {\n      return !1;\n    }, je.prototype.serialize = function () {\n      return ["var", this.name];\n    };\n\n    var qe = function qe(t, e, r, n, i) {\n      void 0 === e && (e = []), void 0 === n && (n = new Lt()), void 0 === i && (i = []), this.registry = t, this.path = e, this.key = e.map(function (t) {\n        return "[" + t + "]";\n      }).join(""), this.scope = n, this.errors = i, this.expectedType = r;\n    };\n\n    function Ne(t, e) {\n      for (var r, n = t.length - 1, i = 0, a = n, o = 0; i <= a;) {\n        if ((r = t[o = Math.floor((i + a) / 2)]) <= e) {\n          if (o === n || e < t[o + 1]) return o;\n          i = o + 1;\n        } else {\n          if (!(r > e)) throw new ce("Input is not a number.");\n          a = o - 1;\n        }\n      }\n\n      return 0;\n    }\n\n    qe.prototype.parse = function (t, e, r, n, i) {\n      return void 0 === i && (i = {}), e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n    }, qe.prototype._parse = function (t, e) {\n      function r(t, e, r) {\n        return "assert" === r ? new fe(e, [t]) : "coerce" === r ? new ve(e, [t]) : t;\n      }\n\n      if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {\n        if (0 === t.length) return this.error(\'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].\');\n        var n = t[0];\n        if ("string" != typeof n) return this.error("Expression name must be a string, but found " + typeof n + \' instead. If you wanted a literal array, use ["literal", [...]].\', 0), null;\n        var i = this.registry[n];\n\n        if (i) {\n          var a = i.parse(t, this);\n          if (!a) return null;\n\n          if (this.expectedType) {\n            var o = this.expectedType,\n                s = a.type;\n            if ("string" !== o.kind && "number" !== o.kind && "boolean" !== o.kind && "object" !== o.kind && "array" !== o.kind || "value" !== s.kind) {\n              if ("color" !== o.kind && "formatted" !== o.kind && "resolvedImage" !== o.kind || "value" !== s.kind && "string" !== s.kind) {\n                if (this.checkSubtype(o, s)) return null;\n              } else a = r(a, o, e.typeAnnotation || "coerce");\n            } else a = r(a, o, e.typeAnnotation || "assert");\n          }\n\n          if (!(a instanceof pe) && "resolvedImage" !== a.type.kind && function t(e) {\n            if (e instanceof je) return t(e.boundExpression);\n            if (e instanceof be && "error" === e.name) return !1;\n            if (e instanceof we) return !1;\n            if (e instanceof Le) return !1;\n            var r = e instanceof ve || e instanceof fe,\n                n = !0;\n            return e.eachChild(function (e) {\n              n = r ? n && t(e) : n && e instanceof pe;\n            }), !!n && Re(e) && Ue(e, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);\n          }(a)) {\n            var u = new xe();\n\n            try {\n              a = new pe(a.type, a.evaluate(u));\n            } catch (t) {\n              return this.error(t.message), null;\n            }\n          }\n\n          return a;\n        }\n\n        return this.error(\'Unknown expression "\' + n + \'". If you wanted a literal array, use ["literal", [...]].\', 0);\n      }\n\n      return this.error(void 0 === t ? "\'undefined\' value invalid. Use null instead." : "object" == typeof t ? \'Bare objects invalid. Use ["literal", {...}] instead.\' : "Expected an array, but found " + typeof t + " instead.");\n    }, qe.prototype.concat = function (t, e, r) {\n      var n = "number" == typeof t ? this.path.concat(t) : this.path,\n          i = r ? this.scope.concat(r) : this.scope;\n      return new qe(this.registry, n, e || null, i, this.errors);\n    }, qe.prototype.error = function (t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) {\n        e[r] = arguments[r + 1];\n      }\n\n      var n = "" + this.key + e.map(function (t) {\n        return "[" + t + "]";\n      }).join("");\n      this.errors.push(new Dt(n, t));\n    }, qe.prototype.checkSubtype = function (t, e) {\n      var r = $t(t, e);\n      return r && this.error(r), r;\n    };\n\n    var Ke = function Ke(t, e, r) {\n      this.type = t, this.input = e, this.labels = [], this.outputs = [];\n\n      for (var n = 0, i = r; n < i.length; n += 1) {\n        var a = i[n],\n            o = a[1];\n        this.labels.push(a[0]), this.outputs.push(o);\n      }\n    };\n\n    function Ge(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n\n    Ke.parse = function (t, e) {\n      if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");\n      var r = e.parse(t[1], 1, Ot);\n      if (!r) return null;\n      var n = [],\n          i = null;\n      e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);\n\n      for (var a = 1; a < t.length; a += 2) {\n        var o = 1 === a ? -1 / 0 : t[a],\n            s = t[a + 1],\n            u = a,\n            l = a + 1;\n        if ("number" != typeof o) return e.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', u);\n        if (n.length && n[n.length - 1][0] >= o) return e.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\', u);\n        var p = e.parse(s, l, i);\n        if (!p) return null;\n        i = i || p.type, n.push([o, p]);\n      }\n\n      return new Ke(i, r, n);\n    }, Ke.prototype.evaluate = function (t) {\n      var e = this.labels,\n          r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      var n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      var i = e.length;\n      return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Ne(e, n)].evaluate(t);\n    }, Ke.prototype.eachChild = function (t) {\n      t(this.input);\n\n      for (var e = 0, r = this.outputs; e < r.length; e += 1) {\n        t(r[e]);\n      }\n    }, Ke.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      });\n    }, Ke.prototype.serialize = function () {\n      for (var t = ["step", this.input.serialize()], e = 0; e < this.labels.length; e++) {\n        e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n      }\n\n      return t;\n    };\n    var Ze = Object.freeze({\n      __proto__: null,\n      number: Ge,\n      color: function color(t, e, r) {\n        return new ee(Ge(t.r, e.r, r), Ge(t.g, e.g, r), Ge(t.b, e.b, r), Ge(t.a, e.a, r));\n      },\n      array: function array(t, e, r) {\n        return t.map(function (t, n) {\n          return Ge(t, e[n], r);\n        });\n      }\n    }),\n        Xe = 6 / 29 * 3 * (6 / 29),\n        Je = Math.PI / 180,\n        He = 180 / Math.PI;\n\n    function Ye(t) {\n      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Xe + 4 / 29;\n    }\n\n    function $e(t) {\n      return t > 6 / 29 ? t * t * t : Xe * (t - 4 / 29);\n    }\n\n    function We(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n\n    function Qe(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n\n    function tr(t) {\n      var e = Qe(t.r),\n          r = Qe(t.g),\n          n = Qe(t.b),\n          i = Ye((.4124564 * e + .3575761 * r + .1804375 * n) / .95047),\n          a = Ye((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * a - 16,\n        a: 500 * (i - a),\n        b: 200 * (a - Ye((.0193339 * e + .119192 * r + .9503041 * n) / 1.08883)),\n        alpha: t.a\n      };\n    }\n\n    function er(t) {\n      var e = (t.l + 16) / 116,\n          r = isNaN(t.a) ? e : e + t.a / 500,\n          n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * $e(e), r = .95047 * $e(r), n = 1.08883 * $e(n), new ee(We(3.2404542 * r - 1.5371385 * e - .4985314 * n), We(-.969266 * r + 1.8760108 * e + .041556 * n), We(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n\n    function rr(t, e, r) {\n      var n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n\n    var nr = {\n      forward: tr,\n      reverse: er,\n      interpolate: function interpolate(t, e, r) {\n        return {\n          l: Ge(t.l, e.l, r),\n          a: Ge(t.a, e.a, r),\n          b: Ge(t.b, e.b, r),\n          alpha: Ge(t.alpha, e.alpha, r)\n        };\n      }\n    },\n        ir = {\n      forward: function forward(t) {\n        var e = tr(t),\n            r = e.l,\n            n = e.a,\n            i = e.b,\n            a = Math.atan2(i, n) * He;\n        return {\n          h: a < 0 ? a + 360 : a,\n          c: Math.sqrt(n * n + i * i),\n          l: r,\n          alpha: t.a\n        };\n      },\n      reverse: function reverse(t) {\n        var e = t.h * Je,\n            r = t.c;\n        return er({\n          l: t.l,\n          a: Math.cos(e) * r,\n          b: Math.sin(e) * r,\n          alpha: t.alpha\n        });\n      },\n      interpolate: function interpolate(t, e, r) {\n        return {\n          h: rr(t.h, e.h, r),\n          c: Ge(t.c, e.c, r),\n          l: Ge(t.l, e.l, r),\n          alpha: Ge(t.alpha, e.alpha, r)\n        };\n      }\n    },\n        ar = Object.freeze({\n      __proto__: null,\n      lab: nr,\n      hcl: ir\n    }),\n        or = function or(t, e, r, n, i) {\n      this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n\n      for (var a = 0, o = i; a < o.length; a += 1) {\n        var s = o[a],\n            u = s[1];\n        this.labels.push(s[0]), this.outputs.push(u);\n      }\n    };\n\n    function sr(t, e, r, n) {\n      var i = n - r,\n          a = t - r;\n      return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n    }\n\n    or.interpolationFactor = function (t, e, n, i) {\n      var a = 0;\n      if ("exponential" === t.name) a = sr(e, t.base, n, i);else if ("linear" === t.name) a = sr(e, 1, n, i);else if ("cubic-bezier" === t.name) {\n        var o = t.controlPoints;\n        a = new r(o[0], o[1], o[2], o[3]).solve(sr(e, 1, n, i));\n      }\n      return a;\n    }, or.parse = function (t, e) {\n      var r = t[0],\n          n = t[1],\n          i = t[2],\n          a = t.slice(3);\n      if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);\n      if ("linear" === n[0]) n = {\n        name: "linear"\n      };else if ("exponential" === n[0]) {\n        var o = n[1];\n        if ("number" != typeof o) return e.error("Exponential interpolation requires a numeric base.", 1, 1);\n        n = {\n          name: "exponential",\n          base: o\n        };\n      } else {\n        if ("cubic-bezier" !== n[0]) return e.error("Unknown interpolation type " + String(n[0]), 1, 0);\n        var s = n.slice(1);\n        if (4 !== s.length || s.some(function (t) {\n          return "number" != typeof t || t < 0 || t > 1;\n        })) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);\n        n = {\n          name: "cubic-bezier",\n          controlPoints: s\n        };\n      }\n      if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");\n      if (!(i = e.parse(i, 2, Ot))) return null;\n      var u = [],\n          l = null;\n      "interpolate-hcl" === r || "interpolate-lab" === r ? l = qt : e.expectedType && "value" !== e.expectedType.kind && (l = e.expectedType);\n\n      for (var p = 0; p < a.length; p += 2) {\n        var c = a[p],\n            h = a[p + 1],\n            f = p + 3,\n            y = p + 4;\n        if ("number" != typeof c) return e.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', f);\n        if (u.length && u[u.length - 1][0] >= c) return e.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\', f);\n        var d = e.parse(h, y, l);\n        if (!d) return null;\n        l = l || d.type, u.push([c, d]);\n      }\n\n      return "number" === l.kind || "color" === l.kind || "array" === l.kind && "number" === l.itemType.kind && "number" == typeof l.N ? new or(l, r, n, i, u) : e.error("Type " + Ht(l) + " is not interpolatable.");\n    }, or.prototype.evaluate = function (t) {\n      var e = this.labels,\n          r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      var n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      var i = e.length;\n      if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n      var a = Ne(e, n),\n          o = or.interpolationFactor(this.interpolation, n, e[a], e[a + 1]),\n          s = r[a].evaluate(t),\n          u = r[a + 1].evaluate(t);\n      return "interpolate" === this.operator ? Ze[this.type.kind.toLowerCase()](s, u, o) : "interpolate-hcl" === this.operator ? ir.reverse(ir.interpolate(ir.forward(s), ir.forward(u), o)) : nr.reverse(nr.interpolate(nr.forward(s), nr.forward(u), o));\n    }, or.prototype.eachChild = function (t) {\n      t(this.input);\n\n      for (var e = 0, r = this.outputs; e < r.length; e += 1) {\n        t(r[e]);\n      }\n    }, or.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      });\n    }, or.prototype.serialize = function () {\n      var t;\n      t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);\n\n      for (var e = [this.operator, t, this.input.serialize()], r = 0; r < this.labels.length; r++) {\n        e.push(this.labels[r], this.outputs[r].serialize());\n      }\n\n      return e;\n    };\n\n    var ur = function ur(t, e) {\n      this.type = t, this.args = e;\n    };\n\n    ur.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expectected at least one argument.");\n      var r = null,\n          n = e.expectedType;\n      n && "value" !== n.kind && (r = n);\n\n      for (var i = [], a = 0, o = t.slice(1); a < o.length; a += 1) {\n        var s = e.parse(o[a], 1 + i.length, r, void 0, {\n          typeAnnotation: "omit"\n        });\n        if (!s) return null;\n        r = r || s.type, i.push(s);\n      }\n\n      var u = n && i.some(function (t) {\n        return $t(n, t.type);\n      });\n      return new ur(u ? Kt : r, i);\n    }, ur.prototype.evaluate = function (t) {\n      for (var e, r = null, n = 0, i = 0, a = this.args; i < a.length && (n++, (r = a[i].evaluate(t)) && r instanceof ae && !r.available && (e || (e = r.name), r = null, n === this.args.length && (r = e)), null === r); i += 1) {\n        ;\n      }\n\n      return r;\n    }, ur.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, ur.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, ur.prototype.serialize = function () {\n      var t = ["coalesce"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n\n    var lr = function lr(t, e) {\n      this.type = e.type, this.bindings = [].concat(t), this.result = e;\n    };\n\n    lr.prototype.evaluate = function (t) {\n      return this.result.evaluate(t);\n    }, lr.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.bindings; e < r.length; e += 1) {\n        t(r[e][1]);\n      }\n\n      t(this.result);\n    }, lr.parse = function (t, e) {\n      if (t.length < 4) return e.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead.");\n\n      for (var r = [], n = 1; n < t.length - 1; n += 2) {\n        var i = t[n];\n        if ("string" != typeof i) return e.error("Expected string, but found " + typeof i + " instead.", n);\n        if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or \'_\'.", n);\n        var a = e.parse(t[n + 1], n + 1);\n        if (!a) return null;\n        r.push([i, a]);\n      }\n\n      var o = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n      return o ? new lr(r, o) : null;\n    }, lr.prototype.outputDefined = function () {\n      return this.result.outputDefined();\n    }, lr.prototype.serialize = function () {\n      for (var t = ["let"], e = 0, r = this.bindings; e < r.length; e += 1) {\n        var n = r[e];\n        t.push(n[0], n[1].serialize());\n      }\n\n      return t.push(this.result.serialize()), t;\n    };\n\n    var pr = function pr(t, e, r) {\n      this.type = t, this.index = e, this.input = r;\n    };\n\n    pr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Ot),\n          n = e.parse(t[2], 2, Jt(e.expectedType || Kt));\n      return r && n ? new pr(n.type.itemType, r, n) : null;\n    }, pr.prototype.evaluate = function (t) {\n      var e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n      if (e < 0) throw new ce("Array index out of bounds: " + e + " < 0.");\n      if (e >= r.length) throw new ce("Array index out of bounds: " + e + " > " + (r.length - 1) + ".");\n      if (e !== Math.floor(e)) throw new ce("Array index must be an integer, but found " + e + " instead.");\n      return r[e];\n    }, pr.prototype.eachChild = function (t) {\n      t(this.index), t(this.input);\n    }, pr.prototype.outputDefined = function () {\n      return !1;\n    }, pr.prototype.serialize = function () {\n      return ["at", this.index.serialize(), this.input.serialize()];\n    };\n\n    var cr = function cr(t, e) {\n      this.type = jt, this.needle = t, this.haystack = e;\n    };\n\n    cr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Kt),\n          n = e.parse(t[2], 2, Kt);\n      return r && n ? Wt(r.type, [jt, Ut, Ot, Rt, Kt]) ? new cr(r, n) : e.error("Expected first argument to be of type boolean, string, number or null, but found " + Ht(r.type) + " instead") : null;\n    }, cr.prototype.evaluate = function (t) {\n      var e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n      if (!r) return !1;\n      if (!Qt(e, ["boolean", "string", "number", "null"])) throw new ce("Expected first argument to be of type boolean, string, number or null, but found " + Ht(ue(e)) + " instead.");\n      if (!Qt(r, ["string", "array"])) throw new ce("Expected second argument to be of type array or string, but found " + Ht(ue(r)) + " instead.");\n      return r.indexOf(e) >= 0;\n    }, cr.prototype.eachChild = function (t) {\n      t(this.needle), t(this.haystack);\n    }, cr.prototype.outputDefined = function () {\n      return !0;\n    }, cr.prototype.serialize = function () {\n      return ["in", this.needle.serialize(), this.haystack.serialize()];\n    };\n\n    var hr = function hr(t, e, r) {\n      this.type = Ot, this.needle = t, this.haystack = e, this.fromIndex = r;\n    };\n\n    hr.parse = function (t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Kt),\n          n = e.parse(t[2], 2, Kt);\n      if (!r || !n) return null;\n      if (!Wt(r.type, [jt, Ut, Ot, Rt, Kt])) return e.error("Expected first argument to be of type boolean, string, number or null, but found " + Ht(r.type) + " instead");\n\n      if (4 === t.length) {\n        var i = e.parse(t[3], 3, Ot);\n        return i ? new hr(r, n, i) : null;\n      }\n\n      return new hr(r, n);\n    }, hr.prototype.evaluate = function (t) {\n      var e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n      if (!Qt(e, ["boolean", "string", "number", "null"])) throw new ce("Expected first argument to be of type boolean, string, number or null, but found " + Ht(ue(e)) + " instead.");\n      if (!Qt(r, ["string", "array"])) throw new ce("Expected second argument to be of type array or string, but found " + Ht(ue(r)) + " instead.");\n\n      if (this.fromIndex) {\n        var n = this.fromIndex.evaluate(t);\n        return r.indexOf(e, n);\n      }\n\n      return r.indexOf(e);\n    }, hr.prototype.eachChild = function (t) {\n      t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n    }, hr.prototype.outputDefined = function () {\n      return !1;\n    }, hr.prototype.serialize = function () {\n      if (null != this.fromIndex && void 0 !== this.fromIndex) {\n        var t = this.fromIndex.serialize();\n        return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];\n      }\n\n      return ["index-of", this.needle.serialize(), this.haystack.serialize()];\n    };\n\n    var fr = function fr(t, e, r, n, i, a) {\n      this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = a;\n    };\n\n    fr.parse = function (t, e) {\n      if (t.length < 5) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");\n      var r, n;\n      e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);\n\n      for (var i = {}, a = [], o = 2; o < t.length - 1; o += 2) {\n        var s = t[o],\n            u = t[o + 1];\n        Array.isArray(s) || (s = [s]);\n        var l = e.concat(o);\n        if (0 === s.length) return l.error("Expected at least one branch label.");\n\n        for (var p = 0, c = s; p < c.length; p += 1) {\n          var h = c[p];\n          if ("number" != typeof h && "string" != typeof h) return l.error("Branch labels must be numbers or strings.");\n          if ("number" == typeof h && Math.abs(h) > Number.MAX_SAFE_INTEGER) return l.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");\n          if ("number" == typeof h && Math.floor(h) !== h) return l.error("Numeric branch labels must be integer values.");\n\n          if (r) {\n            if (l.checkSubtype(r, ue(h))) return null;\n          } else r = ue(h);\n\n          if (void 0 !== i[String(h)]) return l.error("Branch labels must be unique.");\n          i[String(h)] = a.length;\n        }\n\n        var f = e.parse(u, o, n);\n        if (!f) return null;\n        n = n || f.type, a.push(f);\n      }\n\n      var y = e.parse(t[1], 1, Kt);\n      if (!y) return null;\n      var d = e.parse(t[t.length - 1], t.length - 1, n);\n      return d ? "value" !== y.type.kind && e.concat(1).checkSubtype(r, y.type) ? null : new fr(r, n, y, i, a, d) : null;\n    }, fr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t);\n      return (ue(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n    }, fr.prototype.eachChild = function (t) {\n      t(this.input), this.outputs.forEach(t), t(this.otherwise);\n    }, fr.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }, fr.prototype.serialize = function () {\n      for (var t = this, e = ["match", this.input.serialize()], r = [], n = {}, i = 0, a = Object.keys(this.cases).sort(); i < a.length; i += 1) {\n        var o = a[i];\n        void 0 === (c = n[this.cases[o]]) ? (n[this.cases[o]] = r.length, r.push([this.cases[o], [o]])) : r[c][1].push(o);\n      }\n\n      for (var s = function s(e) {\n        return "number" === t.inputType.kind ? Number(e) : e;\n      }, u = 0, l = r; u < l.length; u += 1) {\n        var p = l[u],\n            c = p[0],\n            h = p[1];\n        e.push(1 === h.length ? s(h[0]) : h.map(s)), e.push(this.outputs[outputIndex$1].serialize());\n      }\n\n      return e.push(this.otherwise.serialize()), e;\n    };\n\n    var yr = function yr(t, e, r) {\n      this.type = t, this.branches = e, this.otherwise = r;\n    };\n\n    yr.parse = function (t, e) {\n      if (t.length < 4) return e.error("Expected at least 3 arguments, but found only " + (t.length - 1) + ".");\n      if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");\n      var r;\n      e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);\n\n      for (var n = [], i = 1; i < t.length - 1; i += 2) {\n        var a = e.parse(t[i], i, jt);\n        if (!a) return null;\n        var o = e.parse(t[i + 1], i + 1, r);\n        if (!o) return null;\n        n.push([a, o]), r = r || o.type;\n      }\n\n      var s = e.parse(t[t.length - 1], t.length - 1, r);\n      return s ? new yr(r, n, s) : null;\n    }, yr.prototype.evaluate = function (t) {\n      for (var e = 0, r = this.branches; e < r.length; e += 1) {\n        var n = r[e],\n            i = n[1];\n        if (n[0].evaluate(t)) return i.evaluate(t);\n      }\n\n      return this.otherwise.evaluate(t);\n    }, yr.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.branches; e < r.length; e += 1) {\n        var n = r[e],\n            i = n[1];\n        t(n[0]), t(i);\n      }\n\n      t(this.otherwise);\n    }, yr.prototype.outputDefined = function () {\n      return this.branches.every(function (t) {\n        return t[1].outputDefined();\n      }) && this.otherwise.outputDefined();\n    }, yr.prototype.serialize = function () {\n      var t = ["case"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n\n    var dr = function dr(t, e, r, n) {\n      this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n    };\n\n    function mr(t, e) {\n      return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;\n    }\n\n    function vr(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n\n    function gr(t, e, r) {\n      var n = "==" !== t && "!=" !== t;\n      return function () {\n        function i(t, e, r) {\n          this.type = jt, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;\n        }\n\n        return i.parse = function (t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");\n          var r = t[0],\n              a = e.parse(t[1], 1, Kt);\n          if (!a) return null;\n          if (!mr(r, a.type)) return e.concat(1).error(\'"\' + r + "\\" comparisons are not supported for type \'" + Ht(a.type) + "\'.");\n          var o = e.parse(t[2], 2, Kt);\n          if (!o) return null;\n          if (!mr(r, o.type)) return e.concat(2).error(\'"\' + r + "\\" comparisons are not supported for type \'" + Ht(o.type) + "\'.");\n          if (a.type.kind !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot compare types \'" + Ht(a.type) + "\' and \'" + Ht(o.type) + "\'.");\n          n && ("value" === a.type.kind && "value" !== o.type.kind ? a = new fe(o.type, [a]) : "value" !== a.type.kind && "value" === o.type.kind && (o = new fe(a.type, [o])));\n          var s = null;\n\n          if (4 === t.length) {\n            if ("string" !== a.type.kind && "string" !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot use collator to compare non-string types.");\n            if (!(s = e.parse(t[3], 3, Gt))) return null;\n          }\n\n          return new i(a, o, s);\n        }, i.prototype.evaluate = function (i) {\n          var a = this.lhs.evaluate(i),\n              o = this.rhs.evaluate(i);\n\n          if (n && this.hasUntypedArgument) {\n            var s = ue(a),\n                u = ue(o);\n            if (s.kind !== u.kind || "string" !== s.kind && "number" !== s.kind) throw new ce(\'Expected arguments for "\' + t + \'" to be (string, string) or (number, number), but found (\' + s.kind + ", " + u.kind + ") instead.");\n          }\n\n          if (this.collator && !n && this.hasUntypedArgument) {\n            var l = ue(a),\n                p = ue(o);\n            if ("string" !== l.kind || "string" !== p.kind) return e(i, a, o);\n          }\n\n          return this.collator ? r(i, a, o, this.collator.evaluate(i)) : e(i, a, o);\n        }, i.prototype.eachChild = function (t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }, i.prototype.outputDefined = function () {\n          return !0;\n        }, i.prototype.serialize = function () {\n          var e = [t];\n          return this.eachChild(function (t) {\n            e.push(t.serialize());\n          }), e;\n        }, i;\n      }();\n    }\n\n    dr.parse = function (t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Kt),\n          n = e.parse(t[2], 2, Ot);\n      if (!r || !n) return null;\n      if (!Wt(r.type, [Jt(Kt), Ut, Kt])) return e.error("Expected first argument to be of type array or string, but found " + Ht(r.type) + " instead");\n\n      if (4 === t.length) {\n        var i = e.parse(t[3], 3, Ot);\n        return i ? new dr(r.type, r, n, i) : null;\n      }\n\n      return new dr(r.type, r, n);\n    }, dr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t),\n          r = this.beginIndex.evaluate(t);\n      if (!Qt(e, ["string", "array"])) throw new ce("Expected first argument to be of type array or string, but found " + Ht(ue(e)) + " instead.");\n\n      if (this.endIndex) {\n        var n = this.endIndex.evaluate(t);\n        return e.slice(r, n);\n      }\n\n      return e.slice(r);\n    }, dr.prototype.eachChild = function (t) {\n      t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n    }, dr.prototype.outputDefined = function () {\n      return !1;\n    }, dr.prototype.serialize = function () {\n      if (null != this.endIndex && void 0 !== this.endIndex) {\n        var t = this.endIndex.serialize();\n        return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];\n      }\n\n      return ["slice", this.input.serialize(), this.beginIndex.serialize()];\n    };\n\n    var xr = gr("==", function (t, e, r) {\n      return e === r;\n    }, vr),\n        br = gr("!=", function (t, e, r) {\n      return e !== r;\n    }, function (t, e, r, n) {\n      return !vr(0, e, r, n);\n    }),\n        wr = gr("<", function (t, e, r) {\n      return e < r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) < 0;\n    }),\n        _r = gr(">", function (t, e, r) {\n      return e > r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) > 0;\n    }),\n        Ar = gr("<=", function (t, e, r) {\n      return e <= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) <= 0;\n    }),\n        Sr = gr(">=", function (t, e, r) {\n      return e >= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) >= 0;\n    }),\n        kr = function kr(t, e, r, n, i) {\n      this.type = Ut, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;\n    };\n\n    kr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected two arguments.");\n      var r = e.parse(t[1], 1, Ot);\n      if (!r) return null;\n      var n = t[2];\n      if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");\n      var i = null;\n      if (n.locale && !(i = e.parse(n.locale, 1, Ut))) return null;\n      var a = null;\n      if (n.currency && !(a = e.parse(n.currency, 1, Ut))) return null;\n      var o = null;\n      if (n["min-fraction-digits"] && !(o = e.parse(n["min-fraction-digits"], 1, Ot))) return null;\n      var s = null;\n      return n["max-fraction-digits"] && !(s = e.parse(n["max-fraction-digits"], 1, Ot)) ? null : new kr(r, i, a, o, s);\n    }, kr.prototype.evaluate = function (t) {\n      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n        style: this.currency ? "currency" : "decimal",\n        currency: this.currency ? this.currency.evaluate(t) : void 0,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n      }).format(this.number.evaluate(t));\n    }, kr.prototype.eachChild = function (t) {\n      t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n    }, kr.prototype.outputDefined = function () {\n      return !1;\n    }, kr.prototype.serialize = function () {\n      var t = {};\n      return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];\n    };\n\n    var Ir = function Ir(t) {\n      this.type = Ot, this.input = t;\n    };\n\n    Ir.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected 1 argument, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1);\n      return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error("Expected argument of type string or array, but found " + Ht(r.type) + " instead.") : new Ir(r) : null;\n    }, Ir.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t);\n      if ("string" == typeof e) return e.length;\n      if (Array.isArray(e)) return e.length;\n      throw new ce("Expected value to be of type string or array, but found " + Ht(ue(e)) + " instead.");\n    }, Ir.prototype.eachChild = function (t) {\n      t(this.input);\n    }, Ir.prototype.outputDefined = function () {\n      return !1;\n    }, Ir.prototype.serialize = function () {\n      var t = ["length"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n    var zr = {\n      "==": xr,\n      "!=": br,\n      ">": _r,\n      "<": wr,\n      ">=": Sr,\n      "<=": Ar,\n      array: fe,\n      at: pr,\n      boolean: fe,\n      case: yr,\n      coalesce: ur,\n      collator: we,\n      format: ye,\n      image: de,\n      in: cr,\n      "index-of": hr,\n      interpolate: or,\n      "interpolate-hcl": or,\n      "interpolate-lab": or,\n      length: Ir,\n      let: lr,\n      literal: pe,\n      match: fr,\n      number: fe,\n      "number-format": kr,\n      object: fe,\n      slice: dr,\n      step: Ke,\n      string: fe,\n      "to-boolean": ve,\n      "to-color": ve,\n      "to-number": ve,\n      "to-string": ve,\n      var: je,\n      within: Le\n    };\n\n    function Cr(t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          a = e[3];\n      r = r.evaluate(t), n = n.evaluate(t), i = i.evaluate(t);\n      var o = a ? a.evaluate(t) : 1,\n          s = oe(r, n, i, o);\n      if (s) throw new ce(s);\n      return new ee(r / 255 * o, n / 255 * o, i / 255 * o, o);\n    }\n\n    function Er(t, e) {\n      return t in e;\n    }\n\n    function Pr(t, e) {\n      var r = e[t];\n      return void 0 === r ? null : r;\n    }\n\n    function Mr(t) {\n      return {\n        type: t\n      };\n    }\n\n    function Br(t) {\n      return {\n        result: "success",\n        value: t\n      };\n    }\n\n    function Tr(t) {\n      return {\n        result: "error",\n        value: t\n      };\n    }\n\n    function Vr(t) {\n      return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"];\n    }\n\n    function Fr(t) {\n      return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;\n    }\n\n    function Dr(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n\n    function Lr(t) {\n      return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t;\n    }\n\n    function Rr(t) {\n      return "object" == typeof t && null !== t && !Array.isArray(t);\n    }\n\n    function Or(t) {\n      return t;\n    }\n\n    function Ur(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n\n    function jr(t, e, r, n, i) {\n      return Ur(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n\n    function qr(t, e, r) {\n      if ("number" !== Lr(r)) return Ur(t.default, e.default);\n      var n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      var i = Ne(t.stops.map(function (t) {\n        return t[0];\n      }), r);\n      return t.stops[i][1];\n    }\n\n    function Nr(t, e, r) {\n      var n = void 0 !== t.base ? t.base : 1;\n      if ("number" !== Lr(r)) return Ur(t.default, e.default);\n      var i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n\n      var a = Ne(t.stops.map(function (t) {\n        return t[0];\n      }), r),\n          o = function (t, e, r, n) {\n        var i = n - r,\n            a = t - r;\n        return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n      }(r, n, t.stops[a][0], t.stops[a + 1][0]),\n          s = t.stops[a][1],\n          u = t.stops[a + 1][1],\n          l = Ze[e.type] || Or;\n\n      if (t.colorSpace && "rgb" !== t.colorSpace) {\n        var p = ar[t.colorSpace];\n\n        l = function l(t, e) {\n          return p.reverse(p.interpolate(p.forward(t), p.forward(e), o));\n        };\n      }\n\n      return "function" == typeof s.evaluate ? {\n        evaluate: function evaluate() {\n          for (var t = [], e = arguments.length; e--;) {\n            t[e] = arguments[e];\n          }\n\n          var r = s.evaluate.apply(void 0, t),\n              n = u.evaluate.apply(void 0, t);\n          if (void 0 !== r && void 0 !== n) return l(r, n, o);\n        }\n      } : l(s, u, o);\n    }\n\n    function Kr(t, e, r) {\n      return "color" === e.type ? r = ee.parse(r) : "formatted" === e.type ? r = ie.fromString(r.toString()) : "resolvedImage" === e.type ? r = ae.fromString(r.toString()) : Lr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Ur(r, t.default, e.default);\n    }\n\n    be.register(zr, {\n      error: [{\n        kind: "error"\n      }, [Ut], function (t, e) {\n        throw new ce(e[0].evaluate(t));\n      }],\n      typeof: [Ut, [Kt], function (t, e) {\n        return Ht(ue(e[0].evaluate(t)));\n      }],\n      "to-rgba": [Jt(Ot, 4), [qt], function (t, e) {\n        return e[0].evaluate(t).toArray();\n      }],\n      rgb: [qt, [Ot, Ot, Ot], Cr],\n      rgba: [qt, [Ot, Ot, Ot, Ot], Cr],\n      has: {\n        type: jt,\n        overloads: [[[Ut], function (t, e) {\n          return Er(e[0].evaluate(t), t.properties());\n        }], [[Ut, Nt], function (t, e) {\n          var r = e[1];\n          return Er(e[0].evaluate(t), r.evaluate(t));\n        }]]\n      },\n      get: {\n        type: Kt,\n        overloads: [[[Ut], function (t, e) {\n          return Pr(e[0].evaluate(t), t.properties());\n        }], [[Ut, Nt], function (t, e) {\n          var r = e[1];\n          return Pr(e[0].evaluate(t), r.evaluate(t));\n        }]]\n      },\n      "feature-state": [Kt, [Ut], function (t, e) {\n        return Pr(e[0].evaluate(t), t.featureState || {});\n      }],\n      properties: [Nt, [], function (t) {\n        return t.properties();\n      }],\n      "geometry-type": [Ut, [], function (t) {\n        return t.geometryType();\n      }],\n      id: [Kt, [], function (t) {\n        return t.id();\n      }],\n      zoom: [Ot, [], function (t) {\n        return t.globals.zoom;\n      }],\n      "heatmap-density": [Ot, [], function (t) {\n        return t.globals.heatmapDensity || 0;\n      }],\n      "line-progress": [Ot, [], function (t) {\n        return t.globals.lineProgress || 0;\n      }],\n      accumulated: [Kt, [], function (t) {\n        return void 0 === t.globals.accumulated ? null : t.globals.accumulated;\n      }],\n      "+": [Ot, Mr(Ot), function (t, e) {\n        for (var r = 0, n = 0, i = e; n < i.length; n += 1) {\n          r += i[n].evaluate(t);\n        }\n\n        return r;\n      }],\n      "*": [Ot, Mr(Ot), function (t, e) {\n        for (var r = 1, n = 0, i = e; n < i.length; n += 1) {\n          r *= i[n].evaluate(t);\n        }\n\n        return r;\n      }],\n      "-": {\n        type: Ot,\n        overloads: [[[Ot, Ot], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) - r.evaluate(t);\n        }], [[Ot], function (t, e) {\n          return -e[0].evaluate(t);\n        }]]\n      },\n      "/": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return e[0].evaluate(t) / r.evaluate(t);\n      }],\n      "%": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return e[0].evaluate(t) % r.evaluate(t);\n      }],\n      ln2: [Ot, [], function () {\n        return Math.LN2;\n      }],\n      pi: [Ot, [], function () {\n        return Math.PI;\n      }],\n      e: [Ot, [], function () {\n        return Math.E;\n      }],\n      "^": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return Math.pow(e[0].evaluate(t), r.evaluate(t));\n      }],\n      sqrt: [Ot, [Ot], function (t, e) {\n        return Math.sqrt(e[0].evaluate(t));\n      }],\n      log10: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t)) / Math.LN10;\n      }],\n      ln: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t));\n      }],\n      log2: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t)) / Math.LN2;\n      }],\n      sin: [Ot, [Ot], function (t, e) {\n        return Math.sin(e[0].evaluate(t));\n      }],\n      cos: [Ot, [Ot], function (t, e) {\n        return Math.cos(e[0].evaluate(t));\n      }],\n      tan: [Ot, [Ot], function (t, e) {\n        return Math.tan(e[0].evaluate(t));\n      }],\n      asin: [Ot, [Ot], function (t, e) {\n        return Math.asin(e[0].evaluate(t));\n      }],\n      acos: [Ot, [Ot], function (t, e) {\n        return Math.acos(e[0].evaluate(t));\n      }],\n      atan: [Ot, [Ot], function (t, e) {\n        return Math.atan(e[0].evaluate(t));\n      }],\n      min: [Ot, Mr(Ot), function (t, e) {\n        return Math.min.apply(Math, e.map(function (e) {\n          return e.evaluate(t);\n        }));\n      }],\n      max: [Ot, Mr(Ot), function (t, e) {\n        return Math.max.apply(Math, e.map(function (e) {\n          return e.evaluate(t);\n        }));\n      }],\n      abs: [Ot, [Ot], function (t, e) {\n        return Math.abs(e[0].evaluate(t));\n      }],\n      round: [Ot, [Ot], function (t, e) {\n        var r = e[0].evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [Ot, [Ot], function (t, e) {\n        return Math.floor(e[0].evaluate(t));\n      }],\n      ceil: [Ot, [Ot], function (t, e) {\n        return Math.ceil(e[0].evaluate(t));\n      }],\n      "filter-==": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n            n = e[1];\n        return t.properties()[r.value] === n.value;\n      }],\n      "filter-id-==": [jt, [Kt], function (t, e) {\n        var r = e[0];\n        return t.id() === r.value;\n      }],\n      "filter-type-==": [jt, [Ut], function (t, e) {\n        var r = e[0];\n        return t.geometryType() === r.value;\n      }],\n      "filter-<": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i < a;\n      }],\n      "filter-id-<": [jt, [Kt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      "filter->": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i > a;\n      }],\n      "filter-id->": [jt, [Kt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      "filter-<=": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i <= a;\n      }],\n      "filter-id-<=": [jt, [Kt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      "filter->=": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n            n = e[1],\n            i = t.properties()[r.value],\n            a = n.value;\n        return typeof i == typeof a && i >= a;\n      }],\n      "filter-id->=": [jt, [Kt], function (t, e) {\n        var r = e[0],\n            n = t.id(),\n            i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      "filter-has": [jt, [Kt], function (t, e) {\n        return e[0].value in t.properties();\n      }],\n      "filter-has-id": [jt, [], function (t) {\n        return null !== t.id() && void 0 !== t.id();\n      }],\n      "filter-type-in": [jt, [Jt(Ut)], function (t, e) {\n        return e[0].value.indexOf(t.geometryType()) >= 0;\n      }],\n      "filter-id-in": [jt, [Jt(Kt)], function (t, e) {\n        return e[0].value.indexOf(t.id()) >= 0;\n      }],\n      "filter-in-small": [jt, [Ut, Jt(Kt)], function (t, e) {\n        var r = e[0];\n        return e[1].value.indexOf(t.properties()[r.value]) >= 0;\n      }],\n      "filter-in-large": [jt, [Ut, Jt(Kt)], function (t, e) {\n        var r = e[0],\n            n = e[1];\n        return function (t, e, r, n) {\n          for (; r <= n;) {\n            var i = r + n >> 1;\n            if (e[i] === t) return !0;\n            e[i] > t ? n = i - 1 : r = i + 1;\n          }\n\n          return !1;\n        }(t.properties()[r.value], n.value, 0, n.value.length - 1);\n      }],\n      all: {\n        type: jt,\n        overloads: [[[jt, jt], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) && r.evaluate(t);\n        }], [Mr(jt), function (t, e) {\n          for (var r = 0, n = e; r < n.length; r += 1) {\n            if (!n[r].evaluate(t)) return !1;\n          }\n\n          return !0;\n        }]]\n      },\n      any: {\n        type: jt,\n        overloads: [[[jt, jt], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) || r.evaluate(t);\n        }], [Mr(jt), function (t, e) {\n          for (var r = 0, n = e; r < n.length; r += 1) {\n            if (n[r].evaluate(t)) return !0;\n          }\n\n          return !1;\n        }]]\n      },\n      "!": [jt, [jt], function (t, e) {\n        return !e[0].evaluate(t);\n      }],\n      "is-supported-script": [jt, [Ut], function (t, e) {\n        var r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e[0].evaluate(t));\n      }],\n      upcase: [Ut, [Ut], function (t, e) {\n        return e[0].evaluate(t).toUpperCase();\n      }],\n      downcase: [Ut, [Ut], function (t, e) {\n        return e[0].evaluate(t).toLowerCase();\n      }],\n      concat: [Ut, Mr(Kt), function (t, e) {\n        return e.map(function (e) {\n          return le(e.evaluate(t));\n        }).join("");\n      }],\n      "resolved-locale": [Ut, [Gt], function (t, e) {\n        return e[0].evaluate(t).resolvedLocale();\n      }]\n    });\n\n    var Gr = function Gr(t, e) {\n      this.expression = t, this._warningHistory = {}, this._evaluator = new xe(), this._defaultValue = e ? function (t) {\n        return "color" === t.type && Rr(t.default) ? new ee(0, 0, 0, 0) : "color" === t.type ? ee.parse(t.default) || null : void 0 === t.default ? null : t.default;\n      }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;\n    };\n\n    function Zr(t) {\n      return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in zr;\n    }\n\n    function Xr(t, e) {\n      var r = new qe(zr, [], e ? function (t) {\n        var e = {\n          color: qt,\n          string: Ut,\n          number: Ot,\n          enum: Ut,\n          boolean: jt,\n          formatted: Zt,\n          resolvedImage: Xt\n        };\n        return "array" === t.type ? Jt(e[t.value] || Kt, t.length) : e[t.type];\n      }(e) : void 0),\n          n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {\n        typeAnnotation: "coerce"\n      } : void 0);\n      return n ? Br(new Gr(n, e)) : Tr(r.errors);\n    }\n\n    Gr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);\n    }, Gr.prototype.evaluate = function (t, e, r, n, i, a) {\n      this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null;\n\n      try {\n        var o = this.expression.evaluate(this._evaluator);\n        if (null == o || "number" == typeof o && o != o) return this._defaultValue;\n        if (this._enumValues && !(o in this._enumValues)) throw new ce("Expected value to be one of " + Object.keys(this._enumValues).map(function (t) {\n          return JSON.stringify(t);\n        }).join(", ") + ", but found " + JSON.stringify(o) + " instead.");\n        return o;\n      } catch (t) {\n        return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue;\n      }\n    };\n\n    var Jr = function Jr(t, e) {\n      this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !Oe(e.expression);\n    };\n\n    Jr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n    }, Jr.prototype.evaluate = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluate(t, e, r, n, i, a);\n    };\n\n    var Hr = function Hr(t, e, r, n) {\n      this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !Oe(e.expression), this.interpolationType = n;\n    };\n\n    function Yr(t, e) {\n      if ("error" === (t = Xr(t, e)).result) return t;\n      var r = t.value.expression,\n          n = Re(r);\n      if (!n && !Vr(e)) return Tr([new Dt("", "data expressions not supported")]);\n      var i = Ue(r, ["zoom"]);\n      if (!i && !Fr(e)) return Tr([new Dt("", "zoom expressions not supported")]);\n\n      var a = function t(e) {\n        var r = null;\n        if (e instanceof lr) r = t(e.result);else if (e instanceof ur) for (var n = 0, i = e.args; n < i.length && !(r = t(i[n])); n += 1) {\n          ;\n        } else (e instanceof Ke || e instanceof or) && e.input instanceof be && "zoom" === e.input.name && (r = e);\n        return r instanceof Dt || e.eachChild(function (e) {\n          var n = t(e);\n          n instanceof Dt ? r = n : !r && n ? r = new Dt("", \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\') : r && n && r !== n && (r = new Dt("", \'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\'));\n        }), r;\n      }(r);\n\n      return a || i ? a instanceof Dt ? Tr([a]) : a instanceof or && !Dr(e) ? Tr([new Dt("", \'"interpolate" expressions cannot be used with this property\')]) : Br(a ? new Hr(n ? "camera" : "composite", t.value, a.labels, a instanceof or ? a.interpolation : void 0) : new Jr(n ? "constant" : "source", t.value)) : Tr([new Dt("", \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);\n    }\n\n    Hr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n    }, Hr.prototype.evaluate = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluate(t, e, r, n, i, a);\n    }, Hr.prototype.interpolationFactor = function (t, e, r) {\n      return this.interpolationType ? or.interpolationFactor(this.interpolationType, t, e, r) : 0;\n    };\n\n    var $r = function $r(t, e) {\n      this._parameters = t, this._specification = e, Tt(this, function t(e, r) {\n        var n,\n            i,\n            a,\n            o = "color" === r.type,\n            s = e.stops && "object" == typeof e.stops[0][0],\n            u = s || !(s || void 0 !== e.property),\n            l = e.type || (Dr(r) ? "exponential" : "interval");\n        if (o && ((e = Tt({}, e)).stops && (e.stops = e.stops.map(function (t) {\n          return [t[0], ee.parse(t[1])];\n        })), e.default = ee.parse(e.default ? e.default : r.default)), e.colorSpace && "rgb" !== e.colorSpace && !ar[e.colorSpace]) throw new Error("Unknown color space: " + e.colorSpace);\n        if ("exponential" === l) n = Nr;else if ("interval" === l) n = qr;else if ("categorical" === l) {\n          n = jr, i = Object.create(null);\n\n          for (var p = 0, c = e.stops; p < c.length; p += 1) {\n            var h = c[p];\n            i[h[0]] = h[1];\n          }\n\n          a = typeof e.stops[0][0];\n        } else {\n          if ("identity" !== l) throw new Error(\'Unknown function type "\' + l + \'"\');\n          n = Kr;\n        }\n\n        if (s) {\n          for (var f = {}, y = [], d = 0; d < e.stops.length; d++) {\n            var m = e.stops[d],\n                v = m[0].zoom;\n            void 0 === f[v] && (f[v] = {\n              zoom: v,\n              type: e.type,\n              property: e.property,\n              default: e.default,\n              stops: []\n            }, y.push(v)), f[v].stops.push([m[0].value, m[1]]);\n          }\n\n          for (var g = [], x = 0, b = y; x < b.length; x += 1) {\n            var w = b[x];\n            g.push([f[w].zoom, t(f[w], r)]);\n          }\n\n          var _ = {\n            name: "linear"\n          };\n          return {\n            kind: "composite",\n            interpolationType: _,\n            interpolationFactor: or.interpolationFactor.bind(void 0, _),\n            zoomStops: g.map(function (t) {\n              return t[0];\n            }),\n            evaluate: function evaluate(t, n) {\n              var i = t.zoom;\n              return Nr({\n                stops: g,\n                base: e.base\n              }, r, i).evaluate(i, n);\n            }\n          };\n        }\n\n        if (u) {\n          var A = "exponential" === l ? {\n            name: "exponential",\n            base: void 0 !== e.base ? e.base : 1\n          } : null;\n          return {\n            kind: "camera",\n            interpolationType: A,\n            interpolationFactor: or.interpolationFactor.bind(void 0, A),\n            zoomStops: e.stops.map(function (t) {\n              return t[0];\n            }),\n            evaluate: function evaluate(t) {\n              return n(e, r, t.zoom, i, a);\n            }\n          };\n        }\n\n        return {\n          kind: "source",\n          evaluate: function evaluate(t, o) {\n            var s = o && o.properties ? o.properties[e.property] : void 0;\n            return void 0 === s ? Ur(e.default, r.default) : n(e, r, s, i, a);\n          }\n        };\n      }(this._parameters, this._specification));\n    };\n\n    function Wr(t) {\n      var e = t.key,\n          r = t.value,\n          n = t.valueSpec || {},\n          i = t.objectElementValidators || {},\n          a = t.style,\n          o = t.styleSpec,\n          s = [],\n          u = Lr(r);\n      if ("object" !== u) return [new Mt(e, r, "object expected, " + u + " found")];\n\n      for (var l in r) {\n        var p = l.split(".")[0],\n            c = n[p] || n["*"],\n            h = void 0;\n        if (i[p]) h = i[p];else if (n[p]) h = Sn;else if (i["*"]) h = i["*"];else {\n          if (!n["*"]) {\n            s.push(new Mt(e, r[l], \'unknown property "\' + l + \'"\'));\n            continue;\n          }\n\n          h = Sn;\n        }\n        s = s.concat(h({\n          key: (e ? e + "." : e) + l,\n          value: r[l],\n          valueSpec: c,\n          style: a,\n          styleSpec: o,\n          object: r,\n          objectKey: l\n        }, r));\n      }\n\n      for (var f in n) {\n        i[f] || n[f].required && void 0 === n[f].default && void 0 === r[f] && s.push(new Mt(e, r, \'missing required property "\' + f + \'"\'));\n      }\n\n      return s;\n    }\n\n    function Qr(t) {\n      var e = t.value,\n          r = t.valueSpec,\n          n = t.style,\n          i = t.styleSpec,\n          a = t.key,\n          o = t.arrayElementValidator || Sn;\n      if ("array" !== Lr(e)) return [new Mt(a, e, "array expected, " + Lr(e) + " found")];\n      if (r.length && e.length !== r.length) return [new Mt(a, e, "array length " + r.length + " expected, length " + e.length + " found")];\n      if (r["min-length"] && e.length < r["min-length"]) return [new Mt(a, e, "array length at least " + r["min-length"] + " expected, length " + e.length + " found")];\n      var s = {\n        type: r.value,\n        values: r.values\n      };\n      i.$version < 7 && (s.function = r.function), "object" === Lr(r.value) && (s = r.value);\n\n      for (var u = [], l = 0; l < e.length; l++) {\n        u = u.concat(o({\n          array: e,\n          arrayIndex: l,\n          value: e[l],\n          valueSpec: s,\n          style: n,\n          styleSpec: i,\n          key: a + "[" + l + "]"\n        }));\n      }\n\n      return u;\n    }\n\n    function tn(t) {\n      var e = t.key,\n          r = t.value,\n          n = t.valueSpec,\n          i = Lr(r);\n      return "number" === i && r != r && (i = "NaN"), "number" !== i ? [new Mt(e, r, "number expected, " + i + " found")] : "minimum" in n && r < n.minimum ? [new Mt(e, r, r + " is less than the minimum value " + n.minimum)] : "maximum" in n && r > n.maximum ? [new Mt(e, r, r + " is greater than the maximum value " + n.maximum)] : [];\n    }\n\n    function en(t) {\n      var e,\n          r,\n          n,\n          i = t.valueSpec,\n          a = Vt(t.value.type),\n          o = {},\n          s = "categorical" !== a && void 0 === t.value.property,\n          u = !s,\n          l = "array" === Lr(t.value.stops) && "array" === Lr(t.value.stops[0]) && "object" === Lr(t.value.stops[0][0]),\n          p = Wr({\n        key: t.key,\n        value: t.value,\n        valueSpec: t.styleSpec.function,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          stops: function stops(t) {\n            if ("identity" === a) return [new Mt(t.key, t.value, \'identity function may not have a "stops" property\')];\n            var e = [],\n                r = t.value;\n            return e = e.concat(Qr({\n              key: t.key,\n              value: r,\n              valueSpec: t.valueSpec,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              arrayElementValidator: c\n            })), "array" === Lr(r) && 0 === r.length && e.push(new Mt(t.key, r, "array must have at least one stop")), e;\n          },\n          default: function _default(t) {\n            return Sn({\n              key: t.key,\n              value: t.value,\n              valueSpec: i,\n              style: t.style,\n              styleSpec: t.styleSpec\n            });\n          }\n        }\n      });\n      return "identity" === a && s && p.push(new Mt(t.key, t.value, \'missing required property "property"\')), "identity" === a || t.value.stops || p.push(new Mt(t.key, t.value, \'missing required property "stops"\')), "exponential" === a && t.valueSpec.expression && !Dr(t.valueSpec) && p.push(new Mt(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (u && !Vr(t.valueSpec) ? p.push(new Mt(t.key, t.value, "property functions not supported")) : s && !Fr(t.valueSpec) && p.push(new Mt(t.key, t.value, "zoom functions not supported"))), "categorical" !== a && !l || void 0 !== t.value.property || p.push(new Mt(t.key, t.value, \'"property" property is required\')), p;\n\n      function c(t) {\n        var e = [],\n            a = t.value,\n            s = t.key;\n        if ("array" !== Lr(a)) return [new Mt(s, a, "array expected, " + Lr(a) + " found")];\n        if (2 !== a.length) return [new Mt(s, a, "array length 2 expected, length " + a.length + " found")];\n\n        if (l) {\n          if ("object" !== Lr(a[0])) return [new Mt(s, a, "object expected, " + Lr(a[0]) + " found")];\n          if (void 0 === a[0].zoom) return [new Mt(s, a, "object stop key must have zoom")];\n          if (void 0 === a[0].value) return [new Mt(s, a, "object stop key must have value")];\n          if (n && n > Vt(a[0].zoom)) return [new Mt(s, a[0].zoom, "stop zoom values must appear in ascending order")];\n          Vt(a[0].zoom) !== n && (n = Vt(a[0].zoom), r = void 0, o = {}), e = e.concat(Wr({\n            key: s + "[0]",\n            value: a[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: tn,\n              value: h\n            }\n          }));\n        } else e = e.concat(h({\n          key: s + "[0]",\n          value: a[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, a));\n\n        return Zr(Ft(a[1])) ? e.concat([new Mt(s + "[1]", a[1], "expressions are not allowed in function stops.")]) : e.concat(Sn({\n          key: s + "[1]",\n          value: a[1],\n          valueSpec: i,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n\n      function h(t, n) {\n        var s = Lr(t.value),\n            u = Vt(t.value),\n            l = null !== t.value ? t.value : n;\n\n        if (e) {\n          if (s !== e) return [new Mt(t.key, l, s + " stop domain type must match previous stop domain type " + e)];\n        } else e = s;\n\n        if ("number" !== s && "string" !== s && "boolean" !== s) return [new Mt(t.key, l, "stop domain value must be a number, string, or boolean")];\n\n        if ("number" !== s && "categorical" !== a) {\n          var p = "number expected, " + s + " found";\n          return Vr(i) && void 0 === a && (p += \'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\'), [new Mt(t.key, l, p)];\n        }\n\n        return "categorical" !== a || "number" !== s || isFinite(u) && Math.floor(u) === u ? "categorical" !== a && "number" === s && void 0 !== r && u < r ? [new Mt(t.key, l, "stop domain values must appear in ascending order")] : (r = u, "categorical" === a && u in o ? [new Mt(t.key, l, "stop domain values must be unique")] : (o[u] = !0, [])) : [new Mt(t.key, l, "integer expected, found " + u)];\n      }\n    }\n\n    function rn(t) {\n      var e = ("property" === t.expressionContext ? Yr : Xr)(Ft(t.value), t.valueSpec);\n      if ("error" === e.result) return e.value.map(function (e) {\n        return new Mt("" + t.key + e.key, t.value, e.message);\n      });\n      var r = e.value.expression || e.value._styleExpression.expression;\n      if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new Mt(t.key, t.value, \'Invalid data expression for "\' + t.propertyKey + \'". Output values must be contained as literals within the expression.\')];\n      if ("property" === t.expressionContext && "layout" === t.propertyType && !Oe(r)) return [new Mt(t.key, t.value, \'"feature-state" data expressions are not supported with layout properties.\')];\n      if ("filter" === t.expressionContext && !Oe(r)) return [new Mt(t.key, t.value, \'"feature-state" data expressions are not supported with filters.\')];\n\n      if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {\n        if (!Ue(r, ["zoom", "feature-state"])) return [new Mt(t.key, t.value, \'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];\n        if ("cluster-initial" === t.expressionContext && !Re(r)) return [new Mt(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];\n      }\n\n      return [];\n    }\n\n    function nn(t) {\n      var e = t.key,\n          r = t.value,\n          n = t.valueSpec,\n          i = [];\n      return Array.isArray(n.values) ? -1 === n.values.indexOf(Vt(r)) && i.push(new Mt(e, r, "expected one of [" + n.values.join(", ") + "], " + JSON.stringify(r) + " found")) : -1 === Object.keys(n.values).indexOf(Vt(r)) && i.push(new Mt(e, r, "expected one of [" + Object.keys(n.values).join(", ") + "], " + JSON.stringify(r) + " found")), i;\n    }\n\n    function an(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n\n      switch (t[0]) {\n        case "has":\n          return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];\n\n        case "in":\n          return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));\n\n        case "!in":\n        case "!has":\n        case "none":\n          return !1;\n\n        case "==":\n        case "!=":\n        case ">":\n        case ">=":\n        case "<":\n        case "<=":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n\n        case "any":\n        case "all":\n          for (var e = 0, r = t.slice(1); e < r.length; e += 1) {\n            var n = r[e];\n            if (!an(n) && "boolean" != typeof n) return !1;\n          }\n\n          return !0;\n\n        default:\n          return !0;\n      }\n    }\n\n    $r.deserialize = function (t) {\n      return new $r(t._parameters, t._specification);\n    }, $r.serialize = function (t) {\n      return {\n        _parameters: t._parameters,\n        _specification: t._specification\n      };\n    };\n    var on = {\n      type: "boolean",\n      default: !1,\n      transition: !1,\n      "property-type": "data-driven",\n      expression: {\n        interpolated: !1,\n        parameters: ["zoom", "feature"]\n      }\n    };\n\n    function sn(t) {\n      if (null == t) return {\n        filter: function filter() {\n          return !0;\n        },\n        needGeometry: !1\n      };\n      an(t) || (t = ln(t));\n      var e = Xr(t, on);\n      if ("error" === e.result) throw new Error(e.value.map(function (t) {\n        return t.key + ": " + t.message;\n      }).join(", "));\n      return {\n        filter: function filter(t, r, n) {\n          return e.value.evaluate(t, r, {}, n);\n        },\n        needGeometry: function t(e) {\n          if (!Array.isArray(e)) return !1;\n          if ("within" === e[0]) return !0;\n\n          for (var r = 1; r < e.length; r++) {\n            if (t(e[r])) return !0;\n          }\n\n          return !1;\n        }(t)\n      };\n    }\n\n    function un(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function ln(t) {\n      if (!t) return !0;\n      var e,\n          r = t[0];\n      return t.length <= 1 ? "any" !== r : "==" === r ? pn(t[1], t[2], "==") : "!=" === r ? fn(pn(t[1], t[2], "==")) : "<" === r || ">" === r || "<=" === r || ">=" === r ? pn(t[1], t[2], r) : "any" === r ? (e = t.slice(1), ["any"].concat(e.map(ln))) : "all" === r ? ["all"].concat(t.slice(1).map(ln)) : "none" === r ? ["all"].concat(t.slice(1).map(ln).map(fn)) : "in" === r ? cn(t[1], t.slice(2)) : "!in" === r ? fn(cn(t[1], t.slice(2))) : "has" === r ? hn(t[1]) : "!has" === r ? fn(hn(t[1])) : "within" !== r || t;\n    }\n\n    function pn(t, e, r) {\n      switch (t) {\n        case "$type":\n          return ["filter-type-" + r, e];\n\n        case "$id":\n          return ["filter-id-" + r, e];\n\n        default:\n          return ["filter-" + r, t, e];\n      }\n    }\n\n    function cn(t, e) {\n      if (0 === e.length) return !1;\n\n      switch (t) {\n        case "$type":\n          return ["filter-type-in", ["literal", e]];\n\n        case "$id":\n          return ["filter-id-in", ["literal", e]];\n\n        default:\n          return e.length > 200 && !e.some(function (t) {\n            return typeof t != typeof e[0];\n          }) ? ["filter-in-large", t, ["literal", e.sort(un)]] : ["filter-in-small", t, ["literal", e]];\n      }\n    }\n\n    function hn(t) {\n      switch (t) {\n        case "$type":\n          return !0;\n\n        case "$id":\n          return ["filter-has-id"];\n\n        default:\n          return ["filter-has", t];\n      }\n    }\n\n    function fn(t) {\n      return ["!", t];\n    }\n\n    function yn(t) {\n      return an(Ft(t.value)) ? rn(Tt({}, t, {\n        expressionContext: "filter",\n        valueSpec: {\n          value: "boolean"\n        }\n      })) : function t(e) {\n        var r = e.value,\n            n = e.key;\n        if ("array" !== Lr(r)) return [new Mt(n, r, "array expected, " + Lr(r) + " found")];\n        var i,\n            a = e.styleSpec,\n            o = [];\n        if (r.length < 1) return [new Mt(n, r, "filter array must have at least 1 element")];\n\n        switch (o = o.concat(nn({\n          key: n + "[0]",\n          value: r[0],\n          valueSpec: a.filter_operator,\n          style: e.style,\n          styleSpec: e.styleSpec\n        })), Vt(r[0])) {\n          case "<":\n          case "<=":\n          case ">":\n          case ">=":\n            r.length >= 2 && "$type" === Vt(r[1]) && o.push(new Mt(n, r, \'"$type" cannot be use with operator "\' + r[0] + \'"\'));\n\n          case "==":\n          case "!=":\n            3 !== r.length && o.push(new Mt(n, r, \'filter array for operator "\' + r[0] + \'" must have 3 elements\'));\n\n          case "in":\n          case "!in":\n            r.length >= 2 && "string" !== (i = Lr(r[1])) && o.push(new Mt(n + "[1]", r[1], "string expected, " + i + " found"));\n\n            for (var s = 2; s < r.length; s++) {\n              i = Lr(r[s]), "$type" === Vt(r[1]) ? o = o.concat(nn({\n                key: n + "[" + s + "]",\n                value: r[s],\n                valueSpec: a.geometry_type,\n                style: e.style,\n                styleSpec: e.styleSpec\n              })) : "string" !== i && "number" !== i && "boolean" !== i && o.push(new Mt(n + "[" + s + "]", r[s], "string, number, or boolean expected, " + i + " found"));\n            }\n\n            break;\n\n          case "any":\n          case "all":\n          case "none":\n            for (var u = 1; u < r.length; u++) {\n              o = o.concat(t({\n                key: n + "[" + u + "]",\n                value: r[u],\n                style: e.style,\n                styleSpec: e.styleSpec\n              }));\n            }\n\n            break;\n\n          case "has":\n          case "!has":\n            i = Lr(r[1]), 2 !== r.length ? o.push(new Mt(n, r, \'filter array for "\' + r[0] + \'" operator must have 2 elements\')) : "string" !== i && o.push(new Mt(n + "[1]", r[1], "string expected, " + i + " found"));\n            break;\n\n          case "within":\n            i = Lr(r[1]), 2 !== r.length ? o.push(new Mt(n, r, \'filter array for "\' + r[0] + \'" operator must have 2 elements\')) : "object" !== i && o.push(new Mt(n + "[1]", r[1], "object expected, " + i + " found"));\n        }\n\n        return o;\n      }(t);\n    }\n\n    function dn(t, e) {\n      var r = t.key,\n          n = t.style,\n          i = t.styleSpec,\n          a = t.value,\n          o = t.objectKey,\n          s = i[e + "_" + t.layerType];\n      if (!s) return [];\n      var u = o.match(/^(.*)-transition$/);\n      if ("paint" === e && u && s[u[1]] && s[u[1]].transition) return Sn({\n        key: r,\n        value: a,\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      });\n      var l,\n          p = t.valueSpec || s[o];\n      if (!p) return [new Mt(r, a, \'unknown property "\' + o + \'"\')];\n      if ("string" === Lr(a) && Vr(p) && !p.tokens && (l = /^{([^}]+)}$/.exec(a))) return [new Mt(r, a, \'"\' + o + \'" does not support interpolation syntax\\nUse an identity property function instead: `{ "type": "identity", "property": \' + JSON.stringify(l[1]) + " }`.")];\n      var c = [];\n      return "symbol" === t.layerType && ("text-field" === o && n && !n.glyphs && c.push(new Mt(r, a, \'use of "text-field" requires a style "glyphs" property\')), "text-font" === o && Rr(Ft(a)) && "identity" === Vt(a.type) && c.push(new Mt(r, a, \'"text-font" does not support identity functions\'))), c.concat(Sn({\n        key: t.key,\n        value: a,\n        valueSpec: p,\n        style: n,\n        styleSpec: i,\n        expressionContext: "property",\n        propertyType: e,\n        propertyKey: o\n      }));\n    }\n\n    function mn(t) {\n      return dn(t, "paint");\n    }\n\n    function vn(t) {\n      return dn(t, "layout");\n    }\n\n    function gn(t) {\n      var e = [],\n          r = t.value,\n          n = t.key,\n          i = t.style,\n          a = t.styleSpec;\n      r.type || r.ref || e.push(new Mt(n, r, \'either "type" or "ref" is required\'));\n      var o,\n          s = Vt(r.type),\n          u = Vt(r.ref);\n      if (r.id) for (var l = Vt(r.id), p = 0; p < t.arrayIndex; p++) {\n        var c = i.layers[p];\n        Vt(c.id) === l && e.push(new Mt(n, r.id, \'duplicate layer id "\' + r.id + \'", previously used at line \' + c.id.__line__));\n      }\n      if ("ref" in r) ["type", "source", "source-layer", "filter", "layout"].forEach(function (t) {\n        t in r && e.push(new Mt(n, r[t], \'"\' + t + \'" is prohibited for ref layers\'));\n      }), i.layers.forEach(function (t) {\n        Vt(t.id) === u && (o = t);\n      }), o ? o.ref ? e.push(new Mt(n, r.ref, "ref cannot reference another ref layer")) : s = Vt(o.type) : e.push(new Mt(n, r.ref, \'ref layer "\' + u + \'" not found\'));else if ("background" !== s) if (r.source) {\n        var h = i.sources && i.sources[r.source],\n            f = h && Vt(h.type);\n        h ? "vector" === f && "raster" === s ? e.push(new Mt(n, r.source, \'layer "\' + r.id + \'" requires a raster source\')) : "raster" === f && "raster" !== s ? e.push(new Mt(n, r.source, \'layer "\' + r.id + \'" requires a vector source\')) : "vector" !== f || r["source-layer"] ? "raster-dem" === f && "hillshade" !== s ? e.push(new Mt(n, r.source, "raster-dem source can only be used with layer type \'hillshade\'.")) : "line" !== s || !r.paint || !r.paint["line-gradient"] || "geojson" === f && h.lineMetrics || e.push(new Mt(n, r, \'layer "\' + r.id + \'" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.\')) : e.push(new Mt(n, r, \'layer "\' + r.id + \'" must specify a "source-layer"\')) : e.push(new Mt(n, r.source, \'source "\' + r.source + \'" not found\'));\n      } else e.push(new Mt(n, r, \'missing required property "source"\'));\n      return e = e.concat(Wr({\n        key: n,\n        value: r,\n        valueSpec: a.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          "*": function _() {\n            return [];\n          },\n          type: function type() {\n            return Sn({\n              key: n + ".type",\n              value: r.type,\n              valueSpec: a.layer.type,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              object: r,\n              objectKey: "type"\n            });\n          },\n          filter: yn,\n          layout: function layout(t) {\n            return Wr({\n              layer: r,\n              key: t.key,\n              value: t.value,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              objectElementValidators: {\n                "*": function _(t) {\n                  return vn(Tt({\n                    layerType: s\n                  }, t));\n                }\n              }\n            });\n          },\n          paint: function paint(t) {\n            return Wr({\n              layer: r,\n              key: t.key,\n              value: t.value,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              objectElementValidators: {\n                "*": function _(t) {\n                  return mn(Tt({\n                    layerType: s\n                  }, t));\n                }\n              }\n            });\n          }\n        }\n      }));\n    }\n\n    function xn(t) {\n      var e = t.value,\n          r = t.key,\n          n = Lr(e);\n      return "string" !== n ? [new Mt(r, e, "string expected, " + n + " found")] : [];\n    }\n\n    var bn = {\n      promoteId: function promoteId(t) {\n        var e = t.key,\n            r = t.value;\n        if ("string" === Lr(r)) return xn({\n          key: e,\n          value: r\n        });\n        var n = [];\n\n        for (var i in r) {\n          n.push.apply(n, xn({\n            key: e + "." + i,\n            value: r[i]\n          }));\n        }\n\n        return n;\n      }\n    };\n\n    function wn(t) {\n      var e = t.value,\n          r = t.key,\n          n = t.styleSpec,\n          i = t.style;\n      if (!e.type) return [new Mt(r, e, \'"type" is required\')];\n      var a,\n          o = Vt(e.type);\n\n      switch (o) {\n        case "vector":\n        case "raster":\n        case "raster-dem":\n          return Wr({\n            key: r,\n            value: e,\n            valueSpec: n["source_" + o.replace("-", "_")],\n            style: t.style,\n            styleSpec: n,\n            objectElementValidators: bn\n          });\n\n        case "geojson":\n          if (a = Wr({\n            key: r,\n            value: e,\n            valueSpec: n.source_geojson,\n            style: i,\n            styleSpec: n,\n            objectElementValidators: bn\n          }), e.cluster) for (var s in e.clusterProperties) {\n            var u = e.clusterProperties[s],\n                l = u[0],\n                p = "string" == typeof l ? [l, ["accumulated"], ["get", s]] : l;\n            a.push.apply(a, rn({\n              key: r + "." + s + ".map",\n              value: u[1],\n              expressionContext: "cluster-map"\n            })), a.push.apply(a, rn({\n              key: r + "." + s + ".reduce",\n              value: p,\n              expressionContext: "cluster-reduce"\n            }));\n          }\n          return a;\n\n        case "video":\n          return Wr({\n            key: r,\n            value: e,\n            valueSpec: n.source_video,\n            style: i,\n            styleSpec: n\n          });\n\n        case "image":\n          return Wr({\n            key: r,\n            value: e,\n            valueSpec: n.source_image,\n            style: i,\n            styleSpec: n\n          });\n\n        case "canvas":\n          return [new Mt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];\n\n        default:\n          return nn({\n            key: r + ".type",\n            value: e.type,\n            valueSpec: {\n              values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]\n            },\n            style: i,\n            styleSpec: n\n          });\n      }\n    }\n\n    function _n(t) {\n      var e = t.value,\n          r = t.styleSpec,\n          n = r.light,\n          i = t.style,\n          a = [],\n          o = Lr(e);\n      if (void 0 === e) return a;\n      if ("object" !== o) return a.concat([new Mt("light", e, "object expected, " + o + " found")]);\n\n      for (var s in e) {\n        var u = s.match(/^(.*)-transition$/);\n        a = a.concat(u && n[u[1]] && n[u[1]].transition ? Sn({\n          key: s,\n          value: e[s],\n          valueSpec: r.transition,\n          style: i,\n          styleSpec: r\n        }) : n[s] ? Sn({\n          key: s,\n          value: e[s],\n          valueSpec: n[s],\n          style: i,\n          styleSpec: r\n        }) : [new Mt(s, e[s], \'unknown property "\' + s + \'"\')]);\n      }\n\n      return a;\n    }\n\n    var An = {\n      "*": function _() {\n        return [];\n      },\n      array: Qr,\n      boolean: function boolean(t) {\n        var e = t.value,\n            r = t.key,\n            n = Lr(e);\n        return "boolean" !== n ? [new Mt(r, e, "boolean expected, " + n + " found")] : [];\n      },\n      number: tn,\n      color: function color(t) {\n        var e = t.key,\n            r = t.value,\n            n = Lr(r);\n        return "string" !== n ? [new Mt(e, r, "color expected, " + n + " found")] : null === te(r) ? [new Mt(e, r, \'color expected, "\' + r + \'" found\')] : [];\n      },\n      constants: Bt,\n      enum: nn,\n      filter: yn,\n      function: en,\n      layer: gn,\n      object: Wr,\n      source: wn,\n      light: _n,\n      string: xn,\n      formatted: function formatted(t) {\n        return 0 === xn(t).length ? [] : rn(t);\n      },\n      resolvedImage: function resolvedImage(t) {\n        return 0 === xn(t).length ? [] : rn(t);\n      }\n    };\n\n    function Sn(t) {\n      var e = t.value,\n          r = t.valueSpec,\n          n = t.styleSpec;\n      return r.expression && Rr(Vt(e)) ? en(t) : r.expression && Zr(Ft(e)) ? rn(t) : r.type && An[r.type] ? An[r.type](t) : Wr(Tt({}, t, {\n        valueSpec: r.type ? n[r.type] : r\n      }));\n    }\n\n    function kn(t) {\n      var e = t.value,\n          r = t.key,\n          n = xn(t);\n      return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new Mt(r, e, \'"glyphs" url must include a "{fontstack}" token\')), -1 === e.indexOf("{range}") && n.push(new Mt(r, e, \'"glyphs" url must include a "{range}" token\'))), n;\n    }\n\n    function In(t, e) {\n      void 0 === e && (e = Pt);\n      var r = [];\n      return r = r.concat(Sn({\n        key: "",\n        value: t,\n        valueSpec: e.$root,\n        styleSpec: e,\n        style: t,\n        objectElementValidators: {\n          glyphs: kn,\n          "*": function _() {\n            return [];\n          }\n        }\n      })), t.constants && (r = r.concat(Bt({\n        key: "constants",\n        value: t.constants,\n        style: t,\n        styleSpec: e\n      }))), zn(r);\n    }\n\n    function zn(t) {\n      return [].concat(t).sort(function (t, e) {\n        return t.line - e.line;\n      });\n    }\n\n    function Cn(t) {\n      return function () {\n        for (var e = [], r = arguments.length; r--;) {\n          e[r] = arguments[r];\n        }\n\n        return zn(t.apply(this, e));\n      };\n    }\n\n    In.source = Cn(wn), In.light = Cn(_n), In.layer = Cn(gn), In.filter = Cn(yn), In.paintProperty = Cn(mn), In.layoutProperty = Cn(vn);\n    var En = In,\n        Pn = En.light,\n        Mn = En.paintProperty,\n        Bn = En.layoutProperty;\n\n    function Tn(t, e) {\n      var r = !1;\n      if (e && e.length) for (var n = 0, i = e; n < i.length; n += 1) {\n        t.fire(new Ct(new Error(i[n].message))), r = !0;\n      }\n      return r;\n    }\n\n    var Vn = Fn;\n\n    function Fn(t, e, r) {\n      var n = this.cells = [];\n\n      if (t instanceof ArrayBuffer) {\n        this.arrayBuffer = t;\n        var i = new Int32Array(this.arrayBuffer);\n        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n\n        for (var a = 0; a < this.d * this.d; a++) {\n          var o = i[3 + a],\n              s = i[3 + a + 1];\n          n.push(o === s ? null : i.subarray(o, s));\n        }\n\n        var u = i[3 + n.length + 1];\n        this.keys = i.subarray(i[3 + n.length], u), this.bboxes = i.subarray(u), this.insert = this._insertReadonly;\n      } else {\n        this.d = e + 2 * r;\n\n        for (var l = 0; l < this.d * this.d; l++) {\n          n.push([]);\n        }\n\n        this.keys = [], this.bboxes = [];\n      }\n\n      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n      var p = r / e * t;\n      this.min = -p, this.max = t + p;\n    }\n\n    Fn.prototype.insert = function (t, e, r, n, i) {\n      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n    }, Fn.prototype._insertReadonly = function () {\n      throw "Cannot insert into a GridIndex created from an ArrayBuffer.";\n    }, Fn.prototype._insertCell = function (t, e, r, n, i, a) {\n      this.cells[i].push(a);\n    }, Fn.prototype.query = function (t, e, r, n, i) {\n      var a = this.min,\n          o = this.max;\n      if (t <= a && e <= a && o <= r && o <= n && !i) return Array.prototype.slice.call(this.keys);\n      var s = [];\n      return this._forEachCell(t, e, r, n, this._queryCell, s, {}, i), s;\n    }, Fn.prototype._queryCell = function (t, e, r, n, i, a, o, s) {\n      var u = this.cells[i];\n      if (null !== u) for (var l = this.keys, p = this.bboxes, c = 0; c < u.length; c++) {\n        var h = u[c];\n\n        if (void 0 === o[h]) {\n          var f = 4 * h;\n          (s ? s(p[f + 0], p[f + 1], p[f + 2], p[f + 3]) : t <= p[f + 2] && e <= p[f + 3] && r >= p[f + 0] && n >= p[f + 1]) ? (o[h] = !0, a.push(l[h])) : o[h] = !1;\n        }\n      }\n    }, Fn.prototype._forEachCell = function (t, e, r, n, i, a, o, s) {\n      for (var u = this._convertToCellCoord(t), l = this._convertToCellCoord(e), p = this._convertToCellCoord(r), c = this._convertToCellCoord(n), h = u; h <= p; h++) {\n        for (var f = l; f <= c; f++) {\n          var y = this.d * f + h;\n          if ((!s || s(this._convertFromCellCoord(h), this._convertFromCellCoord(f), this._convertFromCellCoord(h + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, y, a, o, s)) return;\n        }\n      }\n    }, Fn.prototype._convertFromCellCoord = function (t) {\n      return (t - this.padding) / this.scale;\n    }, Fn.prototype._convertToCellCoord = function (t) {\n      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n    }, Fn.prototype.toArrayBuffer = function () {\n      if (this.arrayBuffer) return this.arrayBuffer;\n\n      for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) {\n        r += this.cells[n].length;\n      }\n\n      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n\n      for (var a = e, o = 0; o < t.length; o++) {\n        var s = t[o];\n        i[3 + o] = a, i.set(s, a), a += s.length;\n      }\n\n      return i[3 + t.length] = a, i.set(this.keys, a), i[3 + t.length + 1] = a += this.keys.length, i.set(this.bboxes, a), a += this.bboxes.length, i.buffer;\n    };\n    var Dn = o.ImageData,\n        Ln = o.ImageBitmap,\n        Rn = {};\n\n    function On(t, e, r) {\n      void 0 === r && (r = {}), Object.defineProperty(e, "_classRegistryKey", {\n        value: t,\n        writeable: !1\n      }), Rn[t] = {\n        klass: e,\n        omit: r.omit || [],\n        shallow: r.shallow || []\n      };\n    }\n\n    for (var Un in On("Object", Object), Vn.serialize = function (t, e) {\n      var r = t.toArrayBuffer();\n      return e && e.push(r), {\n        buffer: r\n      };\n    }, Vn.deserialize = function (t) {\n      return new Vn(t.buffer);\n    }, On("Grid", Vn), On("Color", ee), On("Error", Error), On("ResolvedImage", ae), On("StylePropertyFunction", $r), On("StyleExpression", Gr, {\n      omit: ["_evaluator"]\n    }), On("ZoomDependentExpression", Hr), On("ZoomConstantExpression", Jr), On("CompoundExpression", be, {\n      omit: ["_evaluate"]\n    }), zr) {\n      zr[Un]._classRegistryKey || On("Expression_" + Un, zr[Un]);\n    }\n\n    function jn(t) {\n      return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name);\n    }\n\n    function qn(t) {\n      return Ln && t instanceof Ln;\n    }\n\n    function Nn(t, e) {\n      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (jn(t) || qn(t)) return e && e.push(t), t;\n\n      if (ArrayBuffer.isView(t)) {\n        var r = t;\n        return e && e.push(r.buffer), r;\n      }\n\n      if (t instanceof Dn) return e && e.push(t.data.buffer), t;\n\n      if (Array.isArray(t)) {\n        for (var n = [], i = 0, a = t; i < a.length; i += 1) {\n          n.push(Nn(a[i], e));\n        }\n\n        return n;\n      }\n\n      if ("object" == typeof t) {\n        var o = t.constructor,\n            s = o._classRegistryKey;\n        if (!s) throw new Error("can\'t serialize object of unregistered class");\n        var u = o.serialize ? o.serialize(t, e) : {};\n\n        if (!o.serialize) {\n          for (var l in t) {\n            if (t.hasOwnProperty(l) && !(Rn[s].omit.indexOf(l) >= 0)) {\n              var p = t[l];\n              u[l] = Rn[s].shallow.indexOf(l) >= 0 ? p : Nn(p, e);\n            }\n          }\n\n          t instanceof Error && (u.message = t.message);\n        }\n\n        if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");\n        return "Object" !== s && (u.$name = s), u;\n      }\n\n      throw new Error("can\'t serialize object of type " + typeof t);\n    }\n\n    function Kn(t) {\n      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || jn(t) || qn(t) || ArrayBuffer.isView(t) || t instanceof Dn) return t;\n      if (Array.isArray(t)) return t.map(Kn);\n\n      if ("object" == typeof t) {\n        var e = t.$name || "Object",\n            r = Rn[e].klass;\n        if (!r) throw new Error("can\'t deserialize unregistered class " + e);\n        if (r.deserialize) return r.deserialize(t);\n\n        for (var n = Object.create(r.prototype), i = 0, a = Object.keys(t); i < a.length; i += 1) {\n          var o = a[i];\n\n          if ("$name" !== o) {\n            var s = t[o];\n            n[o] = Rn[e].shallow.indexOf(o) >= 0 ? s : Kn(s);\n          }\n        }\n\n        return n;\n      }\n\n      throw new Error("can\'t deserialize object of type " + typeof t);\n    }\n\n    var Gn = function Gn() {\n      this.first = !0;\n    };\n\n    Gn.prototype.update = function (t, e) {\n      var r = Math.floor(t);\n      return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));\n    };\n\n    var Zn = {\n      "Latin-1 Supplement": function Latin1Supplement(t) {\n        return t >= 128 && t <= 255;\n      },\n      Arabic: function Arabic(t) {\n        return t >= 1536 && t <= 1791;\n      },\n      "Arabic Supplement": function ArabicSupplement(t) {\n        return t >= 1872 && t <= 1919;\n      },\n      "Arabic Extended-A": function ArabicExtendedA(t) {\n        return t >= 2208 && t <= 2303;\n      },\n      "Hangul Jamo": function HangulJamo(t) {\n        return t >= 4352 && t <= 4607;\n      },\n      "Unified Canadian Aboriginal Syllabics": function UnifiedCanadianAboriginalSyllabics(t) {\n        return t >= 5120 && t <= 5759;\n      },\n      Khmer: function Khmer(t) {\n        return t >= 6016 && t <= 6143;\n      },\n      "Unified Canadian Aboriginal Syllabics Extended": function UnifiedCanadianAboriginalSyllabicsExtended(t) {\n        return t >= 6320 && t <= 6399;\n      },\n      "General Punctuation": function GeneralPunctuation(t) {\n        return t >= 8192 && t <= 8303;\n      },\n      "Letterlike Symbols": function LetterlikeSymbols(t) {\n        return t >= 8448 && t <= 8527;\n      },\n      "Number Forms": function NumberForms(t) {\n        return t >= 8528 && t <= 8591;\n      },\n      "Miscellaneous Technical": function MiscellaneousTechnical(t) {\n        return t >= 8960 && t <= 9215;\n      },\n      "Control Pictures": function ControlPictures(t) {\n        return t >= 9216 && t <= 9279;\n      },\n      "Optical Character Recognition": function OpticalCharacterRecognition(t) {\n        return t >= 9280 && t <= 9311;\n      },\n      "Enclosed Alphanumerics": function EnclosedAlphanumerics(t) {\n        return t >= 9312 && t <= 9471;\n      },\n      "Geometric Shapes": function GeometricShapes(t) {\n        return t >= 9632 && t <= 9727;\n      },\n      "Miscellaneous Symbols": function MiscellaneousSymbols(t) {\n        return t >= 9728 && t <= 9983;\n      },\n      "Miscellaneous Symbols and Arrows": function MiscellaneousSymbolsAndArrows(t) {\n        return t >= 11008 && t <= 11263;\n      },\n      "CJK Radicals Supplement": function CJKRadicalsSupplement(t) {\n        return t >= 11904 && t <= 12031;\n      },\n      "Kangxi Radicals": function KangxiRadicals(t) {\n        return t >= 12032 && t <= 12255;\n      },\n      "Ideographic Description Characters": function IdeographicDescriptionCharacters(t) {\n        return t >= 12272 && t <= 12287;\n      },\n      "CJK Symbols and Punctuation": function CJKSymbolsAndPunctuation(t) {\n        return t >= 12288 && t <= 12351;\n      },\n      Hiragana: function Hiragana(t) {\n        return t >= 12352 && t <= 12447;\n      },\n      Katakana: function Katakana(t) {\n        return t >= 12448 && t <= 12543;\n      },\n      Bopomofo: function Bopomofo(t) {\n        return t >= 12544 && t <= 12591;\n      },\n      "Hangul Compatibility Jamo": function HangulCompatibilityJamo(t) {\n        return t >= 12592 && t <= 12687;\n      },\n      Kanbun: function Kanbun(t) {\n        return t >= 12688 && t <= 12703;\n      },\n      "Bopomofo Extended": function BopomofoExtended(t) {\n        return t >= 12704 && t <= 12735;\n      },\n      "CJK Strokes": function CJKStrokes(t) {\n        return t >= 12736 && t <= 12783;\n      },\n      "Katakana Phonetic Extensions": function KatakanaPhoneticExtensions(t) {\n        return t >= 12784 && t <= 12799;\n      },\n      "Enclosed CJK Letters and Months": function EnclosedCJKLettersAndMonths(t) {\n        return t >= 12800 && t <= 13055;\n      },\n      "CJK Compatibility": function CJKCompatibility(t) {\n        return t >= 13056 && t <= 13311;\n      },\n      "CJK Unified Ideographs Extension A": function CJKUnifiedIdeographsExtensionA(t) {\n        return t >= 13312 && t <= 19903;\n      },\n      "Yijing Hexagram Symbols": function YijingHexagramSymbols(t) {\n        return t >= 19904 && t <= 19967;\n      },\n      "CJK Unified Ideographs": function CJKUnifiedIdeographs(t) {\n        return t >= 19968 && t <= 40959;\n      },\n      "Yi Syllables": function YiSyllables(t) {\n        return t >= 40960 && t <= 42127;\n      },\n      "Yi Radicals": function YiRadicals(t) {\n        return t >= 42128 && t <= 42191;\n      },\n      "Hangul Jamo Extended-A": function HangulJamoExtendedA(t) {\n        return t >= 43360 && t <= 43391;\n      },\n      "Hangul Syllables": function HangulSyllables(t) {\n        return t >= 44032 && t <= 55215;\n      },\n      "Hangul Jamo Extended-B": function HangulJamoExtendedB(t) {\n        return t >= 55216 && t <= 55295;\n      },\n      "Private Use Area": function PrivateUseArea(t) {\n        return t >= 57344 && t <= 63743;\n      },\n      "CJK Compatibility Ideographs": function CJKCompatibilityIdeographs(t) {\n        return t >= 63744 && t <= 64255;\n      },\n      "Arabic Presentation Forms-A": function ArabicPresentationFormsA(t) {\n        return t >= 64336 && t <= 65023;\n      },\n      "Vertical Forms": function VerticalForms(t) {\n        return t >= 65040 && t <= 65055;\n      },\n      "CJK Compatibility Forms": function CJKCompatibilityForms(t) {\n        return t >= 65072 && t <= 65103;\n      },\n      "Small Form Variants": function SmallFormVariants(t) {\n        return t >= 65104 && t <= 65135;\n      },\n      "Arabic Presentation Forms-B": function ArabicPresentationFormsB(t) {\n        return t >= 65136 && t <= 65279;\n      },\n      "Halfwidth and Fullwidth Forms": function HalfwidthAndFullwidthForms(t) {\n        return t >= 65280 && t <= 65519;\n      }\n    };\n\n    function Xn(t) {\n      for (var e = 0, r = t; e < r.length; e += 1) {\n        if (Jn(r[e].charCodeAt(0))) return !0;\n      }\n\n      return !1;\n    }\n\n    function Jn(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(Zn["Bopomofo Extended"](t) || Zn.Bopomofo(t) || Zn["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || Zn["CJK Compatibility Ideographs"](t) || Zn["CJK Compatibility"](t) || Zn["CJK Radicals Supplement"](t) || Zn["CJK Strokes"](t) || !(!Zn["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Zn["CJK Unified Ideographs Extension A"](t) || Zn["CJK Unified Ideographs"](t) || Zn["Enclosed CJK Letters and Months"](t) || Zn["Hangul Compatibility Jamo"](t) || Zn["Hangul Jamo Extended-A"](t) || Zn["Hangul Jamo Extended-B"](t) || Zn["Hangul Jamo"](t) || Zn["Hangul Syllables"](t) || Zn.Hiragana(t) || Zn["Ideographic Description Characters"](t) || Zn.Kanbun(t) || Zn["Kangxi Radicals"](t) || Zn["Katakana Phonetic Extensions"](t) || Zn.Katakana(t) && 12540 !== t || !(!Zn["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Zn["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Zn["Unified Canadian Aboriginal Syllabics"](t) || Zn["Unified Canadian Aboriginal Syllabics Extended"](t) || Zn["Vertical Forms"](t) || Zn["Yijing Hexagram Symbols"](t) || Zn["Yi Syllables"](t) || Zn["Yi Radicals"](t))));\n    }\n\n    function Hn(t) {\n      return !(Jn(t) || function (t) {\n        return !!(Zn["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Zn["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Zn["Letterlike Symbols"](t) || Zn["Number Forms"](t) || Zn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Zn["Control Pictures"](t) && 9251 !== t || Zn["Optical Character Recognition"](t) || Zn["Enclosed Alphanumerics"](t) || Zn["Geometric Shapes"](t) || Zn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Zn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Zn["CJK Symbols and Punctuation"](t) || Zn.Katakana(t) || Zn["Private Use Area"](t) || Zn["CJK Compatibility Forms"](t) || Zn["Small Form Variants"](t) || Zn["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n\n    function Yn(t) {\n      return t >= 1424 && t <= 2303 || Zn["Arabic Presentation Forms-A"](t) || Zn["Arabic Presentation Forms-B"](t);\n    }\n\n    function $n(t, e) {\n      return !(!e && Yn(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Zn.Khmer(t));\n    }\n\n    function Wn(t) {\n      for (var e = 0, r = t; e < r.length; e += 1) {\n        if (Yn(r[e].charCodeAt(0))) return !0;\n      }\n\n      return !1;\n    }\n\n    var Qn = null,\n        ti = "unavailable",\n        ei = null,\n        ri = function ri(t) {\n      t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (ti = "error"), Qn && Qn(t);\n    };\n\n    function ni() {\n      ii.fire(new zt("pluginStateChange", {\n        pluginStatus: ti,\n        pluginURL: ei\n      }));\n    }\n\n    var ii = new Et(),\n        ai = function ai() {\n      return ti;\n    },\n        oi = function oi() {\n      if ("deferred" !== ti || !ei) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");\n      ti = "loading", ni(), ei && wt({\n        url: ei\n      }, function (t) {\n        t ? ri(t) : (ti = "loaded", ni());\n      });\n    },\n        si = {\n      applyArabicShaping: null,\n      processBidirectionalText: null,\n      processStyledBidirectionalText: null,\n      isLoaded: function isLoaded() {\n        return "loaded" === ti || null != si.applyArabicShaping;\n      },\n      isLoading: function isLoading() {\n        return "loading" === ti;\n      },\n      setState: function setState(t) {\n        ti = t.pluginStatus, ei = t.pluginURL;\n      },\n      isParsed: function isParsed() {\n        return null != si.applyArabicShaping && null != si.processBidirectionalText && null != si.processStyledBidirectionalText;\n      },\n      getPluginURL: function getPluginURL() {\n        return ei;\n      }\n    },\n        ui = function ui(t, e) {\n      this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Gn(), this.transition = {});\n    };\n\n    ui.prototype.isSupportedScript = function (t) {\n      return function (t, e) {\n        for (var r = 0, n = t; r < n.length; r += 1) {\n          if (!$n(n[r].charCodeAt(0), e)) return !1;\n        }\n\n        return !0;\n      }(t, si.isLoaded());\n    }, ui.prototype.crossFadingFactor = function () {\n      return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n    }, ui.prototype.getCrossfadeParameters = function () {\n      var t = this.zoom,\n          e = t - Math.floor(t),\n          r = this.crossFadingFactor();\n      return t > this.zoomHistory.lastIntegerZoom ? {\n        fromScale: 2,\n        toScale: 1,\n        t: e + (1 - e) * r\n      } : {\n        fromScale: .5,\n        toScale: 1,\n        t: 1 - (1 - r) * e\n      };\n    };\n\n    var li = function li(t, e) {\n      this.property = t, this.value = e, this.expression = function (t, e) {\n        if (Rr(t)) return new $r(t, e);\n\n        if (Zr(t)) {\n          var r = Yr(t, e);\n          if ("error" === r.result) throw new Error(r.value.map(function (t) {\n            return t.key + ": " + t.message;\n          }).join(", "));\n          return r.value;\n        }\n\n        var n = t;\n        return "string" == typeof t && "color" === e.type && (n = ee.parse(t)), {\n          kind: "constant",\n          evaluate: function evaluate() {\n            return n;\n          }\n        };\n      }(void 0 === e ? t.specification.default : e, t.specification);\n    };\n\n    li.prototype.isDataDriven = function () {\n      return "source" === this.expression.kind || "composite" === this.expression.kind;\n    }, li.prototype.possiblyEvaluate = function (t, e, r) {\n      return this.property.possiblyEvaluate(this, t, e, r);\n    };\n\n    var pi = function pi(t) {\n      this.property = t, this.value = new li(t, void 0);\n    };\n\n    pi.prototype.transitioned = function (t, e) {\n      return new hi(this.property, this.value, e, h({}, t.transition, this.transition), t.now);\n    }, pi.prototype.untransitioned = function () {\n      return new hi(this.property, this.value, null, {}, 0);\n    };\n\n    var ci = function ci(t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n    };\n\n    ci.prototype.getValue = function (t) {\n      return w(this._values[t].value.value);\n    }, ci.prototype.setValue = function (t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new pi(this._values[t].property)), this._values[t].value = new li(this._values[t].property, null === e ? void 0 : w(e));\n    }, ci.prototype.getTransition = function (t) {\n      return w(this._values[t].transition);\n    }, ci.prototype.setTransition = function (t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new pi(this._values[t].property)), this._values[t].transition = w(e) || void 0;\n    }, ci.prototype.serialize = function () {\n      for (var t = {}, e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e],\n            i = this.getValue(n);\n        void 0 !== i && (t[n] = i);\n        var a = this.getTransition(n);\n        void 0 !== a && (t[n + "-transition"] = a);\n      }\n\n      return t;\n    }, ci.prototype.transitioned = function (t, e) {\n      for (var r = new fi(this._properties), n = 0, i = Object.keys(this._values); n < i.length; n += 1) {\n        var a = i[n];\n        r._values[a] = this._values[a].transitioned(t, e._values[a]);\n      }\n\n      return r;\n    }, ci.prototype.untransitioned = function () {\n      for (var t = new fi(this._properties), e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e];\n        t._values[n] = this._values[n].untransitioned();\n      }\n\n      return t;\n    };\n\n    var hi = function hi(t, e, r, n, i) {\n      this.property = t, this.value = e, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n    };\n\n    hi.prototype.possiblyEvaluate = function (t, e, r) {\n      var n = t.now || 0,\n          i = this.value.possiblyEvaluate(t, e, r),\n          a = this.prior;\n\n      if (a) {\n        if (n > this.end) return this.prior = null, i;\n        if (this.value.isDataDriven()) return this.prior = null, i;\n        if (n < this.begin) return a.possiblyEvaluate(t, e, r);\n        var o = (n - this.begin) / (this.end - this.begin);\n        return this.property.interpolate(a.possiblyEvaluate(t, e, r), i, function (t) {\n          if (t <= 0) return 0;\n          if (t >= 1) return 1;\n          var e = t * t,\n              r = e * t;\n          return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n        }(o));\n      }\n\n      return i;\n    };\n\n    var fi = function fi(t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n    };\n\n    fi.prototype.possiblyEvaluate = function (t, e, r) {\n      for (var n = new mi(this._properties), i = 0, a = Object.keys(this._values); i < a.length; i += 1) {\n        var o = a[i];\n        n._values[o] = this._values[o].possiblyEvaluate(t, e, r);\n      }\n\n      return n;\n    }, fi.prototype.hasTransition = function () {\n      for (var t = 0, e = Object.keys(this._values); t < e.length; t += 1) {\n        if (this._values[e[t]].prior) return !0;\n      }\n\n      return !1;\n    };\n\n    var yi = function yi(t) {\n      this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n    };\n\n    yi.prototype.getValue = function (t) {\n      return w(this._values[t].value);\n    }, yi.prototype.setValue = function (t, e) {\n      this._values[t] = new li(this._values[t].property, null === e ? void 0 : w(e));\n    }, yi.prototype.serialize = function () {\n      for (var t = {}, e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e],\n            i = this.getValue(n);\n        void 0 !== i && (t[n] = i);\n      }\n\n      return t;\n    }, yi.prototype.possiblyEvaluate = function (t, e, r) {\n      for (var n = new mi(this._properties), i = 0, a = Object.keys(this._values); i < a.length; i += 1) {\n        var o = a[i];\n        n._values[o] = this._values[o].possiblyEvaluate(t, e, r);\n      }\n\n      return n;\n    };\n\n    var di = function di(t, e, r) {\n      this.property = t, this.value = e, this.parameters = r;\n    };\n\n    di.prototype.isConstant = function () {\n      return "constant" === this.value.kind;\n    }, di.prototype.constantOr = function (t) {\n      return "constant" === this.value.kind ? this.value.value : t;\n    }, di.prototype.evaluate = function (t, e, r, n) {\n      return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n    };\n\n    var mi = function mi(t) {\n      this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n    };\n\n    mi.prototype.get = function (t) {\n      return this._values[t];\n    };\n\n    var vi = function vi(t) {\n      this.specification = t;\n    };\n\n    vi.prototype.possiblyEvaluate = function (t, e) {\n      return t.expression.evaluate(e);\n    }, vi.prototype.interpolate = function (t, e, r) {\n      var n = Ze[this.specification.type];\n      return n ? n(t, e, r) : t;\n    };\n\n    var gi = function gi(t, e) {\n      this.specification = t, this.overrides = e;\n    };\n\n    gi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      return new di(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? {\n        kind: "constant",\n        value: t.expression.evaluate(e, null, {}, r, n)\n      } : t.expression, e);\n    }, gi.prototype.interpolate = function (t, e, r) {\n      if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;\n      if (void 0 === t.value.value || void 0 === e.value.value) return new di(this, {\n        kind: "constant",\n        value: void 0\n      }, t.parameters);\n      var n = Ze[this.specification.type];\n      return n ? new di(this, {\n        kind: "constant",\n        value: n(t.value.value, e.value.value, r)\n      }, t.parameters) : t;\n    }, gi.prototype.evaluate = function (t, e, r, n, i, a) {\n      return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, a);\n    };\n\n    var xi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (t, e, r, n) {\n        if (void 0 === t.value) return new di(this, {\n          kind: "constant",\n          value: void 0\n        }, e);\n\n        if ("constant" === t.expression.kind) {\n          var i = t.expression.evaluate(e, null, {}, r, n),\n              a = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i,\n              o = this._calculate(a, a, a, e);\n\n          return new di(this, {\n            kind: "constant",\n            value: o\n          }, e);\n        }\n\n        if ("camera" === t.expression.kind) {\n          var s = this._calculate(t.expression.evaluate({\n            zoom: e.zoom - 1\n          }), t.expression.evaluate({\n            zoom: e.zoom\n          }), t.expression.evaluate({\n            zoom: e.zoom + 1\n          }), e);\n\n          return new di(this, {\n            kind: "constant",\n            value: s\n          }, e);\n        }\n\n        return new di(this, t.expression, e);\n      }, e.prototype.evaluate = function (t, e, r, n, i, a) {\n        if ("source" === t.kind) {\n          var o = t.evaluate(e, r, n, i, a);\n          return this._calculate(o, o, o, e);\n        }\n\n        return "composite" === t.kind ? this._calculate(t.evaluate({\n          zoom: Math.floor(e.zoom) - 1\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom)\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom) + 1\n        }, r, n), e) : t.value;\n      }, e.prototype._calculate = function (t, e, r, n) {\n        return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n          from: t,\n          to: e\n        } : {\n          from: r,\n          to: e\n        };\n      }, e.prototype.interpolate = function (t) {\n        return t;\n      }, e;\n    }(gi),\n        bi = function bi(t) {\n      this.specification = t;\n    };\n\n    bi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      if (void 0 !== t.value) {\n        if ("constant" === t.expression.kind) {\n          var i = t.expression.evaluate(e, null, {}, r, n);\n          return this._calculate(i, i, i, e);\n        }\n\n        return this._calculate(t.expression.evaluate(new ui(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new ui(Math.floor(e.zoom), e)), t.expression.evaluate(new ui(Math.floor(e.zoom + 1), e)), e);\n      }\n    }, bi.prototype._calculate = function (t, e, r, n) {\n      return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n        from: t,\n        to: e\n      } : {\n        from: r,\n        to: e\n      };\n    }, bi.prototype.interpolate = function (t) {\n      return t;\n    };\n\n    var wi = function wi(t) {\n      this.specification = t;\n    };\n\n    wi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      return !!t.expression.evaluate(e, null, {}, r, n);\n    }, wi.prototype.interpolate = function () {\n      return !1;\n    };\n\n    var _i = function _i(t) {\n      for (var e in this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t) {\n        var r = t[e];\n        r.specification.overridable && this.overridableProperties.push(e);\n        var n = this.defaultPropertyValues[e] = new li(r, void 0),\n            i = this.defaultTransitionablePropertyValues[e] = new pi(r);\n        this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});\n      }\n    };\n\n    On("DataDrivenProperty", gi), On("DataConstantProperty", vi), On("CrossFadedDataDrivenProperty", xi), On("CrossFadedProperty", bi), On("ColorRampProperty", wi);\n\n    var Ai = function (t) {\n      function e(e, r) {\n        if (t.call(this), this.id = e.id, this.type = e.type, this._featureFilter = {\n          filter: function filter() {\n            return !0;\n          },\n          needGeometry: !1\n        }, "custom" !== e.type && (this.metadata = (e = e).metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), r.layout && (this._unevaluatedLayout = new yi(r.layout)), r.paint)) {\n          for (var n in this._transitionablePaint = new ci(r.paint), e.paint) {\n            this.setPaintProperty(n, e.paint[n], {\n              validate: !1\n            });\n          }\n\n          for (var i in e.layout) {\n            this.setLayoutProperty(i, e.layout[i], {\n              validate: !1\n            });\n          }\n\n          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(r.paint);\n        }\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getCrossfadeParameters = function () {\n        return this._crossfadeParameters;\n      }, e.prototype.getLayoutProperty = function (t) {\n        return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }, e.prototype.setLayoutProperty = function (t, e, r) {\n        void 0 === r && (r = {}), null != e && this._validate(Bn, "layers." + this.id + ".layout." + t, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n      }, e.prototype.getPaintProperty = function (t) {\n        return g(t, "-transition") ? this._transitionablePaint.getTransition(t.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t);\n      }, e.prototype.setPaintProperty = function (t, e, r) {\n        if (void 0 === r && (r = {}), null != e && this._validate(Mn, "layers." + this.id + ".paint." + t, t, e, r)) return !1;\n        if (g(t, "-transition")) return this._transitionablePaint.setTransition(t.slice(0, -"-transition".length), e || void 0), !1;\n        var n = this._transitionablePaint._values[t],\n            i = "cross-faded-data-driven" === n.property.specification["property-type"],\n            a = n.value.isDataDriven(),\n            o = n.value;\n        this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n        var s = this._transitionablePaint._values[t].value;\n        return s.isDataDriven() || a || i || this._handleOverridablePaintPropertyUpdate(t, o, s);\n      }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {}, e.prototype._handleOverridablePaintPropertyUpdate = function (t, e, r) {\n        return !1;\n      }, e.prototype.isHidden = function (t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;\n      }, e.prototype.updateTransitions = function (t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }, e.prototype.hasTransition = function () {\n        return this._transitioningPaint.hasTransition();\n      }, e.prototype.recalculate = function (t, e) {\n        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }, e.prototype.serialize = function () {\n        var t = {\n          id: this.id,\n          type: this.type,\n          source: this.source,\n          "source-layer": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        };\n        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), b(t, function (t, e) {\n          return !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length);\n        });\n      }, e.prototype._validate = function (t, e, r, n, i) {\n        return void 0 === i && (i = {}), (!i || !1 !== i.validate) && Tn(this, t.call(En, {\n          key: e,\n          layerType: this.type,\n          objectKey: r,\n          value: n,\n          styleSpec: Pt,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          }\n        }));\n      }, e.prototype.is3D = function () {\n        return !1;\n      }, e.prototype.isTileClipped = function () {\n        return !1;\n      }, e.prototype.hasOffscreenPass = function () {\n        return !1;\n      }, e.prototype.resize = function () {}, e.prototype.isStateDependent = function () {\n        for (var t in this.paint._values) {\n          var e = this.paint.get(t);\n          if (e instanceof di && Vr(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n\n        return !1;\n      }, e;\n    }(Et),\n        Si = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    },\n        ki = function ki(t, e) {\n      this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n    },\n        Ii = function Ii() {\n      this.isTransferred = !1, this.capacity = -1, this.resize(0);\n    };\n\n    function zi(t, e) {\n      void 0 === e && (e = 1);\n      var r = 0,\n          n = 0;\n      return {\n        members: t.map(function (t) {\n          var i = Si[t.type].BYTES_PER_ELEMENT,\n              a = r = Ci(r, Math.max(e, i)),\n              o = t.components || 1;\n          return n = Math.max(n, i), r += i * o, {\n            name: t.name,\n            type: t.type,\n            components: o,\n            offset: a\n          };\n        }),\n        size: Ci(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n\n    function Ci(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n\n    Ii.serialize = function (t, e) {\n      return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n        length: t.length,\n        arrayBuffer: t.arrayBuffer\n      };\n    }, Ii.deserialize = function (t) {\n      var e = Object.create(this.prototype);\n      return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n    }, Ii.prototype._trim = function () {\n      this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n    }, Ii.prototype.clear = function () {\n      this.length = 0;\n    }, Ii.prototype.resize = function (t) {\n      this.reserve(t), this.length = t;\n    }, Ii.prototype.reserve = function (t) {\n      if (t > this.capacity) {\n        this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n        var e = this.uint8;\n        this._refreshViews(), e && this.uint8.set(e);\n      }\n    }, Ii.prototype._refreshViews = function () {\n      throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");\n    };\n\n    var Ei = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }, e;\n    }(Ii);\n\n    Ei.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", Ei);\n\n    var Pi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 4 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, t;\n      }, e;\n    }(Ii);\n\n    Pi.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Pi);\n\n    var Mi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 6 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, this.int16[s + 5] = o, t;\n      }, e;\n    }(Ii);\n\n    Mi.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", Mi);\n\n    var Bi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 4 * t,\n            u = 8 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = a, this.uint8[u + 7] = o, t;\n      }, e;\n    }(Ii);\n\n    Bi.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Bi);\n\n    var Ti = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }, e;\n    }(Ii);\n\n    Ti.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", Ti);\n\n    var Vi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l) {\n        var p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, a, o, s, u, l);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p) {\n        var c = 10 * t;\n        return this.uint16[c + 0] = e, this.uint16[c + 1] = r, this.uint16[c + 2] = n, this.uint16[c + 3] = i, this.uint16[c + 4] = a, this.uint16[c + 5] = o, this.uint16[c + 6] = s, this.uint16[c + 7] = u, this.uint16[c + 8] = l, this.uint16[c + 9] = p, t;\n      }, e;\n    }(Ii);\n\n    Vi.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Vi);\n\n    var Fi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c) {\n        var h = this.length;\n        return this.resize(h + 1), this.emplace(h, t, e, r, n, i, a, o, s, u, l, p, c);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h) {\n        var f = 12 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = a, this.uint16[f + 5] = o, this.uint16[f + 6] = s, this.uint16[f + 7] = u, this.int16[f + 8] = l, this.int16[f + 9] = p, this.int16[f + 10] = c, this.int16[f + 11] = h, t;\n      }, e;\n    }(Ii);\n\n    Fi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Fi);\n\n    var Di = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }, e;\n    }(Ii);\n\n    Di.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Di);\n\n    var Li = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }, e;\n    }(Ii);\n\n    Li.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Li);\n\n    var Ri = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u) {\n        var l = this.length;\n        return this.resize(l + 1), this.emplace(l, t, e, r, n, i, a, o, s, u);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l) {\n        var p = 10 * t,\n            c = 5 * t;\n        return this.int16[p + 0] = e, this.int16[p + 1] = r, this.int16[p + 2] = n, this.int16[p + 3] = i, this.int16[p + 4] = a, this.int16[p + 5] = o, this.uint32[c + 3] = s, this.uint16[p + 8] = u, this.uint16[p + 9] = l, t;\n      }, e;\n    }(Ii);\n\n    Ri.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Ri);\n\n    var Oi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 6 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, this.int16[s + 5] = o, t;\n      }, e;\n    }(Ii);\n\n    Oi.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Oi);\n\n    var Ui = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i) {\n        var a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }, e.prototype.emplace = function (t, e, r, n, i, a) {\n        var o = 4 * t,\n            s = 8 * t;\n        return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.int16[s + 6] = i, this.int16[s + 7] = a, t;\n      }, e;\n    }(Ii);\n\n    Ui.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Ui);\n\n    var ji = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 12 * t,\n            o = 3 * t;\n        return this.uint8[a + 0] = e, this.uint8[a + 1] = r, this.float32[o + 1] = n, this.float32[o + 2] = i, t;\n      }, e;\n    }(Ii);\n\n    ji.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", ji);\n\n    var qi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }, e;\n    }(Ii);\n\n    qi.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", qi);\n\n    var Ni = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m) {\n        var v = this.length;\n        return this.resize(v + 1), this.emplace(v, t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v) {\n        var g = 24 * t,\n            x = 12 * t,\n            b = 48 * t;\n        return this.int16[g + 0] = e, this.int16[g + 1] = r, this.uint16[g + 2] = n, this.uint16[g + 3] = i, this.uint32[x + 2] = a, this.uint32[x + 3] = o, this.uint32[x + 4] = s, this.uint16[g + 10] = u, this.uint16[g + 11] = l, this.uint16[g + 12] = p, this.float32[x + 7] = c, this.float32[x + 8] = h, this.uint8[b + 36] = f, this.uint8[b + 37] = y, this.uint8[b + 38] = d, this.uint32[x + 10] = m, this.int16[g + 22] = v, t;\n      }, e;\n    }(Ii);\n\n    Ni.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ni);\n\n    var Ki = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z) {\n        var C = this.length;\n        return this.resize(C + 1), this.emplace(C, t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z, C) {\n        var E = 34 * t,\n            P = 17 * t;\n        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.int16[E + 3] = i, this.int16[E + 4] = a, this.int16[E + 5] = o, this.int16[E + 6] = s, this.int16[E + 7] = u, this.uint16[E + 8] = l, this.uint16[E + 9] = p, this.uint16[E + 10] = c, this.uint16[E + 11] = h, this.uint16[E + 12] = f, this.uint16[E + 13] = y, this.uint16[E + 14] = d, this.uint16[E + 15] = m, this.uint16[E + 16] = v, this.uint16[E + 17] = g, this.uint16[E + 18] = x, this.uint16[E + 19] = b, this.uint16[E + 20] = w, this.uint16[E + 21] = _, this.uint16[E + 22] = A, this.uint32[P + 12] = S, this.float32[P + 13] = k, this.float32[P + 14] = I, this.float32[P + 15] = z, this.float32[P + 16] = C, t;\n      }, e;\n    }(Ii);\n\n    Ki.prototype.bytesPerElement = 68, On("StructArrayLayout8i15ui1ul4f68", Ki);\n\n    var Gi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }, e;\n    }(Ii);\n\n    Gi.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Gi);\n\n    var Zi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }, e;\n    }(Ii);\n\n    Zi.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Zi);\n\n    var Xi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 4 * t;\n        return this.uint32[2 * t + 0] = e, this.uint16[i + 2] = r, this.uint16[i + 3] = n, t;\n      }, e;\n    }(Ii);\n\n    Xi.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Xi);\n\n    var Ji = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }, e;\n    }(Ii);\n\n    Ji.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", Ji);\n\n    var Hi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }, e;\n    }(Ii);\n\n    Hi.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", Hi);\n\n    var Yi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 4 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, t;\n      }, e;\n    }(Ii);\n\n    Yi.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Yi);\n\n    var $i = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorPointX: {\n          configurable: !0\n        },\n        anchorPointY: {\n          configurable: !0\n        },\n        x1: {\n          configurable: !0\n        },\n        y1: {\n          configurable: !0\n        },\n        x2: {\n          configurable: !0\n        },\n        y2: {\n          configurable: !0\n        },\n        featureIndex: {\n          configurable: !0\n        },\n        sourceLayerIndex: {\n          configurable: !0\n        },\n        bucketIndex: {\n          configurable: !0\n        },\n        anchorPoint: {\n          configurable: !0\n        }\n      };\n      return r.anchorPointX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorPointY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.x1.get = function () {\n        return this._structArray.int16[this._pos2 + 2];\n      }, r.y1.get = function () {\n        return this._structArray.int16[this._pos2 + 3];\n      }, r.x2.get = function () {\n        return this._structArray.int16[this._pos2 + 4];\n      }, r.y2.get = function () {\n        return this._structArray.int16[this._pos2 + 5];\n      }, r.featureIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 3];\n      }, r.sourceLayerIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 8];\n      }, r.bucketIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 9];\n      }, r.anchorPoint.get = function () {\n        return new i(this.anchorPointX, this.anchorPointY);\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n\n    $i.prototype.size = 20;\n\n    var Wi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new $i(this, t);\n      }, e;\n    }(Ri);\n\n    On("CollisionBoxArray", Wi);\n\n    var Qi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorX: {\n          configurable: !0\n        },\n        anchorY: {\n          configurable: !0\n        },\n        glyphStartIndex: {\n          configurable: !0\n        },\n        numGlyphs: {\n          configurable: !0\n        },\n        vertexStartIndex: {\n          configurable: !0\n        },\n        lineStartIndex: {\n          configurable: !0\n        },\n        lineLength: {\n          configurable: !0\n        },\n        segment: {\n          configurable: !0\n        },\n        lowerSize: {\n          configurable: !0\n        },\n        upperSize: {\n          configurable: !0\n        },\n        lineOffsetX: {\n          configurable: !0\n        },\n        lineOffsetY: {\n          configurable: !0\n        },\n        writingMode: {\n          configurable: !0\n        },\n        placedOrientation: {\n          configurable: !0\n        },\n        hidden: {\n          configurable: !0\n        },\n        crossTileID: {\n          configurable: !0\n        },\n        associatedIconIndex: {\n          configurable: !0\n        }\n      };\n      return r.anchorX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.glyphStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 2];\n      }, r.numGlyphs.get = function () {\n        return this._structArray.uint16[this._pos2 + 3];\n      }, r.vertexStartIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 2];\n      }, r.lineStartIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 3];\n      }, r.lineLength.get = function () {\n        return this._structArray.uint32[this._pos4 + 4];\n      }, r.segment.get = function () {\n        return this._structArray.uint16[this._pos2 + 10];\n      }, r.lowerSize.get = function () {\n        return this._structArray.uint16[this._pos2 + 11];\n      }, r.upperSize.get = function () {\n        return this._structArray.uint16[this._pos2 + 12];\n      }, r.lineOffsetX.get = function () {\n        return this._structArray.float32[this._pos4 + 7];\n      }, r.lineOffsetY.get = function () {\n        return this._structArray.float32[this._pos4 + 8];\n      }, r.writingMode.get = function () {\n        return this._structArray.uint8[this._pos1 + 36];\n      }, r.placedOrientation.get = function () {\n        return this._structArray.uint8[this._pos1 + 37];\n      }, r.placedOrientation.set = function (t) {\n        this._structArray.uint8[this._pos1 + 37] = t;\n      }, r.hidden.get = function () {\n        return this._structArray.uint8[this._pos1 + 38];\n      }, r.hidden.set = function (t) {\n        this._structArray.uint8[this._pos1 + 38] = t;\n      }, r.crossTileID.get = function () {\n        return this._structArray.uint32[this._pos4 + 10];\n      }, r.crossTileID.set = function (t) {\n        this._structArray.uint32[this._pos4 + 10] = t;\n      }, r.associatedIconIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 22];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n\n    Qi.prototype.size = 48;\n\n    var ta = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new Qi(this, t);\n      }, e;\n    }(Ni);\n\n    On("PlacedSymbolArray", ta);\n\n    var ea = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorX: {\n          configurable: !0\n        },\n        anchorY: {\n          configurable: !0\n        },\n        rightJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        centerJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        leftJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        verticalPlacedTextSymbolIndex: {\n          configurable: !0\n        },\n        placedIconSymbolIndex: {\n          configurable: !0\n        },\n        verticalPlacedIconSymbolIndex: {\n          configurable: !0\n        },\n        key: {\n          configurable: !0\n        },\n        textBoxStartIndex: {\n          configurable: !0\n        },\n        textBoxEndIndex: {\n          configurable: !0\n        },\n        verticalTextBoxStartIndex: {\n          configurable: !0\n        },\n        verticalTextBoxEndIndex: {\n          configurable: !0\n        },\n        iconBoxStartIndex: {\n          configurable: !0\n        },\n        iconBoxEndIndex: {\n          configurable: !0\n        },\n        verticalIconBoxStartIndex: {\n          configurable: !0\n        },\n        verticalIconBoxEndIndex: {\n          configurable: !0\n        },\n        featureIndex: {\n          configurable: !0\n        },\n        numHorizontalGlyphVertices: {\n          configurable: !0\n        },\n        numVerticalGlyphVertices: {\n          configurable: !0\n        },\n        numIconVertices: {\n          configurable: !0\n        },\n        numVerticalIconVertices: {\n          configurable: !0\n        },\n        useRuntimeCollisionCircles: {\n          configurable: !0\n        },\n        crossTileID: {\n          configurable: !0\n        },\n        textBoxScale: {\n          configurable: !0\n        },\n        textOffset0: {\n          configurable: !0\n        },\n        textOffset1: {\n          configurable: !0\n        },\n        collisionCircleDiameter: {\n          configurable: !0\n        }\n      };\n      return r.anchorX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.rightJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 2];\n      }, r.centerJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 3];\n      }, r.leftJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 4];\n      }, r.verticalPlacedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 5];\n      }, r.placedIconSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 6];\n      }, r.verticalPlacedIconSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 7];\n      }, r.key.get = function () {\n        return this._structArray.uint16[this._pos2 + 8];\n      }, r.textBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 9];\n      }, r.textBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 10];\n      }, r.verticalTextBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 11];\n      }, r.verticalTextBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 12];\n      }, r.iconBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 13];\n      }, r.iconBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 14];\n      }, r.verticalIconBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 15];\n      }, r.verticalIconBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 16];\n      }, r.featureIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 17];\n      }, r.numHorizontalGlyphVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 18];\n      }, r.numVerticalGlyphVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 19];\n      }, r.numIconVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 20];\n      }, r.numVerticalIconVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 21];\n      }, r.useRuntimeCollisionCircles.get = function () {\n        return this._structArray.uint16[this._pos2 + 22];\n      }, r.crossTileID.get = function () {\n        return this._structArray.uint32[this._pos4 + 12];\n      }, r.crossTileID.set = function (t) {\n        this._structArray.uint32[this._pos4 + 12] = t;\n      }, r.textBoxScale.get = function () {\n        return this._structArray.float32[this._pos4 + 13];\n      }, r.textOffset0.get = function () {\n        return this._structArray.float32[this._pos4 + 14];\n      }, r.textOffset1.get = function () {\n        return this._structArray.float32[this._pos4 + 15];\n      }, r.collisionCircleDiameter.get = function () {\n        return this._structArray.float32[this._pos4 + 16];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n\n    ea.prototype.size = 68;\n\n    var ra = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new ea(this, t);\n      }, e;\n    }(Ki);\n\n    On("SymbolInstanceArray", ra);\n\n    var na = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getoffsetX = function (t) {\n        return this.float32[1 * t + 0];\n      }, e;\n    }(Gi);\n\n    On("GlyphOffsetArray", na);\n\n    var ia = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getx = function (t) {\n        return this.int16[3 * t + 0];\n      }, e.prototype.gety = function (t) {\n        return this.int16[3 * t + 1];\n      }, e.prototype.gettileUnitDistanceFromAnchor = function (t) {\n        return this.int16[3 * t + 2];\n      }, e;\n    }(Zi);\n\n    On("SymbolLineVertexArray", ia);\n\n    var aa = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        featureIndex: {\n          configurable: !0\n        },\n        sourceLayerIndex: {\n          configurable: !0\n        },\n        bucketIndex: {\n          configurable: !0\n        }\n      };\n      return r.featureIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 0];\n      }, r.sourceLayerIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 2];\n      }, r.bucketIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 3];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n\n    aa.prototype.size = 8;\n\n    var oa = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new aa(this, t);\n      }, e;\n    }(Xi);\n\n    On("FeatureIndexArray", oa);\n\n    var sa = zi([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }], 4).members,\n        ua = function ua(t) {\n      void 0 === t && (t = []), this.segments = t;\n    };\n\n    function la(t, e) {\n      return 256 * (t = p(Math.floor(t), 0, 255)) + p(Math.floor(e), 0, 255);\n    }\n\n    ua.prototype.prepareSegment = function (t, e, r, n) {\n      var i = this.segments[this.segments.length - 1];\n      return t > ua.MAX_VERTEX_ARRAY_LENGTH && A("Max vertices per segment is " + ua.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t), (!i || i.vertexLength + t > ua.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n        vertexOffset: e.length,\n        primitiveOffset: r.length,\n        vertexLength: 0,\n        primitiveLength: 0\n      }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n    }, ua.prototype.get = function () {\n      return this.segments;\n    }, ua.prototype.destroy = function () {\n      for (var t = 0, e = this.segments; t < e.length; t += 1) {\n        var r = e[t];\n\n        for (var n in r.vaos) {\n          r.vaos[n].destroy();\n        }\n      }\n    }, ua.simpleSegment = function (t, e, r, n) {\n      return new ua([{\n        vertexOffset: t,\n        primitiveOffset: e,\n        vertexLength: r,\n        primitiveLength: n,\n        vaos: {},\n        sortKey: 0\n      }]);\n    }, ua.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", ua);\n    var pa = zi([{\n      name: "a_pattern_from",\n      components: 4,\n      type: "Uint16"\n    }, {\n      name: "a_pattern_to",\n      components: 4,\n      type: "Uint16"\n    }, {\n      name: "a_pixel_ratio_from",\n      components: 1,\n      type: "Uint16"\n    }, {\n      name: "a_pixel_ratio_to",\n      components: 1,\n      type: "Uint16"\n    }]),\n        ca = e(function (t) {\n      t.exports = function (t, e) {\n        var r, n, i, a, o, s, u, l;\n\n        for (n = t.length - (r = 3 & t.length), i = e, o = 3432918353, s = 461845907, l = 0; l < n;) {\n          u = 255 & t.charCodeAt(l) | (255 & t.charCodeAt(++l)) << 8 | (255 & t.charCodeAt(++l)) << 16 | (255 & t.charCodeAt(++l)) << 24, ++l, i = 27492 + (65535 & (a = 5 * (65535 & (i = (i ^= u = (65535 & (u = (u = (65535 & u) * o + (((u >>> 16) * o & 65535) << 16) & 4294967295) << 15 | u >>> 17)) * s + (((u >>> 16) * s & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16);\n        }\n\n        switch (u = 0, r) {\n          case 3:\n            u ^= (255 & t.charCodeAt(l + 2)) << 16;\n\n          case 2:\n            u ^= (255 & t.charCodeAt(l + 1)) << 8;\n\n          case 1:\n            i ^= u = (65535 & (u = (u = (65535 & (u ^= 255 & t.charCodeAt(l))) * o + (((u >>> 16) * o & 65535) << 16) & 4294967295) << 15 | u >>> 17)) * s + (((u >>> 16) * s & 65535) << 16) & 4294967295;\n        }\n\n        return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n      };\n    }),\n        ha = e(function (t) {\n      t.exports = function (t, e) {\n        for (var r, n = t.length, i = e ^ n, a = 0; n >= 4;) {\n          r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(a) | (255 & t.charCodeAt(++a)) << 8 | (255 & t.charCodeAt(++a)) << 16 | (255 & t.charCodeAt(++a)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++a;\n        }\n\n        switch (n) {\n          case 3:\n            i ^= (255 & t.charCodeAt(a + 2)) << 16;\n\n          case 2:\n            i ^= (255 & t.charCodeAt(a + 1)) << 8;\n\n          case 1:\n            i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(a))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n        }\n\n        return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n      };\n    }),\n        fa = ca,\n        ya = ha;\n    fa.murmur3 = ca, fa.murmur2 = ya;\n\n    var da = function da() {\n      this.ids = [], this.positions = [], this.indexed = !1;\n    };\n\n    da.prototype.add = function (t, e, r, n) {\n      this.ids.push(va(t)), this.positions.push(e, r, n);\n    }, da.prototype.getPositions = function (t) {\n      for (var e = va(t), r = 0, n = this.ids.length - 1; r < n;) {\n        var i = r + n >> 1;\n        this.ids[i] >= e ? n = i : r = i + 1;\n      }\n\n      for (var a = []; this.ids[r] === e;) {\n        a.push({\n          index: this.positions[3 * r],\n          start: this.positions[3 * r + 1],\n          end: this.positions[3 * r + 2]\n        }), r++;\n      }\n\n      return a;\n    }, da.serialize = function (t, e) {\n      var r = new Float64Array(t.ids),\n          n = new Uint32Array(t.positions);\n      return function t(e, r, n, i) {\n        for (; n < i;) {\n          for (var a = e[n + i >> 1], o = n - 1, s = i + 1;;) {\n            do {\n              o++;\n            } while (e[o] < a);\n\n            do {\n              s--;\n            } while (e[s] > a);\n\n            if (o >= s) break;\n            ga(e, o, s), ga(r, 3 * o, 3 * s), ga(r, 3 * o + 1, 3 * s + 1), ga(r, 3 * o + 2, 3 * s + 2);\n          }\n\n          s - n < i - s ? (t(e, r, n, s), n = s + 1) : (t(e, r, s + 1, i), i = s);\n        }\n      }(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n        ids: r,\n        positions: n\n      };\n    }, da.deserialize = function (t) {\n      var e = new da();\n      return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n    };\n    var ma = Math.pow(2, 53) - 1;\n\n    function va(t) {\n      var e = +t;\n      return !isNaN(e) && e <= ma ? e : fa(String(t));\n    }\n\n    function ga(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    On("FeaturePositionMap", da);\n\n    var xa = function xa(t, e) {\n      this.gl = t.gl, this.location = e;\n    },\n        ba = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = 0;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t));\n      }, e;\n    }(xa),\n        wa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = 0;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));\n      }, e;\n    }(xa),\n        _a = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = [0, 0];\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1]));\n      }, e;\n    }(xa),\n        Aa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = [0, 0, 0];\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2]));\n      }, e;\n    }(xa),\n        Sa = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = [0, 0, 0, 0];\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));\n      }, e;\n    }(xa),\n        ka = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = ee.transparent;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));\n      }, e;\n    }(xa),\n        Ia = new Float32Array(16),\n        za = function (t) {\n      function e(e, r) {\n        t.call(this, e, r), this.current = Ia;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t);\n\n        for (var e = 1; e < 16; e++) {\n          if (t[e] !== this.current[e]) {\n            this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);\n            break;\n          }\n        }\n      }, e;\n    }(xa);\n\n    function Ca(t) {\n      return [la(255 * t.r, 255 * t.g), la(255 * t.b, 255 * t.a)];\n    }\n\n    var Ea = function Ea(t, e, r) {\n      this.value = t, this.uniformNames = e.map(function (t) {\n        return "u_" + t;\n      }), this.type = r;\n    };\n\n    Ea.prototype.setUniform = function (t, e, r) {\n      t.set(r.constantOr(this.value));\n    }, Ea.prototype.getBinding = function (t, e, r) {\n      return "color" === this.type ? new ka(t, e) : new wa(t, e);\n    };\n\n    var Pa = function Pa(t, e) {\n      this.uniformNames = e.map(function (t) {\n        return "u_" + t;\n      }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;\n    };\n\n    Pa.prototype.setConstantPatternPositions = function (t, e) {\n      this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr;\n    }, Pa.prototype.setUniform = function (t, e, r, n) {\n      var i = "u_pattern_to" === n ? this.patternTo : "u_pattern_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null;\n      i && t.set(i);\n    }, Pa.prototype.getBinding = function (t, e, r) {\n      return "u_pattern" === r.substr(0, 9) ? new Sa(t, e) : new wa(t, e);\n    };\n\n    var Ma = function Ma(t, e, r, n) {\n      this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(function (t) {\n        return {\n          name: "a_" + t,\n          type: "Float32",\n          components: "color" === r ? 2 : 1,\n          offset: 0\n        };\n      }), this.paintVertexArray = new n();\n    };\n\n    Ma.prototype.populatePaintArray = function (t, e, r, n, i) {\n      var a = this.paintVertexArray.length,\n          o = this.expression.evaluate(new ui(0), e, {}, n, [], i);\n      this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);\n    }, Ma.prototype.updatePaintArray = function (t, e, r, n) {\n      var i = this.expression.evaluate({\n        zoom: 0\n      }, r, n);\n\n      this._setPaintValue(t, e, i);\n    }, Ma.prototype._setPaintValue = function (t, e, r) {\n      if ("color" === this.type) for (var n = Ca(r), i = t; i < e; i++) {\n        this.paintVertexArray.emplace(i, n[0], n[1]);\n      } else {\n        for (var a = t; a < e; a++) {\n          this.paintVertexArray.emplace(a, r);\n        }\n\n        this.maxValue = Math.max(this.maxValue, Math.abs(r));\n      }\n    }, Ma.prototype.upload = function (t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }, Ma.prototype.destroy = function () {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    };\n\n    var Ba = function Ba(t, e, r, n, i, a) {\n      this.expression = t, this.uniformNames = e.map(function (t) {\n        return "u_" + t + "_t";\n      }), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(function (t) {\n        return {\n          name: "a_" + t,\n          type: "Float32",\n          components: "color" === r ? 4 : 2,\n          offset: 0\n        };\n      }), this.paintVertexArray = new a();\n    };\n\n    Ba.prototype.populatePaintArray = function (t, e, r, n, i) {\n      var a = this.expression.evaluate(new ui(this.zoom), e, {}, n, [], i),\n          o = this.expression.evaluate(new ui(this.zoom + 1), e, {}, n, [], i),\n          s = this.paintVertexArray.length;\n      this.paintVertexArray.resize(t), this._setPaintValue(s, t, a, o);\n    }, Ba.prototype.updatePaintArray = function (t, e, r, n) {\n      var i = this.expression.evaluate({\n        zoom: this.zoom\n      }, r, n),\n          a = this.expression.evaluate({\n        zoom: this.zoom + 1\n      }, r, n);\n\n      this._setPaintValue(t, e, i, a);\n    }, Ba.prototype._setPaintValue = function (t, e, r, n) {\n      if ("color" === this.type) for (var i = Ca(r), a = Ca(n), o = t; o < e; o++) {\n        this.paintVertexArray.emplace(o, i[0], i[1], a[0], a[1]);\n      } else {\n        for (var s = t; s < e; s++) {\n          this.paintVertexArray.emplace(s, r, n);\n        }\n\n        this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n      }\n    }, Ba.prototype.upload = function (t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }, Ba.prototype.destroy = function () {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    }, Ba.prototype.setUniform = function (t, e) {\n      var r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,\n          n = p(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);\n      t.set(n);\n    }, Ba.prototype.getBinding = function (t, e, r) {\n      return new wa(t, e);\n    };\n\n    var Ta = function Ta(t, e, r, n, i, a) {\n      this.expression = t, this.type = e, this.useIntegerZoom = r, this.zoom = n, this.layerId = a, this.zoomInPaintVertexArray = new i(), this.zoomOutPaintVertexArray = new i();\n    };\n\n    Ta.prototype.populatePaintArray = function (t, e, r) {\n      var n = this.zoomInPaintVertexArray.length;\n      this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n    }, Ta.prototype.updatePaintArray = function (t, e, r, n, i) {\n      this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], i);\n    }, Ta.prototype._setPaintValues = function (t, e, r, n) {\n      if (n && r) {\n        var i = n[r.min],\n            a = n[r.mid],\n            o = n[r.max];\n        if (i && a && o) for (var s = t; s < e; s++) {\n          this.zoomInPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], i.tl[0], i.tl[1], i.br[0], i.br[1], a.pixelRatio, i.pixelRatio), this.zoomOutPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], a.pixelRatio, o.pixelRatio);\n        }\n      }\n    }, Ta.prototype.upload = function (t) {\n      this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, pa.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, pa.members, this.expression.isStateDependent));\n    }, Ta.prototype.destroy = function () {\n      this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();\n    };\n\n    var Va = function Va(t, e, r) {\n      this.binders = {}, this._buffers = [];\n      var n = [];\n\n      for (var i in t.paint._values) {\n        if (r(i)) {\n          var a = t.paint.get(i);\n\n          if (a instanceof di && Vr(a.property.specification)) {\n            var o = Da(i, t.type),\n                s = a.value,\n                u = a.property.specification.type,\n                l = a.property.useIntegerZoom,\n                p = a.property.specification["property-type"],\n                c = "cross-faded" === p || "cross-faded-data-driven" === p;\n            if ("constant" === s.kind) this.binders[i] = c ? new Pa(s.value, o) : new Ea(s.value, o, u), n.push("/u_" + i);else if ("source" === s.kind || c) {\n              var h = La(i, u, "source");\n              this.binders[i] = c ? new Ta(s, u, l, e, h, t.id) : new Ma(s, o, u, h), n.push("/a_" + i);\n            } else {\n              var f = La(i, u, "composite");\n              this.binders[i] = new Ba(s, o, u, l, e, f), n.push("/z_" + i);\n            }\n          }\n        }\n      }\n\n      this.cacheKey = n.sort().join("");\n    };\n\n    Va.prototype.getMaxValue = function (t) {\n      var e = this.binders[t];\n      return e instanceof Ma || e instanceof Ba ? e.maxValue : 0;\n    }, Va.prototype.populatePaintArrays = function (t, e, r, n, i) {\n      for (var a in this.binders) {\n        var o = this.binders[a];\n        (o instanceof Ma || o instanceof Ba || o instanceof Ta) && o.populatePaintArray(t, e, r, n, i);\n      }\n    }, Va.prototype.setConstantPatternPositions = function (t, e) {\n      for (var r in this.binders) {\n        var n = this.binders[r];\n        n instanceof Pa && n.setConstantPatternPositions(t, e);\n      }\n    }, Va.prototype.updatePaintArrays = function (t, e, r, n, i) {\n      var a = !1;\n\n      for (var o in t) {\n        for (var s = 0, u = e.getPositions(o); s < u.length; s += 1) {\n          var l = u[s],\n              p = r.feature(l.index);\n\n          for (var c in this.binders) {\n            var h = this.binders[c];\n\n            if ((h instanceof Ma || h instanceof Ba || h instanceof Ta) && !0 === h.expression.isStateDependent) {\n              var f = n.paint.get(c);\n              h.expression = f.value, h.updatePaintArray(l.start, l.end, p, t[o], i), a = !0;\n            }\n          }\n        }\n      }\n\n      return a;\n    }, Va.prototype.defines = function () {\n      var t = [];\n\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        (r instanceof Ea || r instanceof Pa) && t.push.apply(t, r.uniformNames.map(function (t) {\n          return "#define HAS_UNIFORM_" + t;\n        }));\n      }\n\n      return t;\n    }, Va.prototype.getBinderAttributes = function () {\n      var t = [];\n\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        if (r instanceof Ma || r instanceof Ba) for (var n = 0; n < r.paintVertexAttributes.length; n++) {\n          t.push(r.paintVertexAttributes[n].name);\n        } else if (r instanceof Ta) for (var i = 0; i < pa.members.length; i++) {\n          t.push(pa.members[i].name);\n        }\n      }\n\n      return t;\n    }, Va.prototype.getBinderUniforms = function () {\n      var t = [];\n\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        if (r instanceof Ea || r instanceof Pa || r instanceof Ba) for (var n = 0, i = r.uniformNames; n < i.length; n += 1) {\n          t.push(i[n]);\n        }\n      }\n\n      return t;\n    }, Va.prototype.getPaintVertexBuffers = function () {\n      return this._buffers;\n    }, Va.prototype.getUniforms = function (t, e) {\n      var r = [];\n\n      for (var n in this.binders) {\n        var i = this.binders[n];\n        if (i instanceof Ea || i instanceof Pa || i instanceof Ba) for (var a = 0, o = i.uniformNames; a < o.length; a += 1) {\n          var s = o[a];\n\n          if (e[s]) {\n            var u = i.getBinding(t, e[s], s);\n            r.push({\n              name: s,\n              property: n,\n              binding: u\n            });\n          }\n        }\n      }\n\n      return r;\n    }, Va.prototype.setUniforms = function (t, e, r, n) {\n      for (var i = 0, a = e; i < a.length; i += 1) {\n        var o = a[i],\n            s = o.name,\n            u = o.property;\n        this.binders[u].setUniform(o.binding, n, r.get(u), s);\n      }\n    }, Va.prototype.updatePaintBuffers = function (t) {\n      for (var e in this._buffers = [], this.binders) {\n        var r = this.binders[e];\n\n        if (t && r instanceof Ta) {\n          var n = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;\n          n && this._buffers.push(n);\n        } else (r instanceof Ma || r instanceof Ba) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);\n      }\n    }, Va.prototype.upload = function (t) {\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        (r instanceof Ma || r instanceof Ba || r instanceof Ta) && r.upload(t);\n      }\n\n      this.updatePaintBuffers();\n    }, Va.prototype.destroy = function () {\n      for (var t in this.binders) {\n        var e = this.binders[t];\n        (e instanceof Ma || e instanceof Ba || e instanceof Ta) && e.destroy();\n      }\n    };\n\n    var Fa = function Fa(t, e, r) {\n      void 0 === r && (r = function r() {\n        return !0;\n      }), this.programConfigurations = {};\n\n      for (var n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n];\n        this.programConfigurations[a.id] = new Va(a, e, r);\n      }\n\n      this.needsUpload = !1, this._featureMap = new da(), this._bufferOffset = 0;\n    };\n\n    function Da(t, e) {\n      return {\n        "text-opacity": ["opacity"],\n        "icon-opacity": ["opacity"],\n        "text-color": ["fill_color"],\n        "icon-color": ["fill_color"],\n        "text-halo-color": ["halo_color"],\n        "icon-halo-color": ["halo_color"],\n        "text-halo-blur": ["halo_blur"],\n        "icon-halo-blur": ["halo_blur"],\n        "text-halo-width": ["halo_width"],\n        "icon-halo-width": ["halo_width"],\n        "line-gap-width": ["gapwidth"],\n        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],\n        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],\n        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]\n      }[t] || [t.replace(e + "-", "").replace(/-/g, "_")];\n    }\n\n    function La(t, e, r) {\n      var n = {\n        color: {\n          source: Ti,\n          composite: Yi\n        },\n        number: {\n          source: Gi,\n          composite: Ti\n        }\n      },\n          i = function (t) {\n        return {\n          "line-pattern": {\n            source: Vi,\n            composite: Vi\n          },\n          "fill-pattern": {\n            source: Vi,\n            composite: Vi\n          },\n          "fill-extrusion-pattern": {\n            source: Vi,\n            composite: Vi\n          }\n        }[t];\n      }(t);\n\n      return i && i[r] || n[e][r];\n    }\n\n    Fa.prototype.populatePaintArrays = function (t, e, r, n, i, a) {\n      for (var o in this.programConfigurations) {\n        this.programConfigurations[o].populatePaintArrays(t, e, n, i, a);\n      }\n\n      void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n    }, Fa.prototype.updatePaintArrays = function (t, e, r, n) {\n      for (var i = 0, a = r; i < a.length; i += 1) {\n        var o = a[i];\n        this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, e, o, n) || this.needsUpload;\n      }\n    }, Fa.prototype.get = function (t) {\n      return this.programConfigurations[t];\n    }, Fa.prototype.upload = function (t) {\n      if (this.needsUpload) {\n        for (var e in this.programConfigurations) {\n          this.programConfigurations[e].upload(t);\n        }\n\n        this.needsUpload = !1;\n      }\n    }, Fa.prototype.destroy = function () {\n      for (var t in this.programConfigurations) {\n        this.programConfigurations[t].destroy();\n      }\n    }, On("ConstantBinder", Ea), On("CrossFadedConstantBinder", Pa), On("SourceExpressionBinder", Ma), On("CrossFadedCompositeBinder", Ta), On("CompositeExpressionBinder", Ba), On("ProgramConfiguration", Va, {\n      omit: ["_buffers"]\n    }), On("ProgramConfigurationSet", Fa);\n    var Ra = Math.pow(2, 14) - 1,\n        Oa = -Ra - 1;\n\n    function Ua(t) {\n      for (var e = 8192 / t.extent, r = t.loadGeometry(), n = 0; n < r.length; n++) {\n        for (var i = r[n], a = 0; a < i.length; a++) {\n          var o = i[a],\n              s = Math.round(o.x * e),\n              u = Math.round(o.y * e);\n          o.x = p(s, Oa, Ra), o.y = p(u, Oa, Ra), (s < o.x || s > o.x + 1 || u < o.y || u > o.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");\n        }\n      }\n\n      return r;\n    }\n\n    function ja(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? Ua(t) : []\n      };\n    }\n\n    function qa(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n\n    var Na = function Na(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ei(), this.indexArray = new qi(), this.segments = new ua(), this.programConfigurations = new Fa(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    function Ka(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        if (Qa(e, t[r])) return !0;\n      }\n\n      for (var n = 0; n < e.length; n++) {\n        if (Qa(t, e[n])) return !0;\n      }\n\n      return !!Ja(t, e);\n    }\n\n    function Ga(t, e, r) {\n      return !!Qa(t, e) || !!Ya(e, t, r);\n    }\n\n    function Za(t, e) {\n      if (1 === t.length) return Wa(e, t[0]);\n\n      for (var r = 0; r < e.length; r++) {\n        for (var n = e[r], i = 0; i < n.length; i++) {\n          if (Qa(t, n[i])) return !0;\n        }\n      }\n\n      for (var a = 0; a < t.length; a++) {\n        if (Wa(e, t[a])) return !0;\n      }\n\n      for (var o = 0; o < e.length; o++) {\n        if (Ja(t, e[o])) return !0;\n      }\n\n      return !1;\n    }\n\n    function Xa(t, e, r) {\n      if (t.length > 1) {\n        if (Ja(t, e)) return !0;\n\n        for (var n = 0; n < e.length; n++) {\n          if (Ya(e[n], t, r)) return !0;\n        }\n      }\n\n      for (var i = 0; i < t.length; i++) {\n        if (Ya(t[i], e, r)) return !0;\n      }\n\n      return !1;\n    }\n\n    function Ja(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n\n      for (var r = 0; r < t.length - 1; r++) {\n        for (var n = t[r], i = t[r + 1], a = 0; a < e.length - 1; a++) {\n          if (Ha(n, i, e[a], e[a + 1])) return !0;\n        }\n      }\n\n      return !1;\n    }\n\n    function Ha(t, e, r, n) {\n      return S(t, r, n) !== S(e, r, n) && S(t, e, r) !== S(t, e, n);\n    }\n\n    function Ya(t, e, r) {\n      var n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n\n      for (var i = 1; i < e.length; i++) {\n        if ($a(t, e[i - 1], e[i]) < n) return !0;\n      }\n\n      return !1;\n    }\n\n    function $a(t, e, r) {\n      var n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      var i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n\n    function Wa(t, e) {\n      for (var r, n, i, a = !1, o = 0; o < t.length; o++) {\n        for (var s = 0, u = (r = t[o]).length - 1; s < r.length; u = s++) {\n          (n = r[s]).y > e.y != (i = r[u]).y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (a = !a);\n        }\n      }\n\n      return a;\n    }\n\n    function Qa(t, e) {\n      for (var r = !1, n = 0, i = t.length - 1; n < t.length; i = n++) {\n        var a = t[n],\n            o = t[i];\n        a.y > e.y != o.y > e.y && e.x < (o.x - a.x) * (e.y - a.y) / (o.y - a.y) + a.x && (r = !r);\n      }\n\n      return r;\n    }\n\n    function to(t, e, r) {\n      var n = r[0],\n          i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      var a = S(t, e, r[0]);\n      return a !== S(t, e, r[1]) || a !== S(t, e, r[2]) || a !== S(t, e, r[3]);\n    }\n\n    function eo(t, e, r) {\n      var n = e.paint.get(t).value;\n      return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n\n    function ro(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n\n    function no(t, e, r, n, a) {\n      if (!e[0] && !e[1]) return t;\n\n      var o = i.convert(e)._mult(a);\n\n      "viewport" === r && o._rotate(-n);\n\n      for (var s = [], u = 0; u < t.length; u++) {\n        s.push(t[u].sub(o));\n      }\n\n      return s;\n    }\n\n    Na.prototype.populate = function (t, e, r) {\n      var n = this.layers[0],\n          i = [],\n          a = null,\n          o = !1;\n      "circle" === n.type && (o = !(a = n.layout.get("circle-sort-key")).isConstant());\n\n      for (var s = 0, u = t; s < u.length; s += 1) {\n        var l = u[s],\n            p = l.feature,\n            c = l.id,\n            h = l.index,\n            f = l.sourceLayerIndex,\n            y = this.layers[0]._featureFilter.needGeometry,\n            d = ja(p, y);\n\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), d, r)) {\n          var m = o ? a.evaluate(d, {}, r) : void 0,\n              v = {\n            id: c,\n            properties: p.properties,\n            type: p.type,\n            sourceLayerIndex: f,\n            index: h,\n            geometry: y ? d.geometry : Ua(p),\n            patterns: {},\n            sortKey: m\n          };\n          i.push(v);\n        }\n      }\n\n      o && i.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var g = 0, x = i; g < x.length; g += 1) {\n        var b = x[g],\n            w = b.geometry,\n            _ = b.index,\n            A = b.sourceLayerIndex,\n            S = t[_].feature;\n        this.addFeature(b, w, _, r), e.featureIndex.insert(S, w, _, A, this.index);\n      }\n    }, Na.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, Na.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, Na.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, Na.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, sa), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, Na.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, Na.prototype.addFeature = function (t, e, r, n) {\n      for (var i = 0, a = e; i < a.length; i += 1) {\n        for (var o = 0, s = a[i]; o < s.length; o += 1) {\n          var u = s[o],\n              l = u.x,\n              p = u.y;\n\n          if (!(l < 0 || l >= 8192 || p < 0 || p >= 8192)) {\n            var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n                h = c.vertexLength;\n            qa(this.layoutVertexArray, l, p, -1, -1), qa(this.layoutVertexArray, l, p, 1, -1), qa(this.layoutVertexArray, l, p, 1, 1), qa(this.layoutVertexArray, l, p, -1, 1), this.indexArray.emplaceBack(h, h + 1, h + 2), this.indexArray.emplaceBack(h, h + 3, h + 2), c.vertexLength += 4, c.primitiveLength += 2;\n          }\n        }\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n);\n    }, On("CircleBucket", Na, {\n      omit: ["layers"]\n    });\n    var io = new _i({\n      "circle-sort-key": new gi(Pt.layout_circle["circle-sort-key"])\n    }),\n        ao = {\n      paint: new _i({\n        "circle-radius": new gi(Pt.paint_circle["circle-radius"]),\n        "circle-color": new gi(Pt.paint_circle["circle-color"]),\n        "circle-blur": new gi(Pt.paint_circle["circle-blur"]),\n        "circle-opacity": new gi(Pt.paint_circle["circle-opacity"]),\n        "circle-translate": new vi(Pt.paint_circle["circle-translate"]),\n        "circle-translate-anchor": new vi(Pt.paint_circle["circle-translate-anchor"]),\n        "circle-pitch-scale": new vi(Pt.paint_circle["circle-pitch-scale"]),\n        "circle-pitch-alignment": new vi(Pt.paint_circle["circle-pitch-alignment"]),\n        "circle-stroke-width": new gi(Pt.paint_circle["circle-stroke-width"]),\n        "circle-stroke-color": new gi(Pt.paint_circle["circle-stroke-color"]),\n        "circle-stroke-opacity": new gi(Pt.paint_circle["circle-stroke-opacity"])\n      }),\n      layout: io\n    },\n        oo = "undefined" != typeof Float32Array ? Float32Array : Array;\n\n    function so(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n\n    function uo(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = e[3],\n          s = e[4],\n          u = e[5],\n          l = e[6],\n          p = e[7],\n          c = e[8],\n          h = e[9],\n          f = e[10],\n          y = e[11],\n          d = e[12],\n          m = e[13],\n          v = e[14],\n          g = e[15],\n          x = r[0],\n          b = r[1],\n          w = r[2],\n          _ = r[3];\n      return t[0] = x * n + b * s + w * c + _ * d, t[1] = x * i + b * u + w * h + _ * m, t[2] = x * a + b * l + w * f + _ * v, t[3] = x * o + b * p + w * y + _ * g, t[4] = (x = r[4]) * n + (b = r[5]) * s + (w = r[6]) * c + (_ = r[7]) * d, t[5] = x * i + b * u + w * h + _ * m, t[6] = x * a + b * l + w * f + _ * v, t[7] = x * o + b * p + w * y + _ * g, t[8] = (x = r[8]) * n + (b = r[9]) * s + (w = r[10]) * c + (_ = r[11]) * d, t[9] = x * i + b * u + w * h + _ * m, t[10] = x * a + b * l + w * f + _ * v, t[11] = x * o + b * p + w * y + _ * g, t[12] = (x = r[12]) * n + (b = r[13]) * s + (w = r[14]) * c + (_ = r[15]) * d, t[13] = x * i + b * u + w * h + _ * m, t[14] = x * a + b * l + w * f + _ * v, t[15] = x * o + b * p + w * y + _ * g, t;\n    }\n\n    Math.hypot || (Math.hypot = function () {\n      for (var t = arguments, e = 0, r = arguments.length; r--;) {\n        e += t[r] * t[r];\n      }\n\n      return Math.sqrt(e);\n    });\n    var lo,\n        po = uo;\n\n    function co(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * a + r[12] * o, t[1] = r[1] * n + r[5] * i + r[9] * a + r[13] * o, t[2] = r[2] * n + r[6] * i + r[10] * a + r[14] * o, t[3] = r[3] * n + r[7] * i + r[11] * a + r[15] * o, t;\n    }\n\n    lo = new oo(3), oo != Float32Array && (lo[0] = 0, lo[1] = 0, lo[2] = 0), function () {\n      var t = new oo(4);\n      oo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0);\n    }();\n    var ho = (function () {\n      var t = new oo(2);\n      oo != Float32Array && (t[0] = 0, t[1] = 0);\n    }(), function (t) {\n      function e(e) {\n        t.call(this, e, ao);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new Na(t);\n      }, e.prototype.queryRadius = function (t) {\n        var e = t;\n        return eo("circle-radius", this, e) + eo("circle-stroke-width", this, e) + ro(this.paint.get("circle-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, i, a, o, s) {\n        for (var u = no(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, o), l = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r), p = "map" === this.paint.get("circle-pitch-alignment"), c = p ? u : function (t, e) {\n          return t.map(function (t) {\n            return fo(t, e);\n          });\n        }(u, s), h = p ? l * o : l, f = 0, y = n; f < y.length; f += 1) {\n          for (var d = 0, m = y[f]; d < m.length; d += 1) {\n            var v = m[d],\n                g = p ? v : fo(v, s),\n                x = h,\n                b = co([], [v.x, v.y, 0, 1], s);\n            if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x *= b[3] / a.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x *= a.cameraToCenterDistance / b[3]), Ga(c, g, x)) return !0;\n          }\n        }\n\n        return !1;\n      }, e;\n    }(Ai));\n\n    function fo(t, e) {\n      var r = co([], [t.x, t.y, 0, 1], e);\n      return new i(r[0] / r[3], r[1] / r[3]);\n    }\n\n    var yo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(Na);\n\n    function mo(t, e, r, n) {\n      var i = e.width,\n          a = e.height;\n\n      if (n) {\n        if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);else if (n.length !== i * a * r) throw new RangeError("mismatched image size");\n      } else n = new Uint8Array(i * a * r);\n\n      return t.width = i, t.height = a, t.data = n, t;\n    }\n\n    function vo(t, e, r) {\n      var n = e.width,\n          i = e.height;\n\n      if (n !== t.width || i !== t.height) {\n        var a = mo({}, {\n          width: n,\n          height: i\n        }, r);\n        go(t, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: 0,\n          y: 0\n        }, {\n          width: Math.min(t.width, n),\n          height: Math.min(t.height, i)\n        }, r), t.width = n, t.height = i, t.data = a.data;\n      }\n    }\n\n    function go(t, e, r, n, i, a) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");\n\n      for (var o = t.data, s = e.data, u = 0; u < i.height; u++) {\n        for (var l = ((r.y + u) * t.width + r.x) * a, p = ((n.y + u) * e.width + n.x) * a, c = 0; c < i.width * a; c++) {\n          s[p + c] = o[l + c];\n        }\n      }\n\n      return e;\n    }\n\n    On("HeatmapBucket", yo, {\n      omit: ["layers"]\n    });\n\n    var xo = function xo(t, e) {\n      mo(this, t, 1, e);\n    };\n\n    xo.prototype.resize = function (t) {\n      vo(this, t, 1);\n    }, xo.prototype.clone = function () {\n      return new xo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }, xo.copy = function (t, e, r, n, i) {\n      go(t, e, r, n, i, 1);\n    };\n\n    var bo = function bo(t, e) {\n      mo(this, t, 4, e);\n    };\n\n    bo.prototype.resize = function (t) {\n      vo(this, t, 4);\n    }, bo.prototype.replace = function (t, e) {\n      e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n    }, bo.prototype.clone = function () {\n      return new bo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }, bo.copy = function (t, e, r, n, i) {\n      go(t, e, r, n, i, 4);\n    }, On("AlphaImage", xo), On("RGBAImage", bo);\n    var wo = {\n      paint: new _i({\n        "heatmap-radius": new gi(Pt.paint_heatmap["heatmap-radius"]),\n        "heatmap-weight": new gi(Pt.paint_heatmap["heatmap-weight"]),\n        "heatmap-intensity": new vi(Pt.paint_heatmap["heatmap-intensity"]),\n        "heatmap-color": new wi(Pt.paint_heatmap["heatmap-color"]),\n        "heatmap-opacity": new vi(Pt.paint_heatmap["heatmap-opacity"])\n      })\n    };\n\n    function _o(t) {\n      var e = {},\n          r = t.resolution || 256,\n          n = t.clips ? t.clips.length : 1,\n          i = t.image || new bo({\n        width: r,\n        height: n\n      }),\n          a = function a(r, n, _a2) {\n        e[t.evaluationKey] = _a2;\n        var o = t.expression.evaluate(e);\n        i.data[r + n + 0] = Math.floor(255 * o.r / o.a), i.data[r + n + 1] = Math.floor(255 * o.g / o.a), i.data[r + n + 2] = Math.floor(255 * o.b / o.a), i.data[r + n + 3] = Math.floor(255 * o.a);\n      };\n\n      if (t.clips) for (var o = 0, s = 0; o < n; ++o, s += 4 * r) {\n        for (var u = 0, l = 0; u < r; u++, l += 4) {\n          var p = u / (r - 1),\n              c = t.clips[o];\n          a(s, l, c.start * (1 - p) + c.end * p);\n        }\n      } else for (var h = 0, f = 0; h < r; h++, f += 4) {\n        a(0, f, h / (r - 1));\n      }\n      return i;\n    }\n\n    var Ao = function (t) {\n      function e(e) {\n        t.call(this, e, wo), this._updateColorRamp();\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new yo(t);\n      }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {\n        "heatmap-color" === t && this._updateColorRamp();\n      }, e.prototype._updateColorRamp = function () {\n        this.colorRamp = _o({\n          expression: this._transitionablePaint._values["heatmap-color"].value.expression,\n          evaluationKey: "heatmapDensity",\n          image: this.colorRamp\n        }), this.colorRampTexture = null;\n      }, e.prototype.resize = function () {\n        this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n      }, e.prototype.queryRadius = function () {\n        return 0;\n      }, e.prototype.queryIntersectsFeature = function () {\n        return !1;\n      }, e.prototype.hasOffscreenPass = function () {\n        return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;\n      }, e;\n    }(Ai),\n        So = {\n      paint: new _i({\n        "hillshade-illumination-direction": new vi(Pt.paint_hillshade["hillshade-illumination-direction"]),\n        "hillshade-illumination-anchor": new vi(Pt.paint_hillshade["hillshade-illumination-anchor"]),\n        "hillshade-exaggeration": new vi(Pt.paint_hillshade["hillshade-exaggeration"]),\n        "hillshade-shadow-color": new vi(Pt.paint_hillshade["hillshade-shadow-color"]),\n        "hillshade-highlight-color": new vi(Pt.paint_hillshade["hillshade-highlight-color"]),\n        "hillshade-accent-color": new vi(Pt.paint_hillshade["hillshade-accent-color"])\n      })\n    },\n        ko = function (t) {\n      function e(e) {\n        t.call(this, e, So);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.hasOffscreenPass = function () {\n        return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;\n      }, e;\n    }(Ai),\n        Io = zi([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }], 4).members,\n        zo = Eo,\n        Co = Eo;\n\n    function Eo(t, e, r) {\n      r = r || 2;\n      var n,\n          i,\n          a,\n          o,\n          s,\n          u,\n          l,\n          p = e && e.length,\n          c = p ? e[0] * r : t.length,\n          h = Po(t, 0, c, r, !0),\n          f = [];\n      if (!h || h.next === h.prev) return f;\n\n      if (p && (h = function (t, e, r, n) {\n        var i,\n            a,\n            o,\n            s = [];\n\n        for (i = 0, a = e.length; i < a; i++) {\n          (o = Po(t, e[i] * n, i < a - 1 ? e[i + 1] * n : t.length, n, !1)) === o.next && (o.steiner = !0), s.push(jo(o));\n        }\n\n        for (s.sort(Lo), i = 0; i < s.length; i++) {\n          Ro(s[i], r), r = Mo(r, r.next);\n        }\n\n        return r;\n      }(t, e, h, r)), t.length > 80 * r) {\n        n = a = t[0], i = o = t[1];\n\n        for (var y = r; y < c; y += r) {\n          (s = t[y]) < n && (n = s), (u = t[y + 1]) < i && (i = u), s > a && (a = s), u > o && (o = u);\n        }\n\n        l = 0 !== (l = Math.max(a - n, o - i)) ? 1 / l : 0;\n      }\n\n      return Bo(h, f, r, n, i, l), f;\n    }\n\n    function Po(t, e, r, n, i) {\n      var a, o;\n      if (i === ts(t, e, r, n) > 0) for (a = e; a < r; a += n) {\n        o = $o(a, t[a], t[a + 1], o);\n      } else for (a = r - n; a >= e; a -= n) {\n        o = $o(a, t[a], t[a + 1], o);\n      }\n      return o && Go(o, o.next) && (Wo(o), o = o.next), o;\n    }\n\n    function Mo(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n          n = t;\n\n      do {\n        if (r = !1, n.steiner || !Go(n, n.next) && 0 !== Ko(n.prev, n, n.next)) n = n.next;else {\n          if (Wo(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n\n      return e;\n    }\n\n    function Bo(t, e, r, n, i, a, o) {\n      if (t) {\n        !o && a && function (t, e, r, n) {\n          var i = t;\n\n          do {\n            null === i.z && (i.z = Uo(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n                r,\n                n,\n                i,\n                a,\n                o,\n                s,\n                u,\n                l = 1;\n\n            do {\n              for (r = t, t = null, a = null, o = 0; r;) {\n                for (o++, n = r, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++) {\n                  ;\n                }\n\n                for (u = l; s > 0 || u > 0 && n;) {\n                  0 !== s && (0 === u || !n || r.z <= n.z) ? (i = r, r = r.nextZ, s--) : (i = n, n = n.nextZ, u--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;\n                }\n\n                r = n;\n              }\n\n              a.nextZ = null, l *= 2;\n            } while (o > 1);\n          }(i);\n        }(t, n, i, a);\n\n        for (var s, u, l = t; t.prev !== t.next;) {\n          if (s = t.prev, u = t.next, a ? Vo(t, n, i, a) : To(t)) e.push(s.i / r), e.push(t.i / r), e.push(u.i / r), Wo(t), t = u.next, l = u.next;else if ((t = u) === l) {\n            o ? 1 === o ? Bo(t = Fo(Mo(t), e, r), e, r, n, i, a, 2) : 2 === o && Do(t, e, r, n, i, a) : Bo(Mo(t), e, r, n, i, a, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    function To(t) {\n      var e = t.prev,\n          r = t,\n          n = t.next;\n      if (Ko(e, r, n) >= 0) return !1;\n\n      for (var i = t.next.next; i !== t.prev;) {\n        if (qo(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && Ko(i.prev, i, i.next) >= 0) return !1;\n        i = i.next;\n      }\n\n      return !0;\n    }\n\n    function Vo(t, e, r, n) {\n      var i = t.prev,\n          a = t,\n          o = t.next;\n      if (Ko(i, a, o) >= 0) return !1;\n\n      for (var s = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, l = Uo(i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, e, r, n), p = Uo(s, u, e, r, n), c = t.prevZ, h = t.nextZ; c && c.z >= l && h && h.z <= p;) {\n        if (c !== t.prev && c !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, c.x, c.y) && Ko(c.prev, c, c.next) >= 0) return !1;\n        if (c = c.prevZ, h !== t.prev && h !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) && Ko(h.prev, h, h.next) >= 0) return !1;\n        h = h.nextZ;\n      }\n\n      for (; c && c.z >= l;) {\n        if (c !== t.prev && c !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, c.x, c.y) && Ko(c.prev, c, c.next) >= 0) return !1;\n        c = c.prevZ;\n      }\n\n      for (; h && h.z <= p;) {\n        if (h !== t.prev && h !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) && Ko(h.prev, h, h.next) >= 0) return !1;\n        h = h.nextZ;\n      }\n\n      return !0;\n    }\n\n    function Fo(t, e, r) {\n      var n = t;\n\n      do {\n        var i = n.prev,\n            a = n.next.next;\n        !Go(i, a) && Zo(i, n, n.next, a) && Ho(i, a) && Ho(a, i) && (e.push(i.i / r), e.push(n.i / r), e.push(a.i / r), Wo(n), Wo(n.next), n = t = a), n = n.next;\n      } while (n !== t);\n\n      return Mo(n);\n    }\n\n    function Do(t, e, r, n, i, a) {\n      var o = t;\n\n      do {\n        for (var s = o.next.next; s !== o.prev;) {\n          if (o.i !== s.i && No(o, s)) {\n            var u = Yo(o, s);\n            return o = Mo(o, o.next), u = Mo(u, u.next), Bo(o, e, r, n, i, a), void Bo(u, e, r, n, i, a);\n          }\n\n          s = s.next;\n        }\n\n        o = o.next;\n      } while (o !== t);\n    }\n\n    function Lo(t, e) {\n      return t.x - e.x;\n    }\n\n    function Ro(t, e) {\n      if (e = function (t, e) {\n        var r,\n            n = e,\n            i = t.x,\n            a = t.y,\n            o = -1 / 0;\n\n        do {\n          if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {\n            var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n\n            if (s <= i && s > o) {\n              if (o = s, s === i) {\n                if (a === n.y) return n;\n                if (a === n.next.y) return n.next;\n              }\n\n              r = n.x < n.next.x ? n : n.next;\n            }\n          }\n\n          n = n.next;\n        } while (n !== e);\n\n        if (!r) return null;\n        if (i === o) return r;\n        var u,\n            l = r,\n            p = r.x,\n            c = r.y,\n            h = 1 / 0;\n        n = r;\n\n        do {\n          i >= n.x && n.x >= p && i !== n.x && qo(a < c ? i : o, a, p, c, a < c ? o : i, a, n.x, n.y) && (u = Math.abs(a - n.y) / (i - n.x), Ho(n, t) && (u < h || u === h && (n.x > r.x || n.x === r.x && Oo(r, n))) && (r = n, h = u)), n = n.next;\n        } while (n !== l);\n\n        return r;\n      }(t, e)) {\n        var r = Yo(e, t);\n        Mo(e, e.next), Mo(r, r.next);\n      }\n    }\n\n    function Oo(t, e) {\n      return Ko(t.prev, t, e.prev) < 0 && Ko(e.next, t, t.next) < 0;\n    }\n\n    function Uo(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n\n    function jo(t) {\n      var e = t,\n          r = t;\n\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n\n      return r;\n    }\n\n    function qo(t, e, r, n, i, a, o, s) {\n      return (i - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (n - s) - (r - o) * (e - s) >= 0 && (r - o) * (a - s) - (i - o) * (n - s) >= 0;\n    }\n\n    function No(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Zo(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n\n        return !1;\n      }(t, e) && (Ho(t, e) && Ho(e, t) && function (t, e) {\n        var r = t,\n            n = !1,\n            i = (t.x + e.x) / 2,\n            a = (t.y + e.y) / 2;\n\n        do {\n          r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n\n        return n;\n      }(t, e) && (Ko(t.prev, t, e.prev) || Ko(t, e.prev, e)) || Go(t, e) && Ko(t.prev, t, t.next) > 0 && Ko(e.prev, e, e.next) > 0);\n    }\n\n    function Ko(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n\n    function Go(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n\n    function Zo(t, e, r, n) {\n      var i = Jo(Ko(t, e, r)),\n          a = Jo(Ko(t, e, n)),\n          o = Jo(Ko(r, n, t)),\n          s = Jo(Ko(r, n, e));\n      return i !== a && o !== s || !(0 !== i || !Xo(t, r, e)) || !(0 !== a || !Xo(t, n, e)) || !(0 !== o || !Xo(r, t, n)) || !(0 !== s || !Xo(r, e, n));\n    }\n\n    function Xo(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n\n    function Jo(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n\n    function Ho(t, e) {\n      return Ko(t.prev, t, t.next) < 0 ? Ko(t, e, t.next) >= 0 && Ko(t, t.prev, e) >= 0 : Ko(t, e, t.prev) < 0 || Ko(t, t.next, e) < 0;\n    }\n\n    function Yo(t, e) {\n      var r = new Qo(t.i, t.x, t.y),\n          n = new Qo(e.i, e.x, e.y),\n          i = t.next,\n          a = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;\n    }\n\n    function $o(t, e, r, n) {\n      var i = new Qo(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n\n    function Wo(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n\n    function Qo(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n\n    function ts(t, e, r, n) {\n      for (var i = 0, a = e, o = r - n; a < r; a += n) {\n        i += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;\n      }\n\n      return i;\n    }\n\n    function es(t, e, r, n, i) {\n      !function t(e, r, n, i, a) {\n        for (; i > n;) {\n          if (i - n > 600) {\n            var o = i - n + 1,\n                s = r - n + 1,\n                u = Math.log(o),\n                l = .5 * Math.exp(2 * u / 3),\n                p = .5 * Math.sqrt(u * l * (o - l) / o) * (s - o / 2 < 0 ? -1 : 1);\n            t(e, r, Math.max(n, Math.floor(r - s * l / o + p)), Math.min(i, Math.floor(r + (o - s) * l / o + p)), a);\n          }\n\n          var c = e[r],\n              h = n,\n              f = i;\n\n          for (rs(e, n, r), a(e[i], c) > 0 && rs(e, n, i); h < f;) {\n            for (rs(e, h, f), h++, f--; a(e[h], c) < 0;) {\n              h++;\n            }\n\n            for (; a(e[f], c) > 0;) {\n              f--;\n            }\n          }\n\n          0 === a(e[n], c) ? rs(e, n, f) : rs(e, ++f, i), f <= r && (n = f + 1), r <= f && (i = f - 1);\n        }\n      }(t, e, r || 0, n || t.length - 1, i || ns);\n    }\n\n    function rs(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    function ns(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function is(t, e) {\n      var r = t.length;\n      if (r <= 1) return [t];\n\n      for (var n, i, a = [], o = 0; o < r; o++) {\n        var s = k(t[o]);\n        0 !== s && (t[o].area = Math.abs(s), void 0 === i && (i = s < 0), i === s < 0 ? (n && a.push(n), n = [t[o]]) : n.push(t[o]));\n      }\n\n      if (n && a.push(n), e > 1) for (var u = 0; u < a.length; u++) {\n        a[u].length <= e || (es(a[u], e, 1, a[u].length - 1, as), a[u] = a[u].slice(0, e));\n      }\n      return a;\n    }\n\n    function as(t, e) {\n      return e.area - t.area;\n    }\n\n    function os(t, e, r) {\n      for (var n = r.patternDependencies, i = !1, a = 0, o = e; a < o.length; a += 1) {\n        var s = o[a].paint.get(t + "-pattern");\n        s.isConstant() || (i = !0);\n        var u = s.constantOr(null);\n        u && (i = !0, n[u.to] = !0, n[u.from] = !0);\n      }\n\n      return i;\n    }\n\n    function ss(t, e, r, n, i) {\n      for (var a = i.patternDependencies, o = 0, s = e; o < s.length; o += 1) {\n        var u = s[o],\n            l = u.paint.get(t + "-pattern").value;\n\n        if ("constant" !== l.kind) {\n          var p = l.evaluate({\n            zoom: n - 1\n          }, r, {}, i.availableImages),\n              c = l.evaluate({\n            zoom: n\n          }, r, {}, i.availableImages),\n              h = l.evaluate({\n            zoom: n + 1\n          }, r, {}, i.availableImages);\n          c = c && c.name ? c.name : c, h = h && h.name ? h.name : h, a[p = p && p.name ? p.name : p] = !0, a[c] = !0, a[h] = !0, r.patterns[u.id] = {\n            min: p,\n            mid: c,\n            max: h\n          };\n        }\n      }\n\n      return r;\n    }\n\n    Eo.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n          a = Math.abs(ts(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var o = 0, s = e.length; o < s; o++) {\n        a -= Math.abs(ts(t, e[o] * r, o < s - 1 ? e[o + 1] * r : t.length, r));\n      }\n      var u = 0;\n\n      for (o = 0; o < n.length; o += 3) {\n        var l = n[o] * r,\n            p = n[o + 1] * r,\n            c = n[o + 2] * r;\n        u += Math.abs((t[l] - t[c]) * (t[p + 1] - t[l + 1]) - (t[l] - t[p]) * (t[c + 1] - t[l + 1]));\n      }\n\n      return 0 === a && 0 === u ? 0 : Math.abs((u - a) / a);\n    }, Eo.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n        vertices: [],\n        holes: [],\n        dimensions: e\n      }, n = 0, i = 0; i < t.length; i++) {\n        for (var a = 0; a < t[i].length; a++) {\n          for (var o = 0; o < e; o++) {\n            r.vertices.push(t[i][a][o]);\n          }\n        }\n\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n\n      return r;\n    }, zo.default = Co;\n\n    var us = function us(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ei(), this.indexArray = new qi(), this.indexArray2 = new Ji(), this.programConfigurations = new Fa(t.layers, t.zoom), this.segments = new ua(), this.segments2 = new ua(), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    us.prototype.populate = function (t, e, r) {\n      this.hasPattern = os("fill", this.layers, e);\n\n      for (var n = this.layers[0].layout.get("fill-sort-key"), i = !n.isConstant(), a = [], o = 0, s = t; o < s.length; o += 1) {\n        var u = s[o],\n            l = u.feature,\n            p = u.id,\n            c = u.index,\n            h = u.sourceLayerIndex,\n            f = this.layers[0]._featureFilter.needGeometry,\n            y = ja(l, f);\n\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), y, r)) {\n          var d = i ? n.evaluate(y, {}, r, e.availableImages) : void 0,\n              m = {\n            id: p,\n            properties: l.properties,\n            type: l.type,\n            sourceLayerIndex: h,\n            index: c,\n            geometry: f ? y.geometry : Ua(l),\n            patterns: {},\n            sortKey: d\n          };\n          a.push(m);\n        }\n      }\n\n      i && a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var v = 0, g = a; v < g.length; v += 1) {\n        var x = g[v],\n            b = x.geometry,\n            w = x.index,\n            _ = x.sourceLayerIndex;\n\n        if (this.hasPattern) {\n          var A = ss("fill", this.layers, x, this.zoom, e);\n          this.patternFeatures.push(A);\n        } else this.addFeature(x, b, w, r, {});\n\n        e.featureIndex.insert(t[w].feature, b, w, _, this.index);\n      }\n    }, us.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, us.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.patternFeatures; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, us.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, us.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, us.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Io), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, us.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n    }, us.prototype.addFeature = function (t, e, r, n, i) {\n      for (var a = 0, o = is(e, 500); a < o.length; a += 1) {\n        for (var s = o[a], u = 0, l = 0, p = s; l < p.length; l += 1) {\n          u += p[l].length;\n        }\n\n        for (var c = this.segments.prepareSegment(u, this.layoutVertexArray, this.indexArray), h = c.vertexLength, f = [], y = [], d = 0, m = s; d < m.length; d += 1) {\n          var v = m[d];\n\n          if (0 !== v.length) {\n            v !== s[0] && y.push(f.length / 2);\n            var g = this.segments2.prepareSegment(v.length, this.layoutVertexArray, this.indexArray2),\n                x = g.vertexLength;\n            this.layoutVertexArray.emplaceBack(v[0].x, v[0].y), this.indexArray2.emplaceBack(x + v.length - 1, x), f.push(v[0].x), f.push(v[0].y);\n\n            for (var b = 1; b < v.length; b++) {\n              this.layoutVertexArray.emplaceBack(v[b].x, v[b].y), this.indexArray2.emplaceBack(x + b - 1, x + b), f.push(v[b].x), f.push(v[b].y);\n            }\n\n            g.vertexLength += v.length, g.primitiveLength += v.length;\n          }\n        }\n\n        for (var w = zo(f, y), _ = 0; _ < w.length; _ += 3) {\n          this.indexArray.emplaceBack(h + w[_], h + w[_ + 1], h + w[_ + 2]);\n        }\n\n        c.vertexLength += u, c.primitiveLength += w.length / 3;\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, On("FillBucket", us, {\n      omit: ["layers", "patternFeatures"]\n    });\n\n    var ls = new _i({\n      "fill-sort-key": new gi(Pt.layout_fill["fill-sort-key"])\n    }),\n        ps = {\n      paint: new _i({\n        "fill-antialias": new vi(Pt.paint_fill["fill-antialias"]),\n        "fill-opacity": new gi(Pt.paint_fill["fill-opacity"]),\n        "fill-color": new gi(Pt.paint_fill["fill-color"]),\n        "fill-outline-color": new gi(Pt.paint_fill["fill-outline-color"]),\n        "fill-translate": new vi(Pt.paint_fill["fill-translate"]),\n        "fill-translate-anchor": new vi(Pt.paint_fill["fill-translate-anchor"]),\n        "fill-pattern": new xi(Pt.paint_fill["fill-pattern"])\n      }),\n      layout: ls\n    },\n        cs = function (t) {\n      function e(e) {\n        t.call(this, e, ps);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, r) {\n        t.prototype.recalculate.call(this, e, r);\n        var n = this.paint._values["fill-outline-color"];\n        "constant" === n.value.kind && void 0 === n.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);\n      }, e.prototype.createBucket = function (t) {\n        return new us(t);\n      }, e.prototype.queryRadius = function () {\n        return ro(this.paint.get("fill-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, i, a, o) {\n        return Za(no(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, o), n);\n      }, e.prototype.isTileClipped = function () {\n        return !0;\n      }, e;\n    }(Ai),\n        hs = zi([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_normal_ed",\n      components: 4,\n      type: "Int16"\n    }], 4).members,\n        fs = ys;\n\n    function ys(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(ds, this, e);\n    }\n\n    function ds(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n              i = e._values[t.readVarint()];\n\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n\n    function ms(t) {\n      for (var e, r, n = 0, i = 0, a = t.length, o = a - 1; i < a; o = i++) {\n        n += ((r = t[o]).x - (e = t[i]).x) * (e.y + r.y);\n      }\n\n      return n;\n    }\n\n    ys.types = ["Unknown", "Point", "LineString", "Polygon"], ys.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e, r = t.readVarint() + t.pos, n = 1, a = 0, o = 0, s = 0, u = []; t.pos < r;) {\n        if (a <= 0) {\n          var l = t.readVarint();\n          n = 7 & l, a = l >> 3;\n        }\n\n        if (a--, 1 === n || 2 === n) o += t.readSVarint(), s += t.readSVarint(), 1 === n && (e && u.push(e), e = []), e.push(new i(o, s));else {\n          if (7 !== n) throw new Error("unknown command " + n);\n          e && e.push(e[0].clone());\n        }\n      }\n\n      return e && u.push(e), u;\n    }, ys.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, a = 0, o = 1 / 0, s = -1 / 0, u = 1 / 0, l = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var p = t.readVarint();\n          r = 7 & p, n = p >> 3;\n        }\n\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < o && (o = i), i > s && (s = i), (a += t.readSVarint()) < u && (u = a), a > l && (l = a);else if (7 !== r) throw new Error("unknown command " + r);\n      }\n\n      return [o, u, s, l];\n    }, ys.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n          i,\n          a = this.extent * Math.pow(2, r),\n          o = this.extent * t,\n          s = this.extent * e,\n          u = this.loadGeometry(),\n          l = ys.types[this.type];\n\n      function p(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + o) / a - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + s) / a) * Math.PI / 180)) - 90];\n        }\n      }\n\n      switch (this.type) {\n        case 1:\n          var c = [];\n\n          for (n = 0; n < u.length; n++) {\n            c[n] = u[n][0];\n          }\n\n          p(u = c);\n          break;\n\n        case 2:\n          for (n = 0; n < u.length; n++) {\n            p(u[n]);\n          }\n\n          break;\n\n        case 3:\n          for (u = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n\n            for (var r, n, i = [], a = 0; a < e; a++) {\n              var o = ms(t[a]);\n              0 !== o && (void 0 === n && (n = o < 0), n === o < 0 ? (r && i.push(r), r = [t[a]]) : r.push(t[a]));\n            }\n\n            return r && i.push(r), i;\n          }(u), n = 0; n < u.length; n++) {\n            for (i = 0; i < u[n].length; i++) {\n              p(u[n][i]);\n            }\n          }\n\n      }\n\n      1 === u.length ? u = u[0] : l = "Multi" + l;\n      var h = {\n        type: "Feature",\n        geometry: {\n          type: l,\n          coordinates: u\n        },\n        properties: this.properties\n      };\n      return "id" in this && (h.id = this.id), h;\n    };\n    var vs = gs;\n\n    function gs(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(xs, this, e), this.length = this._features.length;\n    }\n\n    function xs(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n\n        return e;\n      }(r));\n    }\n\n    function bs(t, e, r) {\n      if (3 === t) {\n        var n = new vs(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n\n    gs.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");\n      this._pbf.pos = this._features[t];\n\n      var e = this._pbf.readVarint() + this._pbf.pos;\n\n      return new fs(this._pbf, e, this.extent, this._keys, this._values);\n    };\n\n    var ws = {\n      VectorTile: function VectorTile(t, e) {\n        this.layers = t.readFields(bs, {}, e);\n      },\n      VectorTileFeature: fs,\n      VectorTileLayer: vs\n    },\n        _s = ws.VectorTileFeature.types,\n        As = Math.pow(2, 13);\n\n    function Ss(t, e, r, n, i, a, o, s) {\n      t.emplaceBack(e, r, 2 * Math.floor(n * As) + o, i * As * 2, a * As * 2, Math.round(s));\n    }\n\n    var ks = function ks(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Mi(), this.indexArray = new qi(), this.programConfigurations = new Fa(t.layers, t.zoom), this.segments = new ua(), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    function Is(t, e) {\n      return t.x === e.x && (t.x < 0 || t.x > 8192) || t.y === e.y && (t.y < 0 || t.y > 8192);\n    }\n\n    ks.prototype.populate = function (t, e, r) {\n      this.features = [], this.hasPattern = os("fill-extrusion", this.layers, e);\n\n      for (var n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n],\n            o = a.feature,\n            s = a.id,\n            u = a.index,\n            l = a.sourceLayerIndex,\n            p = this.layers[0]._featureFilter.needGeometry,\n            c = ja(o, p);\n\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), c, r)) {\n          var h = {\n            id: s,\n            sourceLayerIndex: l,\n            index: u,\n            geometry: p ? c.geometry : Ua(o),\n            properties: o.properties,\n            type: o.type,\n            patterns: {}\n          };\n          this.hasPattern ? this.features.push(ss("fill-extrusion", this.layers, h, this.zoom, e)) : this.addFeature(h, h.geometry, u, r, {}), e.featureIndex.insert(o, h.geometry, u, l, this.index, !0);\n        }\n      }\n    }, ks.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.features; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, ks.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, ks.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, ks.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, ks.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, hs), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, ks.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, ks.prototype.addFeature = function (t, e, r, n, i) {\n      for (var a = 0, o = is(e, 500); a < o.length; a += 1) {\n        for (var s = o[a], u = 0, l = 0, p = s; l < p.length; l += 1) {\n          u += p[l].length;\n        }\n\n        for (var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h = 0, f = s; h < f.length; h += 1) {\n          var y = f[h];\n          if (0 !== y.length && !((B = y).every(function (t) {\n            return t.x < 0;\n          }) || B.every(function (t) {\n            return t.x > 8192;\n          }) || B.every(function (t) {\n            return t.y < 0;\n          }) || B.every(function (t) {\n            return t.y > 8192;\n          }))) for (var d = 0, m = 0; m < y.length; m++) {\n            var v = y[m];\n\n            if (m >= 1) {\n              var g = y[m - 1];\n\n              if (!Is(v, g)) {\n                c.vertexLength + 4 > ua.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));\n\n                var x = v.sub(g)._perp()._unit(),\n                    b = g.dist(v);\n\n                d + b > 32768 && (d = 0), Ss(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 0, d), Ss(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 1, d), Ss(this.layoutVertexArray, g.x, g.y, x.x, x.y, 0, 0, d += b), Ss(this.layoutVertexArray, g.x, g.y, x.x, x.y, 0, 1, d);\n                var w = c.vertexLength;\n                this.indexArray.emplaceBack(w, w + 2, w + 1), this.indexArray.emplaceBack(w + 1, w + 2, w + 3), c.vertexLength += 4, c.primitiveLength += 2;\n              }\n            }\n          }\n        }\n\n        if (c.vertexLength + u > ua.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(u, this.layoutVertexArray, this.indexArray)), "Polygon" === _s[t.type]) {\n          for (var _ = [], A = [], S = c.vertexLength, k = 0, I = s; k < I.length; k += 1) {\n            var z = I[k];\n\n            if (0 !== z.length) {\n              z !== s[0] && A.push(_.length / 2);\n\n              for (var C = 0; C < z.length; C++) {\n                var E = z[C];\n                Ss(this.layoutVertexArray, E.x, E.y, 0, 0, 1, 1, 0), _.push(E.x), _.push(E.y);\n              }\n            }\n          }\n\n          for (var P = zo(_, A), M = 0; M < P.length; M += 3) {\n            this.indexArray.emplaceBack(S + P[M], S + P[M + 2], S + P[M + 1]);\n          }\n\n          c.primitiveLength += P.length / 3, c.vertexLength += u;\n        }\n      }\n\n      var B;\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, On("FillExtrusionBucket", ks, {\n      omit: ["layers", "features"]\n    });\n\n    var zs = {\n      paint: new _i({\n        "fill-extrusion-opacity": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-opacity"]),\n        "fill-extrusion-color": new gi(Pt["paint_fill-extrusion"]["fill-extrusion-color"]),\n        "fill-extrusion-translate": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-translate"]),\n        "fill-extrusion-translate-anchor": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),\n        "fill-extrusion-pattern": new xi(Pt["paint_fill-extrusion"]["fill-extrusion-pattern"]),\n        "fill-extrusion-height": new gi(Pt["paint_fill-extrusion"]["fill-extrusion-height"]),\n        "fill-extrusion-base": new gi(Pt["paint_fill-extrusion"]["fill-extrusion-base"]),\n        "fill-extrusion-vertical-gradient": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])\n      })\n    },\n        Cs = function (t) {\n      function e(e) {\n        t.call(this, e, zs);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new ks(t);\n      }, e.prototype.queryRadius = function () {\n        return ro(this.paint.get("fill-extrusion-translate"));\n      }, e.prototype.is3D = function () {\n        return !0;\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, a, o, s, u) {\n        var l = no(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, s),\n            p = this.paint.get("fill-extrusion-height").evaluate(e, r),\n            c = this.paint.get("fill-extrusion-base").evaluate(e, r),\n            h = function (t, e, r, n) {\n          for (var a = [], o = 0, s = t; o < s.length; o += 1) {\n            var u = s[o],\n                l = [u.x, u.y, 0, 1];\n            co(l, l, e), a.push(new i(l[0] / l[3], l[1] / l[3]));\n          }\n\n          return a;\n        }(l, u),\n            f = function (t, e, r, n) {\n          for (var a = [], o = [], s = n[8] * e, u = n[9] * e, l = n[10] * e, p = n[11] * e, c = n[8] * r, h = n[9] * r, f = n[10] * r, y = n[11] * r, d = 0, m = t; d < m.length; d += 1) {\n            for (var v = [], g = [], x = 0, b = m[d]; x < b.length; x += 1) {\n              var w = b[x],\n                  _ = w.x,\n                  A = w.y,\n                  S = n[0] * _ + n[4] * A + n[12],\n                  k = n[1] * _ + n[5] * A + n[13],\n                  I = n[2] * _ + n[6] * A + n[14],\n                  z = n[3] * _ + n[7] * A + n[15],\n                  C = I + l,\n                  E = z + p,\n                  P = S + c,\n                  M = k + h,\n                  B = I + f,\n                  T = z + y,\n                  V = new i((S + s) / E, (k + u) / E);\n              V.z = C / E, v.push(V);\n              var F = new i(P / T, M / T);\n              F.z = B / T, g.push(F);\n            }\n\n            a.push(v), o.push(g);\n          }\n\n          return [a, o];\n        }(n, c, p, u);\n\n        return function (t, e, r) {\n          var n = 1 / 0;\n          Za(r, e) && (n = Ps(r, e[0]));\n\n          for (var i = 0; i < e.length; i++) {\n            for (var a = e[i], o = t[i], s = 0; s < a.length - 1; s++) {\n              var u = a[s],\n                  l = [u, a[s + 1], o[s + 1], o[s], u];\n              Ka(r, l) && (n = Math.min(n, Ps(r, l)));\n            }\n          }\n\n          return n !== 1 / 0 && n;\n        }(f[0], f[1], h);\n      }, e;\n    }(Ai);\n\n    function Es(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n\n    function Ps(t, e) {\n      if (1 === t.length) {\n        for (var r, n = 0, i = e[n++]; !r || i.equals(r);) {\n          if (!(r = e[n++])) return 1 / 0;\n        }\n\n        for (; n < e.length; n++) {\n          var a = e[n],\n              o = t[0],\n              s = r.sub(i),\n              u = a.sub(i),\n              l = o.sub(i),\n              p = Es(s, s),\n              c = Es(s, u),\n              h = Es(u, u),\n              f = Es(l, s),\n              y = Es(l, u),\n              d = p * h - c * c,\n              m = (h * f - c * y) / d,\n              v = (p * y - c * f) / d,\n              g = i.z * (1 - m - v) + r.z * m + a.z * v;\n          if (isFinite(g)) return g;\n        }\n\n        return 1 / 0;\n      }\n\n      for (var x = 1 / 0, b = 0, w = e; b < w.length; b += 1) {\n        x = Math.min(x, w[b].z);\n      }\n\n      return x;\n    }\n\n    var Ms = zi([{\n      name: "a_pos_normal",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_data",\n      components: 4,\n      type: "Uint8"\n    }], 4).members,\n        Bs = zi([{\n      name: "a_uv_x",\n      components: 1,\n      type: "Float32"\n    }, {\n      name: "a_split_index",\n      components: 1,\n      type: "Float32"\n    }]).members,\n        Ts = ws.VectorTileFeature.types,\n        Vs = Math.cos(Math.PI / 180 * 37.5),\n        Fs = Math.pow(2, 14) / .5,\n        Ds = function Ds(t) {\n      var e = this;\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function (t) {\n        e.gradients[t.id] = {};\n      }), this.layoutVertexArray = new Bi(), this.layoutVertexArray2 = new Ti(), this.indexArray = new qi(), this.programConfigurations = new Fa(t.layers, t.zoom), this.segments = new ua(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n\n    Ds.prototype.populate = function (t, e, r) {\n      this.hasPattern = os("line", this.layers, e);\n\n      for (var n = this.layers[0].layout.get("line-sort-key"), i = !n.isConstant(), a = [], o = 0, s = t; o < s.length; o += 1) {\n        var u = s[o],\n            l = u.feature,\n            p = u.id,\n            c = u.index,\n            h = u.sourceLayerIndex,\n            f = this.layers[0]._featureFilter.needGeometry,\n            y = ja(l, f);\n\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), y, r)) {\n          var d = i ? n.evaluate(y, {}, r) : void 0,\n              m = {\n            id: p,\n            properties: l.properties,\n            type: l.type,\n            sourceLayerIndex: h,\n            index: c,\n            geometry: f ? y.geometry : Ua(l),\n            patterns: {},\n            sortKey: d\n          };\n          a.push(m);\n        }\n      }\n\n      i && a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var v = 0, g = a; v < g.length; v += 1) {\n        var x = g[v],\n            b = x.geometry,\n            w = x.index,\n            _ = x.sourceLayerIndex;\n\n        if (this.hasPattern) {\n          var A = ss("line", this.layers, x, this.zoom, e);\n          this.patternFeatures.push(A);\n        } else this.addFeature(x, b, w, r, {});\n\n        e.featureIndex.insert(t[w].feature, b, w, _, this.index);\n      }\n    }, Ds.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, Ds.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.patternFeatures; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, Ds.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, Ds.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, Ds.prototype.upload = function (t) {\n      this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Bs)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ms), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, Ds.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, Ds.prototype.lineFeatureClips = function (t) {\n      if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return {\n        start: +t.properties.mapbox_clip_start,\n        end: +t.properties.mapbox_clip_end\n      };\n    }, Ds.prototype.addFeature = function (t, e, r, n, i) {\n      var a = this.layers[0].layout,\n          o = a.get("line-join").evaluate(t, {}),\n          s = a.get("line-cap"),\n          u = a.get("line-miter-limit"),\n          l = a.get("line-round-limit");\n      this.lineClips = this.lineFeatureClips(t);\n\n      for (var p = 0, c = e; p < c.length; p += 1) {\n        this.addLine(c[p], t, o, s, u, l);\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, Ds.prototype.addLine = function (t, e, r, n, i, a) {\n      if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {\n        this.lineClipsArray.push(this.lineClips);\n\n        for (var o = 0; o < t.length - 1; o++) {\n          this.totalDistance += t[o].dist(t[o + 1]);\n        }\n\n        this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n      }\n\n      for (var s = "Polygon" === Ts[e.type], u = t.length; u >= 2 && t[u - 1].equals(t[u - 2]);) {\n        u--;\n      }\n\n      for (var l = 0; l < u - 1 && t[l].equals(t[l + 1]);) {\n        l++;\n      }\n\n      if (!(u < (s ? 3 : 2))) {\n        "bevel" === r && (i = 1.05);\n        var p,\n            c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,\n            h = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray),\n            f = void 0,\n            y = void 0,\n            d = void 0,\n            m = void 0;\n        this.e1 = this.e2 = -1, s && (m = t[l].sub(p = t[u - 2])._unit()._perp());\n\n        for (var v = l; v < u; v++) {\n          if (!(y = v === u - 1 ? s ? t[l + 1] : void 0 : t[v + 1]) || !t[v].equals(y)) {\n            m && (d = m), p && (f = p), p = t[v], m = y ? y.sub(p)._unit()._perp() : d;\n            var g = (d = d || m).add(m);\n            0 === g.x && 0 === g.y || g._unit();\n\n            var x = d.x * m.x + d.y * m.y,\n                b = g.x * m.x + g.y * m.y,\n                w = 0 !== b ? 1 / b : 1 / 0,\n                _ = 2 * Math.sqrt(2 - 2 * b),\n                A = b < Vs && f && y,\n                S = d.x * m.y - d.y * m.x > 0;\n\n            if (A && v > l) {\n              var k = p.dist(f);\n\n              if (k > 2 * c) {\n                var I = p.sub(p.sub(f)._mult(c / k)._round());\n                this.updateDistance(f, I), this.addCurrentVertex(I, d, 0, 0, h), f = I;\n              }\n            }\n\n            var z = f && y,\n                C = z ? r : s ? "butt" : n;\n            if (z && "round" === C && (w < a ? C = "miter" : w <= 2 && (C = "fakeround")), "miter" === C && w > i && (C = "bevel"), "bevel" === C && (w > 2 && (C = "flipbevel"), w < i && (C = "miter")), f && this.updateDistance(f, p), "miter" === C) g._mult(w), this.addCurrentVertex(p, g, 0, 0, h);else if ("flipbevel" === C) {\n              if (w > 100) g = m.mult(-1);else {\n                var E = w * d.add(m).mag() / d.sub(m).mag();\n\n                g._perp()._mult(E * (S ? -1 : 1));\n              }\n              this.addCurrentVertex(p, g, 0, 0, h), this.addCurrentVertex(p, g.mult(-1), 0, 0, h);\n            } else if ("bevel" === C || "fakeround" === C) {\n              var P = -Math.sqrt(w * w - 1),\n                  M = S ? P : 0,\n                  B = S ? 0 : P;\n              if (f && this.addCurrentVertex(p, d, M, B, h), "fakeround" === C) for (var T = Math.round(180 * _ / Math.PI / 20), V = 1; V < T; V++) {\n                var F = V / T;\n\n                if (.5 !== F) {\n                  var D = F - .5;\n                  F += F * D * (F - 1) * ((1.0904 + x * (x * (3.55645 - 1.43519 * x) - 3.2452)) * D * D + (.848013 + x * (.215638 * x - 1.06021)));\n                }\n\n                var L = m.sub(d)._mult(F)._add(d)._unit()._mult(S ? -1 : 1);\n\n                this.addHalfVertex(p, L.x, L.y, !1, S, 0, h);\n              }\n              y && this.addCurrentVertex(p, m, -M, -B, h);\n            } else if ("butt" === C) this.addCurrentVertex(p, g, 0, 0, h);else if ("square" === C) {\n              var R = f ? 1 : -1;\n              this.addCurrentVertex(p, g, R, R, h);\n            } else "round" === C && (f && (this.addCurrentVertex(p, d, 0, 0, h), this.addCurrentVertex(p, d, 1, 1, h, !0)), y && (this.addCurrentVertex(p, m, -1, -1, h, !0), this.addCurrentVertex(p, m, 0, 0, h)));\n\n            if (A && v < u - 1) {\n              var O = p.dist(y);\n\n              if (O > 2 * c) {\n                var U = p.add(y.sub(p)._mult(c / O)._round());\n                this.updateDistance(p, U), this.addCurrentVertex(U, m, 0, 0, h), p = U;\n              }\n            }\n          }\n        }\n      }\n    }, Ds.prototype.addCurrentVertex = function (t, e, r, n, i, a) {\n      void 0 === a && (a = !1);\n      var o = e.y * n - e.x,\n          s = -e.y - e.x * n;\n      this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, a, !1, r, i), this.addHalfVertex(t, o, s, a, !0, -n, i), this.distance > Fs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t, e, r, n, i, a));\n    }, Ds.prototype.addHalfVertex = function (t, e, r, n, i, a, o) {\n      var s = .5 * (this.lineClips ? this.scaledDistance * (Fs - 1) : this.scaledDistance);\n      this.layoutVertexArray.emplaceBack((t.x << 1) + (n ? 1 : 0), (t.y << 1) + (i ? 1 : 0), Math.round(63 * e) + 128, Math.round(63 * r) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & s) << 2, s >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);\n      var u = o.vertexLength++;\n      this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), i ? this.e2 = u : this.e1 = u;\n    }, Ds.prototype.updateScaledDistance = function () {\n      this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;\n    }, Ds.prototype.updateDistance = function (t, e) {\n      this.distance += t.dist(e), this.updateScaledDistance();\n    }, On("LineBucket", Ds, {\n      omit: ["layers", "patternFeatures"]\n    });\n    var Ls = new _i({\n      "line-cap": new vi(Pt.layout_line["line-cap"]),\n      "line-join": new gi(Pt.layout_line["line-join"]),\n      "line-miter-limit": new vi(Pt.layout_line["line-miter-limit"]),\n      "line-round-limit": new vi(Pt.layout_line["line-round-limit"]),\n      "line-sort-key": new gi(Pt.layout_line["line-sort-key"])\n    }),\n        Rs = {\n      paint: new _i({\n        "line-opacity": new gi(Pt.paint_line["line-opacity"]),\n        "line-color": new gi(Pt.paint_line["line-color"]),\n        "line-translate": new vi(Pt.paint_line["line-translate"]),\n        "line-translate-anchor": new vi(Pt.paint_line["line-translate-anchor"]),\n        "line-width": new gi(Pt.paint_line["line-width"]),\n        "line-gap-width": new gi(Pt.paint_line["line-gap-width"]),\n        "line-offset": new gi(Pt.paint_line["line-offset"]),\n        "line-blur": new gi(Pt.paint_line["line-blur"]),\n        "line-dasharray": new bi(Pt.paint_line["line-dasharray"]),\n        "line-pattern": new xi(Pt.paint_line["line-pattern"]),\n        "line-gradient": new wi(Pt.paint_line["line-gradient"])\n      }),\n      layout: Ls\n    },\n        Os = new (function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (e, r) {\n        return r = new ui(Math.floor(r.zoom), {\n          now: r.now,\n          fadeDuration: r.fadeDuration,\n          zoomHistory: r.zoomHistory,\n          transition: r.transition\n        }), t.prototype.possiblyEvaluate.call(this, e, r);\n      }, e.prototype.evaluate = function (e, r, n, i) {\n        return r = h({}, r, {\n          zoom: Math.floor(r.zoom)\n        }), t.prototype.evaluate.call(this, e, r, n, i);\n      }, e;\n    }(gi))(Rs.paint.properties["line-width"].specification);\n    Os.useIntegerZoom = !0;\n\n    var Us = function (t) {\n      function e(e) {\n        t.call(this, e, Rs), this.gradientVersion = 0;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {\n        "line-gradient" === t && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ke, this.gradientVersion = (this.gradientVersion + 1) % s);\n      }, e.prototype.gradientExpression = function () {\n        return this._transitionablePaint._values["line-gradient"].value.expression;\n      }, e.prototype.recalculate = function (e, r) {\n        t.prototype.recalculate.call(this, e, r), this.paint._values["line-floorwidth"] = Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);\n      }, e.prototype.createBucket = function (t) {\n        return new Ds(t);\n      }, e.prototype.queryRadius = function (t) {\n        var e = t,\n            r = js(eo("line-width", this, e), eo("line-gap-width", this, e)),\n            n = eo("line-offset", this, e);\n        return r / 2 + Math.abs(n) + ro(this.paint.get("line-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, a, o, s) {\n        var u = no(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, s),\n            l = s / 2 * js(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)),\n            p = this.paint.get("line-offset").evaluate(e, r);\n        return p && (n = function (t, e) {\n          for (var r = [], n = new i(0, 0), a = 0; a < t.length; a++) {\n            for (var o = t[a], s = [], u = 0; u < o.length; u++) {\n              var l = o[u],\n                  p = o[u + 1],\n                  c = 0 === u ? n : l.sub(o[u - 1])._unit()._perp(),\n                  h = u === o.length - 1 ? n : p.sub(l)._unit()._perp(),\n                  f = c._add(h)._unit();\n\n              f._mult(1 / (f.x * h.x + f.y * h.y)), s.push(f._mult(e)._add(l));\n            }\n\n            r.push(s);\n          }\n\n          return r;\n        }(n, p * s)), function (t, e, r) {\n          for (var n = 0; n < e.length; n++) {\n            var i = e[n];\n            if (t.length >= 3) for (var a = 0; a < i.length; a++) {\n              if (Qa(t, i[a])) return !0;\n            }\n            if (Xa(t, i, r)) return !0;\n          }\n\n          return !1;\n        }(u, n, l);\n      }, e.prototype.isTileClipped = function () {\n        return !0;\n      }, e;\n    }(Ai);\n\n    function js(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n\n    var qs = zi([{\n      name: "a_pos_offset",\n      components: 4,\n      type: "Int16"\n    }, {\n      name: "a_data",\n      components: 4,\n      type: "Uint16"\n    }, {\n      name: "a_pixeloffset",\n      components: 4,\n      type: "Int16"\n    }], 4),\n        Ns = zi([{\n      name: "a_projected_pos",\n      components: 3,\n      type: "Float32"\n    }], 4),\n        Ks = (zi([{\n      name: "a_fade_opacity",\n      components: 1,\n      type: "Uint32"\n    }], 4), zi([{\n      name: "a_placed",\n      components: 2,\n      type: "Uint8"\n    }, {\n      name: "a_shift",\n      components: 2,\n      type: "Float32"\n    }])),\n        Gs = (zi([{\n      type: "Int16",\n      name: "anchorPointX"\n    }, {\n      type: "Int16",\n      name: "anchorPointY"\n    }, {\n      type: "Int16",\n      name: "x1"\n    }, {\n      type: "Int16",\n      name: "y1"\n    }, {\n      type: "Int16",\n      name: "x2"\n    }, {\n      type: "Int16",\n      name: "y2"\n    }, {\n      type: "Uint32",\n      name: "featureIndex"\n    }, {\n      type: "Uint16",\n      name: "sourceLayerIndex"\n    }, {\n      type: "Uint16",\n      name: "bucketIndex"\n    }]), zi([{\n      name: "a_pos",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_anchor_pos",\n      components: 2,\n      type: "Int16"\n    }, {\n      name: "a_extrude",\n      components: 2,\n      type: "Int16"\n    }], 4)),\n        Zs = zi([{\n      name: "a_pos",\n      components: 2,\n      type: "Float32"\n    }, {\n      name: "a_radius",\n      components: 1,\n      type: "Float32"\n    }, {\n      name: "a_flags",\n      components: 2,\n      type: "Int16"\n    }], 4);\n\n    function Xs(t, e, r) {\n      return t.sections.forEach(function (t) {\n        t.text = function (t, e, r) {\n          var n = e.layout.get("text-transform").evaluate(r, {});\n          return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), si.applyArabicShaping && (t = si.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n\n    zi([{\n      name: "triangle",\n      components: 3,\n      type: "Uint16"\n    }]), zi([{\n      type: "Int16",\n      name: "anchorX"\n    }, {\n      type: "Int16",\n      name: "anchorY"\n    }, {\n      type: "Uint16",\n      name: "glyphStartIndex"\n    }, {\n      type: "Uint16",\n      name: "numGlyphs"\n    }, {\n      type: "Uint32",\n      name: "vertexStartIndex"\n    }, {\n      type: "Uint32",\n      name: "lineStartIndex"\n    }, {\n      type: "Uint32",\n      name: "lineLength"\n    }, {\n      type: "Uint16",\n      name: "segment"\n    }, {\n      type: "Uint16",\n      name: "lowerSize"\n    }, {\n      type: "Uint16",\n      name: "upperSize"\n    }, {\n      type: "Float32",\n      name: "lineOffsetX"\n    }, {\n      type: "Float32",\n      name: "lineOffsetY"\n    }, {\n      type: "Uint8",\n      name: "writingMode"\n    }, {\n      type: "Uint8",\n      name: "placedOrientation"\n    }, {\n      type: "Uint8",\n      name: "hidden"\n    }, {\n      type: "Uint32",\n      name: "crossTileID"\n    }, {\n      type: "Int16",\n      name: "associatedIconIndex"\n    }]), zi([{\n      type: "Int16",\n      name: "anchorX"\n    }, {\n      type: "Int16",\n      name: "anchorY"\n    }, {\n      type: "Int16",\n      name: "rightJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "centerJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "leftJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "verticalPlacedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "placedIconSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "verticalPlacedIconSymbolIndex"\n    }, {\n      type: "Uint16",\n      name: "key"\n    }, {\n      type: "Uint16",\n      name: "textBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "textBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalTextBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalTextBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "iconBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "iconBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalIconBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalIconBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "featureIndex"\n    }, {\n      type: "Uint16",\n      name: "numHorizontalGlyphVertices"\n    }, {\n      type: "Uint16",\n      name: "numVerticalGlyphVertices"\n    }, {\n      type: "Uint16",\n      name: "numIconVertices"\n    }, {\n      type: "Uint16",\n      name: "numVerticalIconVertices"\n    }, {\n      type: "Uint16",\n      name: "useRuntimeCollisionCircles"\n    }, {\n      type: "Uint32",\n      name: "crossTileID"\n    }, {\n      type: "Float32",\n      name: "textBoxScale"\n    }, {\n      type: "Float32",\n      components: 2,\n      name: "textOffset"\n    }, {\n      type: "Float32",\n      name: "collisionCircleDiameter"\n    }]), zi([{\n      type: "Float32",\n      name: "offsetX"\n    }]), zi([{\n      type: "Int16",\n      name: "x"\n    }, {\n      type: "Int16",\n      name: "y"\n    }, {\n      type: "Int16",\n      name: "tileUnitDistanceFromAnchor"\n    }]);\n\n    var Js = {\n      "!": "︕",\n      "#": "＃",\n      $: "＄",\n      "%": "％",\n      "&": "＆",\n      "(": "︵",\n      ")": "︶",\n      "*": "＊",\n      "+": "＋",\n      ",": "︐",\n      "-": "︲",\n      ".": "・",\n      "/": "／",\n      ":": "︓",\n      ";": "︔",\n      "<": "︿",\n      "=": "＝",\n      ">": "﹀",\n      "?": "︖",\n      "@": "＠",\n      "[": "﹇",\n      "\\\\": "＼",\n      "]": "﹈",\n      "^": "＾",\n      _: "︳",\n      "`": "｀",\n      "{": "︷",\n      "|": "―",\n      "}": "︸",\n      "~": "～",\n      "¢": "￠",\n      "£": "￡",\n      "¥": "￥",\n      "¦": "￤",\n      "¬": "￢",\n      "¯": "￣",\n      "–": "︲",\n      "—": "︱",\n      "‘": "﹃",\n      "’": "﹄",\n      "“": "﹁",\n      "”": "﹂",\n      "…": "︙",\n      "‧": "・",\n      "₩": "￦",\n      "、": "︑",\n      "。": "︒",\n      "〈": "︿",\n      "〉": "﹀",\n      "《": "︽",\n      "》": "︾",\n      "「": "﹁",\n      "」": "﹂",\n      "『": "﹃",\n      "』": "﹄",\n      "【": "︻",\n      "】": "︼",\n      "〔": "︹",\n      "〕": "︺",\n      "〖": "︗",\n      "〗": "︘",\n      "！": "︕",\n      "（": "︵",\n      "）": "︶",\n      "，": "︐",\n      "－": "︲",\n      "．": "・",\n      "：": "︓",\n      "；": "︔",\n      "＜": "︿",\n      "＞": "﹀",\n      "？": "︖",\n      "［": "﹇",\n      "］": "﹈",\n      "＿": "︳",\n      "｛": "︷",\n      "｜": "―",\n      "｝": "︸",\n      "｟": "︵",\n      "｠": "︶",\n      "｡": "︒",\n      "｢": "﹁",\n      "｣": "﹂"\n    },\n        Hs = function Hs(t, e, r, n, i) {\n      var a,\n          o,\n          s = 8 * i - n - 1,\n          u = (1 << s) - 1,\n          l = u >> 1,\n          p = -7,\n          c = r ? i - 1 : 0,\n          h = r ? -1 : 1,\n          f = t[e + c];\n\n      for (c += h, a = f & (1 << -p) - 1, f >>= -p, p += s; p > 0; a = 256 * a + t[e + c], c += h, p -= 8) {\n        ;\n      }\n\n      for (o = a & (1 << -p) - 1, a >>= -p, p += n; p > 0; o = 256 * o + t[e + c], c += h, p -= 8) {\n        ;\n      }\n\n      if (0 === a) a = 1 - l;else {\n        if (a === u) return o ? NaN : 1 / 0 * (f ? -1 : 1);\n        o += Math.pow(2, n), a -= l;\n      }\n      return (f ? -1 : 1) * o * Math.pow(2, a - n);\n    },\n        Ys = function Ys(t, e, r, n, i, a) {\n      var o,\n          s,\n          u,\n          l = 8 * a - i - 1,\n          p = (1 << l) - 1,\n          c = p >> 1,\n          h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = n ? 0 : a - 1,\n          y = n ? 1 : -1,\n          d = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = p) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), (e += o + c >= 1 ? h / u : h * Math.pow(2, 1 - c)) * u >= 2 && (o++, u /= 2), o + c >= p ? (s = 0, o = p) : o + c >= 1 ? (s = (e * u - 1) * Math.pow(2, i), o += c) : (s = e * Math.pow(2, c - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + f] = 255 & s, f += y, s /= 256, i -= 8) {\n        ;\n      }\n\n      for (o = o << i | s, l += i; l > 0; t[r + f] = 255 & o, f += y, o /= 256, l -= 8) {\n        ;\n      }\n\n      t[r + f - y] |= 128 * d;\n    },\n        $s = Ws;\n\n    function Ws(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n\n    Ws.Varint = 0, Ws.Fixed64 = 1, Ws.Bytes = 2, Ws.Fixed32 = 5;\n    var Qs = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");\n\n    function tu(t) {\n      return t.type === Ws.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n\n    function eu(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n\n    function ru(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n\n      for (var i = r.pos - 1; i >= t; i--) {\n        r.buf[i + n] = r.buf[i];\n      }\n    }\n\n    function nu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeVarint(t[r]);\n      }\n    }\n\n    function iu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeSVarint(t[r]);\n      }\n    }\n\n    function au(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeFloat(t[r]);\n      }\n    }\n\n    function ou(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeDouble(t[r]);\n      }\n    }\n\n    function su(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeBoolean(t[r]);\n      }\n    }\n\n    function uu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeFixed32(t[r]);\n      }\n    }\n\n    function lu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeSFixed32(t[r]);\n      }\n    }\n\n    function pu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeFixed64(t[r]);\n      }\n    }\n\n    function cu(t, e) {\n      for (var r = 0; r < t.length; r++) {\n        e.writeSFixed64(t[r]);\n      }\n    }\n\n    function hu(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n\n    function fu(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n\n    function yu(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n\n    function du(t, e, r) {\n      1 === t && r.readMessage(mu, e);\n    }\n\n    function mu(t, e, r) {\n      if (3 === t) {\n        var n = r.readMessage(vu, {}),\n            i = n.width,\n            a = n.height,\n            o = n.left,\n            s = n.top,\n            u = n.advance;\n        e.push({\n          id: n.id,\n          bitmap: new xo({\n            width: i + 6,\n            height: a + 6\n          }, n.bitmap),\n          metrics: {\n            width: i,\n            height: a,\n            left: o,\n            top: s,\n            advance: u\n          }\n        });\n      }\n    }\n\n    function vu(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n\n    function gu(t) {\n      for (var e = 0, r = 0, n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n];\n        e += a.w * a.h, r = Math.max(r, a.w);\n      }\n\n      t.sort(function (t, e) {\n        return e.h - t.h;\n      });\n\n      for (var o = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }], s = 0, u = 0, l = 0, p = t; l < p.length; l += 1) {\n        for (var c = p[l], h = o.length - 1; h >= 0; h--) {\n          var f = o[h];\n\n          if (!(c.w > f.w || c.h > f.h)) {\n            if (c.x = f.x, c.y = f.y, u = Math.max(u, c.y + c.h), s = Math.max(s, c.x + c.w), c.w === f.w && c.h === f.h) {\n              var y = o.pop();\n              h < o.length && (o[h] = y);\n            } else c.h === f.h ? (f.x += c.w, f.w -= c.w) : c.w === f.w ? (f.y += c.h, f.h -= c.h) : (o.push({\n              x: f.x + c.w,\n              y: f.y,\n              w: f.w - c.w,\n              h: c.h\n            }), f.y += c.h, f.h -= c.h);\n\n            break;\n          }\n        }\n      }\n\n      return {\n        w: s,\n        h: u,\n        fill: e / (s * u) || 0\n      };\n    }\n\n    Ws.prototype = {\n      destroy: function destroy() {\n        this.buf = null;\n      },\n      readFields: function readFields(t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n              i = n >> 3,\n              a = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === a && this.skip(n);\n        }\n\n        return e;\n      },\n      readMessage: function readMessage(t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function readFixed32() {\n        var t = hu(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readSFixed32: function readSFixed32() {\n        var t = yu(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function readFixed64() {\n        var t = hu(this.buf, this.pos) + 4294967296 * hu(this.buf, this.pos + 4);\n        return this.pos += 8, t;\n      },\n      readSFixed64: function readSFixed64() {\n        var t = hu(this.buf, this.pos) + 4294967296 * yu(this.buf, this.pos + 4);\n        return this.pos += 8, t;\n      },\n      readFloat: function readFloat() {\n        var t = Hs(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function readDouble() {\n        var t = Hs(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function readVarint(t) {\n        var e,\n            r,\n            n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n              i,\n              a = r.buf;\n          if (n = (112 & (i = a[r.pos++])) >> 4, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 3, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 10, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 17, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 24, i < 128) return eu(t, n, e);\n          if (n |= (1 & (i = a[r.pos++])) << 31, i < 128) return eu(t, n, e);\n          throw new Error("Expected varint not more than 10 bytes");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function readVarint64() {\n        return this.readVarint(!0);\n      },\n      readSVarint: function readSVarint() {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function readBoolean() {\n        return Boolean(this.readVarint());\n      },\n      readString: function readString() {\n        var t = this.readVarint() + this.pos,\n            e = this.pos;\n        return this.pos = t, t - e >= 12 && Qs ? function (t, e, r) {\n          return Qs.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = "", i = e; i < r;) {\n            var a,\n                o,\n                s,\n                u = t[i],\n                l = null,\n                p = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;\n            if (i + p > r) break;\n            1 === p ? u < 128 && (l = u) : 2 === p ? 128 == (192 & (a = t[i + 1])) && (l = (31 & u) << 6 | 63 & a) <= 127 && (l = null) : 3 === p ? (o = t[i + 2], 128 == (192 & (a = t[i + 1])) && 128 == (192 & o) && ((l = (15 & u) << 12 | (63 & a) << 6 | 63 & o) <= 2047 || l >= 55296 && l <= 57343) && (l = null)) : 4 === p && (o = t[i + 2], s = t[i + 3], 128 == (192 & (a = t[i + 1])) && 128 == (192 & o) && 128 == (192 & s) && ((l = (15 & u) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) <= 65535 || l >= 1114112) && (l = null)), null === l ? (l = 65533, p = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += p;\n          }\n\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function readBytes() {\n        var t = this.readVarint() + this.pos,\n            e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function readPackedVarint(t, e) {\n        if (this.type !== Ws.Bytes) return t.push(this.readVarint(e));\n        var r = tu(this);\n\n        for (t = t || []; this.pos < r;) {\n          t.push(this.readVarint(e));\n        }\n\n        return t;\n      },\n      readPackedSVarint: function readPackedSVarint(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readSVarint());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readSVarint());\n        }\n\n        return t;\n      },\n      readPackedBoolean: function readPackedBoolean(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readBoolean());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readBoolean());\n        }\n\n        return t;\n      },\n      readPackedFloat: function readPackedFloat(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readFloat());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readFloat());\n        }\n\n        return t;\n      },\n      readPackedDouble: function readPackedDouble(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readDouble());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readDouble());\n        }\n\n        return t;\n      },\n      readPackedFixed32: function readPackedFixed32(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readFixed32());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readFixed32());\n        }\n\n        return t;\n      },\n      readPackedSFixed32: function readPackedSFixed32(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readSFixed32());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readSFixed32());\n        }\n\n        return t;\n      },\n      readPackedFixed64: function readPackedFixed64(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readFixed64());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readFixed64());\n        }\n\n        return t;\n      },\n      readPackedSFixed64: function readPackedSFixed64(t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readSFixed64());\n        var e = tu(this);\n\n        for (t = t || []; this.pos < e;) {\n          t.push(this.readSFixed64());\n        }\n\n        return t;\n      },\n      skip: function skip(t) {\n        var e = 7 & t;\n        if (e === Ws.Varint) for (; this.buf[this.pos++] > 127;) {\n          ;\n        } else if (e === Ws.Bytes) this.pos = this.readVarint() + this.pos;else if (e === Ws.Fixed32) this.pos += 4;else {\n          if (e !== Ws.Fixed64) throw new Error("Unimplemented type: " + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function writeTag(t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function realloc(t) {\n        for (var e = this.length || 16; e < this.pos + t;) {\n          e *= 2;\n        }\n\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function finish() {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function writeFixed32(t) {\n        this.realloc(4), fu(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function writeSFixed32(t) {\n        this.realloc(4), fu(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function writeFixed64(t) {\n        this.realloc(8), fu(this.buf, -1 & t, this.pos), fu(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function writeSFixed64(t) {\n        this.realloc(8), fu(this.buf, -1 & t, this.pos), fu(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function writeVarint(t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn\'t fit into 10 bytes");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function writeSVarint(t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function writeBoolean(t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function writeString(t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n\n        this.pos = function (t, e, r) {\n          for (var n, i, a = 0; a < e.length; a++) {\n            if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || a + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n\n          return r;\n        }(this.buf, t, this.pos);\n\n        var r = this.pos - e;\n        r >= 128 && ru(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function writeFloat(t) {\n        this.realloc(4), Ys(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function writeDouble(t) {\n        this.realloc(8), Ys(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function writeBytes(t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n\n        for (var r = 0; r < e; r++) {\n          this.buf[this.pos++] = t[r];\n        }\n      },\n      writeRawMessage: function writeRawMessage(t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && ru(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function writeMessage(t, e, r) {\n        this.writeTag(t, Ws.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function writePackedVarint(t, e) {\n        e.length && this.writeMessage(t, nu, e);\n      },\n      writePackedSVarint: function writePackedSVarint(t, e) {\n        e.length && this.writeMessage(t, iu, e);\n      },\n      writePackedBoolean: function writePackedBoolean(t, e) {\n        e.length && this.writeMessage(t, su, e);\n      },\n      writePackedFloat: function writePackedFloat(t, e) {\n        e.length && this.writeMessage(t, au, e);\n      },\n      writePackedDouble: function writePackedDouble(t, e) {\n        e.length && this.writeMessage(t, ou, e);\n      },\n      writePackedFixed32: function writePackedFixed32(t, e) {\n        e.length && this.writeMessage(t, uu, e);\n      },\n      writePackedSFixed32: function writePackedSFixed32(t, e) {\n        e.length && this.writeMessage(t, lu, e);\n      },\n      writePackedFixed64: function writePackedFixed64(t, e) {\n        e.length && this.writeMessage(t, pu, e);\n      },\n      writePackedSFixed64: function writePackedSFixed64(t, e) {\n        e.length && this.writeMessage(t, cu, e);\n      },\n      writeBytesField: function writeBytesField(t, e) {\n        this.writeTag(t, Ws.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function writeFixed32Field(t, e) {\n        this.writeTag(t, Ws.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function writeSFixed32Field(t, e) {\n        this.writeTag(t, Ws.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function writeFixed64Field(t, e) {\n        this.writeTag(t, Ws.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function writeSFixed64Field(t, e) {\n        this.writeTag(t, Ws.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function writeVarintField(t, e) {\n        this.writeTag(t, Ws.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function writeSVarintField(t, e) {\n        this.writeTag(t, Ws.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function writeStringField(t, e) {\n        this.writeTag(t, Ws.Bytes), this.writeString(e);\n      },\n      writeFloatField: function writeFloatField(t, e) {\n        this.writeTag(t, Ws.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function writeDoubleField(t, e) {\n        this.writeTag(t, Ws.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function writeBooleanField(t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n\n    var xu = function xu(t, e) {\n      var r = e.pixelRatio,\n          n = e.version,\n          i = e.stretchX,\n          a = e.stretchY,\n          o = e.content;\n      this.paddedRect = t, this.pixelRatio = r, this.stretchX = i, this.stretchY = a, this.content = o, this.version = n;\n    },\n        bu = {\n      tl: {\n        configurable: !0\n      },\n      br: {\n        configurable: !0\n      },\n      tlbr: {\n        configurable: !0\n      },\n      displaySize: {\n        configurable: !0\n      }\n    };\n\n    bu.tl.get = function () {\n      return [this.paddedRect.x + 1, this.paddedRect.y + 1];\n    }, bu.br.get = function () {\n      return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];\n    }, bu.tlbr.get = function () {\n      return this.tl.concat(this.br);\n    }, bu.displaySize.get = function () {\n      return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];\n    }, Object.defineProperties(xu.prototype, bu);\n\n    var wu = function wu(t, e) {\n      var r = {},\n          n = {};\n      this.haveRenderCallbacks = [];\n      var i = [];\n      this.addImages(t, r, i), this.addImages(e, n, i);\n      var a = gu(i),\n          o = new bo({\n        width: a.w || 1,\n        height: a.h || 1\n      });\n\n      for (var s in t) {\n        var u = t[s],\n            l = r[s].paddedRect;\n        bo.copy(u.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: l.x + 1,\n          y: l.y + 1\n        }, u.data);\n      }\n\n      for (var p in e) {\n        var c = e[p],\n            h = n[p].paddedRect,\n            f = h.x + 1,\n            y = h.y + 1,\n            d = c.data.width,\n            m = c.data.height;\n        bo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f,\n          y: y\n        }, c.data), bo.copy(c.data, o, {\n          x: 0,\n          y: m - 1\n        }, {\n          x: f,\n          y: y - 1\n        }, {\n          width: d,\n          height: 1\n        }), bo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f,\n          y: y + m\n        }, {\n          width: d,\n          height: 1\n        }), bo.copy(c.data, o, {\n          x: d - 1,\n          y: 0\n        }, {\n          x: f - 1,\n          y: y\n        }, {\n          width: 1,\n          height: m\n        }), bo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f + d,\n          y: y\n        }, {\n          width: 1,\n          height: m\n        });\n      }\n\n      this.image = o, this.iconPositions = r, this.patternPositions = n;\n    };\n\n    wu.prototype.addImages = function (t, e, r) {\n      for (var n in t) {\n        var i = t[n],\n            a = {\n          x: 0,\n          y: 0,\n          w: i.data.width + 2,\n          h: i.data.height + 2\n        };\n        r.push(a), e[n] = new xu(a, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n      }\n    }, wu.prototype.patchUpdatedImages = function (t, e) {\n      for (var r in t.dispatchRenderCallbacks(this.haveRenderCallbacks), t.updatedImages) {\n        this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n      }\n    }, wu.prototype.patchUpdatedImage = function (t, e, r) {\n      if (t && e && t.version !== e.version) {\n        t.version = e.version;\n        var n = t.tl;\n        r.update(e.data, void 0, {\n          x: n[0],\n          y: n[1]\n        });\n      }\n    }, On("ImagePosition", xu), On("ImageAtlas", wu);\n\n    var _u = {\n      horizontal: 1,\n      vertical: 2,\n      horizontalOnly: 3\n    },\n        Au = function Au() {\n      this.scale = 1, this.fontStack = "", this.imageName = null;\n    };\n\n    Au.forText = function (t, e) {\n      var r = new Au();\n      return r.scale = t || 1, r.fontStack = e, r;\n    }, Au.forImage = function (t) {\n      var e = new Au();\n      return e.imageName = t, e;\n    };\n\n    var Su = function Su() {\n      this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n    };\n\n    function ku(t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d) {\n      var m,\n          v = Su.fromFeature(t, i);\n      c === _u.vertical && v.verticalizePunctuation();\n      var g = si.processBidirectionalText,\n          x = si.processStyledBidirectionalText;\n\n      if (g && 1 === v.sections.length) {\n        m = [];\n\n        for (var b = 0, w = g(v.toString(), Bu(v, l, a, e, n, f, y)); b < w.length; b += 1) {\n          var _ = w[b],\n              A = new Su();\n          A.text = _, A.sections = v.sections;\n\n          for (var S = 0; S < _.length; S++) {\n            A.sectionIndex.push(0);\n          }\n\n          m.push(A);\n        }\n      } else if (x) {\n        m = [];\n\n        for (var k = 0, I = x(v.text, v.sectionIndex, Bu(v, l, a, e, n, f, y)); k < I.length; k += 1) {\n          var z = I[k],\n              C = new Su();\n          C.text = z[0], C.sectionIndex = z[1], C.sections = v.sections, m.push(C);\n        }\n      } else m = function (t, e) {\n        for (var r = [], n = t.text, i = 0, a = 0, o = e; a < o.length; a += 1) {\n          var s = o[a];\n          r.push(t.substring(i, s)), i = s;\n        }\n\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(v, Bu(v, l, a, e, n, f, y));\n\n      var E = [],\n          P = {\n        positionedLines: E,\n        text: v.toString(),\n        top: p[1],\n        bottom: p[1],\n        left: p[0],\n        right: p[0],\n        writingMode: c,\n        iconsInText: !1,\n        verticalizable: !1\n      };\n      return function (t, e, r, n, i, a, o, s, u, l, p, c) {\n        for (var h = 0, f = -17, y = 0, d = 0, m = "right" === s ? 1 : "left" === s ? 0 : .5, v = 0, g = 0, x = i; g < x.length; g += 1) {\n          var b = x[g];\n          b.trim();\n\n          var w = b.getMaxScale(),\n              _ = 24 * (w - 1),\n              A = {\n            positionedGlyphs: [],\n            lineOffset: 0\n          };\n\n          t.positionedLines[v] = A;\n          var S = A.positionedGlyphs,\n              k = 0;\n\n          if (b.length()) {\n            for (var I = 0; I < b.length(); I++) {\n              var z = b.getSection(I),\n                  C = b.getSectionIndex(I),\n                  E = b.getCharCode(I),\n                  P = 0,\n                  M = null,\n                  B = null,\n                  T = null,\n                  V = 24,\n                  F = !(u === _u.horizontal || !p && !Jn(E) || p && (Iu[E] || (K = E, Zn.Arabic(K) || Zn["Arabic Supplement"](K) || Zn["Arabic Extended-A"](K) || Zn["Arabic Presentation Forms-A"](K) || Zn["Arabic Presentation Forms-B"](K))));\n\n              if (z.imageName) {\n                var D = n[z.imageName];\n                if (!D) continue;\n                T = z.imageName, t.iconsInText = t.iconsInText || !0, B = D.paddedRect;\n                var L = D.displaySize;\n                z.scale = 24 * z.scale / c, P = _ + (24 - L[1] * z.scale), V = (M = {\n                  width: L[0],\n                  height: L[1],\n                  left: 1,\n                  top: -3,\n                  advance: F ? L[1] : L[0]\n                }).advance;\n                var R = F ? L[0] * z.scale - 24 * w : L[1] * z.scale - 24 * w;\n                R > 0 && R > k && (k = R);\n              } else {\n                var O = r[z.fontStack],\n                    U = O && O[E];\n                if (U && U.rect) B = U.rect, M = U.metrics;else {\n                  var j = e[z.fontStack],\n                      q = j && j[E];\n                  if (!q) continue;\n                  M = q.metrics;\n                }\n                P = 24 * (w - z.scale);\n              }\n\n              F ? (t.verticalizable = !0, S.push({\n                glyph: E,\n                imageName: T,\n                x: h,\n                y: f + P,\n                vertical: F,\n                scale: z.scale,\n                fontStack: z.fontStack,\n                sectionIndex: C,\n                metrics: M,\n                rect: B\n              }), h += V * z.scale + l) : (S.push({\n                glyph: E,\n                imageName: T,\n                x: h,\n                y: f + P,\n                vertical: F,\n                scale: z.scale,\n                fontStack: z.fontStack,\n                sectionIndex: C,\n                metrics: M,\n                rect: B\n              }), h += M.advance * z.scale + l);\n            }\n\n            0 !== S.length && (y = Math.max(h - l, y), Vu(S, 0, S.length - 1, m, k)), h = 0;\n            var N = a * w + k;\n            A.lineOffset = Math.max(k, _), f += N, d = Math.max(N, d), ++v;\n          } else f += a, ++v;\n        }\n\n        var K,\n            G = f - -17,\n            Z = Tu(o),\n            X = Z.horizontalAlign,\n            J = Z.verticalAlign;\n        (function (t, e, r, n, i, a, o, s, u) {\n          var l,\n              p = (e - r) * i;\n          l = a !== o ? -s * n - -17 : (-n * u + .5) * o;\n\n          for (var c = 0, h = t; c < h.length; c += 1) {\n            for (var f = 0, y = h[c].positionedGlyphs; f < y.length; f += 1) {\n              var d = y[f];\n              d.x += p, d.y += l;\n            }\n          }\n        })(t.positionedLines, m, X, J, y, d, a, G, i.length), t.top += -J * G, t.bottom = t.top + G, t.left += -X * y, t.right = t.left + y;\n      }(P, e, r, n, m, o, s, u, c, l, h, d), !function (t) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          if (0 !== r[e].positionedGlyphs.length) return !1;\n        }\n\n        return !0;\n      }(E) && P;\n    }\n\n    Su.fromFeature = function (t, e) {\n      for (var r = new Su(), n = 0; n < t.sections.length; n++) {\n        var i = t.sections[n];\n        i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n      }\n\n      return r;\n    }, Su.prototype.length = function () {\n      return this.text.length;\n    }, Su.prototype.getSection = function (t) {\n      return this.sections[this.sectionIndex[t]];\n    }, Su.prototype.getSectionIndex = function (t) {\n      return this.sectionIndex[t];\n    }, Su.prototype.getCharCode = function (t) {\n      return this.text.charCodeAt(t);\n    }, Su.prototype.verticalizePunctuation = function () {\n      this.text = function (t) {\n        for (var e = "", r = 0; r < t.length; r++) {\n          var n = t.charCodeAt(r + 1) || null,\n              i = t.charCodeAt(r - 1) || null;\n          e += n && Hn(n) && !Js[t[r + 1]] || i && Hn(i) && !Js[t[r - 1]] || !Js[t[r]] ? t[r] : Js[t[r]];\n        }\n\n        return e;\n      }(this.text);\n    }, Su.prototype.trim = function () {\n      for (var t = 0, e = 0; e < this.text.length && Iu[this.text.charCodeAt(e)]; e++) {\n        t++;\n      }\n\n      for (var r = this.text.length, n = this.text.length - 1; n >= 0 && n >= t && Iu[this.text.charCodeAt(n)]; n--) {\n        r--;\n      }\n\n      this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r);\n    }, Su.prototype.substring = function (t, e) {\n      var r = new Su();\n      return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n    }, Su.prototype.toString = function () {\n      return this.text;\n    }, Su.prototype.getMaxScale = function () {\n      var t = this;\n      return this.sectionIndex.reduce(function (e, r) {\n        return Math.max(e, t.sections[r].scale);\n      }, 0);\n    }, Su.prototype.addTextSection = function (t, e) {\n      this.text += t.text, this.sections.push(Au.forText(t.scale, t.fontStack || e));\n\n      for (var r = this.sections.length - 1, n = 0; n < t.text.length; ++n) {\n        this.sectionIndex.push(r);\n      }\n    }, Su.prototype.addImageSection = function (t) {\n      var e = t.image ? t.image.name : "";\n\n      if (0 !== e.length) {\n        var r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCharCode(r), this.sections.push(Au.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");\n      } else A("Can\'t add FormattedSection with an empty image.");\n    }, Su.prototype.getNextImageSectionCharCode = function () {\n      return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n    };\n    var Iu = {\n      9: !0,\n      10: !0,\n      11: !0,\n      12: !0,\n      13: !0,\n      32: !0\n    },\n        zu = {};\n\n    function Cu(t, e, r, n, i, a) {\n      if (e.imageName) {\n        var o = n[e.imageName];\n        return o ? o.displaySize[0] * e.scale * 24 / a + i : 0;\n      }\n\n      var s = r[e.fontStack],\n          u = s && s[t];\n      return u ? u.metrics.advance * e.scale + i : 0;\n    }\n\n    function Eu(t, e, r, n) {\n      var i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n\n    function Pu(t, e, r) {\n      var n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n\n    function Mu(t, e, r, n, i, a) {\n      for (var o = null, s = Eu(e, r, i, a), u = 0, l = n; u < l.length; u += 1) {\n        var p = l[u],\n            c = Eu(e - p.x, r, i, a) + p.badness;\n        c <= s && (o = p, s = c);\n      }\n\n      return {\n        index: t,\n        x: e,\n        priorBreak: o,\n        badness: s\n      };\n    }\n\n    function Bu(t, e, r, n, i, a, o) {\n      if ("point" !== a) return [];\n      if (!t) return [];\n\n      for (var s, u = [], l = function (t, e, r, n, i, a) {\n        for (var o = 0, s = 0; s < t.length(); s++) {\n          var u = t.getSection(s);\n          o += Cu(t.getCharCode(s), u, n, i, e, a);\n        }\n\n        return o / Math.max(1, Math.ceil(o / r));\n      }(t, e, r, n, i, o), p = t.text.indexOf("​") >= 0, c = 0, h = 0; h < t.length(); h++) {\n        var f = t.getSection(h),\n            y = t.getCharCode(h);\n\n        if (Iu[y] || (c += Cu(y, f, n, i, e, o)), h < t.length() - 1) {\n          var d = !((s = y) < 11904 || !(Zn["Bopomofo Extended"](s) || Zn.Bopomofo(s) || Zn["CJK Compatibility Forms"](s) || Zn["CJK Compatibility Ideographs"](s) || Zn["CJK Compatibility"](s) || Zn["CJK Radicals Supplement"](s) || Zn["CJK Strokes"](s) || Zn["CJK Symbols and Punctuation"](s) || Zn["CJK Unified Ideographs Extension A"](s) || Zn["CJK Unified Ideographs"](s) || Zn["Enclosed CJK Letters and Months"](s) || Zn["Halfwidth and Fullwidth Forms"](s) || Zn.Hiragana(s) || Zn["Ideographic Description Characters"](s) || Zn["Kangxi Radicals"](s) || Zn["Katakana Phonetic Extensions"](s) || Zn.Katakana(s) || Zn["Vertical Forms"](s) || Zn["Yi Radicals"](s) || Zn["Yi Syllables"](s)));\n          (zu[y] || d || f.imageName) && u.push(Mu(h + 1, c, l, u, Pu(y, t.getCharCode(h + 1), d && p), !1));\n        }\n      }\n\n      return function t(e) {\n        return e ? t(e.priorBreak).concat(e.index) : [];\n      }(Mu(t.length(), c, l, u, 0, !0));\n    }\n\n    function Tu(t) {\n      var e = .5,\n          r = .5;\n\n      switch (t) {\n        case "right":\n        case "top-right":\n        case "bottom-right":\n          e = 1;\n          break;\n\n        case "left":\n        case "top-left":\n        case "bottom-left":\n          e = 0;\n      }\n\n      switch (t) {\n        case "bottom":\n        case "bottom-right":\n        case "bottom-left":\n          r = 1;\n          break;\n\n        case "top":\n        case "top-right":\n        case "top-left":\n          r = 0;\n      }\n\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n\n    function Vu(t, e, r, n, i) {\n      if (n || i) for (var a = t[r], o = (t[r].x + a.metrics.advance * a.scale) * n, s = e; s <= r; s++) {\n        t[s].x -= o, t[s].y += i;\n      }\n    }\n\n    function Fu(t, e, r, n, i, a) {\n      var o,\n          s = t.image;\n\n      if (s.content) {\n        var u = s.content,\n            l = s.pixelRatio || 1;\n        o = [u[0] / l, u[1] / l, s.displaySize[0] - u[2] / l, s.displaySize[1] - u[3] / l];\n      }\n\n      var p,\n          c,\n          h,\n          f,\n          y = e.left * a,\n          d = e.right * a;\n      "width" === r || "both" === r ? (f = i[0] + y - n[3], c = i[0] + d + n[1]) : c = (f = i[0] + (y + d - s.displaySize[0]) / 2) + s.displaySize[0];\n      var m = e.top * a,\n          v = e.bottom * a;\n      return "height" === r || "both" === r ? (p = i[1] + m - n[0], h = i[1] + v + n[2]) : h = (p = i[1] + (m + v - s.displaySize[1]) / 2) + s.displaySize[1], {\n        image: s,\n        top: p,\n        right: c,\n        bottom: h,\n        left: f,\n        collisionPadding: o\n      };\n    }\n\n    zu[10] = !0, zu[32] = !0, zu[38] = !0, zu[40] = !0, zu[41] = !0, zu[43] = !0, zu[45] = !0, zu[47] = !0, zu[173] = !0, zu[183] = !0, zu[8203] = !0, zu[8208] = !0, zu[8211] = !0, zu[8231] = !0;\n\n    var Du = function (t) {\n      function e(e, r, n, i) {\n        t.call(this, e, r), this.angle = n, void 0 !== i && (this.segment = i);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.clone = function () {\n        return new e(this.x, this.y, this.angle, this.segment);\n      }, e;\n    }(i);\n\n    function Lu(t, e) {\n      var r = e.expression;\n      if ("constant" === r.kind) return {\n        kind: "constant",\n        layoutSize: r.evaluate(new ui(t + 1))\n      };\n      if ("source" === r.kind) return {\n        kind: "source"\n      };\n\n      for (var n = r.zoomStops, i = r.interpolationType, a = 0; a < n.length && n[a] <= t;) {\n        a++;\n      }\n\n      for (var o = a = Math.max(0, a - 1); o < n.length && n[o] < t + 1;) {\n        o++;\n      }\n\n      o = Math.min(n.length - 1, o);\n      var s = n[a],\n          u = n[o];\n      return "composite" === r.kind ? {\n        kind: "composite",\n        minZoom: s,\n        maxZoom: u,\n        interpolationType: i\n      } : {\n        kind: "camera",\n        minZoom: s,\n        maxZoom: u,\n        minSize: r.evaluate(new ui(s)),\n        maxSize: r.evaluate(new ui(u)),\n        interpolationType: i\n      };\n    }\n\n    function Ru(t, e, r) {\n      var n = e.uSize,\n          i = r.lowerSize;\n      return "source" === t.kind ? i / 128 : "composite" === t.kind ? Ge(i / 128, r.upperSize / 128, e.uSizeT) : n;\n    }\n\n    function Ou(t, e) {\n      var r = 0,\n          n = 0;\n      if ("constant" === t.kind) n = t.layoutSize;else if ("source" !== t.kind) {\n        var i = t.interpolationType,\n            a = i ? p(or.interpolationFactor(i, e, t.minZoom, t.maxZoom), 0, 1) : 0;\n        "camera" === t.kind ? n = Ge(t.minSize, t.maxSize, a) : r = a;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n\n    On("Anchor", Du);\n    var Uu = Object.freeze({\n      __proto__: null,\n      getSizeData: Lu,\n      evaluateSizeForFeature: Ru,\n      evaluateSizeForZoom: Ou,\n      SIZE_PACK_FACTOR: 128\n    });\n\n    function ju(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n\n      for (var a = e, o = e.segment + 1, s = 0; s > -r / 2;) {\n        if (--o < 0) return !1;\n        s -= t[o].dist(a), a = t[o];\n      }\n\n      s += t[o].dist(t[o + 1]), o++;\n\n      for (var u = [], l = 0; s < r / 2;) {\n        var p = t[o],\n            c = t[o + 1];\n        if (!c) return !1;\n        var h = t[o - 1].angleTo(p) - p.angleTo(c);\n\n        for (h = Math.abs((h + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u.push({\n          distance: s,\n          angleDelta: h\n        }), l += h; s - u[0].distance > n;) {\n          l -= u.shift().angleDelta;\n        }\n\n        if (l > i) return !1;\n        o++, s += p.dist(c);\n      }\n\n      return !0;\n    }\n\n    function qu(t) {\n      for (var e = 0, r = 0; r < t.length - 1; r++) {\n        e += t[r].dist(t[r + 1]);\n      }\n\n      return e;\n    }\n\n    function Nu(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n\n    function Ku(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n\n    function Gu(t, e, r, n, i, a) {\n      for (var o = Nu(r, i, a), s = Ku(r, n) * a, u = 0, l = qu(t) / 2, p = 0; p < t.length - 1; p++) {\n        var c = t[p],\n            h = t[p + 1],\n            f = c.dist(h);\n\n        if (u + f > l) {\n          var y = (l - u) / f,\n              d = Ge(c.x, h.x, y),\n              m = Ge(c.y, h.y, y),\n              v = new Du(d, m, h.angleTo(c), p);\n          return v._round(), !o || ju(t, v, s, o, e) ? v : void 0;\n        }\n\n        u += f;\n      }\n    }\n\n    function Zu(t, e, r, n, i, a, o, s, u) {\n      var l = Nu(n, a, o),\n          p = Ku(n, i),\n          c = p * o,\n          h = 0 === t[0].x || t[0].x === u || 0 === t[0].y || t[0].y === u;\n      return e - c < e / 4 && (e = c + e / 4), function t(e, r, n, i, a, o, s, u, l) {\n        for (var p = o / 2, c = qu(e), h = 0, f = r - n, y = [], d = 0; d < e.length - 1; d++) {\n          for (var m = e[d], v = e[d + 1], g = m.dist(v), x = v.angleTo(m); f + n < h + g;) {\n            var b = ((f += n) - h) / g,\n                w = Ge(m.x, v.x, b),\n                _ = Ge(m.y, v.y, b);\n\n            if (w >= 0 && w < l && _ >= 0 && _ < l && f - p >= 0 && f + p <= c) {\n              var A = new Du(w, _, x, d);\n              A._round(), i && !ju(e, A, o, i, a) || y.push(A);\n            }\n          }\n\n          h += g;\n        }\n\n        return u || y.length || s || (y = t(e, h / 2, n, i, a, o, s, !0, l)), y;\n      }(t, h ? e / 2 * s % e : (p / 2 + 2 * a) * o * s % e, e, l, r, c, h, !1, u);\n    }\n\n    function Xu(t, e, r, n, a) {\n      for (var o = [], s = 0; s < t.length; s++) {\n        for (var u = t[s], l = void 0, p = 0; p < u.length - 1; p++) {\n          var c = u[p],\n              h = u[p + 1];\n          c.x < e && h.x < e || (c.x < e ? c = new i(e, c.y + (e - c.x) / (h.x - c.x) * (h.y - c.y))._round() : h.x < e && (h = new i(e, c.y + (e - c.x) / (h.x - c.x) * (h.y - c.y))._round()), c.y < r && h.y < r || (c.y < r ? c = new i(c.x + (r - c.y) / (h.y - c.y) * (h.x - c.x), r)._round() : h.y < r && (h = new i(c.x + (r - c.y) / (h.y - c.y) * (h.x - c.x), r)._round()), c.x >= n && h.x >= n || (c.x >= n ? c = new i(n, c.y + (n - c.x) / (h.x - c.x) * (h.y - c.y))._round() : h.x >= n && (h = new i(n, c.y + (n - c.x) / (h.x - c.x) * (h.y - c.y))._round()), c.y >= a && h.y >= a || (c.y >= a ? c = new i(c.x + (a - c.y) / (h.y - c.y) * (h.x - c.x), a)._round() : h.y >= a && (h = new i(c.x + (a - c.y) / (h.y - c.y) * (h.x - c.x), a)._round()), l && c.equals(l[l.length - 1]) || o.push(l = [c]), l.push(h)))));\n        }\n      }\n\n      return o;\n    }\n\n    function Ju(t, e, r, n) {\n      var a = [],\n          o = t.image,\n          s = o.pixelRatio,\n          u = o.paddedRect.w - 2,\n          l = o.paddedRect.h - 2,\n          p = t.right - t.left,\n          c = t.bottom - t.top,\n          h = o.stretchX || [[0, u]],\n          f = o.stretchY || [[0, l]],\n          y = function y(t, e) {\n        return t + e[1] - e[0];\n      },\n          d = h.reduce(y, 0),\n          m = f.reduce(y, 0),\n          v = u - d,\n          g = l - m,\n          x = 0,\n          b = d,\n          w = 0,\n          _ = m,\n          A = 0,\n          S = v,\n          k = 0,\n          I = g;\n\n      if (o.content && n) {\n        var z = o.content;\n        x = Hu(h, 0, z[0]), w = Hu(f, 0, z[1]), b = Hu(h, z[0], z[2]), _ = Hu(f, z[1], z[3]), A = z[0] - x, k = z[1] - w, S = z[2] - z[0] - b, I = z[3] - z[1] - _;\n      }\n\n      var C = function C(n, a, u, l) {\n        var h = $u(n.stretch - x, b, p, t.left),\n            f = Wu(n.fixed - A, S, n.stretch, d),\n            y = $u(a.stretch - w, _, c, t.top),\n            v = Wu(a.fixed - k, I, a.stretch, m),\n            g = $u(u.stretch - x, b, p, t.left),\n            z = Wu(u.fixed - A, S, u.stretch, d),\n            C = $u(l.stretch - w, _, c, t.top),\n            E = Wu(l.fixed - k, I, l.stretch, m),\n            P = new i(h, y),\n            M = new i(g, y),\n            B = new i(g, C),\n            T = new i(h, C),\n            V = new i(f / s, v / s),\n            F = new i(z / s, E / s),\n            D = e * Math.PI / 180;\n\n        if (D) {\n          var L = Math.sin(D),\n              R = Math.cos(D),\n              O = [R, -L, L, R];\n          P._matMult(O), M._matMult(O), T._matMult(O), B._matMult(O);\n        }\n\n        var U = n.stretch + n.fixed,\n            j = a.stretch + a.fixed;\n        return {\n          tl: P,\n          tr: M,\n          bl: T,\n          br: B,\n          tex: {\n            x: o.paddedRect.x + 1 + U,\n            y: o.paddedRect.y + 1 + j,\n            w: u.stretch + u.fixed - U,\n            h: l.stretch + l.fixed - j\n          },\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: V,\n          pixelOffsetBR: F,\n          minFontScaleX: S / s / p,\n          minFontScaleY: I / s / c,\n          isSDF: r\n        };\n      };\n\n      if (n && (o.stretchX || o.stretchY)) for (var E = Yu(h, v, d), P = Yu(f, g, m), M = 0; M < E.length - 1; M++) {\n        for (var B = E[M], T = E[M + 1], V = 0; V < P.length - 1; V++) {\n          a.push(C(B, P[V], T, P[V + 1]));\n        }\n      } else a.push(C({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: u + 1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }));\n      return a;\n    }\n\n    function Hu(t, e, r) {\n      for (var n = 0, i = 0, a = t; i < a.length; i += 1) {\n        var o = a[i];\n        n += Math.max(e, Math.min(r, o[1])) - Math.max(e, Math.min(r, o[0]));\n      }\n\n      return n;\n    }\n\n    function Yu(t, e, r) {\n      for (var n = [{\n        fixed: -1,\n        stretch: 0\n      }], i = 0, a = t; i < a.length; i += 1) {\n        var o = a[i],\n            s = o[0],\n            u = o[1],\n            l = n[n.length - 1];\n        n.push({\n          fixed: s - l.stretch,\n          stretch: l.stretch\n        }), n.push({\n          fixed: s - l.stretch,\n          stretch: l.stretch + (u - s)\n        });\n      }\n\n      return n.push({\n        fixed: e + 1,\n        stretch: r\n      }), n;\n    }\n\n    function $u(t, e, r, n) {\n      return t / e * r + n;\n    }\n\n    function Wu(t, e, r, n) {\n      return t - e * r / n;\n    }\n\n    var Qu = function Qu(t, e, r, n, a, o, s, u, l, p) {\n      if (this.boxStartIndex = t.length, l) {\n        var c = o.top,\n            h = o.bottom,\n            f = o.collisionPadding;\n        f && (c -= f[1], h += f[3]);\n        var y = h - c;\n        y > 0 && (y = Math.max(10, y), this.circleDiameter = y);\n      } else {\n        var d = o.top * s - u,\n            m = o.bottom * s + u,\n            v = o.left * s - u,\n            g = o.right * s + u,\n            x = o.collisionPadding;\n\n        if (x && (v -= x[0] * s, d -= x[1] * s, g += x[2] * s, m += x[3] * s), p) {\n          var b = new i(v, d),\n              w = new i(g, d),\n              _ = new i(v, m),\n              A = new i(g, m),\n              S = p * Math.PI / 180;\n\n          b._rotate(S), w._rotate(S), _._rotate(S), A._rotate(S), v = Math.min(b.x, w.x, _.x, A.x), g = Math.max(b.x, w.x, _.x, A.x), d = Math.min(b.y, w.y, _.y, A.y), m = Math.max(b.y, w.y, _.y, A.y);\n        }\n\n        t.emplaceBack(e.x, e.y, v, d, g, m, r, n, a);\n      }\n\n      this.boxEndIndex = t.length;\n    },\n        tl = function tl(t, e) {\n      if (void 0 === t && (t = []), void 0 === e && (e = el), this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (var r = (this.length >> 1) - 1; r >= 0; r--) {\n        this._down(r);\n      }\n    };\n\n    function el(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function rl(t, e, r) {\n      void 0 === e && (e = 1), void 0 === r && (r = !1);\n\n      for (var n = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, u = t[0], l = 0; l < u.length; l++) {\n        var p = u[l];\n        (!l || p.x < n) && (n = p.x), (!l || p.y < a) && (a = p.y), (!l || p.x > o) && (o = p.x), (!l || p.y > s) && (s = p.y);\n      }\n\n      var c = Math.min(o - n, s - a),\n          h = c / 2,\n          f = new tl([], nl);\n      if (0 === c) return new i(n, a);\n\n      for (var y = n; y < o; y += c) {\n        for (var d = a; d < s; d += c) {\n          f.push(new il(y + h, d + h, h, t));\n        }\n      }\n\n      for (var m = function (t) {\n        for (var e = 0, r = 0, n = 0, i = t[0], a = 0, o = i.length, s = o - 1; a < o; s = a++) {\n          var u = i[a],\n              l = i[s],\n              p = u.x * l.y - l.x * u.y;\n          r += (u.x + l.x) * p, n += (u.y + l.y) * p, e += 3 * p;\n        }\n\n        return new il(r / e, n / e, 0, t);\n      }(t), v = f.length; f.length;) {\n        var g = f.pop();\n        (g.d > m.d || !m.d) && (m = g, r && console.log("found best %d after %d probes", Math.round(1e4 * g.d) / 1e4, v)), g.max - m.d <= e || (f.push(new il(g.p.x - (h = g.h / 2), g.p.y - h, h, t)), f.push(new il(g.p.x + h, g.p.y - h, h, t)), f.push(new il(g.p.x - h, g.p.y + h, h, t)), f.push(new il(g.p.x + h, g.p.y + h, h, t)), v += 4);\n      }\n\n      return r && (console.log("num probes: " + v), console.log("best distance: " + m.d)), m.p;\n    }\n\n    function nl(t, e) {\n      return e.max - t.max;\n    }\n\n    function il(t, e, r, n) {\n      this.p = new i(t, e), this.h = r, this.d = function (t, e) {\n        for (var r = !1, n = 1 / 0, i = 0; i < e.length; i++) {\n          for (var a = e[i], o = 0, s = a.length, u = s - 1; o < s; u = o++) {\n            var l = a[o],\n                p = a[u];\n            l.y > t.y != p.y > t.y && t.x < (p.x - l.x) * (t.y - l.y) / (p.y - l.y) + l.x && (r = !r), n = Math.min(n, $a(t, l, p));\n          }\n        }\n\n        return (r ? 1 : -1) * Math.sqrt(n);\n      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n    }\n\n    tl.prototype.push = function (t) {\n      this.data.push(t), this.length++, this._up(this.length - 1);\n    }, tl.prototype.pop = function () {\n      if (0 !== this.length) {\n        var t = this.data[0],\n            e = this.data.pop();\n        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n    }, tl.prototype.peek = function () {\n      return this.data[0];\n    }, tl.prototype._up = function (t) {\n      for (var e = this.data, r = this.compare, n = e[t]; t > 0;) {\n        var i = t - 1 >> 1,\n            a = e[i];\n        if (r(n, a) >= 0) break;\n        e[t] = a, t = i;\n      }\n\n      e[t] = n;\n    }, tl.prototype._down = function (t) {\n      for (var e = this.data, r = this.compare, n = this.length >> 1, i = e[t]; t < n;) {\n        var a = 1 + (t << 1),\n            o = e[a],\n            s = a + 1;\n        if (s < this.length && r(e[s], o) < 0 && (a = s, o = e[s]), r(o, i) >= 0) break;\n        e[t] = o, t = a;\n      }\n\n      e[t] = i;\n    };\n    var al = Number.POSITIVE_INFINITY;\n\n    function ol(t, e) {\n      return e[1] !== al ? function (t, e, r) {\n        var n = 0,\n            i = 0;\n\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case "top-right":\n          case "top-left":\n          case "top":\n            i = r - 7;\n            break;\n\n          case "bottom-right":\n          case "bottom-left":\n          case "bottom":\n            i = 7 - r;\n        }\n\n        switch (t) {\n          case "top-right":\n          case "bottom-right":\n          case "right":\n            n = -e;\n            break;\n\n          case "top-left":\n          case "bottom-left":\n          case "left":\n            n = e;\n        }\n\n        return [n, i];\n      }(t, e[0], e[1]) : function (t, e) {\n        var r = 0,\n            n = 0;\n        e < 0 && (e = 0);\n        var i = e / Math.sqrt(2);\n\n        switch (t) {\n          case "top-right":\n          case "top-left":\n            n = i - 7;\n            break;\n\n          case "bottom-right":\n          case "bottom-left":\n            n = 7 - i;\n            break;\n\n          case "bottom":\n            n = 7 - e;\n            break;\n\n          case "top":\n            n = e - 7;\n        }\n\n        switch (t) {\n          case "top-right":\n          case "bottom-right":\n            r = -i;\n            break;\n\n          case "top-left":\n          case "bottom-left":\n            r = i;\n            break;\n\n          case "left":\n            r = e;\n            break;\n\n          case "right":\n            r = -e;\n        }\n\n        return [r, n];\n      }(t, e[0]);\n    }\n\n    function sl(t) {\n      switch (t) {\n        case "right":\n        case "top-right":\n        case "bottom-right":\n          return "right";\n\n        case "left":\n        case "top-left":\n        case "bottom-left":\n          return "left";\n      }\n\n      return "center";\n    }\n\n    function ul(t, e, r, n, a, o, s, u, l, p, c, h, f, y, d) {\n      var m = function (t, e, r, n, a, o, s, u) {\n        for (var l = n.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180, p = [], c = 0, h = e.positionedLines; c < h.length; c += 1) {\n          for (var f = h[c], y = 0, d = f.positionedGlyphs; y < d.length; y += 1) {\n            var m = d[y];\n\n            if (m.rect) {\n              var v = m.rect || {},\n                  g = 4,\n                  x = !0,\n                  b = 1,\n                  w = 0,\n                  _ = (a || u) && m.vertical,\n                  A = m.metrics.advance * m.scale / 2;\n\n              if (u && e.verticalizable && (w = f.lineOffset / 2 - (m.imageName ? -(24 - m.metrics.width * m.scale) / 2 : 24 * (m.scale - 1))), m.imageName) {\n                var S = s[m.imageName];\n                x = S.sdf, g = 1 / (b = S.pixelRatio);\n              }\n\n              var k = a ? [m.x + A, m.y] : [0, 0],\n                  I = a ? [0, 0] : [m.x + A + r[0], m.y + r[1] - w],\n                  z = [0, 0];\n              _ && (z = I, I = [0, 0]);\n              var C = (m.metrics.left - g) * m.scale - A + I[0],\n                  E = (-m.metrics.top - g) * m.scale + I[1],\n                  P = C + v.w * m.scale / b,\n                  M = E + v.h * m.scale / b,\n                  B = new i(C, E),\n                  T = new i(P, E),\n                  V = new i(C, M),\n                  F = new i(P, M);\n\n              if (_) {\n                var D = new i(-A, A - -17),\n                    L = -Math.PI / 2,\n                    R = 12 - A,\n                    O = new i(22 - R, -(m.imageName ? R : 0)),\n                    U = new (Function.prototype.bind.apply(i, [null].concat(z)))();\n                B._rotateAround(L, D)._add(O)._add(U), T._rotateAround(L, D)._add(O)._add(U), V._rotateAround(L, D)._add(O)._add(U), F._rotateAround(L, D)._add(O)._add(U);\n              }\n\n              if (l) {\n                var j = Math.sin(l),\n                    q = Math.cos(l),\n                    N = [q, -j, j, q];\n                B._matMult(N), T._matMult(N), V._matMult(N), F._matMult(N);\n              }\n\n              var K = new i(0, 0),\n                  G = new i(0, 0);\n              p.push({\n                tl: B,\n                tr: T,\n                bl: V,\n                br: F,\n                tex: v,\n                writingMode: e.writingMode,\n                glyphOffset: k,\n                sectionIndex: m.sectionIndex,\n                isSDF: x,\n                pixelOffsetTL: K,\n                pixelOffsetBR: G,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n        }\n\n        return p;\n      }(0, r, u, a, o, s, n, t.allowVerticalPlacement),\n          v = t.textSizeData,\n          g = null;\n\n      "source" === v.kind ? (g = [128 * a.layout.get("text-size").evaluate(s, {})])[0] > 32640 && A(t.layerIds[0] + \': Value for "text-size" is >= 255. Reduce your "text-size".\') : "composite" === v.kind && ((g = [128 * y.compositeTextSizes[0].evaluate(s, {}, d), 128 * y.compositeTextSizes[1].evaluate(s, {}, d)])[0] > 32640 || g[1] > 32640) && A(t.layerIds[0] + \': Value for "text-size" is >= 255. Reduce your "text-size".\'), t.addSymbols(t.text, m, g, u, o, s, p, e, l.lineStartIndex, l.lineLength, f, d);\n\n      for (var x = 0, b = c; x < b.length; x += 1) {\n        h[b[x]] = t.text.placedSymbolArray.length - 1;\n      }\n\n      return 4 * m.length;\n    }\n\n    function ll(t) {\n      for (var e in t) {\n        return t[e];\n      }\n\n      return null;\n    }\n\n    function pl(t, e, r, n) {\n      var i = t.compareText;\n\n      if (e in i) {\n        for (var a = i[e], o = a.length - 1; o >= 0; o--) {\n          if (n.dist(a[o]) < r) return !0;\n        }\n      } else i[e] = [];\n\n      return i[e].push(n), !1;\n    }\n\n    var cl = ws.VectorTileFeature.types,\n        hl = [{\n      name: "a_fade_opacity",\n      components: 1,\n      type: "Uint8",\n      offset: 0\n    }];\n\n    function fl(t, e, r, n, i, a, o, s, u, l, p, c, h) {\n      var f = s ? Math.min(32640, Math.round(s[0])) : 0,\n          y = s ? Math.min(32640, Math.round(s[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), a, o, (f << 1) + (u ? 1 : 0), y, 16 * l, 16 * p, 256 * c, 256 * h);\n    }\n\n    function yl(t, e, r) {\n      t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);\n    }\n\n    function dl(t) {\n      for (var e = 0, r = t.sections; e < r.length; e += 1) {\n        if (Wn(r[e].text)) return !0;\n      }\n\n      return !1;\n    }\n\n    var ml = function ml(t) {\n      this.layoutVertexArray = new Fi(), this.indexArray = new qi(), this.programConfigurations = t, this.segments = new ua(), this.dynamicLayoutVertexArray = new Di(), this.opacityVertexArray = new Li(), this.placedSymbolArray = new ta();\n    };\n\n    ml.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n    }, ml.prototype.upload = function (t, e, r, n) {\n      this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, qs.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Ns.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, hl, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n    }, ml.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());\n    }, On("SymbolBuffers", ml);\n\n    var vl = function vl(t, e, r) {\n      this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new ua(), this.collisionVertexArray = new ji();\n    };\n\n    vl.prototype.upload = function (t) {\n      this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Ks.members, !0);\n    }, vl.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());\n    }, On("CollisionBuffers", vl);\n\n    var gl = function gl(t) {\n      this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = so([]), this.placementViewportMatrix = so([]);\n      var e = this.layers[0]._unevaluatedLayout._values;\n      this.textSizeData = Lu(this.zoom, e["text-size"]), this.iconSizeData = Lu(this.zoom, e["icon-size"]);\n      var r = this.layers[0].layout,\n          n = r.get("symbol-sort-key"),\n          i = r.get("symbol-z-order");\n      this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && !n.isConstant(), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, "point" === r.get("symbol-placement") && (this.writingModes = r.get("text-writing-mode").map(function (t) {\n        return _u[t];\n      })), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      }), this.sourceID = t.sourceID;\n    };\n\n    gl.prototype.createArrays = function () {\n      this.text = new ml(new Fa(this.layers, this.zoom, function (t) {\n        return /^text/.test(t);\n      })), this.icon = new ml(new Fa(this.layers, this.zoom, function (t) {\n        return /^icon/.test(t);\n      })), this.glyphOffsetArray = new na(), this.lineVertexArray = new ia(), this.symbolInstances = new ra();\n    }, gl.prototype.calculateGlyphDependencies = function (t, e, r, n, i) {\n      for (var a = 0; a < t.length; a++) {\n        if (e[t.charCodeAt(a)] = !0, (r || n) && i) {\n          var o = Js[t.charAt(a)];\n          o && (e[o.charCodeAt(0)] = !0);\n        }\n      }\n    }, gl.prototype.populate = function (t, e, r) {\n      var n = this.layers[0],\n          i = n.layout,\n          a = i.get("text-font"),\n          o = i.get("text-field"),\n          s = i.get("icon-image"),\n          u = ("constant" !== o.value.kind || o.value.value instanceof ie && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0),\n          l = "constant" !== s.value.kind || !!s.value.value || Object.keys(s.parameters).length > 0,\n          p = i.get("symbol-sort-key");\n\n      if (this.features = [], u || l) {\n        for (var c = e.iconDependencies, h = e.glyphDependencies, f = e.availableImages, y = new ui(this.zoom), d = 0, m = t; d < m.length; d += 1) {\n          var v = m[d],\n              g = v.feature,\n              x = v.id,\n              b = v.index,\n              w = v.sourceLayerIndex,\n              _ = n._featureFilter.needGeometry,\n              A = ja(g, _);\n\n          if (n._featureFilter.filter(y, A, r)) {\n            _ || (A.geometry = Ua(g));\n            var S = void 0;\n\n            if (u) {\n              var k = n.getValueAndResolveTokens("text-field", A, r, f),\n                  I = ie.factory(k);\n              dl(I) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === ai() || this.hasRTLText && si.isParsed()) && (S = Xs(I, n, A));\n            }\n\n            var z = void 0;\n\n            if (l) {\n              var C = n.getValueAndResolveTokens("icon-image", A, r, f);\n              z = C instanceof ae ? C : ae.fromString(C);\n            }\n\n            if (S || z) {\n              var E = this.sortFeaturesByKey ? p.evaluate(A, {}, r) : void 0;\n\n              if (this.features.push({\n                id: x,\n                text: S,\n                icon: z,\n                index: b,\n                sourceLayerIndex: w,\n                geometry: A.geometry,\n                properties: g.properties,\n                type: cl[g.type],\n                sortKey: E\n              }), z && (c[z.name] = !0), S) {\n                var P = a.evaluate(A, {}, r).join(","),\n                    M = "map" === i.get("text-rotation-alignment") && "point" !== i.get("symbol-placement");\n                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(_u.vertical) >= 0;\n\n                for (var B = 0, T = S.sections; B < T.length; B += 1) {\n                  var V = T[B];\n                  if (V.image) c[V.image.name] = !0;else {\n                    var F = Xn(S.toString()),\n                        D = V.fontStack || P,\n                        L = h[D] = h[D] || {};\n                    this.calculateGlyphDependencies(V.text, L, M, this.allowVerticalPlacement, F);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        "line" === i.get("symbol-placement") && (this.features = function (t) {\n          var e = {},\n              r = {},\n              n = [],\n              i = 0;\n\n          function a(e) {\n            n.push(t[e]), i++;\n          }\n\n          function o(t, e, i) {\n            var a = r[t];\n            return delete r[t], r[e] = a, n[a].geometry[0].pop(), n[a].geometry[0] = n[a].geometry[0].concat(i[0]), a;\n          }\n\n          function s(t, r, i) {\n            var a = e[r];\n            return delete e[r], e[t] = a, n[a].geometry[0].shift(), n[a].geometry[0] = i[0].concat(n[a].geometry[0]), a;\n          }\n\n          function u(t, e, r) {\n            var n = r ? e[0][e[0].length - 1] : e[0][0];\n            return t + ":" + n.x + ":" + n.y;\n          }\n\n          for (var l = 0; l < t.length; l++) {\n            var p = t[l],\n                c = p.geometry,\n                h = p.text ? p.text.toString() : null;\n\n            if (h) {\n              var f = u(h, c),\n                  y = u(h, c, !0);\n\n              if (f in r && y in e && r[f] !== e[y]) {\n                var d = s(f, y, c),\n                    m = o(f, y, n[d].geometry);\n                delete e[f], delete r[y], r[u(h, n[m].geometry, !0)] = m, n[d].geometry = null;\n              } else f in r ? o(f, y, c) : y in e ? s(f, y, c) : (a(l), e[f] = i - 1, r[y] = i - 1);\n            } else a(l);\n          }\n\n          return n.filter(function (t) {\n            return t.geometry;\n          });\n        }(this.features)), this.sortFeaturesByKey && this.features.sort(function (t, e) {\n          return t.sortKey - e.sortKey;\n        });\n      }\n    }, gl.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r));\n    }, gl.prototype.isEmpty = function () {\n      return 0 === this.symbolInstances.length && !this.hasRTLText;\n    }, gl.prototype.uploadPending = function () {\n      return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n    }, gl.prototype.upload = function (t) {\n      !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n    }, gl.prototype.destroyDebugData = function () {\n      this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n    }, gl.prototype.destroy = function () {\n      this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n    }, gl.prototype.addToLineVertexArray = function (t, e) {\n      var r = this.lineVertexArray.length;\n\n      if (void 0 !== t.segment) {\n        for (var n = t.dist(e[t.segment + 1]), i = t.dist(e[t.segment]), a = {}, o = t.segment + 1; o < e.length; o++) {\n          a[o] = {\n            x: e[o].x,\n            y: e[o].y,\n            tileUnitDistanceFromAnchor: n\n          }, o < e.length - 1 && (n += e[o + 1].dist(e[o]));\n        }\n\n        for (var s = t.segment || 0; s >= 0; s--) {\n          a[s] = {\n            x: e[s].x,\n            y: e[s].y,\n            tileUnitDistanceFromAnchor: i\n          }, s > 0 && (i += e[s - 1].dist(e[s]));\n        }\n\n        for (var u = 0; u < e.length; u++) {\n          var l = a[u];\n          this.lineVertexArray.emplaceBack(l.x, l.y, l.tileUnitDistanceFromAnchor);\n        }\n      }\n\n      return {\n        lineStartIndex: r,\n        lineLength: this.lineVertexArray.length - r\n      };\n    }, gl.prototype.addSymbols = function (t, e, r, n, i, a, o, s, u, l, p, c) {\n      for (var h = t.indexArray, f = t.layoutVertexArray, y = t.segments.prepareSegment(4 * e.length, f, h, this.canOverlap ? a.sortKey : void 0), d = this.glyphOffsetArray.length, m = y.vertexLength, v = this.allowVerticalPlacement && o === _u.vertical ? Math.PI / 2 : 0, g = a.text && a.text.sections, x = 0; x < e.length; x++) {\n        var b = e[x],\n            w = b.tl,\n            _ = b.tr,\n            A = b.bl,\n            S = b.br,\n            k = b.tex,\n            I = b.pixelOffsetTL,\n            z = b.pixelOffsetBR,\n            C = b.minFontScaleX,\n            E = b.minFontScaleY,\n            P = b.glyphOffset,\n            M = b.isSDF,\n            B = b.sectionIndex,\n            T = y.vertexLength,\n            V = P[1];\n        fl(f, s.x, s.y, w.x, V + w.y, k.x, k.y, r, M, I.x, I.y, C, E), fl(f, s.x, s.y, _.x, V + _.y, k.x + k.w, k.y, r, M, z.x, I.y, C, E), fl(f, s.x, s.y, A.x, V + A.y, k.x, k.y + k.h, r, M, I.x, z.y, C, E), fl(f, s.x, s.y, S.x, V + S.y, k.x + k.w, k.y + k.h, r, M, z.x, z.y, C, E), yl(t.dynamicLayoutVertexArray, s, v), h.emplaceBack(T, T + 1, T + 2), h.emplaceBack(T + 1, T + 2, T + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), x !== e.length - 1 && B === e[x + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, a, a.index, {}, c, g && g[B]);\n      }\n\n      t.placedSymbolArray.emplaceBack(s.x, s.y, d, this.glyphOffsetArray.length - d, m, u, l, s.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], o, 0, !1, 0, p);\n    }, gl.prototype._addCollisionDebugVertex = function (t, e, r, n, i, a) {\n      return e.emplaceBack(0, 0), t.emplaceBack(r.x, r.y, n, i, Math.round(a.x), Math.round(a.y));\n    }, gl.prototype.addCollisionDebugVertices = function (t, e, r, n, a, o, s) {\n      var u = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray),\n          l = u.vertexLength,\n          p = a.layoutVertexArray,\n          c = a.collisionVertexArray,\n          h = s.anchorX,\n          f = s.anchorY;\n      this._addCollisionDebugVertex(p, c, o, h, f, new i(t, e)), this._addCollisionDebugVertex(p, c, o, h, f, new i(r, e)), this._addCollisionDebugVertex(p, c, o, h, f, new i(r, n)), this._addCollisionDebugVertex(p, c, o, h, f, new i(t, n)), u.vertexLength += 4;\n      var y = a.indexArray;\n      y.emplaceBack(l, l + 1), y.emplaceBack(l + 1, l + 2), y.emplaceBack(l + 2, l + 3), y.emplaceBack(l + 3, l), u.primitiveLength += 4;\n    }, gl.prototype.addDebugCollisionBoxes = function (t, e, r, n) {\n      for (var i = t; i < e; i++) {\n        var a = this.collisionBoxArray.get(i);\n        this.addCollisionDebugVertices(a.x1, a.y1, a.x2, a.y2, n ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, r);\n      }\n    }, gl.prototype.generateCollisionDebugBuffers = function () {\n      this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new vl(Oi, Gs.members, Ji), this.iconCollisionBox = new vl(Oi, Gs.members, Ji);\n\n      for (var t = 0; t < this.symbolInstances.length; t++) {\n        var e = this.symbolInstances.get(t);\n        this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1);\n      }\n    }, gl.prototype._deserializeCollisionBoxesForSymbol = function (t, e, r, n, i, a, o, s, u) {\n      for (var l = {}, p = e; p < r; p++) {\n        var c = t.get(p);\n        l.textBox = {\n          x1: c.x1,\n          y1: c.y1,\n          x2: c.x2,\n          y2: c.y2,\n          anchorPointX: c.anchorPointX,\n          anchorPointY: c.anchorPointY\n        }, l.textFeatureIndex = c.featureIndex;\n        break;\n      }\n\n      for (var h = n; h < i; h++) {\n        var f = t.get(h);\n        l.verticalTextBox = {\n          x1: f.x1,\n          y1: f.y1,\n          x2: f.x2,\n          y2: f.y2,\n          anchorPointX: f.anchorPointX,\n          anchorPointY: f.anchorPointY\n        }, l.verticalTextFeatureIndex = f.featureIndex;\n        break;\n      }\n\n      for (var y = a; y < o; y++) {\n        var d = t.get(y);\n        l.iconBox = {\n          x1: d.x1,\n          y1: d.y1,\n          x2: d.x2,\n          y2: d.y2,\n          anchorPointX: d.anchorPointX,\n          anchorPointY: d.anchorPointY\n        }, l.iconFeatureIndex = d.featureIndex;\n        break;\n      }\n\n      for (var m = s; m < u; m++) {\n        var v = t.get(m);\n        l.verticalIconBox = {\n          x1: v.x1,\n          y1: v.y1,\n          x2: v.x2,\n          y2: v.y2,\n          anchorPointX: v.anchorPointX,\n          anchorPointY: v.anchorPointY\n        }, l.verticalIconFeatureIndex = v.featureIndex;\n        break;\n      }\n\n      return l;\n    }, gl.prototype.deserializeCollisionBoxes = function (t) {\n      this.collisionArrays = [];\n\n      for (var e = 0; e < this.symbolInstances.length; e++) {\n        var r = this.symbolInstances.get(e);\n        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n      }\n    }, gl.prototype.hasTextData = function () {\n      return this.text.segments.get().length > 0;\n    }, gl.prototype.hasIconData = function () {\n      return this.icon.segments.get().length > 0;\n    }, gl.prototype.hasDebugData = function () {\n      return this.textCollisionBox && this.iconCollisionBox;\n    }, gl.prototype.hasTextCollisionBoxData = function () {\n      return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n    }, gl.prototype.hasIconCollisionBoxData = function () {\n      return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n    }, gl.prototype.addIndicesForPlacedSymbol = function (t, e) {\n      for (var r = t.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs, i = r.vertexStartIndex; i < n; i += 4) {\n        t.indexArray.emplaceBack(i, i + 1, i + 2), t.indexArray.emplaceBack(i + 1, i + 2, i + 3);\n      }\n    }, gl.prototype.getSortedSymbolIndexes = function (t) {\n      if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n\n      for (var e = Math.sin(t), r = Math.cos(t), n = [], i = [], a = [], o = 0; o < this.symbolInstances.length; ++o) {\n        a.push(o);\n        var s = this.symbolInstances.get(o);\n        n.push(0 | Math.round(e * s.anchorX + r * s.anchorY)), i.push(s.featureIndex);\n      }\n\n      return a.sort(function (t, e) {\n        return n[t] - n[e] || i[e] - i[t];\n      }), a;\n    }, gl.prototype.addToSortKeyRanges = function (t, e) {\n      var r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n      r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n        sortKey: e,\n        symbolInstanceStart: t,\n        symbolInstanceEnd: t + 1\n      });\n    }, gl.prototype.sortFeatures = function (t) {\n      var e = this;\n\n      if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n\n        for (var r = 0, n = this.symbolInstanceIndexes; r < n.length; r += 1) {\n          var i = this.symbolInstances.get(n[r]);\n          this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach(function (t, r, n) {\n            t >= 0 && n.indexOf(t) === r && e.addIndicesForPlacedSymbol(e.text, t);\n          }), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex);\n        }\n\n        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n      }\n    }, On("SymbolBucket", gl, {\n      omit: ["layers", "collisionBoxArray", "features", "compareText"]\n    }), gl.MAX_GLYPHS = 65535, gl.addDynamicAttributes = yl;\n\n    var xl = new _i({\n      "symbol-placement": new vi(Pt.layout_symbol["symbol-placement"]),\n      "symbol-spacing": new vi(Pt.layout_symbol["symbol-spacing"]),\n      "symbol-avoid-edges": new vi(Pt.layout_symbol["symbol-avoid-edges"]),\n      "symbol-sort-key": new gi(Pt.layout_symbol["symbol-sort-key"]),\n      "symbol-z-order": new vi(Pt.layout_symbol["symbol-z-order"]),\n      "icon-allow-overlap": new vi(Pt.layout_symbol["icon-allow-overlap"]),\n      "icon-ignore-placement": new vi(Pt.layout_symbol["icon-ignore-placement"]),\n      "icon-optional": new vi(Pt.layout_symbol["icon-optional"]),\n      "icon-rotation-alignment": new vi(Pt.layout_symbol["icon-rotation-alignment"]),\n      "icon-size": new gi(Pt.layout_symbol["icon-size"]),\n      "icon-text-fit": new vi(Pt.layout_symbol["icon-text-fit"]),\n      "icon-text-fit-padding": new vi(Pt.layout_symbol["icon-text-fit-padding"]),\n      "icon-image": new gi(Pt.layout_symbol["icon-image"]),\n      "icon-rotate": new gi(Pt.layout_symbol["icon-rotate"]),\n      "icon-padding": new vi(Pt.layout_symbol["icon-padding"]),\n      "icon-keep-upright": new vi(Pt.layout_symbol["icon-keep-upright"]),\n      "icon-offset": new gi(Pt.layout_symbol["icon-offset"]),\n      "icon-anchor": new gi(Pt.layout_symbol["icon-anchor"]),\n      "icon-pitch-alignment": new vi(Pt.layout_symbol["icon-pitch-alignment"]),\n      "text-pitch-alignment": new vi(Pt.layout_symbol["text-pitch-alignment"]),\n      "text-rotation-alignment": new vi(Pt.layout_symbol["text-rotation-alignment"]),\n      "text-field": new gi(Pt.layout_symbol["text-field"]),\n      "text-font": new gi(Pt.layout_symbol["text-font"]),\n      "text-size": new gi(Pt.layout_symbol["text-size"]),\n      "text-max-width": new gi(Pt.layout_symbol["text-max-width"]),\n      "text-line-height": new vi(Pt.layout_symbol["text-line-height"]),\n      "text-letter-spacing": new gi(Pt.layout_symbol["text-letter-spacing"]),\n      "text-justify": new gi(Pt.layout_symbol["text-justify"]),\n      "text-radial-offset": new gi(Pt.layout_symbol["text-radial-offset"]),\n      "text-variable-anchor": new vi(Pt.layout_symbol["text-variable-anchor"]),\n      "text-anchor": new gi(Pt.layout_symbol["text-anchor"]),\n      "text-max-angle": new vi(Pt.layout_symbol["text-max-angle"]),\n      "text-writing-mode": new vi(Pt.layout_symbol["text-writing-mode"]),\n      "text-rotate": new gi(Pt.layout_symbol["text-rotate"]),\n      "text-padding": new vi(Pt.layout_symbol["text-padding"]),\n      "text-keep-upright": new vi(Pt.layout_symbol["text-keep-upright"]),\n      "text-transform": new gi(Pt.layout_symbol["text-transform"]),\n      "text-offset": new gi(Pt.layout_symbol["text-offset"]),\n      "text-allow-overlap": new vi(Pt.layout_symbol["text-allow-overlap"]),\n      "text-ignore-placement": new vi(Pt.layout_symbol["text-ignore-placement"]),\n      "text-optional": new vi(Pt.layout_symbol["text-optional"])\n    }),\n        bl = {\n      paint: new _i({\n        "icon-opacity": new gi(Pt.paint_symbol["icon-opacity"]),\n        "icon-color": new gi(Pt.paint_symbol["icon-color"]),\n        "icon-halo-color": new gi(Pt.paint_symbol["icon-halo-color"]),\n        "icon-halo-width": new gi(Pt.paint_symbol["icon-halo-width"]),\n        "icon-halo-blur": new gi(Pt.paint_symbol["icon-halo-blur"]),\n        "icon-translate": new vi(Pt.paint_symbol["icon-translate"]),\n        "icon-translate-anchor": new vi(Pt.paint_symbol["icon-translate-anchor"]),\n        "text-opacity": new gi(Pt.paint_symbol["text-opacity"]),\n        "text-color": new gi(Pt.paint_symbol["text-color"], {\n          runtimeType: qt,\n          getOverride: function getOverride(t) {\n            return t.textColor;\n          },\n          hasOverride: function hasOverride(t) {\n            return !!t.textColor;\n          }\n        }),\n        "text-halo-color": new gi(Pt.paint_symbol["text-halo-color"]),\n        "text-halo-width": new gi(Pt.paint_symbol["text-halo-width"]),\n        "text-halo-blur": new gi(Pt.paint_symbol["text-halo-blur"]),\n        "text-translate": new vi(Pt.paint_symbol["text-translate"]),\n        "text-translate-anchor": new vi(Pt.paint_symbol["text-translate-anchor"])\n      }),\n      layout: xl\n    },\n        wl = function wl(t) {\n      this.type = t.property.overrides ? t.property.overrides.runtimeType : Rt, this.defaultValue = t;\n    };\n\n    wl.prototype.evaluate = function (t) {\n      if (t.formattedSection) {\n        var e = this.defaultValue.property.overrides;\n        if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n      }\n\n      return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n    }, wl.prototype.eachChild = function (t) {\n      this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n    }, wl.prototype.outputDefined = function () {\n      return !1;\n    }, wl.prototype.serialize = function () {\n      return null;\n    }, On("FormatSectionOverride", wl, {\n      omit: ["defaultValue"]\n    });\n\n    var _l = function (t) {\n      function e(e) {\n        t.call(this, e, bl);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, r) {\n        if (t.prototype.recalculate.call(this, e, r), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {\n          var n = this.layout.get("text-writing-mode");\n\n          if (n) {\n            for (var i = [], a = 0, o = n; a < o.length; a += 1) {\n              var s = o[a];\n              i.indexOf(s) < 0 && i.push(s);\n            }\n\n            this.layout._values["text-writing-mode"] = i;\n          } else this.layout._values["text-writing-mode"] = ["horizontal"];\n        }\n\n        this._setPaintOverrides();\n      }, e.prototype.getValueAndResolveTokens = function (t, e, r, n) {\n        var i = this.layout.get(t).evaluate(e, {}, r, n),\n            a = this._unevaluatedLayout._values[t];\n        return a.isDataDriven() || Zr(a.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, function (e, r) {\n            return r in t ? String(t[r]) : "";\n          });\n        }(e.properties, i);\n      }, e.prototype.createBucket = function (t) {\n        return new gl(t);\n      }, e.prototype.queryRadius = function () {\n        return 0;\n      }, e.prototype.queryIntersectsFeature = function () {\n        return !1;\n      }, e.prototype._setPaintOverrides = function () {\n        for (var t = 0, r = bl.paint.overridableProperties; t < r.length; t += 1) {\n          var n = r[t];\n\n          if (e.hasPaintOverride(this.layout, n)) {\n            var i,\n                a = this.paint.get(n),\n                o = new wl(a),\n                s = new Gr(o, a.property.specification);\n            i = "constant" === a.value.kind || "source" === a.value.kind ? new Jr("source", s) : new Hr("composite", s, a.value.zoomStops, a.value._interpolationType), this.paint._values[n] = new di(a.property, i, a.parameters);\n          }\n        }\n      }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, r, n) {\n        return !(!this.layout || r.isDataDriven() || n.isDataDriven()) && e.hasPaintOverride(this.layout, t);\n      }, e.hasPaintOverride = function (t, e) {\n        var r = t.get("text-field"),\n            n = bl.paint.properties[e],\n            i = !1,\n            a = function a(t) {\n          for (var e = 0, r = t; e < r.length; e += 1) {\n            if (n.overrides && n.overrides.hasOverride(r[e])) return void (i = !0);\n          }\n        };\n\n        if ("constant" === r.value.kind && r.value.value instanceof ie) a(r.value.value.sections);else if ("source" === r.value.kind) {\n          var o = function o(t) {\n            i || (t instanceof pe && ue(t.value) === Zt ? a(t.value.sections) : t instanceof ye ? a(t.sections) : t.eachChild(o));\n          },\n              s = r.value;\n\n          s._styleExpression && o(s._styleExpression.expression);\n        }\n        return i;\n      }, e;\n    }(Ai),\n        Al = {\n      paint: new _i({\n        "background-color": new vi(Pt.paint_background["background-color"]),\n        "background-pattern": new bi(Pt.paint_background["background-pattern"]),\n        "background-opacity": new vi(Pt.paint_background["background-opacity"])\n      })\n    },\n        Sl = function (t) {\n      function e(e) {\n        t.call(this, e, Al);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(Ai),\n        kl = {\n      paint: new _i({\n        "raster-opacity": new vi(Pt.paint_raster["raster-opacity"]),\n        "raster-hue-rotate": new vi(Pt.paint_raster["raster-hue-rotate"]),\n        "raster-brightness-min": new vi(Pt.paint_raster["raster-brightness-min"]),\n        "raster-brightness-max": new vi(Pt.paint_raster["raster-brightness-max"]),\n        "raster-saturation": new vi(Pt.paint_raster["raster-saturation"]),\n        "raster-contrast": new vi(Pt.paint_raster["raster-contrast"]),\n        "raster-resampling": new vi(Pt.paint_raster["raster-resampling"]),\n        "raster-fade-duration": new vi(Pt.paint_raster["raster-fade-duration"])\n      })\n    },\n        Il = function (t) {\n      function e(e) {\n        t.call(this, e, kl);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(Ai),\n        zl = function (t) {\n      function e(e) {\n        t.call(this, e, {}), this.implementation = e;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.is3D = function () {\n        return "3d" === this.implementation.renderingMode;\n      }, e.prototype.hasOffscreenPass = function () {\n        return void 0 !== this.implementation.prerender;\n      }, e.prototype.recalculate = function () {}, e.prototype.updateTransitions = function () {}, e.prototype.hasTransition = function () {}, e.prototype.serialize = function () {}, e.prototype.onAdd = function (t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }, e.prototype.onRemove = function (t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }, e;\n    }(Ai),\n        Cl = {\n      circle: ho,\n      heatmap: Ao,\n      hillshade: ko,\n      fill: cs,\n      "fill-extrusion": Cs,\n      line: Us,\n      symbol: _l,\n      background: Sl,\n      raster: Il\n    },\n        El = o.HTMLImageElement,\n        Pl = o.HTMLCanvasElement,\n        Ml = o.HTMLVideoElement,\n        Bl = o.ImageData,\n        Tl = o.ImageBitmap,\n        Vl = function Vl(t, e, r, n) {\n      this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);\n    };\n\n    Vl.prototype.update = function (t, e, r) {\n      var n = t.width,\n          i = t.height,\n          a = !(this.size && this.size[0] === n && this.size[1] === i || r),\n          o = this.context,\n          s = o.gl;\n      if (this.useMipmap = Boolean(e && e.useMipmap), s.bindTexture(s.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!e || !1 !== e.premultiply)), a) this.size = [n, i], t instanceof El || t instanceof Pl || t instanceof Ml || t instanceof Bl || Tl && t instanceof Tl ? s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, s.UNSIGNED_BYTE, t) : s.texImage2D(s.TEXTURE_2D, 0, this.format, n, i, 0, this.format, s.UNSIGNED_BYTE, t.data);else {\n        var u = r || {\n          x: 0,\n          y: 0\n        },\n            l = u.x,\n            p = u.y;\n        t instanceof El || t instanceof Pl || t instanceof Ml || t instanceof Bl || Tl && t instanceof Tl ? s.texSubImage2D(s.TEXTURE_2D, 0, l, p, s.RGBA, s.UNSIGNED_BYTE, t) : s.texSubImage2D(s.TEXTURE_2D, 0, l, p, n, i, s.RGBA, s.UNSIGNED_BYTE, t.data);\n      }\n      this.useMipmap && this.isSizePowerOfTwo() && s.generateMipmap(s.TEXTURE_2D);\n    }, Vl.prototype.bind = function (t, e, r) {\n      var n = this.context.gl;\n      n.bindTexture(n.TEXTURE_2D, this.texture), r !== n.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r = n.LINEAR), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, r || t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);\n    }, Vl.prototype.isSizePowerOfTwo = function () {\n      return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;\n    }, Vl.prototype.destroy = function () {\n      this.context.gl.deleteTexture(this.texture), this.texture = null;\n    };\n\n    var Fl = function Fl(t) {\n      var e = this;\n      this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function () {\n        e._triggered = !1, e._callback();\n      });\n    };\n\n    Fl.prototype.trigger = function () {\n      var t = this;\n      this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function () {\n        t._triggered = !1, t._callback();\n      }, 0));\n    }, Fl.prototype.remove = function () {\n      delete this._channel, this._callback = function () {};\n    };\n\n    var Dl = function Dl(t, e, r) {\n      this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, v(["receive", "process"], this), this.invoker = new Fl(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = I() ? t : o;\n    };\n\n    function Ll(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n\n    Dl.prototype.send = function (t, e, r, n, i) {\n      var a = this;\n      void 0 === i && (i = !1);\n      var o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n      r && (this.callbacks[o] = r);\n      var s = E(this.globalScope) ? void 0 : [];\n      return this.target.postMessage({\n        id: o,\n        type: t,\n        hasCallback: !!r,\n        targetMapId: n,\n        mustQueue: i,\n        sourceMapId: this.mapId,\n        data: Nn(e, s)\n      }, s), {\n        cancel: function cancel() {\n          r && delete a.callbacks[o], a.target.postMessage({\n            id: o,\n            type: "<cancel>",\n            targetMapId: n,\n            sourceMapId: a.mapId\n          });\n        }\n      };\n    }, Dl.prototype.receive = function (t) {\n      var e = t.data,\n          r = e.id;\n      if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {\n        delete this.tasks[r];\n        var n = this.cancelCallbacks[r];\n        delete this.cancelCallbacks[r], n && n();\n      } else I() || e.mustQueue ? (this.tasks[r] = e, this.taskQueue.push(r), this.invoker.trigger()) : this.processTask(r, e);\n    }, Dl.prototype.process = function () {\n      if (this.taskQueue.length) {\n        var t = this.taskQueue.shift(),\n            e = this.tasks[t];\n        delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), e && this.processTask(t, e);\n      }\n    }, Dl.prototype.processTask = function (t, e) {\n      var r = this;\n\n      if ("<response>" === e.type) {\n        var n = this.callbacks[t];\n        delete this.callbacks[t], n && (e.error ? n(Kn(e.error)) : n(null, Kn(e.data)));\n      } else {\n        var i = !1,\n            a = E(this.globalScope) ? void 0 : [],\n            o = e.hasCallback ? function (e, n) {\n          i = !0, delete r.cancelCallbacks[t], r.target.postMessage({\n            id: t,\n            type: "<response>",\n            sourceMapId: r.mapId,\n            error: e ? Nn(e) : null,\n            data: Nn(n, a)\n          }, a);\n        } : function (t) {\n          i = !0;\n        },\n            s = null,\n            u = Kn(e.data);\n        if (this.parent[e.type]) s = this.parent[e.type](e.sourceMapId, u, o);else if (this.parent.getWorkerSource) {\n          var l = e.type.split(".");\n          s = this.parent.getWorkerSource(e.sourceMapId, l[0], u.source)[l[1]](u, o);\n        } else o(new Error("Could not find function " + e.type));\n        !i && s && s.cancel && (this.cancelCallbacks[t] = s.cancel);\n      }\n    }, Dl.prototype.remove = function () {\n      this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);\n    };\n\n    var Rl = function Rl(t, e) {\n      t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n    };\n\n    Rl.prototype.setNorthEast = function (t) {\n      return this._ne = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n    }, Rl.prototype.setSouthWest = function (t) {\n      return this._sw = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n    }, Rl.prototype.extend = function (t) {\n      var e,\n          r,\n          n = this._sw,\n          i = this._ne;\n      if (t instanceof Ol) e = t, r = t;else {\n        if (!(t instanceof Rl)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Rl.convert(t)) : this.extend(Ol.convert(t)) : this;\n        if (r = t._ne, !(e = t._sw) || !r) return this;\n      }\n      return n || i ? (n.lng = Math.min(e.lng, n.lng), n.lat = Math.min(e.lat, n.lat), i.lng = Math.max(r.lng, i.lng), i.lat = Math.max(r.lat, i.lat)) : (this._sw = new Ol(e.lng, e.lat), this._ne = new Ol(r.lng, r.lat)), this;\n    }, Rl.prototype.getCenter = function () {\n      return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }, Rl.prototype.getSouthWest = function () {\n      return this._sw;\n    }, Rl.prototype.getNorthEast = function () {\n      return this._ne;\n    }, Rl.prototype.getNorthWest = function () {\n      return new Ol(this.getWest(), this.getNorth());\n    }, Rl.prototype.getSouthEast = function () {\n      return new Ol(this.getEast(), this.getSouth());\n    }, Rl.prototype.getWest = function () {\n      return this._sw.lng;\n    }, Rl.prototype.getSouth = function () {\n      return this._sw.lat;\n    }, Rl.prototype.getEast = function () {\n      return this._ne.lng;\n    }, Rl.prototype.getNorth = function () {\n      return this._ne.lat;\n    }, Rl.prototype.toArray = function () {\n      return [this._sw.toArray(), this._ne.toArray()];\n    }, Rl.prototype.toString = function () {\n      return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";\n    }, Rl.prototype.isEmpty = function () {\n      return !(this._sw && this._ne);\n    }, Rl.prototype.contains = function (t) {\n      var e = Ol.convert(t),\n          r = e.lng,\n          n = e.lat,\n          i = this._sw.lng <= r && r <= this._ne.lng;\n      return this._sw.lng > this._ne.lng && (i = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= n && n <= this._ne.lat && i;\n    }, Rl.convert = function (t) {\n      return !t || t instanceof Rl ? t : new Rl(t);\n    };\n\n    var Ol = function Ol(t, e) {\n      if (isNaN(t) || isNaN(e)) throw new Error("Invalid LngLat object: (" + t + ", " + e + ")");\n      if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");\n    };\n\n    Ol.prototype.wrap = function () {\n      return new Ol(c(this.lng, -180, 180), this.lat);\n    }, Ol.prototype.toArray = function () {\n      return [this.lng, this.lat];\n    }, Ol.prototype.toString = function () {\n      return "LngLat(" + this.lng + ", " + this.lat + ")";\n    }, Ol.prototype.distanceTo = function (t) {\n      var e = Math.PI / 180,\n          r = this.lat * e,\n          n = t.lat * e,\n          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n      return 6371008.8 * Math.acos(Math.min(i, 1));\n    }, Ol.prototype.toBounds = function (t) {\n      void 0 === t && (t = 0);\n      var e = 360 * t / 40075017,\n          r = e / Math.cos(Math.PI / 180 * this.lat);\n      return new Rl(new Ol(this.lng - r, this.lat - e), new Ol(this.lng + r, this.lat + e));\n    }, Ol.convert = function (t) {\n      if (t instanceof Ol) return t;\n      if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ol(Number(t[0]), Number(t[1]));\n      if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Ol(Number("lng" in t ? t.lng : t.lon), Number(t.lat));\n      throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");\n    };\n    var Ul = 2 * Math.PI * 6371008.8;\n\n    function jl(t) {\n      return Ul * Math.cos(t * Math.PI / 180);\n    }\n\n    function ql(t) {\n      return (180 + t) / 360;\n    }\n\n    function Nl(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n\n    function Kl(t, e) {\n      return t / jl(e);\n    }\n\n    function Gl(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n\n    var Zl = function Zl(t, e, r) {\n      void 0 === r && (r = 0), this.x = +t, this.y = +e, this.z = +r;\n    };\n\n    Zl.fromLngLat = function (t, e) {\n      void 0 === e && (e = 0);\n      var r = Ol.convert(t);\n      return new Zl(ql(r.lng), Nl(r.lat), Kl(e, r.lat));\n    }, Zl.prototype.toLngLat = function () {\n      return new Ol(360 * this.x - 180, Gl(this.y));\n    }, Zl.prototype.toAltitude = function () {\n      return this.z * jl(Gl(this.y));\n    }, Zl.prototype.meterInMercatorCoordinateUnits = function () {\n      return 1 / Ul * (t = Gl(this.y), 1 / Math.cos(t * Math.PI / 180));\n      var t;\n    };\n\n    var Xl = function Xl(t, e, r) {\n      this.z = t, this.x = e, this.y = r, this.key = Yl(0, t, t, e, r);\n    };\n\n    Xl.prototype.equals = function (t) {\n      return this.z === t.z && this.x === t.x && this.y === t.y;\n    }, Xl.prototype.url = function (t, e) {\n      var r,\n          n,\n          i,\n          a,\n          o,\n          s = (n = this.y, i = this.z, a = Ll(256 * (r = this.x), 256 * (n = Math.pow(2, i) - n - 1), i), o = Ll(256 * (r + 1), 256 * (n + 1), i), a[0] + "," + a[1] + "," + o[0] + "," + o[1]),\n          u = function (t, e, r) {\n        for (var n, i = "", a = t; a > 0; a--) {\n          i += (e & (n = 1 << a - 1) ? 1 : 0) + (r & n ? 2 : 0);\n        }\n\n        return i;\n      }(this.z, this.x, this.y);\n\n      return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u).replace("{bbox-epsg-3857}", s);\n    }, Xl.prototype.getTilePoint = function (t) {\n      var e = Math.pow(2, this.z);\n      return new i(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y));\n    }, Xl.prototype.toString = function () {\n      return this.z + "/" + this.x + "/" + this.y;\n    };\n\n    var Jl = function Jl(t, e) {\n      this.wrap = t, this.canonical = e, this.key = Yl(t, e.z, e.z, e.x, e.y);\n    },\n        Hl = function Hl(t, e, r, n, i) {\n      this.overscaledZ = t, this.wrap = e, this.canonical = new Xl(r, +n, +i), this.key = Yl(e, t, r, n, i);\n    };\n\n    function Yl(t, e, r, n, i) {\n      (t *= 2) < 0 && (t = -1 * t - 1);\n      var a = 1 << r;\n      return (a * a * t + a * i + n).toString(36) + r.toString(36) + e.toString(36);\n    }\n\n    Hl.prototype.equals = function (t) {\n      return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n    }, Hl.prototype.scaledTo = function (t) {\n      var e = this.canonical.z - t;\n      return t > this.canonical.z ? new Hl(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Hl(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n    }, Hl.prototype.calculateScaledKey = function (t, e) {\n      var r = this.canonical.z - t;\n      return t > this.canonical.z ? Yl(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : Yl(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n    }, Hl.prototype.isChildOf = function (t) {\n      if (t.wrap !== this.wrap) return !1;\n      var e = this.canonical.z - t.canonical.z;\n      return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n    }, Hl.prototype.children = function (t) {\n      if (this.overscaledZ >= t) return [new Hl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n      var e = this.canonical.z + 1,\n          r = 2 * this.canonical.x,\n          n = 2 * this.canonical.y;\n      return [new Hl(e, this.wrap, e, r, n), new Hl(e, this.wrap, e, r + 1, n), new Hl(e, this.wrap, e, r, n + 1), new Hl(e, this.wrap, e, r + 1, n + 1)];\n    }, Hl.prototype.isLessThan = function (t) {\n      return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n    }, Hl.prototype.wrapped = function () {\n      return new Hl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }, Hl.prototype.unwrapTo = function (t) {\n      return new Hl(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n    }, Hl.prototype.overscaleFactor = function () {\n      return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }, Hl.prototype.toUnwrapped = function () {\n      return new Jl(this.wrap, this.canonical);\n    }, Hl.prototype.toString = function () {\n      return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;\n    }, Hl.prototype.getTilePoint = function (t) {\n      return this.canonical.getTilePoint(new Zl(t.x - this.wrap, t.y));\n    }, On("CanonicalTileID", Xl), On("OverscaledTileID", Hl, {\n      omit: ["posMatrix"]\n    });\n\n    var $l = function $l(t, e, r) {\n      if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square");\n      if (r && "mapbox" !== r && "terrarium" !== r) return A(\'"\' + r + \'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".\');\n      this.stride = e.height;\n      var n = this.dim = e.height - 2;\n      this.data = new Uint32Array(e.data.buffer), this.encoding = r || "mapbox";\n\n      for (var i = 0; i < n; i++) {\n        this.data[this._idx(-1, i)] = this.data[this._idx(0, i)], this.data[this._idx(n, i)] = this.data[this._idx(n - 1, i)], this.data[this._idx(i, -1)] = this.data[this._idx(i, 0)], this.data[this._idx(i, n)] = this.data[this._idx(i, n - 1)];\n      }\n\n      this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n, -1)] = this.data[this._idx(n - 1, 0)], this.data[this._idx(-1, n)] = this.data[this._idx(0, n - 1)], this.data[this._idx(n, n)] = this.data[this._idx(n - 1, n - 1)];\n    };\n\n    $l.prototype.get = function (t, e) {\n      var r = new Uint8Array(this.data.buffer),\n          n = 4 * this._idx(t, e);\n\n      return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r[n], r[n + 1], r[n + 2]);\n    }, $l.prototype.getUnpackVector = function () {\n      return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, .1, 1e4];\n    }, $l.prototype._idx = function (t, e) {\n      if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");\n      return (e + 1) * this.stride + (t + 1);\n    }, $l.prototype._unpackMapbox = function (t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }, $l.prototype._unpackTerrarium = function (t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }, $l.prototype.getPixels = function () {\n      return new bo({\n        width: this.stride,\n        height: this.stride\n      }, new Uint8Array(this.data.buffer));\n    }, $l.prototype.backfillBorder = function (t, e, r) {\n      if (this.dim !== t.dim) throw new Error("dem dimension mismatch");\n      var n = e * this.dim,\n          i = e * this.dim + this.dim,\n          a = r * this.dim,\n          o = r * this.dim + this.dim;\n\n      switch (e) {\n        case -1:\n          n = i - 1;\n          break;\n\n        case 1:\n          i = n + 1;\n      }\n\n      switch (r) {\n        case -1:\n          a = o - 1;\n          break;\n\n        case 1:\n          o = a + 1;\n      }\n\n      for (var s = -e * this.dim, u = -r * this.dim, l = a; l < o; l++) {\n        for (var p = n; p < i; p++) {\n          this.data[this._idx(p, l)] = t.data[this._idx(p + s, l + u)];\n        }\n      }\n    }, On("DEMData", $l);\n\n    var Wl = function Wl(t) {\n      this._stringToNumber = {}, this._numberToString = [];\n\n      for (var e = 0; e < t.length; e++) {\n        var r = t[e];\n        this._stringToNumber[r] = e, this._numberToString[e] = r;\n      }\n    };\n\n    Wl.prototype.encode = function (t) {\n      return this._stringToNumber[t];\n    }, Wl.prototype.decode = function (t) {\n      return this._numberToString[t];\n    };\n\n    var Ql = function Ql(t, e, r, n, i) {\n      this.type = "Feature", this._vectorTileFeature = t, t._z = e, t._x = r, t._y = n, this.properties = t.properties, this.id = i;\n    },\n        tp = {\n      geometry: {\n        configurable: !0\n      }\n    };\n\n    tp.geometry.get = function () {\n      return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;\n    }, tp.geometry.set = function (t) {\n      this._geometry = t;\n    }, Ql.prototype.toJSON = function () {\n      var t = {\n        geometry: this.geometry\n      };\n\n      for (var e in this) {\n        "_geometry" !== e && "_vectorTileFeature" !== e && (t[e] = this[e]);\n      }\n\n      return t;\n    }, Object.defineProperties(Ql.prototype, tp);\n\n    var ep = function ep() {\n      this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n    };\n\n    ep.prototype.updateState = function (t, e, r) {\n      var n = String(e);\n      if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, h(this.stateChanges[t][n], r), null === this.deletedStates[t]) for (var i in this.deletedStates[t] = {}, this.state[t]) {\n        i !== n && (this.deletedStates[t][i] = null);\n      } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) for (var a in this.deletedStates[t][n] = {}, this.state[t][n]) {\n        r[a] || (this.deletedStates[t][n][a] = null);\n      } else for (var o in r) {\n        this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][o] && delete this.deletedStates[t][n][o];\n      }\n    }, ep.prototype.removeFeatureState = function (t, e, r) {\n      if (null !== this.deletedStates[t]) {\n        var n = String(e);\n        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {\n          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) {\n            this.deletedStates[t][n][r] = null;\n          } else this.deletedStates[t][n] = null;\n        } else this.deletedStates[t] = null;\n      }\n    }, ep.prototype.getState = function (t, e) {\n      var r = String(e),\n          n = h({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);\n      if (null === this.deletedStates[t]) return {};\n\n      if (this.deletedStates[t]) {\n        var i = this.deletedStates[t][e];\n        if (null === i) return {};\n\n        for (var a in i) {\n          delete n[a];\n        }\n      }\n\n      return n;\n    }, ep.prototype.initializeTileState = function (t, e) {\n      t.setFeatureState(this.state, e);\n    }, ep.prototype.coalesceChanges = function (t, e) {\n      var r = {};\n\n      for (var n in this.stateChanges) {\n        this.state[n] = this.state[n] || {};\n        var i = {};\n\n        for (var a in this.stateChanges[n]) {\n          this.state[n][a] || (this.state[n][a] = {}), h(this.state[n][a], this.stateChanges[n][a]), i[a] = this.state[n][a];\n        }\n\n        r[n] = i;\n      }\n\n      for (var o in this.deletedStates) {\n        this.state[o] = this.state[o] || {};\n        var s = {};\n        if (null === this.deletedStates[o]) for (var u in this.state[o]) {\n          s[u] = {}, this.state[o][u] = {};\n        } else for (var l in this.deletedStates[o]) {\n          if (null === this.deletedStates[o][l]) this.state[o][l] = {};else for (var p = 0, c = Object.keys(this.deletedStates[o][l]); p < c.length; p += 1) {\n            delete this.state[o][l][c[p]];\n          }\n          s[l] = this.state[o][l];\n        }\n        r[o] = r[o] || {}, h(r[o], s);\n      }\n\n      if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (var f in t) {\n        t[f].setFeatureState(r, e);\n      }\n    };\n\n    var rp = function rp(t, e) {\n      this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Vn(8192, 16, 0), this.grid3D = new Vn(8192, 16, 0), this.featureIndexArray = new oa(), this.promoteId = e;\n    };\n\n    function np(t, e, r, n, i) {\n      return x(t, function (t, a) {\n        var o = e instanceof mi ? e.get(a) : null;\n        return o && o.evaluate ? o.evaluate(r, n, i) : o;\n      });\n    }\n\n    function ip(t) {\n      for (var e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0, o = t; a < o.length; a += 1) {\n        var s = o[a];\n        e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n      }\n\n      return {\n        minX: e,\n        minY: r,\n        maxX: n,\n        maxY: i\n      };\n    }\n\n    function ap(t, e) {\n      return e - t;\n    }\n\n    rp.prototype.insert = function (t, e, r, n, i, a) {\n      var o = this.featureIndexArray.length;\n      this.featureIndexArray.emplaceBack(r, n, i);\n\n      for (var s = a ? this.grid3D : this.grid, u = 0; u < e.length; u++) {\n        for (var l = e[u], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c = 0; c < l.length; c++) {\n          var h = l[c];\n          p[0] = Math.min(p[0], h.x), p[1] = Math.min(p[1], h.y), p[2] = Math.max(p[2], h.x), p[3] = Math.max(p[3], h.y);\n        }\n\n        p[0] < 8192 && p[1] < 8192 && p[2] >= 0 && p[3] >= 0 && s.insert(o, p[0], p[1], p[2], p[3]);\n      }\n    }, rp.prototype.loadVTLayers = function () {\n      return this.vtLayers || (this.vtLayers = new ws.VectorTile(new $s(this.rawTileData)).layers, this.sourceLayerCoder = new Wl(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;\n    }, rp.prototype.query = function (t, e, r, n) {\n      var a = this;\n      this.loadVTLayers();\n\n      for (var o = t.params || {}, s = 8192 / t.tileSize / t.scale, u = sn(o.filter), l = t.queryGeometry, p = t.queryPadding * s, c = ip(l), h = this.grid.query(c.minX - p, c.minY - p, c.maxX + p, c.maxY + p), f = ip(t.cameraQueryGeometry), y = this.grid3D.query(f.minX - p, f.minY - p, f.maxX + p, f.maxY + p, function (e, r, n, a) {\n        return function (t, e, r, n, a) {\n          for (var o = 0, s = t; o < s.length; o += 1) {\n            var u = s[o];\n            if (e <= u.x && r <= u.y && n >= u.x && a >= u.y) return !0;\n          }\n\n          var l = [new i(e, r), new i(e, a), new i(n, a), new i(n, r)];\n          if (t.length > 2) for (var p = 0, c = l; p < c.length; p += 1) {\n            if (Qa(t, c[p])) return !0;\n          }\n\n          for (var h = 0; h < t.length - 1; h++) {\n            if (to(t[h], t[h + 1], l)) return !0;\n          }\n\n          return !1;\n        }(t.cameraQueryGeometry, e - p, r - p, n + p, a + p);\n      }), d = 0, m = y; d < m.length; d += 1) {\n        h.push(m[d]);\n      }\n\n      h.sort(ap);\n\n      for (var v, g = {}, x = function x(i) {\n        var p = h[i];\n\n        if (p !== v) {\n          v = p;\n          var c = a.featureIndexArray.get(p),\n              f = null;\n          a.loadMatchingFeature(g, c.bucketIndex, c.sourceLayerIndex, c.featureIndex, u, o.layers, o.availableImages, e, r, n, function (e, r, n) {\n            return f || (f = Ua(e)), r.queryIntersectsFeature(l, e, n, f, a.z, t.transform, s, t.pixelPosMatrix);\n          });\n        }\n      }, b = 0; b < h.length; b++) {\n        x(b);\n      }\n\n      return g;\n    }, rp.prototype.loadMatchingFeature = function (t, e, r, n, i, a, o, s, u, l, p) {\n      var c = this.bucketLayerIDs[e];\n\n      if (!a || function (t, e) {\n        for (var r = 0; r < t.length; r++) {\n          if (e.indexOf(t[r]) >= 0) return !0;\n        }\n\n        return !1;\n      }(a, c)) {\n        var f = this.sourceLayerCoder.decode(r),\n            y = this.vtLayers[f].feature(n);\n\n        if (i.needGeometry) {\n          var d = ja(y, !0);\n          if (!i.filter(new ui(this.tileID.overscaledZ), d, this.tileID.canonical)) return;\n        } else if (!i.filter(new ui(this.tileID.overscaledZ), y)) return;\n\n        for (var m = this.getId(y, f), v = 0; v < c.length; v++) {\n          var g = c[v];\n\n          if (!(a && a.indexOf(g) < 0)) {\n            var x = s[g];\n\n            if (x) {\n              var b = {};\n              void 0 !== m && l && (b = l.getState(x.sourceLayer || "_geojsonTileLayer", m));\n              var w = h({}, u[g]);\n              w.paint = np(w.paint, x.paint, y, b, o), w.layout = np(w.layout, x.layout, y, b, o);\n\n              var _ = !p || p(y, x, b);\n\n              if (_) {\n                var A = new Ql(y, this.z, this.x, this.y, m);\n                A.layer = w;\n                var S = t[g];\n                void 0 === S && (S = t[g] = []), S.push({\n                  featureIndex: n,\n                  feature: A,\n                  intersectionZ: _\n                });\n              }\n            }\n          }\n        }\n      }\n    }, rp.prototype.lookupSymbolFeatures = function (t, e, r, n, i, a, o, s) {\n      var u = {};\n      this.loadVTLayers();\n\n      for (var l = sn(i), p = 0, c = t; p < c.length; p += 1) {\n        this.loadMatchingFeature(u, r, n, c[p], l, a, o, s, e);\n      }\n\n      return u;\n    }, rp.prototype.hasLayer = function (t) {\n      for (var e = 0, r = this.bucketLayerIDs; e < r.length; e += 1) {\n        for (var n = 0, i = r[e]; n < i.length; n += 1) {\n          if (t === i[n]) return !0;\n        }\n      }\n\n      return !1;\n    }, rp.prototype.getId = function (t, e) {\n      var r = t.id;\n      return this.promoteId && "boolean" == typeof (r = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]]) && (r = Number(r)), r;\n    }, On("FeatureIndex", rp, {\n      omit: ["rawTileData", "sourceLayerCoder"]\n    });\n\n    var op = function op(t, e) {\n      this.tileID = t, this.uid = y(), this.uses = 0, this.tileSize = e, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";\n    };\n\n    op.prototype.registerFadeDuration = function (t) {\n      var e = t + this.timeAdded;\n      e < R.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);\n    }, op.prototype.wasRequested = function () {\n      return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;\n    }, op.prototype.loadVectorData = function (t, e, r) {\n      if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {\n        for (var n in t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {\n          var r = {};\n          if (!e) return r;\n\n          for (var n = function n() {\n            var t = a[i],\n                n = t.layerIds.map(function (t) {\n              return e.getLayer(t);\n            }).filter(Boolean);\n\n            if (0 !== n.length) {\n              t.layers = n, t.stateDependentLayerIds && (t.stateDependentLayers = t.stateDependentLayerIds.map(function (t) {\n                return n.filter(function (e) {\n                  return e.id === t;\n                })[0];\n              }));\n\n              for (var o = 0, s = n; o < s.length; o += 1) {\n                r[s[o].id] = t;\n              }\n            }\n          }, i = 0, a = t; i < a.length; i += 1) {\n            n();\n          }\n\n          return r;\n        }(t.buckets, e.style), this.hasSymbolBuckets = !1, this.buckets) {\n          var i = this.buckets[n];\n\n          if (i instanceof gl) {\n            if (this.hasSymbolBuckets = !0, !r) break;\n            i.justReloaded = !0;\n          }\n        }\n\n        if (this.hasRTLText = !1, this.hasSymbolBuckets) for (var a in this.buckets) {\n          var o = this.buckets[a];\n\n          if (o instanceof gl && o.hasRTLText) {\n            this.hasRTLText = !0, si.isLoading() || si.isLoaded() || "deferred" !== ai() || oi();\n            break;\n          }\n        }\n\n        for (var s in this.queryPadding = 0, this.buckets) {\n          var u = this.buckets[s];\n          this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(s).queryRadius(u));\n        }\n\n        t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);\n      } else this.collisionBoxArray = new Wi();\n    }, op.prototype.unloadVectorData = function () {\n      for (var t in this.buckets) {\n        this.buckets[t].destroy();\n      }\n\n      this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";\n    }, op.prototype.getBucket = function (t) {\n      return this.buckets[t.id];\n    }, op.prototype.upload = function (t) {\n      for (var e in this.buckets) {\n        var r = this.buckets[e];\n        r.uploadPending() && r.upload(t);\n      }\n\n      var n = t.gl;\n      this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Vl(t, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Vl(t, this.glyphAtlasImage, n.ALPHA), this.glyphAtlasImage = null);\n    }, op.prototype.prepare = function (t) {\n      this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);\n    }, op.prototype.queryRenderedFeatures = function (t, e, r, n, i, a, o, s, u, l) {\n      return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({\n        queryGeometry: n,\n        cameraQueryGeometry: i,\n        scale: a,\n        tileSize: this.tileSize,\n        pixelPosMatrix: l,\n        transform: s,\n        params: o,\n        queryPadding: this.queryPadding * u\n      }, t, e, r) : {};\n    }, op.prototype.querySourceFeatures = function (t, e) {\n      var r = this.latestFeatureIndex;\n\n      if (r && r.rawTileData) {\n        var n = r.loadVTLayers(),\n            i = e ? e.sourceLayer : "",\n            a = n._geojsonTileLayer || n[i];\n        if (a) for (var o = sn(e && e.filter), s = this.tileID.canonical, u = s.z, l = s.x, p = s.y, c = {\n          z: u,\n          x: l,\n          y: p\n        }, h = 0; h < a.length; h++) {\n          var f = a.feature(h);\n\n          if (o.needGeometry) {\n            var y = ja(f, !0);\n            if (!o.filter(new ui(this.tileID.overscaledZ), y, this.tileID.canonical)) continue;\n          } else if (!o.filter(new ui(this.tileID.overscaledZ), f)) continue;\n\n          var d = r.getId(f, i),\n              m = new Ql(f, u, l, p, d);\n          m.tile = c, t.push(m);\n        }\n      }\n    }, op.prototype.hasData = function () {\n      return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;\n    }, op.prototype.patternsLoaded = function () {\n      return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n    }, op.prototype.setExpiryData = function (t) {\n      var e = this.expirationTime;\n\n      if (t.cacheControl) {\n        var r = z(t.cacheControl);\n        r["max-age"] && (this.expirationTime = Date.now() + 1e3 * r["max-age"]);\n      } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n\n      if (this.expirationTime) {\n        var n = Date.now(),\n            i = !1;\n        if (this.expirationTime > n) i = !1;else if (e) {\n          if (this.expirationTime < e) i = !0;else {\n            var a = this.expirationTime - e;\n            a ? this.expirationTime = n + Math.max(a, 3e4) : i = !0;\n          }\n        } else i = !0;\n        i ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;\n      }\n    }, op.prototype.getExpiryTimeout = function () {\n      if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n    }, op.prototype.setFeatureState = function (t, e) {\n      if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t).length) {\n        var r = this.latestFeatureIndex.loadVTLayers();\n\n        for (var n in this.buckets) {\n          if (e.style.hasLayer(n)) {\n            var i = this.buckets[n],\n                a = i.layers[0].sourceLayer || "_geojsonTileLayer",\n                o = r[a],\n                s = t[a];\n\n            if (o && s && 0 !== Object.keys(s).length) {\n              i.update(s, o, this.imageAtlas && this.imageAtlas.patternPositions || {});\n              var u = e && e.style && e.style.getLayer(n);\n              u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(i)));\n            }\n          }\n        }\n      }\n    }, op.prototype.holdingForFade = function () {\n      return void 0 !== this.symbolFadeHoldUntil;\n    }, op.prototype.symbolFadeFinished = function () {\n      return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < R.now();\n    }, op.prototype.clearFadeHold = function () {\n      this.symbolFadeHoldUntil = void 0;\n    }, op.prototype.setHoldDuration = function (t) {\n      this.symbolFadeHoldUntil = R.now() + t;\n    }, op.prototype.setDependencies = function (t, e) {\n      for (var r = {}, n = 0, i = e; n < i.length; n += 1) {\n        r[i[n]] = !0;\n      }\n\n      this.dependencies[t] = r;\n    }, op.prototype.hasDependency = function (t, e) {\n      for (var r = 0, n = t; r < n.length; r += 1) {\n        var i = this.dependencies[n[r]];\n        if (i) for (var a = 0, o = e; a < o.length; a += 1) {\n          if (i[o[a]]) return !0;\n        }\n      }\n\n      return !1;\n    };\n\n    var sp = o.performance,\n        up = function up(t) {\n      this._marks = {\n        start: [t.url, "start"].join("#"),\n        end: [t.url, "end"].join("#"),\n        measure: t.url.toString()\n      }, sp.mark(this._marks.start);\n    };\n\n    up.prototype.finish = function () {\n      sp.mark(this._marks.end);\n      var t = sp.getEntriesByName(this._marks.measure);\n      return 0 === t.length && (sp.measure(this._marks.measure, this._marks.start, this._marks.end), t = sp.getEntriesByName(this._marks.measure), sp.clearMarks(this._marks.start), sp.clearMarks(this._marks.end), sp.clearMeasures(this._marks.measure)), t;\n    }, t.Actor = Dl, t.AlphaImage = xo, t.CanonicalTileID = Xl, t.CollisionBoxArray = Wi, t.Color = ee, t.DEMData = $l, t.DataConstantProperty = vi, t.DictionaryCoder = Wl, t.EXTENT = 8192, t.ErrorEvent = Ct, t.EvaluationParameters = ui, t.Event = zt, t.Evented = Et, t.FeatureIndex = rp, t.FillBucket = us, t.FillExtrusionBucket = ks, t.ImageAtlas = wu, t.ImagePosition = xu, t.LineBucket = Ds, t.LngLat = Ol, t.LngLatBounds = Rl, t.MercatorCoordinate = Zl, t.ONE_EM = 24, t.OverscaledTileID = Hl, t.Point = i, t.Point$1 = i, t.Properties = _i, t.Protobuf = $s, t.RGBAImage = bo, t.RequestManager = G, t.RequestPerformance = up, t.ResourceType = yt, t.SegmentVector = ua, t.SourceFeatureState = ep, t.StructArrayLayout1ui2 = Hi, t.StructArrayLayout2f1f2i16 = Ui, t.StructArrayLayout2i4 = Ei, t.StructArrayLayout3ui6 = qi, t.StructArrayLayout4i8 = Pi, t.SymbolBucket = gl, t.Texture = Vl, t.Tile = op, t.Transitionable = ci, t.Uniform1f = wa, t.Uniform1i = ba, t.Uniform2f = _a, t.Uniform3f = Aa, t.Uniform4f = Sa, t.UniformColor = ka, t.UniformMatrix4f = za, t.UnwrappedTileID = Jl, t.ValidationError = Mt, t.WritingMode = _u, t.ZoomHistory = Gn, t.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }, t.addDynamicAttributes = yl, t.asyncAll = function (t, e, r) {\n      if (!t.length) return r(null, []);\n      var n = t.length,\n          i = new Array(t.length),\n          a = null;\n      t.forEach(function (t, o) {\n        e(t, function (t, e) {\n          t && (a = t), i[o] = e, 0 == --n && r(a, i);\n        });\n      });\n    }, t.bezier = u, t.bindAll = v, t.browser = R, t.cacheEntryPossiblyAdded = function (t) {\n      ++ht > ut && (t.getActor().send("enforceCacheSizeLimit", st), ht = 0);\n    }, t.clamp = p, t.clearTileCache = function (t) {\n      var e = o.caches.delete("mapbox-tiles");\n      t && e.catch(t).then(function () {\n        return t();\n      });\n    }, t.clipLine = Xu, t.clone = function (t) {\n      var e = new oo(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.clone$1 = w, t.clone$2 = function (t) {\n      var e = new oo(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }, t.collisionCircleLayout = Zs, t.config = O, t.create = function () {\n      var t = new oo(16);\n      return oo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, t.create$1 = function () {\n      var t = new oo(9);\n      return oo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }, t.create$2 = function () {\n      var t = new oo(4);\n      return oo != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n    }, t.createCommonjsModule = e, t.createExpression = Xr, t.createLayout = zi, t.createStyleLayer = function (t) {\n      return "custom" === t.type ? new zl(t) : new Cl[t.type](t);\n    }, t.cross = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = r[0],\n          s = r[1],\n          u = r[2];\n      return t[0] = i * u - a * s, t[1] = a * o - n * u, t[2] = n * s - i * o, t;\n    }, t.deepEqual = function t(e, r) {\n      if (Array.isArray(e)) {\n        if (!Array.isArray(r) || e.length !== r.length) return !1;\n\n        for (var n = 0; n < e.length; n++) {\n          if (!t(e[n], r[n])) return !1;\n        }\n\n        return !0;\n      }\n\n      if ("object" == typeof e && null !== e && null !== r) {\n        if ("object" != typeof r) return !1;\n        if (Object.keys(e).length !== Object.keys(r).length) return !1;\n\n        for (var i in e) {\n          if (!t(e[i], r[i])) return !1;\n        }\n\n        return !0;\n      }\n\n      return e === r;\n    }, t.dot = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }, t.dot$1 = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];\n    }, t.ease = l, t.emitValidationErrors = Tn, t.endsWith = g, t.enforceCacheSizeLimit = function (t) {\n      lt(), tt && tt.then(function (e) {\n        e.keys().then(function (r) {\n          for (var n = 0; n < r.length - t; n++) {\n            e.delete(r[n]);\n          }\n        });\n      });\n    }, t.evaluateSizeForFeature = Ru, t.evaluateSizeForZoom = Ou, t.evaluateVariableOffset = ol, t.evented = ii, t.extend = h, t.featureFilter = sn, t.filterObject = b, t.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n          n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, t.getAnchorAlignment = Tu, t.getAnchorJustification = sl, t.getArrayBuffer = wt, t.getImage = St, t.getJSON = function (t, e) {\n      return bt(h(t, {\n        type: "json"\n      }), e);\n    }, t.getRTLTextPluginStatus = ai, t.getReferrer = mt, t.getVideo = function (t, e) {\n      var r,\n          n,\n          i = o.document.createElement("video");\n      i.muted = !0, i.onloadstart = function () {\n        e(null, i);\n      };\n\n      for (var a = 0; a < t.length; a++) {\n        var s = o.document.createElement("source");\n        r = t[a], n = void 0, (n = o.document.createElement("a")).href = r, (n.protocol !== o.document.location.protocol || n.host !== o.document.location.host) && (i.crossOrigin = "Anonymous"), s.src = t[a], i.appendChild(s);\n      }\n\n      return {\n        cancel: function cancel() {}\n      };\n    }, t.identity = so, t.invert = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          a = e[3],\n          o = e[4],\n          s = e[5],\n          u = e[6],\n          l = e[7],\n          p = e[8],\n          c = e[9],\n          h = e[10],\n          f = e[11],\n          y = e[12],\n          d = e[13],\n          m = e[14],\n          v = e[15],\n          g = r * s - n * o,\n          x = r * u - i * o,\n          b = r * l - a * o,\n          w = n * u - i * s,\n          _ = n * l - a * s,\n          A = i * l - a * u,\n          S = p * d - c * y,\n          k = p * m - h * y,\n          I = p * v - f * y,\n          z = c * m - h * d,\n          C = c * v - f * d,\n          E = h * v - f * m,\n          P = g * E - x * C + b * z + w * I - _ * k + A * S;\n\n      return P ? (t[0] = (s * E - u * C + l * z) * (P = 1 / P), t[1] = (i * C - n * E - a * z) * P, t[2] = (d * A - m * _ + v * w) * P, t[3] = (h * _ - c * A - f * w) * P, t[4] = (u * I - o * E - l * k) * P, t[5] = (r * E - i * I + a * k) * P, t[6] = (m * b - y * A - v * x) * P, t[7] = (p * A - h * b + f * x) * P, t[8] = (o * C - s * I + l * S) * P, t[9] = (n * I - r * C - a * S) * P, t[10] = (y * _ - d * b + v * g) * P, t[11] = (c * b - p * _ - f * g) * P, t[12] = (s * k - o * z - u * S) * P, t[13] = (r * z - n * k + i * S) * P, t[14] = (d * x - y * w - m * g) * P, t[15] = (p * w - c * x + h * g) * P, t) : null;\n    }, t.isChar = Zn, t.isMapboxURL = Z, t.keysDifference = function (t, e) {\n      var r = [];\n\n      for (var n in t) {\n        n in e || r.push(n);\n      }\n\n      return r;\n    }, t.makeRequest = bt, t.mapObject = x, t.mercatorXfromLng = ql, t.mercatorYfromLat = Nl, t.mercatorZfromAltitude = Kl, t.mul = po, t.multiply = uo, t.mvt = ws, t.nextPowerOfTwo = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }, t.normalize = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          a = r * r + n * n + i * i;\n      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;\n    }, t.number = Ge, t.offscreenCanvasSupported = ft, t.ortho = function (t, e, r, n, i, a, o) {\n      var s = 1 / (e - r),\n          u = 1 / (n - i),\n          l = 1 / (a - o);\n      return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + r) * s, t[13] = (i + n) * u, t[14] = (o + a) * l, t[15] = 1, t;\n    }, t.parseGlyphPBF = function (t) {\n      return new $s(t).readFields(du, []);\n    }, t.pbf = $s, t.performSymbolLayout = function (t, e, r, n, i, a, o) {\n      t.createArrays(), t.tilePixelRatio = 8192 / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      var s = t.layers[0].layout,\n          u = t.layers[0]._unevaluatedLayout._values,\n          l = {};\n\n      if ("composite" === t.textSizeData.kind) {\n        var p = t.textSizeData,\n            c = p.maxZoom;\n        l.compositeTextSizes = [u["text-size"].possiblyEvaluate(new ui(p.minZoom), o), u["text-size"].possiblyEvaluate(new ui(c), o)];\n      }\n\n      if ("composite" === t.iconSizeData.kind) {\n        var h = t.iconSizeData,\n            f = h.maxZoom;\n        l.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new ui(h.minZoom), o), u["icon-size"].possiblyEvaluate(new ui(f), o)];\n      }\n\n      l.layoutTextSize = u["text-size"].possiblyEvaluate(new ui(t.zoom + 1), o), l.layoutIconSize = u["icon-size"].possiblyEvaluate(new ui(t.zoom + 1), o), l.textMaxSize = u["text-size"].possiblyEvaluate(new ui(18));\n\n      for (var y = 24 * s.get("text-line-height"), d = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement"), m = s.get("text-keep-upright"), v = s.get("text-size"), g = function g() {\n        var a = b[x],\n            u = s.get("text-font").evaluate(a, {}, o).join(","),\n            p = v.evaluate(a, {}, o),\n            c = l.layoutTextSize.evaluate(a, {}, o),\n            h = l.layoutIconSize.evaluate(a, {}, o),\n            f = {\n          horizontal: {},\n          vertical: void 0\n        },\n            g = a.text,\n            w = [0, 0];\n\n        if (g) {\n          var _ = g.toString(),\n              S = 24 * s.get("text-letter-spacing").evaluate(a, {}, o),\n              k = function (t) {\n            for (var e = 0, r = t; e < r.length; e += 1) {\n              if (n = r[e].charCodeAt(0), Zn.Arabic(n) || Zn["Arabic Supplement"](n) || Zn["Arabic Extended-A"](n) || Zn["Arabic Presentation Forms-A"](n) || Zn["Arabic Presentation Forms-B"](n)) return !1;\n            }\n\n            var n;\n            return !0;\n          }(_) ? S : 0,\n              I = s.get("text-anchor").evaluate(a, {}, o),\n              z = s.get("text-variable-anchor");\n\n          if (!z) {\n            var C = s.get("text-radial-offset").evaluate(a, {}, o);\n            w = C ? ol(I, [24 * C, al]) : s.get("text-offset").evaluate(a, {}, o).map(function (t) {\n              return 24 * t;\n            });\n          }\n\n          var E = d ? "center" : s.get("text-justify").evaluate(a, {}, o),\n              P = s.get("symbol-placement"),\n              M = "point" === P ? 24 * s.get("text-max-width").evaluate(a, {}, o) : 0,\n              B = function B() {\n            t.allowVerticalPlacement && Xn(_) && (f.vertical = ku(g, e, r, i, u, M, y, I, "left", k, w, _u.vertical, !0, P, c, p));\n          };\n\n          if (!d && z) {\n            for (var T = "auto" === E ? z.map(function (t) {\n              return sl(t);\n            }) : [E], V = !1, F = 0; F < T.length; F++) {\n              var D = T[F];\n              if (!f.horizontal[D]) if (V) f.horizontal[D] = f.horizontal[0];else {\n                var L = ku(g, e, r, i, u, M, y, "center", D, k, w, _u.horizontal, !1, P, c, p);\n                L && (f.horizontal[D] = L, V = 1 === L.positionedLines.length);\n              }\n            }\n\n            B();\n          } else {\n            "auto" === E && (E = sl(I));\n            var R = ku(g, e, r, i, u, M, y, I, E, k, w, _u.horizontal, !1, P, c, p);\n            R && (f.horizontal[E] = R), B(), Xn(_) && d && m && (f.vertical = ku(g, e, r, i, u, M, y, I, E, k, w, _u.vertical, !1, P, c, p));\n          }\n        }\n\n        var O = void 0,\n            U = !1;\n\n        if (a.icon && a.icon.name) {\n          var j = n[a.icon.name];\n          j && (O = function (t, e, r) {\n            var n = Tu(r),\n                i = e[0] - t.displaySize[0] * n.horizontalAlign,\n                a = e[1] - t.displaySize[1] * n.verticalAlign;\n            return {\n              image: t,\n              top: a,\n              bottom: a + t.displaySize[1],\n              left: i,\n              right: i + t.displaySize[0]\n            };\n          }(i[a.icon.name], s.get("icon-offset").evaluate(a, {}, o), s.get("icon-anchor").evaluate(a, {}, o)), U = j.sdf, void 0 === t.sdfIcons ? t.sdfIcons = j.sdf : t.sdfIcons !== j.sdf && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j.pixelRatio !== t.pixelRatio || 0 !== s.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));\n        }\n\n        var q = ll(f.horizontal) || f.vertical;\n        t.iconsInText = !!q && q.iconsInText, (q || O) && function (t, e, r, n, i, a, o, s, u, l, p) {\n          var c = a.textMaxSize.evaluate(e, {});\n          void 0 === c && (c = o);\n\n          var h,\n              f = t.layers[0].layout,\n              y = f.get("icon-offset").evaluate(e, {}, p),\n              d = ll(r.horizontal),\n              m = o / 24,\n              v = t.tilePixelRatio * m,\n              g = t.tilePixelRatio * c / 24,\n              x = t.tilePixelRatio * s,\n              b = t.tilePixelRatio * f.get("symbol-spacing"),\n              w = f.get("text-padding") * t.tilePixelRatio,\n              _ = f.get("icon-padding") * t.tilePixelRatio,\n              S = f.get("text-max-angle") / 180 * Math.PI,\n              k = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"),\n              I = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"),\n              z = f.get("symbol-placement"),\n              C = b / 2,\n              E = f.get("icon-text-fit");\n\n          n && "none" !== E && (t.allowVerticalPlacement && r.vertical && (h = Fu(n, r.vertical, E, f.get("icon-text-fit-padding"), y, m)), d && (n = Fu(n, d, E, f.get("icon-text-fit-padding"), y, m)));\n\n          var P = function P(s, c) {\n            c.x < 0 || c.x >= 8192 || c.y < 0 || c.y >= 8192 || function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, S, k) {\n              var I,\n                  z,\n                  C,\n                  E,\n                  P,\n                  M = t.addToLineVertexArray(e, r),\n                  B = 0,\n                  T = 0,\n                  V = 0,\n                  F = 0,\n                  D = -1,\n                  L = -1,\n                  R = {},\n                  O = fa(""),\n                  U = 0,\n                  j = 0;\n\n              if (void 0 === s._unevaluatedLayout.getValue("text-radial-offset") ? (U = (I = s.layout.get("text-offset").evaluate(b, {}, S).map(function (t) {\n                return 24 * t;\n              }))[0], j = I[1]) : (U = 24 * s.layout.get("text-radial-offset").evaluate(b, {}, S), j = al), t.allowVerticalPlacement && n.vertical) {\n                var q = s.layout.get("text-rotate").evaluate(b, {}, S) + 90;\n                E = new Qu(u, e, l, p, c, n.vertical, h, f, y, q), o && (P = new Qu(u, e, l, p, c, o, m, v, y, q));\n              }\n\n              if (i) {\n                var N = s.layout.get("icon-rotate").evaluate(b, {}),\n                    K = "none" !== s.layout.get("icon-text-fit"),\n                    G = Ju(i, N, _, K),\n                    Z = o ? Ju(o, N, _, K) : void 0;\n                C = new Qu(u, e, l, p, c, i, m, v, !1, N), B = 4 * G.length;\n                var X = t.iconSizeData,\n                    J = null;\n                "source" === X.kind ? (J = [128 * s.layout.get("icon-size").evaluate(b, {})])[0] > 32640 && A(t.layerIds[0] + \': Value for "icon-size" is >= 255. Reduce your "icon-size".\') : "composite" === X.kind && ((J = [128 * w.compositeIconSizes[0].evaluate(b, {}, S), 128 * w.compositeIconSizes[1].evaluate(b, {}, S)])[0] > 32640 || J[1] > 32640) && A(t.layerIds[0] + \': Value for "icon-size" is >= 255. Reduce your "icon-size".\'), t.addSymbols(t.icon, G, J, x, g, b, !1, e, M.lineStartIndex, M.lineLength, -1, S), D = t.icon.placedSymbolArray.length - 1, Z && (T = 4 * Z.length, t.addSymbols(t.icon, Z, J, x, g, b, _u.vertical, e, M.lineStartIndex, M.lineLength, -1, S), L = t.icon.placedSymbolArray.length - 1);\n              }\n\n              for (var H in n.horizontal) {\n                var Y = n.horizontal[H];\n\n                if (!z) {\n                  O = fa(Y.text);\n                  var $ = s.layout.get("text-rotate").evaluate(b, {}, S);\n                  z = new Qu(u, e, l, p, c, Y, h, f, y, $);\n                }\n\n                var W = 1 === Y.positionedLines.length;\n                if (V += ul(t, e, Y, a, s, y, b, d, M, n.vertical ? _u.horizontal : _u.horizontalOnly, W ? Object.keys(n.horizontal) : [H], R, D, w, S), W) break;\n              }\n\n              n.vertical && (F += ul(t, e, n.vertical, a, s, y, b, d, M, _u.vertical, ["vertical"], R, L, w, S));\n\n              var Q = z ? z.boxStartIndex : t.collisionBoxArray.length,\n                  tt = z ? z.boxEndIndex : t.collisionBoxArray.length,\n                  et = E ? E.boxStartIndex : t.collisionBoxArray.length,\n                  rt = E ? E.boxEndIndex : t.collisionBoxArray.length,\n                  nt = C ? C.boxStartIndex : t.collisionBoxArray.length,\n                  it = C ? C.boxEndIndex : t.collisionBoxArray.length,\n                  at = P ? P.boxStartIndex : t.collisionBoxArray.length,\n                  ot = P ? P.boxEndIndex : t.collisionBoxArray.length,\n                  st = -1,\n                  ut = function ut(t, e) {\n                return t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e;\n              };\n\n              st = ut(z, st), st = ut(E, st), st = ut(C, st);\n              var lt = (st = ut(P, st)) > -1 ? 1 : 0;\n              lt && (st *= k / 24), t.glyphOffsetArray.length >= gl.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, R.right >= 0 ? R.right : -1, R.center >= 0 ? R.center : -1, R.left >= 0 ? R.left : -1, R.vertical || -1, D, L, O, Q, tt, et, rt, nt, it, at, ot, l, V, F, B, T, lt, 0, h, U, j, st);\n            }(t, c, s, r, n, i, h, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, v, w, k, u, x, _, I, y, e, a, l, p, o);\n          };\n\n          if ("line" === z) for (var M = 0, B = Xu(e.geometry, 0, 0, 8192, 8192); M < B.length; M += 1) {\n            for (var T = B[M], V = 0, F = Zu(T, b, S, r.vertical || d, n, 24, g, t.overscaling, 8192); V < F.length; V += 1) {\n              var D = F[V];\n              d && pl(t, d.text, C, D) || P(T, D);\n            }\n          } else if ("line-center" === z) for (var L = 0, R = e.geometry; L < R.length; L += 1) {\n            var O = R[L];\n\n            if (O.length > 1) {\n              var U = Gu(O, S, r.vertical || d, n, 24, g);\n              U && P(O, U);\n            }\n          } else if ("Polygon" === e.type) for (var j = 0, q = is(e.geometry, 0); j < q.length; j += 1) {\n            var N = q[j],\n                K = rl(N, 16);\n            P(N[0], new Du(K.x, K.y, 0));\n          } else if ("LineString" === e.type) for (var G = 0, Z = e.geometry; G < Z.length; G += 1) {\n            var X = Z[G];\n            P(X, new Du(X[0].x, X[0].y, 0));\n          } else if ("Point" === e.type) for (var J = 0, H = e.geometry; J < H.length; J += 1) {\n            for (var Y = 0, $ = H[J]; Y < $.length; Y += 1) {\n              var W = $[Y];\n              P([W], new Du(W.x, W.y, 0));\n            }\n          }\n        }(t, a, f, O, n, l, c, h, w, U, o);\n      }, x = 0, b = t.features; x < b.length; x += 1) {\n        g();\n      }\n\n      a && t.generateCollisionDebugBuffers();\n    }, t.perspective = function (t, e, r, n, i) {\n      var a,\n          o = 1 / Math.tan(e / 2);\n      return t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (a = 1 / (n - i)), t[14] = 2 * i * n * a) : (t[10] = -1, t[14] = -2 * n), t;\n    }, t.pick = function (t, e) {\n      for (var r = {}, n = 0; n < e.length; n++) {\n        var i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n\n      return r;\n    }, t.plugin = si, t.polygonIntersectsPolygon = Ka, t.postMapLoadEvent = ot, t.postTurnstileEvent = it, t.potpack = gu, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = On, t.registerForPluginStateChange = function (t) {\n      return t({\n        pluginStatus: ti,\n        pluginURL: ei\n      }), ii.on("pluginStateChange", t), t;\n    }, t.renderColorRamp = _o, t.rotate = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2],\n          o = e[3],\n          s = Math.sin(r),\n          u = Math.cos(r);\n      return t[0] = n * u + a * s, t[1] = i * u + o * s, t[2] = n * -s + a * u, t[3] = i * -s + o * u, t;\n    }, t.rotateX = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          a = e[4],\n          o = e[5],\n          s = e[6],\n          u = e[7],\n          l = e[8],\n          p = e[9],\n          c = e[10],\n          h = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + l * n, t[5] = o * i + p * n, t[6] = s * i + c * n, t[7] = u * i + h * n, t[8] = l * i - a * n, t[9] = p * i - o * n, t[10] = c * i - s * n, t[11] = h * i - u * n, t;\n    }, t.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          a = e[0],\n          o = e[1],\n          s = e[2],\n          u = e[3],\n          l = e[4],\n          p = e[5],\n          c = e[6],\n          h = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + l * n, t[1] = o * i + p * n, t[2] = s * i + c * n, t[3] = u * i + h * n, t[4] = l * i - a * n, t[5] = p * i - o * n, t[6] = c * i - s * n, t[7] = h * i - u * n, t;\n    }, t.scale = function (t, e, r) {\n      var n = r[0],\n          i = r[1],\n          a = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }, t.scale$1 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, t.scale$2 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }, t.setCacheLimits = function (t, e) {\n      st = t, ut = e;\n    }, t.setRTLTextPlugin = function (t, e, r) {\n      if (void 0 === r && (r = !1), "deferred" === ti || "loading" === ti || "loaded" === ti) throw new Error("setRTLTextPlugin cannot be called multiple times.");\n      ei = R.resolveURL(t), ti = "deferred", Qn = e, ni(), r || oi();\n    }, t.sphericalToCartesian = function (t) {\n      var e = t[0],\n          r = t[1],\n          n = t[2];\n      return r += 90, r *= Math.PI / 180, n *= Math.PI / 180, {\n        x: e * Math.cos(r) * Math.sin(n),\n        y: e * Math.sin(r) * Math.sin(n),\n        z: e * Math.cos(n)\n      };\n    }, t.sqrLen = function (t) {\n      var e = t[0],\n          r = t[1];\n      return e * e + r * r;\n    }, t.styleSpec = Pt, t.sub = function (t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }, t.symbolSize = Uu, t.transformMat3 = function (t, e, r) {\n      var n = e[0],\n          i = e[1],\n          a = e[2];\n      return t[0] = n * r[0] + i * r[3] + a * r[6], t[1] = n * r[1] + i * r[4] + a * r[7], t[2] = n * r[2] + i * r[5] + a * r[8], t;\n    }, t.transformMat4 = co, t.translate = function (t, e, r) {\n      var n,\n          i,\n          a,\n          o,\n          s,\n          u,\n          l,\n          p,\n          c,\n          h,\n          f,\n          y,\n          d = r[0],\n          m = r[1],\n          v = r[2];\n      return e === t ? (t[12] = e[0] * d + e[4] * m + e[8] * v + e[12], t[13] = e[1] * d + e[5] * m + e[9] * v + e[13], t[14] = e[2] * d + e[6] * m + e[10] * v + e[14], t[15] = e[3] * d + e[7] * m + e[11] * v + e[15]) : (i = e[1], a = e[2], o = e[3], s = e[4], u = e[5], l = e[6], p = e[7], c = e[8], h = e[9], f = e[10], y = e[11], t[0] = n = e[0], t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = u, t[6] = l, t[7] = p, t[8] = c, t[9] = h, t[10] = f, t[11] = y, t[12] = n * d + s * m + c * v + e[12], t[13] = i * d + u * m + h * v + e[13], t[14] = a * d + l * m + f * v + e[14], t[15] = o * d + p * m + y * v + e[15]), t;\n    }, t.triggerPluginCompletionEvent = ri, t.uniqueId = y, t.validateCustomStyleLayer = function (t) {\n      var e = [],\n          r = t.id;\n      return void 0 === r && e.push({\n        message: "layers." + r + \': missing required property "id"\'\n      }), void 0 === t.render && e.push({\n        message: "layers." + r + \': missing required method "render"\'\n      }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({\n        message: "layers." + r + \': property "renderingMode" must be either "2d" or "3d"\'\n      }), e;\n    }, t.validateLight = Pn, t.validateStyle = En, t.values = function (t) {\n      var e = [];\n\n      for (var r in t) {\n        e.push(t[r]);\n      }\n\n      return e;\n    }, t.vectorTile = ws, t.version = "1.15.0", t.warnOnce = A, t.webpSupported = U, t.window = o, t.wrap = c;\n  });\n  define(["./shared"], function (e) {\n    "use strict";\n\n    function t(e) {\n      var r = typeof e;\n      if ("number" === r || "boolean" === r || "string" === r || null == e) return JSON.stringify(e);\n\n      if (Array.isArray(e)) {\n        for (var i = "[", o = 0, n = e; o < n.length; o += 1) {\n          i += t(n[o]) + ",";\n        }\n\n        return i + "]";\n      }\n\n      for (var s = Object.keys(e).sort(), a = "{", l = 0; l < s.length; l++) {\n        a += JSON.stringify(s[l]) + ":" + t(e[s[l]]) + ",";\n      }\n\n      return a + "}";\n    }\n\n    function r(r) {\n      for (var i = "", o = 0, n = e.refProperties; o < n.length; o += 1) {\n        i += "/" + t(r[n[o]]);\n      }\n\n      return i;\n    }\n\n    var i = function i(e) {\n      this.keyCache = {}, e && this.replace(e);\n    };\n\n    i.prototype.replace = function (e) {\n      this._layerConfigs = {}, this._layers = {}, this.update(e, []);\n    }, i.prototype.update = function (t, i) {\n      for (var o = this, n = 0, s = t; n < s.length; n += 1) {\n        var a = s[n];\n        this._layerConfigs[a.id] = a;\n        var l = this._layers[a.id] = e.createStyleLayer(a);\n        l._featureFilter = e.featureFilter(l.filter), this.keyCache[a.id] && delete this.keyCache[a.id];\n      }\n\n      for (var u = 0, h = i; u < h.length; u += 1) {\n        var c = h[u];\n        delete this.keyCache[c], delete this._layerConfigs[c], delete this._layers[c];\n      }\n\n      this.familiesBySource = {};\n\n      for (var p = 0, f = function (e, t) {\n        for (var i = {}, o = 0; o < e.length; o++) {\n          var n = t && t[e[o].id] || r(e[o]);\n          t && (t[e[o].id] = n);\n          var s = i[n];\n          s || (s = i[n] = []), s.push(e[o]);\n        }\n\n        var a = [];\n\n        for (var l in i) {\n          a.push(i[l]);\n        }\n\n        return a;\n      }(e.values(this._layerConfigs), this.keyCache); p < f.length; p += 1) {\n        var d = f[p].map(function (e) {\n          return o._layers[e.id];\n        }),\n            g = d[0];\n\n        if ("none" !== g.visibility) {\n          var v = g.source || "",\n              m = this.familiesBySource[v];\n          m || (m = this.familiesBySource[v] = {});\n          var y = g.sourceLayer || "_geojsonTileLayer",\n              x = m[y];\n          x || (x = m[y] = []), x.push(d);\n        }\n      }\n    };\n\n    var o = function o(t) {\n      var r = {},\n          i = [];\n\n      for (var o in t) {\n        var n = t[o],\n            s = r[o] = {};\n\n        for (var a in n) {\n          var l = n[+a];\n\n          if (l && 0 !== l.bitmap.width && 0 !== l.bitmap.height) {\n            var u = {\n              x: 0,\n              y: 0,\n              w: l.bitmap.width + 2,\n              h: l.bitmap.height + 2\n            };\n            i.push(u), s[a] = {\n              rect: u,\n              metrics: l.metrics\n            };\n          }\n        }\n      }\n\n      var h = e.potpack(i),\n          c = new e.AlphaImage({\n        width: h.w || 1,\n        height: h.h || 1\n      });\n\n      for (var p in t) {\n        var f = t[p];\n\n        for (var d in f) {\n          var g = f[+d];\n\n          if (g && 0 !== g.bitmap.width && 0 !== g.bitmap.height) {\n            var v = r[p][d].rect;\n            e.AlphaImage.copy(g.bitmap, c, {\n              x: 0,\n              y: 0\n            }, {\n              x: v.x + 1,\n              y: v.y + 1\n            }, g.bitmap);\n          }\n        }\n      }\n\n      this.image = c, this.positions = r;\n    };\n\n    e.register("GlyphAtlas", o);\n\n    var n = function n(t) {\n      this.tileID = new e.OverscaledTileID(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId;\n    };\n\n    function s(t, r, i) {\n      for (var o = new e.EvaluationParameters(r), n = 0, s = t; n < s.length; n += 1) {\n        s[n].recalculate(o, i);\n      }\n    }\n\n    function a(t, r) {\n      var i = e.getArrayBuffer(t.request, function (t, i, o, n) {\n        t ? r(t) : i && r(null, {\n          vectorTile: new e.vectorTile.VectorTile(new e.pbf(i)),\n          rawData: i,\n          cacheControl: o,\n          expires: n\n        });\n      });\n      return function () {\n        i.cancel(), r();\n      };\n    }\n\n    n.prototype.parse = function (t, r, i, n, a) {\n      var l = this;\n      this.status = "parsing", this.data = t, this.collisionBoxArray = new e.CollisionBoxArray();\n      var u = new e.DictionaryCoder(Object.keys(t.layers).sort()),\n          h = new e.FeatureIndex(this.tileID, this.promoteId);\n      h.bucketLayerIDs = [];\n      var c,\n          p,\n          f,\n          d,\n          g = {},\n          v = {\n        featureIndex: h,\n        iconDependencies: {},\n        patternDependencies: {},\n        glyphDependencies: {},\n        availableImages: i\n      },\n          m = r.familiesBySource[this.source];\n\n      for (var y in m) {\n        var x = t.layers[y];\n\n        if (x) {\n          1 === x.version && e.warnOnce(\'Vector tile source "\' + this.source + \'" layer "\' + y + \'" does not use vector tile spec v2 and therefore may have some rendering errors.\');\n\n          for (var w = u.encode(y), S = [], I = 0; I < x.length; I++) {\n            var M = x.feature(I),\n                b = h.getId(M, y);\n            S.push({\n              feature: M,\n              id: b,\n              index: I,\n              sourceLayerIndex: w\n            });\n          }\n\n          for (var _ = 0, k = m[y]; _ < k.length; _ += 1) {\n            var P = k[_],\n                T = P[0];\n            T.minzoom && this.zoom < Math.floor(T.minzoom) || T.maxzoom && this.zoom >= T.maxzoom || "none" !== T.visibility && (s(P, this.zoom, i), (g[T.id] = T.createBucket({\n              index: h.bucketLayerIDs.length,\n              layers: P,\n              zoom: this.zoom,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: w,\n              sourceID: this.source\n            })).populate(S, v, this.tileID.canonical), h.bucketLayerIDs.push(P.map(function (e) {\n              return e.id;\n            })));\n          }\n        }\n      }\n\n      var C = e.mapObject(v.glyphDependencies, function (e) {\n        return Object.keys(e).map(Number);\n      });\n      Object.keys(C).length ? n.send("getGlyphs", {\n        uid: this.uid,\n        stacks: C\n      }, function (e, t) {\n        c || (c = e, p = t, z.call(l));\n      }) : p = {};\n      var D = Object.keys(v.iconDependencies);\n      D.length ? n.send("getImages", {\n        icons: D,\n        source: this.source,\n        tileID: this.tileID,\n        type: "icons"\n      }, function (e, t) {\n        c || (c = e, f = t, z.call(l));\n      }) : f = {};\n      var L = Object.keys(v.patternDependencies);\n\n      function z() {\n        if (c) return a(c);\n\n        if (p && f && d) {\n          var t = new o(p),\n              r = new e.ImageAtlas(f, d);\n\n          for (var n in g) {\n            var l = g[n];\n            l instanceof e.SymbolBucket ? (s(l.layers, this.zoom, i), e.performSymbolLayout(l, p, t.positions, f, r.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l.hasPattern && (l instanceof e.LineBucket || l instanceof e.FillBucket || l instanceof e.FillExtrusionBucket) && (s(l.layers, this.zoom, i), l.addFeatures(v, this.tileID.canonical, r.patternPositions));\n          }\n\n          this.status = "done", a(null, {\n            buckets: e.values(g).filter(function (e) {\n              return !e.isEmpty();\n            }),\n            featureIndex: h,\n            collisionBoxArray: this.collisionBoxArray,\n            glyphAtlasImage: t.image,\n            imageAtlas: r,\n            glyphMap: this.returnDependencies ? p : null,\n            iconMap: this.returnDependencies ? f : null,\n            glyphPositions: this.returnDependencies ? t.positions : null\n          });\n        }\n      }\n\n      L.length ? n.send("getImages", {\n        icons: L,\n        source: this.source,\n        tileID: this.tileID,\n        type: "patterns"\n      }, function (e, t) {\n        c || (c = e, d = t, z.call(l));\n      }) : d = {}, z.call(this);\n    };\n\n    var l = function l(e, t, r, i) {\n      this.actor = e, this.layerIndex = t, this.availableImages = r, this.loadVectorData = i || a, this.loading = {}, this.loaded = {};\n    };\n\n    l.prototype.loadTile = function (t, r) {\n      var i = this,\n          o = t.uid;\n      this.loading || (this.loading = {});\n      var s = !!(t && t.request && t.request.collectResourceTiming) && new e.RequestPerformance(t.request),\n          a = this.loading[o] = new n(t);\n      a.abort = this.loadVectorData(t, function (t, n) {\n        if (delete i.loading[o], t || !n) return a.status = "done", i.loaded[o] = a, r(t);\n        var l = n.rawData,\n            u = {};\n        n.expires && (u.expires = n.expires), n.cacheControl && (u.cacheControl = n.cacheControl);\n        var h = {};\n\n        if (s) {\n          var c = s.finish();\n          c && (h.resourceTiming = JSON.parse(JSON.stringify(c)));\n        }\n\n        a.vectorTile = n.vectorTile, a.parse(n.vectorTile, i.layerIndex, i.availableImages, i.actor, function (t, i) {\n          if (t || !i) return r(t);\n          r(null, e.extend({\n            rawTileData: l.slice(0)\n          }, i, u, h));\n        }), i.loaded = i.loaded || {}, i.loaded[o] = a;\n      });\n    }, l.prototype.reloadTile = function (e, t) {\n      var r = this,\n          i = this.loaded,\n          o = e.uid,\n          n = this;\n\n      if (i && i[o]) {\n        var s = i[o];\n        s.showCollisionBoxes = e.showCollisionBoxes;\n\n        var a = function a(e, i) {\n          var o = s.reloadCallback;\n          o && (delete s.reloadCallback, s.parse(s.vectorTile, n.layerIndex, r.availableImages, n.actor, o)), t(e, i);\n        };\n\n        "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());\n      }\n    }, l.prototype.abortTile = function (e, t) {\n      var r = this.loading,\n          i = e.uid;\n      r && r[i] && r[i].abort && (r[i].abort(), delete r[i]), t();\n    }, l.prototype.removeTile = function (e, t) {\n      var r = this.loaded,\n          i = e.uid;\n      r && r[i] && delete r[i], t();\n    };\n\n    var u = e.window.ImageBitmap,\n        h = function h() {\n      this.loaded = {};\n    };\n\n    function c(e, t) {\n      if (0 !== e.length) {\n        p(e[0], t);\n\n        for (var r = 1; r < e.length; r++) {\n          p(e[r], !t);\n        }\n      }\n    }\n\n    function p(e, t) {\n      for (var r = 0, i = 0, o = e.length, n = o - 1; i < o; n = i++) {\n        r += (e[i][0] - e[n][0]) * (e[n][1] + e[i][1]);\n      }\n\n      r >= 0 != !!t && e.reverse();\n    }\n\n    h.prototype.loadTile = function (t, r) {\n      var i = t.uid,\n          o = t.encoding,\n          n = t.rawImageData,\n          s = u && n instanceof u ? this.getImageData(n) : n,\n          a = new e.DEMData(i, s, o);\n      this.loaded = this.loaded || {}, this.loaded[i] = a, r(null, a);\n    }, h.prototype.getImageData = function (t) {\n      this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width, t.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t.width, this.offscreenCanvas.height = t.height, this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);\n      var r = this.offscreenCanvasContext.getImageData(-1, -1, t.width + 2, t.height + 2);\n      return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({\n        width: r.width,\n        height: r.height\n      }, r.data);\n    }, h.prototype.removeTile = function (e) {\n      var t = this.loaded,\n          r = e.uid;\n      t && t[r] && delete t[r];\n    };\n\n    var f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON,\n        d = function d(t) {\n      this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n    };\n\n    d.prototype.loadGeometry = function () {\n      if (1 === this._feature.type) {\n        for (var t = [], r = 0, i = this._feature.geometry; r < i.length; r += 1) {\n          var o = i[r];\n          t.push([new e.Point$1(o[0], o[1])]);\n        }\n\n        return t;\n      }\n\n      for (var n = [], s = 0, a = this._feature.geometry; s < a.length; s += 1) {\n        for (var l = [], u = 0, h = a[s]; u < h.length; u += 1) {\n          var c = h[u];\n          l.push(new e.Point$1(c[0], c[1]));\n        }\n\n        n.push(l);\n      }\n\n      return n;\n    }, d.prototype.toGeoJSON = function (e, t, r) {\n      return f.call(this, e, t, r);\n    };\n\n    var g = function g(t) {\n      this.layers = {\n        _geojsonTileLayer: this\n      }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t;\n    };\n\n    g.prototype.feature = function (e) {\n      return new d(this._features[e]);\n    };\n\n    var v = e.vectorTile.VectorTileFeature,\n        m = y;\n\n    function y(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n\n    function x(e, t) {\n      this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n\n    y.prototype.feature = function (e) {\n      return new x(this.features[e], this.options.extent);\n    }, x.prototype.loadGeometry = function () {\n      var t = this.rawGeometry;\n      this.geometry = [];\n\n      for (var r = 0; r < t.length; r++) {\n        for (var i = t[r], o = [], n = 0; n < i.length; n++) {\n          o.push(new e.Point$1(i[n][0], i[n][1]));\n        }\n\n        this.geometry.push(o);\n      }\n\n      return this.geometry;\n    }, x.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n\n      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, i = 1 / 0, o = -1 / 0, n = 0; n < e.length; n++) {\n        for (var s = e[n], a = 0; a < s.length; a++) {\n          var l = s[a];\n          t = Math.min(t, l.x), r = Math.max(r, l.x), i = Math.min(i, l.y), o = Math.max(o, l.y);\n        }\n      }\n\n      return [t, i, r, o];\n    }, x.prototype.toGeoJSON = v.prototype.toGeoJSON;\n    var w = I,\n        S = m;\n\n    function I(t) {\n      var r = new e.pbf();\n      return function (e, t) {\n        for (var r in e.layers) {\n          t.writeMessage(3, M, e.layers[r]);\n        }\n      }(t, r), r.finish();\n    }\n\n    function M(e, t) {\n      var r;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);\n      var i = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n\n      for (r = 0; r < e.length; r++) {\n        i.feature = e.feature(r), t.writeMessage(2, b, i);\n      }\n\n      var o = i.keys;\n\n      for (r = 0; r < o.length; r++) {\n        t.writeStringField(3, o[r]);\n      }\n\n      var n = i.values;\n\n      for (r = 0; r < n.length; r++) {\n        t.writeMessage(4, C, n[r]);\n      }\n    }\n\n    function b(e, t) {\n      var r = e.feature;\n      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, _, e), t.writeVarintField(3, r.type), t.writeMessage(4, T, r);\n    }\n\n    function _(e, t) {\n      var r = e.feature,\n          i = e.keys,\n          o = e.values,\n          n = e.keycache,\n          s = e.valuecache;\n\n      for (var a in r.properties) {\n        var l = n[a];\n        void 0 === l && (i.push(a), n[a] = l = i.length - 1), t.writeVarint(l);\n        var u = r.properties[a],\n            h = typeof u;\n        "string" !== h && "boolean" !== h && "number" !== h && (u = JSON.stringify(u));\n        var c = h + ":" + u,\n            p = s[c];\n        void 0 === p && (o.push(u), s[c] = p = o.length - 1), t.writeVarint(p);\n      }\n    }\n\n    function k(e, t) {\n      return (t << 3) + (7 & e);\n    }\n\n    function P(e) {\n      return e << 1 ^ e >> 31;\n    }\n\n    function T(e, t) {\n      for (var r = e.loadGeometry(), i = e.type, o = 0, n = 0, s = r.length, a = 0; a < s; a++) {\n        var l = r[a],\n            u = 1;\n        1 === i && (u = l.length), t.writeVarint(k(1, u));\n\n        for (var h = 3 === i ? l.length - 1 : l.length, c = 0; c < h; c++) {\n          1 === c && 1 !== i && t.writeVarint(k(2, h - 1));\n          var p = l[c].x - o,\n              f = l[c].y - n;\n          t.writeVarint(P(p)), t.writeVarint(P(f)), o += p, n += f;\n        }\n\n        3 === i && t.writeVarint(k(7, 1));\n      }\n    }\n\n    function C(e, t) {\n      var r = typeof e;\n      "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n\n    function D(e, t, r, i) {\n      L(e, r, i), L(t, 2 * r, 2 * i), L(t, 2 * r + 1, 2 * i + 1);\n    }\n\n    function L(e, t, r) {\n      var i = e[t];\n      e[t] = e[r], e[r] = i;\n    }\n\n    function z(e, t, r, i) {\n      var o = e - r,\n          n = t - i;\n      return o * o + n * n;\n    }\n\n    w.fromVectorTileJs = I, w.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var r = {};\n\n      for (var i in e) {\n        r[i] = new m(e[i].features, t), r[i].name = i, r[i].version = t.version, r[i].extent = t.extent;\n      }\n\n      return I({\n        layers: r\n      });\n    }, w.GeoJSONWrapper = S;\n\n    var O = function O(e) {\n      return e[0];\n    },\n        E = function E(e) {\n      return e[1];\n    },\n        F = function F(e, t, r, i, o) {\n      void 0 === t && (t = O), void 0 === r && (r = E), void 0 === i && (i = 64), void 0 === o && (o = Float64Array), this.nodeSize = i, this.points = e;\n\n      for (var n = e.length < 65536 ? Uint16Array : Uint32Array, s = this.ids = new n(e.length), a = this.coords = new o(2 * e.length), l = 0; l < e.length; l++) {\n        s[l] = l, a[2 * l] = t(e[l]), a[2 * l + 1] = r(e[l]);\n      }\n\n      !function e(t, r, i, o, n, s) {\n        if (!(n - o <= i)) {\n          var a = o + n >> 1;\n          !function e(t, r, i, o, n, s) {\n            for (; n > o;) {\n              if (n - o > 600) {\n                var a = n - o + 1,\n                    l = i - o + 1,\n                    u = Math.log(a),\n                    h = .5 * Math.exp(2 * u / 3),\n                    c = .5 * Math.sqrt(u * h * (a - h) / a) * (l - a / 2 < 0 ? -1 : 1);\n                e(t, r, i, Math.max(o, Math.floor(i - l * h / a + c)), Math.min(n, Math.floor(i + (a - l) * h / a + c)), s);\n              }\n\n              var p = r[2 * i + s],\n                  f = o,\n                  d = n;\n\n              for (D(t, r, o, i), r[2 * n + s] > p && D(t, r, o, n); f < d;) {\n                for (D(t, r, f, d), f++, d--; r[2 * f + s] < p;) {\n                  f++;\n                }\n\n                for (; r[2 * d + s] > p;) {\n                  d--;\n                }\n              }\n\n              r[2 * o + s] === p ? D(t, r, o, d) : D(t, r, ++d, n), d <= i && (o = d + 1), i <= d && (n = d - 1);\n            }\n          }(t, r, a, o, n, s % 2), e(t, r, i, o, a - 1, s + 1), e(t, r, i, a + 1, n, s + 1);\n        }\n      }(s, a, i, 0, s.length - 1, 0);\n    };\n\n    F.prototype.range = function (e, t, r, i) {\n      return function (e, t, r, i, o, n, s) {\n        for (var a, l, u = [0, e.length - 1, 0], h = []; u.length;) {\n          var c = u.pop(),\n              p = u.pop(),\n              f = u.pop();\n          if (p - f <= s) for (var d = f; d <= p; d++) {\n            l = t[2 * d + 1], (a = t[2 * d]) >= r && a <= o && l >= i && l <= n && h.push(e[d]);\n          } else {\n            var g = Math.floor((f + p) / 2);\n            l = t[2 * g + 1], (a = t[2 * g]) >= r && a <= o && l >= i && l <= n && h.push(e[g]);\n            var v = (c + 1) % 2;\n            (0 === c ? r <= a : i <= l) && (u.push(f), u.push(g - 1), u.push(v)), (0 === c ? o >= a : n >= l) && (u.push(g + 1), u.push(p), u.push(v));\n          }\n        }\n\n        return h;\n      }(this.ids, this.coords, e, t, r, i, this.nodeSize);\n    }, F.prototype.within = function (e, t, r) {\n      return function (e, t, r, i, o, n) {\n        for (var s = [0, e.length - 1, 0], a = [], l = o * o; s.length;) {\n          var u = s.pop(),\n              h = s.pop(),\n              c = s.pop();\n          if (h - c <= n) for (var p = c; p <= h; p++) {\n            z(t[2 * p], t[2 * p + 1], r, i) <= l && a.push(e[p]);\n          } else {\n            var f = Math.floor((c + h) / 2),\n                d = t[2 * f],\n                g = t[2 * f + 1];\n            z(d, g, r, i) <= l && a.push(e[f]);\n            var v = (u + 1) % 2;\n            (0 === u ? r - o <= d : i - o <= g) && (s.push(c), s.push(f - 1), s.push(v)), (0 === u ? r + o >= d : i + o >= g) && (s.push(f + 1), s.push(h), s.push(v));\n          }\n        }\n\n        return a;\n      }(this.ids, this.coords, e, t, r, this.nodeSize);\n    };\n\n    var N = {\n      minZoom: 0,\n      maxZoom: 16,\n      minPoints: 2,\n      radius: 40,\n      extent: 512,\n      nodeSize: 64,\n      log: !1,\n      generateId: !1,\n      reduce: null,\n      map: function map(e) {\n        return e;\n      }\n    },\n        J = function J(e) {\n      this.options = V(Object.create(N), e), this.trees = new Array(this.options.maxZoom + 1);\n    };\n\n    function Z(e, t, r, i, o) {\n      return {\n        x: e,\n        y: t,\n        zoom: 1 / 0,\n        id: r,\n        parentId: -1,\n        numPoints: i,\n        properties: o\n      };\n    }\n\n    function A(e, t) {\n      var r = e.geometry.coordinates,\n          i = r[1];\n      return {\n        x: Y(r[0]),\n        y: j(i),\n        zoom: 1 / 0,\n        index: t,\n        parentId: -1\n      };\n    }\n\n    function B(e) {\n      return {\n        type: "Feature",\n        id: e.id,\n        properties: G(e),\n        geometry: {\n          type: "Point",\n          coordinates: [(i = e.x, 360 * (i - .5)), (t = e.y, r = (180 - 360 * t) * Math.PI / 180, 360 * Math.atan(Math.exp(r)) / Math.PI - 90)]\n        }\n      };\n      var t, r, i;\n    }\n\n    function G(e) {\n      var t = e.numPoints,\n          r = t >= 1e4 ? Math.round(t / 1e3) + "k" : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;\n      return V(V({}, e.properties), {\n        cluster: !0,\n        cluster_id: e.id,\n        point_count: t,\n        point_count_abbreviated: r\n      });\n    }\n\n    function Y(e) {\n      return e / 360 + .5;\n    }\n\n    function j(e) {\n      var t = Math.sin(e * Math.PI / 180),\n          r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n\n    function V(e, t) {\n      for (var r in t) {\n        e[r] = t[r];\n      }\n\n      return e;\n    }\n\n    function X(e) {\n      return e.x;\n    }\n\n    function W(e) {\n      return e.y;\n    }\n\n    function R(e, t, r, i, o, n) {\n      var s = o - r,\n          a = n - i;\n\n      if (0 !== s || 0 !== a) {\n        var l = ((e - r) * s + (t - i) * a) / (s * s + a * a);\n        l > 1 ? (r = o, i = n) : l > 0 && (r += s * l, i += a * l);\n      }\n\n      return (s = e - r) * s + (a = t - i) * a;\n    }\n\n    function q(e, t, r, i) {\n      var o = {\n        id: void 0 === e ? null : e,\n        type: t,\n        geometry: r,\n        tags: i,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      return function (e) {\n        var t = e.geometry,\n            r = e.type;\n        if ("Point" === r || "MultiPoint" === r || "LineString" === r) U(e, t);else if ("Polygon" === r || "MultiLineString" === r) for (var i = 0; i < t.length; i++) {\n          U(e, t[i]);\n        } else if ("MultiPolygon" === r) for (i = 0; i < t.length; i++) {\n          for (var o = 0; o < t[i].length; o++) {\n            U(e, t[i][o]);\n          }\n        }\n      }(o), o;\n    }\n\n    function U(e, t) {\n      for (var r = 0; r < t.length; r += 3) {\n        e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);\n      }\n    }\n\n    function $(e, t, r, i) {\n      if (t.geometry) {\n        var o = t.geometry.coordinates,\n            n = t.geometry.type,\n            s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),\n            a = [],\n            l = t.id;\n        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = i || 0), "Point" === n) H(o, a);else if ("MultiPoint" === n) for (var u = 0; u < o.length; u++) {\n          H(o[u], a);\n        } else if ("LineString" === n) K(o, a, s, !1);else if ("MultiLineString" === n) {\n          if (r.lineMetrics) {\n            for (u = 0; u < o.length; u++) {\n              K(o[u], a = [], s, !1), e.push(q(l, "LineString", a, t.properties));\n            }\n\n            return;\n          }\n\n          Q(o, a, s, !1);\n        } else if ("Polygon" === n) Q(o, a, s, !0);else {\n          if ("MultiPolygon" !== n) {\n            if ("GeometryCollection" === n) {\n              for (u = 0; u < t.geometry.geometries.length; u++) {\n                $(e, {\n                  id: l,\n                  geometry: t.geometry.geometries[u],\n                  properties: t.properties\n                }, r, i);\n              }\n\n              return;\n            }\n\n            throw new Error("Input data is not a valid GeoJSON object.");\n          }\n\n          for (u = 0; u < o.length; u++) {\n            var h = [];\n            Q(o[u], h, s, !0), a.push(h);\n          }\n        }\n        e.push(q(l, n, a, t.properties));\n      }\n    }\n\n    function H(e, t) {\n      t.push(ee(e[0])), t.push(te(e[1])), t.push(0);\n    }\n\n    function K(e, t, r, i) {\n      for (var o, n, s = 0, a = 0; a < e.length; a++) {\n        var l = ee(e[a][0]),\n            u = te(e[a][1]);\n        t.push(l), t.push(u), t.push(0), a > 0 && (s += i ? (o * u - l * n) / 2 : Math.sqrt(Math.pow(l - o, 2) + Math.pow(u - n, 2))), o = l, n = u;\n      }\n\n      var h = t.length - 3;\n      t[2] = 1, function e(t, r, i, o) {\n        for (var n, s = o, a = i - r >> 1, l = i - r, u = t[r], h = t[r + 1], c = t[i], p = t[i + 1], f = r + 3; f < i; f += 3) {\n          var d = R(t[f], t[f + 1], u, h, c, p);\n          if (d > s) n = f, s = d;else if (d === s) {\n            var g = Math.abs(f - a);\n            g < l && (n = f, l = g);\n          }\n        }\n\n        s > o && (n - r > 3 && e(t, r, n, o), t[n + 2] = s, i - n > 3 && e(t, n, i, o));\n      }(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;\n    }\n\n    function Q(e, t, r, i) {\n      for (var o = 0; o < e.length; o++) {\n        var n = [];\n        K(e[o], n, r, i), t.push(n);\n      }\n    }\n\n    function ee(e) {\n      return e / 360 + .5;\n    }\n\n    function te(e) {\n      var t = Math.sin(e * Math.PI / 180),\n          r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n\n    function re(e, t, r, i, o, n, s, a) {\n      if (i /= t, n >= (r /= t) && s < i) return e;\n      if (s < r || n >= i) return null;\n\n      for (var l = [], u = 0; u < e.length; u++) {\n        var h = e[u],\n            c = h.geometry,\n            p = h.type,\n            f = 0 === o ? h.minX : h.minY,\n            d = 0 === o ? h.maxX : h.maxY;\n        if (f >= r && d < i) l.push(h);else if (!(d < r || f >= i)) {\n          var g = [];\n          if ("Point" === p || "MultiPoint" === p) ie(c, g, r, i, o);else if ("LineString" === p) oe(c, g, r, i, o, !1, a.lineMetrics);else if ("MultiLineString" === p) se(c, g, r, i, o, !1);else if ("Polygon" === p) se(c, g, r, i, o, !0);else if ("MultiPolygon" === p) for (var v = 0; v < c.length; v++) {\n            var m = [];\n            se(c[v], m, r, i, o, !0), m.length && g.push(m);\n          }\n\n          if (g.length) {\n            if (a.lineMetrics && "LineString" === p) {\n              for (v = 0; v < g.length; v++) {\n                l.push(q(h.id, p, g[v], h.tags));\n              }\n\n              continue;\n            }\n\n            "LineString" !== p && "MultiLineString" !== p || (1 === g.length ? (p = "LineString", g = g[0]) : p = "MultiLineString"), "Point" !== p && "MultiPoint" !== p || (p = 3 === g.length ? "Point" : "MultiPoint"), l.push(q(h.id, p, g, h.tags));\n          }\n        }\n      }\n\n      return l.length ? l : null;\n    }\n\n    function ie(e, t, r, i, o) {\n      for (var n = 0; n < e.length; n += 3) {\n        var s = e[n + o];\n        s >= r && s <= i && (t.push(e[n]), t.push(e[n + 1]), t.push(e[n + 2]));\n      }\n    }\n\n    function oe(e, t, r, i, o, n, s) {\n      for (var a, l, u = ne(e), h = 0 === o ? le : ue, c = e.start, p = 0; p < e.length - 3; p += 3) {\n        var f = e[p],\n            d = e[p + 1],\n            g = e[p + 2],\n            v = e[p + 3],\n            m = e[p + 4],\n            y = 0 === o ? f : d,\n            x = 0 === o ? v : m,\n            w = !1;\n        s && (a = Math.sqrt(Math.pow(f - v, 2) + Math.pow(d - m, 2))), y < r ? x > r && (l = h(u, f, d, v, m, r), s && (u.start = c + a * l)) : y > i ? x < i && (l = h(u, f, d, v, m, i), s && (u.start = c + a * l)) : ae(u, f, d, g), x < r && y >= r && (l = h(u, f, d, v, m, r), w = !0), x > i && y <= i && (l = h(u, f, d, v, m, i), w = !0), !n && w && (s && (u.end = c + a * l), t.push(u), u = ne(e)), s && (c += a);\n      }\n\n      var S = e.length - 3;\n      f = e[S], d = e[S + 1], g = e[S + 2], (y = 0 === o ? f : d) >= r && y <= i && ae(u, f, d, g), S = u.length - 3, n && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && ae(u, u[0], u[1], u[2]), u.length && t.push(u);\n    }\n\n    function ne(e) {\n      var t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n\n    function se(e, t, r, i, o, n) {\n      for (var s = 0; s < e.length; s++) {\n        oe(e[s], t, r, i, o, n, !1);\n      }\n    }\n\n    function ae(e, t, r, i) {\n      e.push(t), e.push(r), e.push(i);\n    }\n\n    function le(e, t, r, i, o, n) {\n      var s = (n - t) / (i - t);\n      return e.push(n), e.push(r + (o - r) * s), e.push(1), s;\n    }\n\n    function ue(e, t, r, i, o, n) {\n      var s = (n - r) / (o - r);\n      return e.push(t + (i - t) * s), e.push(n), e.push(1), s;\n    }\n\n    function he(e, t) {\n      for (var r = [], i = 0; i < e.length; i++) {\n        var o,\n            n = e[i],\n            s = n.type;\n        if ("Point" === s || "MultiPoint" === s || "LineString" === s) o = ce(n.geometry, t);else if ("MultiLineString" === s || "Polygon" === s) {\n          o = [];\n\n          for (var a = 0; a < n.geometry.length; a++) {\n            o.push(ce(n.geometry[a], t));\n          }\n        } else if ("MultiPolygon" === s) for (o = [], a = 0; a < n.geometry.length; a++) {\n          for (var l = [], u = 0; u < n.geometry[a].length; u++) {\n            l.push(ce(n.geometry[a][u], t));\n          }\n\n          o.push(l);\n        }\n        r.push(q(n.id, s, o, n.tags));\n      }\n\n      return r;\n    }\n\n    function ce(e, t) {\n      var r = [];\n      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);\n\n      for (var i = 0; i < e.length; i += 3) {\n        r.push(e[i] + t, e[i + 1], e[i + 2]);\n      }\n\n      return r;\n    }\n\n    function pe(e, t) {\n      if (e.transformed) return e;\n      var r,\n          i,\n          o,\n          n = 1 << e.z,\n          s = e.x,\n          a = e.y;\n\n      for (r = 0; r < e.features.length; r++) {\n        var l = e.features[r],\n            u = l.geometry,\n            h = l.type;\n        if (l.geometry = [], 1 === h) for (i = 0; i < u.length; i += 2) {\n          l.geometry.push(fe(u[i], u[i + 1], t, n, s, a));\n        } else for (i = 0; i < u.length; i++) {\n          var c = [];\n\n          for (o = 0; o < u[i].length; o += 2) {\n            c.push(fe(u[i][o], u[i][o + 1], t, n, s, a));\n          }\n\n          l.geometry.push(c);\n        }\n      }\n\n      return e.transformed = !0, e;\n    }\n\n    function fe(e, t, r, i, o, n) {\n      return [Math.round(r * (e * i - o)), Math.round(r * (t * i - n))];\n    }\n\n    function de(e, t, r, i, o) {\n      for (var n = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent), s = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: r,\n        y: i,\n        z: t,\n        transformed: !1,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n      }, a = 0; a < e.length; a++) {\n        s.numFeatures++, ge(s, e[a], n, o);\n        var l = e[a].minX,\n            u = e[a].minY,\n            h = e[a].maxX,\n            c = e[a].maxY;\n        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);\n      }\n\n      return s;\n    }\n\n    function ge(e, t, r, i) {\n      var o = t.geometry,\n          n = t.type,\n          s = [];\n      if ("Point" === n || "MultiPoint" === n) for (var a = 0; a < o.length; a += 3) {\n        s.push(o[a]), s.push(o[a + 1]), e.numPoints++, e.numSimplified++;\n      } else if ("LineString" === n) ve(s, o, e, r, !1, !1);else if ("MultiLineString" === n || "Polygon" === n) for (a = 0; a < o.length; a++) {\n        ve(s, o[a], e, r, "Polygon" === n, 0 === a);\n      } else if ("MultiPolygon" === n) for (var l = 0; l < o.length; l++) {\n        var u = o[l];\n\n        for (a = 0; a < u.length; a++) {\n          ve(s, u[a], e, r, !0, 0 === a);\n        }\n      }\n\n      if (s.length) {\n        var h = t.tags || null;\n\n        if ("LineString" === n && i.lineMetrics) {\n          for (var c in h = {}, t.tags) {\n            h[c] = t.tags[c];\n          }\n\n          h.mapbox_clip_start = o.start / o.size, h.mapbox_clip_end = o.end / o.size;\n        }\n\n        var p = {\n          geometry: s,\n          type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,\n          tags: h\n        };\n        null !== t.id && (p.id = t.id), e.features.push(p);\n      }\n    }\n\n    function ve(e, t, r, i, o, n) {\n      var s = i * i;\n      if (i > 0 && t.size < (o ? s : i)) r.numPoints += t.length / 3;else {\n        for (var a = [], l = 0; l < t.length; l += 3) {\n          (0 === i || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;\n        }\n\n        o && function (e, t) {\n          for (var r = 0, i = 0, o = e.length, n = o - 2; i < o; n = i, i += 2) {\n            r += (e[i] - e[n]) * (e[i + 1] + e[n + 1]);\n          }\n\n          if (r > 0 === t) for (i = 0, o = e.length; i < o / 2; i += 2) {\n            var s = e[i],\n                a = e[i + 1];\n            e[i] = e[o - 2 - i], e[i + 1] = e[o - 1 - i], e[o - 2 - i] = s, e[o - 1 - i] = a;\n          }\n        }(a, n), e.push(a);\n      }\n    }\n\n    function me(e, t) {\n      var r = (t = this.options = function (e, t) {\n        for (var r in t) {\n          e[r] = t[r];\n        }\n\n        return e;\n      }(Object.create(this.options), t)).debug;\n\n      if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");\n      if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");\n\n      var i = function (e, t) {\n        var r = [];\n        if ("FeatureCollection" === e.type) for (var i = 0; i < e.features.length; i++) {\n          $(r, e.features[i], t, i);\n        } else $(r, "Feature" === e.type ? e : {\n          geometry: e\n        }, t);\n        return r;\n      }(e, t);\n\n      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i = function (e, t) {\n        var r = t.buffer / t.extent,\n            i = e,\n            o = re(e, 1, -1 - r, r, 0, -1, 2, t),\n            n = re(e, 1, 1 - r, 2 + r, 0, -1, 2, t);\n        return (o || n) && (i = re(e, 1, -r, 1 + r, 0, -1, 2, t) || [], o && (i = he(o, 1).concat(i)), n && (i = i.concat(he(n, -1)))), i;\n      }(i, t)).length && this.splitTile(i, 0, 0, 0), r && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));\n    }\n\n    function ye(e, t, r) {\n      return 32 * ((1 << e) * r + t) + e;\n    }\n\n    function xe(e, t) {\n      var r = e.tileID.canonical;\n      if (!this._geoJSONIndex) return t(null, null);\n\n      var i = this._geoJSONIndex.getTile(r.z, r.x, r.y);\n\n      if (!i) return t(null, null);\n      var o = new g(i.features),\n          n = w(o);\n      0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t(null, {\n        vectorTile: o,\n        rawData: n.buffer\n      });\n    }\n\n    J.prototype.load = function (e) {\n      var t = this.options,\n          r = t.log,\n          i = t.minZoom,\n          o = t.maxZoom,\n          n = t.nodeSize;\n      r && console.time("total time");\n      var s = "prepare " + e.length + " points";\n      r && console.time(s), this.points = e;\n\n      for (var a = [], l = 0; l < e.length; l++) {\n        e[l].geometry && a.push(A(e[l], l));\n      }\n\n      this.trees[o + 1] = new F(a, X, W, n, Float32Array), r && console.timeEnd(s);\n\n      for (var u = o; u >= i; u--) {\n        var h = +Date.now();\n        a = this._cluster(a, u), this.trees[u] = new F(a, X, W, n, Float32Array), r && console.log("z%d: %d clusters in %dms", u, a.length, +Date.now() - h);\n      }\n\n      return r && console.timeEnd("total time"), this;\n    }, J.prototype.getClusters = function (e, t) {\n      var r = ((e[0] + 180) % 360 + 360) % 360 - 180,\n          i = Math.max(-90, Math.min(90, e[1])),\n          o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180,\n          n = Math.max(-90, Math.min(90, e[3]));\n      if (e[2] - e[0] >= 360) r = -180, o = 180;else if (r > o) {\n        var s = this.getClusters([r, i, 180, n], t),\n            a = this.getClusters([-180, i, o, n], t);\n        return s.concat(a);\n      }\n\n      for (var l = this.trees[this._limitZoom(t)], u = [], h = 0, c = l.range(Y(r), j(n), Y(o), j(i)); h < c.length; h += 1) {\n        var p = l.points[c[h]];\n        u.push(p.numPoints ? B(p) : this.points[p.index]);\n      }\n\n      return u;\n    }, J.prototype.getChildren = function (e) {\n      var t = this._getOriginId(e),\n          r = this._getOriginZoom(e),\n          i = "No cluster with the specified id.",\n          o = this.trees[r];\n\n      if (!o) throw new Error(i);\n      var n = o.points[t];\n      if (!n) throw new Error(i);\n\n      for (var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = [], l = 0, u = o.within(n.x, n.y, s); l < u.length; l += 1) {\n        var h = o.points[u[l]];\n        h.parentId === e && a.push(h.numPoints ? B(h) : this.points[h.index]);\n      }\n\n      if (0 === a.length) throw new Error(i);\n      return a;\n    }, J.prototype.getLeaves = function (e, t, r) {\n      var i = [];\n      return this._appendLeaves(i, e, t = t || 10, r = r || 0, 0), i;\n    }, J.prototype.getTile = function (e, t, r) {\n      var i = this.trees[this._limitZoom(e)],\n          o = Math.pow(2, e),\n          n = this.options,\n          s = n.radius / n.extent,\n          a = (r - s) / o,\n          l = (r + 1 + s) / o,\n          u = {\n        features: []\n      };\n\n      return this._addTileFeatures(i.range((t - s) / o, a, (t + 1 + s) / o, l), i.points, t, r, o, u), 0 === t && this._addTileFeatures(i.range(1 - s / o, a, 1, l), i.points, o, r, o, u), t === o - 1 && this._addTileFeatures(i.range(0, a, s / o, l), i.points, -1, r, o, u), u.features.length ? u : null;\n    }, J.prototype.getClusterExpansionZoom = function (e) {\n      for (var t = this._getOriginZoom(e) - 1; t <= this.options.maxZoom;) {\n        var r = this.getChildren(e);\n        if (t++, 1 !== r.length) break;\n        e = r[0].properties.cluster_id;\n      }\n\n      return t;\n    }, J.prototype._appendLeaves = function (e, t, r, i, o) {\n      for (var n = 0, s = this.getChildren(t); n < s.length; n += 1) {\n        var a = s[n],\n            l = a.properties;\n        if (l && l.cluster ? o + l.point_count <= i ? o += l.point_count : o = this._appendLeaves(e, l.cluster_id, r, i, o) : o < i ? o++ : e.push(a), e.length === r) break;\n      }\n\n      return o;\n    }, J.prototype._addTileFeatures = function (e, t, r, i, o, n) {\n      for (var s = 0, a = e; s < a.length; s += 1) {\n        var l = t[a[s]],\n            u = l.numPoints,\n            h = {\n          type: 1,\n          geometry: [[Math.round(this.options.extent * (l.x * o - r)), Math.round(this.options.extent * (l.y * o - i))]],\n          tags: u ? G(l) : this.points[l.index].properties\n        },\n            c = void 0;\n        u ? c = l.id : this.options.generateId ? c = l.index : this.points[l.index].id && (c = this.points[l.index].id), void 0 !== c && (h.id = c), n.features.push(h);\n      }\n    }, J.prototype._limitZoom = function (e) {\n      return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1));\n    }, J.prototype._cluster = function (e, t) {\n      for (var r = [], i = this.options, o = i.reduce, n = i.minPoints, s = i.radius / (i.extent * Math.pow(2, t)), a = 0; a < e.length; a++) {\n        var l = e[a];\n\n        if (!(l.zoom <= t)) {\n          l.zoom = t;\n\n          for (var u = this.trees[t + 1], h = u.within(l.x, l.y, s), c = l.numPoints || 1, p = c, f = 0, d = h; f < d.length; f += 1) {\n            var g = u.points[d[f]];\n            g.zoom > t && (p += g.numPoints || 1);\n          }\n\n          if (p >= n) {\n            for (var v = l.x * c, m = l.y * c, y = o && c > 1 ? this._map(l, !0) : null, x = (a << 5) + (t + 1) + this.points.length, w = 0, S = h; w < S.length; w += 1) {\n              var I = u.points[S[w]];\n\n              if (!(I.zoom <= t)) {\n                I.zoom = t;\n                var M = I.numPoints || 1;\n                v += I.x * M, m += I.y * M, I.parentId = x, o && (y || (y = this._map(l, !0)), o(y, this._map(I)));\n              }\n            }\n\n            l.parentId = x, r.push(Z(v / p, m / p, x, p, y));\n          } else if (r.push(l), p > 1) for (var b = 0, _ = h; b < _.length; b += 1) {\n            var k = u.points[_[b]];\n            k.zoom <= t || (k.zoom = t, r.push(k));\n          }\n        }\n      }\n\n      return r;\n    }, J.prototype._getOriginId = function (e) {\n      return e - this.points.length >> 5;\n    }, J.prototype._getOriginZoom = function (e) {\n      return (e - this.points.length) % 32;\n    }, J.prototype._map = function (e, t) {\n      if (e.numPoints) return t ? V({}, e.properties) : e.properties;\n      var r = this.points[e.index].properties,\n          i = this.options.map(r);\n      return t && i === r ? V({}, i) : i;\n    }, me.prototype.options = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    }, me.prototype.splitTile = function (e, t, r, i, o, n, s) {\n      for (var a = [e, t, r, i], l = this.options, u = l.debug; a.length;) {\n        i = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();\n        var h = 1 << t,\n            c = ye(t, r, i),\n            p = this.tiles[c];\n\n        if (!p && (u > 1 && console.time("creation"), p = this.tiles[c] = de(e, t, r, i, l), this.tileCoords.push({\n          z: t,\n          x: r,\n          y: i\n        }), u)) {\n          u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd("creation"));\n          var f = "z" + t;\n          this.stats[f] = (this.stats[f] || 0) + 1, this.total++;\n        }\n\n        if (p.source = e, o) {\n          if (t === l.maxZoom || t === o) continue;\n          var d = 1 << o - t;\n          if (r !== Math.floor(n / d) || i !== Math.floor(s / d)) continue;\n        } else if (t === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;\n\n        if (p.source = null, 0 !== e.length) {\n          u > 1 && console.time("clipping");\n          var g,\n              v,\n              m,\n              y,\n              x,\n              w,\n              S = .5 * l.buffer / l.extent,\n              I = .5 - S,\n              M = .5 + S,\n              b = 1 + S;\n          g = v = m = y = null, x = re(e, h, r - S, r + M, 0, p.minX, p.maxX, l), w = re(e, h, r + I, r + b, 0, p.minX, p.maxX, l), e = null, x && (g = re(x, h, i - S, i + M, 1, p.minY, p.maxY, l), v = re(x, h, i + I, i + b, 1, p.minY, p.maxY, l), x = null), w && (m = re(w, h, i - S, i + M, 1, p.minY, p.maxY, l), y = re(w, h, i + I, i + b, 1, p.minY, p.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(g || [], t + 1, 2 * r, 2 * i), a.push(v || [], t + 1, 2 * r, 2 * i + 1), a.push(m || [], t + 1, 2 * r + 1, 2 * i), a.push(y || [], t + 1, 2 * r + 1, 2 * i + 1);\n        }\n      }\n    }, me.prototype.getTile = function (e, t, r) {\n      var i = this.options,\n          o = i.extent,\n          n = i.debug;\n      if (e < 0 || e > 24) return null;\n      var s = 1 << e,\n          a = ye(e, t = (t % s + s) % s, r);\n      if (this.tiles[a]) return pe(this.tiles[a], o);\n      n > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);\n\n      for (var l, u = e, h = t, c = r; !l && u > 0;) {\n        u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[ye(u, h, c)];\n      }\n\n      return l && l.source ? (n > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), n > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e, t, r), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? pe(this.tiles[a], o) : null) : null;\n    };\n\n    var we = function (t) {\n      function r(e, r, i, o) {\n        t.call(this, e, r, i, xe), o && (this.loadGeoJSON = o);\n      }\n\n      return t && (r.__proto__ = t), (r.prototype = Object.create(t && t.prototype)).constructor = r, r.prototype.loadData = function (e, t) {\n        this._pendingCallback && this._pendingCallback(null, {\n          abandoned: !0\n        }), this._pendingCallback = t, this._pendingLoadDataParams = e, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());\n      }, r.prototype._loadData = function () {\n        var t = this;\n\n        if (this._pendingCallback && this._pendingLoadDataParams) {\n          var r = this._pendingCallback,\n              i = this._pendingLoadDataParams;\n          delete this._pendingCallback, delete this._pendingLoadDataParams;\n          var o = !!(i && i.request && i.request.collectResourceTiming) && new e.RequestPerformance(i.request);\n          this.loadGeoJSON(i, function (n, s) {\n            if (n || !s) return r(n);\n            if ("object" != typeof s) return r(new Error("Input data given to \'" + i.source + "\' is not a valid GeoJSON object."));\n            !function e(t, r) {\n              var i,\n                  o = t && t.type;\n              if ("FeatureCollection" === o) for (i = 0; i < t.features.length; i++) {\n                e(t.features[i], r);\n              } else if ("GeometryCollection" === o) for (i = 0; i < t.geometries.length; i++) {\n                e(t.geometries[i], r);\n              } else if ("Feature" === o) e(t.geometry, r);else if ("Polygon" === o) c(t.coordinates, r);else if ("MultiPolygon" === o) for (i = 0; i < t.coordinates.length; i++) {\n                c(t.coordinates[i], r);\n              }\n              return t;\n            }(s, !0);\n\n            try {\n              if (i.filter) {\n                var a = e.createExpression(i.filter, {\n                  type: "boolean",\n                  "property-type": "data-driven",\n                  overridable: !1,\n                  transition: !1\n                });\n                if ("error" === a.result) throw new Error(a.value.map(function (e) {\n                  return e.key + ": " + e.message;\n                }).join(", "));\n                var l = s.features.filter(function (e) {\n                  return a.value.evaluate({\n                    zoom: 0\n                  }, e);\n                });\n                s = {\n                  type: "FeatureCollection",\n                  features: l\n                };\n              }\n\n              t._geoJSONIndex = i.cluster ? new J(function (t) {\n                var r = t.superclusterOptions,\n                    i = t.clusterProperties;\n                if (!i || !r) return r;\n\n                for (var o = {}, n = {}, s = {\n                  accumulated: null,\n                  zoom: 0\n                }, a = {\n                  properties: null\n                }, l = Object.keys(i), u = 0, h = l; u < h.length; u += 1) {\n                  var c = h[u],\n                      p = i[c],\n                      f = p[0],\n                      d = e.createExpression(p[1]),\n                      g = e.createExpression("string" == typeof f ? [f, ["accumulated"], ["get", c]] : f);\n                  o[c] = d.value, n[c] = g.value;\n                }\n\n                return r.map = function (e) {\n                  a.properties = e;\n\n                  for (var t = {}, r = 0, i = l; r < i.length; r += 1) {\n                    var n = i[r];\n                    t[n] = o[n].evaluate(s, a);\n                  }\n\n                  return t;\n                }, r.reduce = function (e, t) {\n                  a.properties = t;\n\n                  for (var r = 0, i = l; r < i.length; r += 1) {\n                    var o = i[r];\n                    s.accumulated = e[o], e[o] = n[o].evaluate(s, a);\n                  }\n                }, r;\n              }(i)).load(s.features) : function (e, t) {\n                return new me(e, t);\n              }(s, i.geojsonVtOptions);\n            } catch (n) {\n              return r(n);\n            }\n\n            t.loaded = {};\n            var u = {};\n\n            if (o) {\n              var h = o.finish();\n              h && (u.resourceTiming = {}, u.resourceTiming[i.source] = JSON.parse(JSON.stringify(h)));\n            }\n\n            r(null, u);\n          });\n        }\n      }, r.prototype.coalesce = function () {\n        "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());\n      }, r.prototype.reloadTile = function (e, r) {\n        var i = this.loaded;\n        return i && i[e.uid] ? t.prototype.reloadTile.call(this, e, r) : this.loadTile(e, r);\n      }, r.prototype.loadGeoJSON = function (t, r) {\n        if (t.request) e.getJSON(t.request, r);else {\n          if ("string" != typeof t.data) return r(new Error("Input data given to \'" + t.source + "\' is not a valid GeoJSON object."));\n\n          try {\n            return r(null, JSON.parse(t.data));\n          } catch (e) {\n            return r(new Error("Input data given to \'" + t.source + "\' is not a valid GeoJSON object."));\n          }\n        }\n      }, r.prototype.removeSource = function (e, t) {\n        this._pendingCallback && this._pendingCallback(null, {\n          abandoned: !0\n        }), t();\n      }, r.prototype.getClusterExpansionZoom = function (e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }, r.prototype.getClusterChildren = function (e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }, r.prototype.getClusterLeaves = function (e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }, r;\n    }(l),\n        Se = function Se(t) {\n      var r = this;\n      this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = {\n        vector: l,\n        geojson: we\n      }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (e, t) {\n        if (r.workerSourceTypes[e]) throw new Error(\'Worker source with name "\' + e + \'" already registered.\');\n        r.workerSourceTypes[e] = t;\n      }, this.self.registerRTLTextPlugin = function (t) {\n        if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");\n        e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;\n      };\n    };\n\n    return Se.prototype.setReferrer = function (e, t) {\n      this.referrer = t;\n    }, Se.prototype.setImages = function (e, t, r) {\n      for (var i in this.availableImages[e] = t, this.workerSources[e]) {\n        var o = this.workerSources[e][i];\n\n        for (var n in o) {\n          o[n].availableImages = t;\n        }\n      }\n\n      r();\n    }, Se.prototype.setLayers = function (e, t, r) {\n      this.getLayerIndex(e).replace(t), r();\n    }, Se.prototype.updateLayers = function (e, t, r) {\n      this.getLayerIndex(e).update(t.layers, t.removedIds), r();\n    }, Se.prototype.loadTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).loadTile(t, r);\n    }, Se.prototype.loadDEMTile = function (e, t, r) {\n      this.getDEMWorkerSource(e, t.source).loadTile(t, r);\n    }, Se.prototype.reloadTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).reloadTile(t, r);\n    }, Se.prototype.abortTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).abortTile(t, r);\n    }, Se.prototype.removeTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).removeTile(t, r);\n    }, Se.prototype.removeDEMTile = function (e, t) {\n      this.getDEMWorkerSource(e, t.source).removeTile(t);\n    }, Se.prototype.removeSource = function (e, t, r) {\n      if (this.workerSources[e] && this.workerSources[e][t.type] && this.workerSources[e][t.type][t.source]) {\n        var i = this.workerSources[e][t.type][t.source];\n        delete this.workerSources[e][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, r) : r();\n      }\n    }, Se.prototype.loadWorkerSource = function (e, t, r) {\n      try {\n        this.self.importScripts(t.url), r();\n      } catch (e) {\n        r(e.toString());\n      }\n    }, Se.prototype.syncRTLPluginState = function (t, r, i) {\n      try {\n        e.plugin.setState(r);\n        var o = e.plugin.getPluginURL();\n\n        if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o) {\n          this.self.importScripts(o);\n          var n = e.plugin.isParsed();\n          i(n ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o), n);\n        }\n      } catch (e) {\n        i(e.toString());\n      }\n    }, Se.prototype.getAvailableImages = function (e) {\n      var t = this.availableImages[e];\n      return t || (t = []), t;\n    }, Se.prototype.getLayerIndex = function (e) {\n      var t = this.layerIndexes[e];\n      return t || (t = this.layerIndexes[e] = new i()), t;\n    }, Se.prototype.getWorkerSource = function (e, t, r) {\n      var i = this;\n      return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), this.workerSources[e][t][r] || (this.workerSources[e][t][r] = new this.workerSourceTypes[t]({\n        send: function send(t, r, o) {\n          i.actor.send(t, r, o, e);\n        }\n      }, this.getLayerIndex(e), this.getAvailableImages(e))), this.workerSources[e][t][r];\n    }, Se.prototype.getDEMWorkerSource = function (e, t) {\n      return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new h()), this.demWorkerSources[e][t];\n    }, Se.prototype.enforceCacheSizeLimit = function (t, r) {\n      e.enforceCacheSizeLimit(r);\n    }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;\n  });\n  define(["./shared"], function (t) {\n    "use strict";\n\n    var e = t.createCommonjsModule(function (t) {\n      function e(t) {\n        return !i(t);\n      }\n\n      function i(t) {\n        return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {\n          if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;\n          var t,\n              e,\n              i = new Blob([""], {\n            type: "text/javascript"\n          }),\n              o = URL.createObjectURL(i);\n\n          try {\n            e = new Worker(o), t = !0;\n          } catch (e) {\n            t = !1;\n          }\n\n          return e && e.terminate(), URL.revokeObjectURL(o), t;\n        }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {\n          var t = document.createElement("canvas");\n          t.width = t.height = 1;\n          var e = t.getContext("2d");\n          if (!e) return !1;\n          var i = e.getImageData(0, 0, 1, 1);\n          return i && i.width === t.width;\n        }() ? (void 0 === o[i = t && t.failIfMajorPerformanceCaveat] && (o[i] = function (t) {\n          var i = function (t) {\n            var i = document.createElement("canvas"),\n                o = Object.create(e.webGLContextAttributes);\n            return o.failIfMajorPerformanceCaveat = t, i.probablySupportsContext ? i.probablySupportsContext("webgl", o) || i.probablySupportsContext("experimental-webgl", o) : i.supportsContext ? i.supportsContext("webgl", o) || i.supportsContext("experimental-webgl", o) : i.getContext("webgl", o) || i.getContext("experimental-webgl", o);\n          }(t);\n\n          if (!i) return !1;\n          var o = i.createShader(i.VERTEX_SHADER);\n          return !(!o || i.isContextLost()) && (i.shaderSource(o, "void main() {}"), i.compileShader(o), !0 === i.getShaderParameter(o, i.COMPILE_STATUS));\n        }(i)), o[i] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";\n        var i;\n      }\n\n      t.exports ? t.exports = e : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e, window.mapboxgl.notSupportedReason = i);\n      var o = {};\n      e.webGLContextAttributes = {\n        antialias: !1,\n        alpha: !0,\n        stencil: !0,\n        depth: !0\n      };\n    }),\n        i = {\n      create: function create(e, i, o) {\n        var r = t.window.document.createElement(e);\n        return void 0 !== i && (r.className = i), o && o.appendChild(r), r;\n      },\n      createNS: function createNS(e, i) {\n        return t.window.document.createElementNS(e, i);\n      }\n    },\n        o = t.window.document && t.window.document.documentElement.style;\n\n    function r(t) {\n      if (!o) return t[0];\n\n      for (var e = 0; e < t.length; e++) {\n        if (t[e] in o) return t[e];\n      }\n\n      return t[0];\n    }\n\n    var a,\n        n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);\n    i.disableDrag = function () {\n      o && n && (a = o[n], o[n] = "none");\n    }, i.enableDrag = function () {\n      o && n && (o[n] = a);\n    };\n    var s = r(["transform", "WebkitTransform"]);\n\n    i.setTransform = function (t, e) {\n      t.style[s] = e;\n    };\n\n    var l = !1;\n\n    try {\n      var c = Object.defineProperty({}, "passive", {\n        get: function get() {\n          l = !0;\n        }\n      });\n      t.window.addEventListener("test", c, c), t.window.removeEventListener("test", c, c);\n    } catch (t) {\n      l = !1;\n    }\n\n    i.addEventListener = function (t, e, i, o) {\n      void 0 === o && (o = {}), t.addEventListener(e, i, "passive" in o && l ? o : o.capture);\n    }, i.removeEventListener = function (t, e, i, o) {\n      void 0 === o && (o = {}), t.removeEventListener(e, i, "passive" in o && l ? o : o.capture);\n    };\n\n    var u = function u(e) {\n      e.preventDefault(), e.stopPropagation(), t.window.removeEventListener("click", u, !0);\n    };\n\n    function h(t) {\n      var e = t.userImage;\n      return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)), !0);\n    }\n\n    i.suppressClick = function () {\n      t.window.addEventListener("click", u, !0), t.window.setTimeout(function () {\n        t.window.removeEventListener("click", u, !0);\n      }, 0);\n    }, i.mousePos = function (e, i) {\n      var o = e.getBoundingClientRect();\n      return new t.Point(i.clientX - o.left - e.clientLeft, i.clientY - o.top - e.clientTop);\n    }, i.touchPos = function (e, i) {\n      for (var o = e.getBoundingClientRect(), r = [], a = 0; a < i.length; a++) {\n        r.push(new t.Point(i[a].clientX - o.left - e.clientLeft, i[a].clientY - o.top - e.clientTop));\n      }\n\n      return r;\n    }, i.mouseButton = function (e) {\n      return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button;\n    }, i.remove = function (t) {\n      t.parentNode && t.parentNode.removeChild(t);\n    };\n\n    var p = function (e) {\n      function i() {\n        e.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({\n          width: 1,\n          height: 1\n        }), this.dirty = !0;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.isLoaded = function () {\n        return this.loaded;\n      }, i.prototype.setLoaded = function (t) {\n        if (this.loaded !== t && (this.loaded = t, t)) {\n          for (var e = 0, i = this.requestors; e < i.length; e += 1) {\n            var o = i[e];\n\n            this._notify(o.ids, o.callback);\n          }\n\n          this.requestors = [];\n        }\n      }, i.prototype.getImage = function (t) {\n        return this.images[t];\n      }, i.prototype.addImage = function (t, e) {\n        this._validate(t, e) && (this.images[t] = e);\n      }, i.prototype._validate = function (e, i) {\n        var o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "stretchX" value\'))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "stretchY" value\'))), o = !1), this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "content" value\'))), o = !1), o;\n      }, i.prototype._validateStretch = function (t, e) {\n        if (!t) return !0;\n\n        for (var i = 0, o = 0, r = t; o < r.length; o += 1) {\n          var a = r[o];\n          if (a[0] < i || a[1] < a[0] || e < a[1]) return !1;\n          i = a[1];\n        }\n\n        return !0;\n      }, i.prototype._validateContent = function (t, e) {\n        return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]));\n      }, i.prototype.updateImage = function (t, e) {\n        e.version = this.images[t].version + 1, this.images[t] = e, this.updatedImages[t] = !0;\n      }, i.prototype.removeImage = function (t) {\n        var e = this.images[t];\n        delete this.images[t], delete this.patterns[t], e.userImage && e.userImage.onRemove && e.userImage.onRemove();\n      }, i.prototype.listImages = function () {\n        return Object.keys(this.images);\n      }, i.prototype.getImages = function (t, e) {\n        var i = !0;\n        if (!this.isLoaded()) for (var o = 0, r = t; o < r.length; o += 1) {\n          this.images[r[o]] || (i = !1);\n        }\n        this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({\n          ids: t,\n          callback: e\n        });\n      }, i.prototype._notify = function (e, i) {\n        for (var o = {}, r = 0, a = e; r < a.length; r += 1) {\n          var n = a[r];\n          this.images[n] || this.fire(new t.Event("styleimagemissing", {\n            id: n\n          }));\n          var s = this.images[n];\n          s ? o[n] = {\n            data: s.data.clone(),\n            pixelRatio: s.pixelRatio,\n            sdf: s.sdf,\n            version: s.version,\n            stretchX: s.stretchX,\n            stretchY: s.stretchY,\n            content: s.content,\n            hasRenderCallback: Boolean(s.userImage && s.userImage.render)\n          } : t.warnOnce(\'Image "\' + n + \'" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.\');\n        }\n\n        i(null, o);\n      }, i.prototype.getPixelSize = function () {\n        var t = this.atlasImage;\n        return {\n          width: t.width,\n          height: t.height\n        };\n      }, i.prototype.getPattern = function (e) {\n        var i = this.patterns[e],\n            o = this.getImage(e);\n        if (!o) return null;\n        if (i && i.position.version === o.version) return i.position;\n        if (i) i.position.version = o.version;else {\n          var r = {\n            w: o.data.width + 2,\n            h: o.data.height + 2,\n            x: 0,\n            y: 0\n          },\n              a = new t.ImagePosition(r, o);\n          this.patterns[e] = {\n            bin: r,\n            position: a\n          };\n        }\n        return this._updatePatternAtlas(), this.patterns[e].position;\n      }, i.prototype.bind = function (e) {\n        var i = e.gl;\n        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.Texture(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n      }, i.prototype._updatePatternAtlas = function () {\n        var e = [];\n\n        for (var i in this.patterns) {\n          e.push(this.patterns[i].bin);\n        }\n\n        var o = t.potpack(e),\n            r = o.w,\n            a = o.h,\n            n = this.atlasImage;\n\n        for (var s in n.resize({\n          width: r || 1,\n          height: a || 1\n        }), this.patterns) {\n          var l = this.patterns[s].bin,\n              c = l.x + 1,\n              u = l.y + 1,\n              h = this.images[s].data,\n              p = h.width,\n              d = h.height;\n          t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: c,\n            y: u\n          }, {\n            width: p,\n            height: d\n          }), t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: d - 1\n          }, {\n            x: c,\n            y: u - 1\n          }, {\n            width: p,\n            height: 1\n          }), t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: c,\n            y: u + d\n          }, {\n            width: p,\n            height: 1\n          }), t.RGBAImage.copy(h, n, {\n            x: p - 1,\n            y: 0\n          }, {\n            x: c - 1,\n            y: u\n          }, {\n            width: 1,\n            height: d\n          }), t.RGBAImage.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: c + p,\n            y: u\n          }, {\n            width: 1,\n            height: d\n          });\n        }\n\n        this.dirty = !0;\n      }, i.prototype.beginFrame = function () {\n        this.callbackDispatchedThisFrame = {};\n      }, i.prototype.dispatchRenderCallbacks = function (t) {\n        for (var e = 0, i = t; e < i.length; e += 1) {\n          var o = i[e];\n\n          if (!this.callbackDispatchedThisFrame[o]) {\n            this.callbackDispatchedThisFrame[o] = !0;\n            var r = this.images[o];\n            h(r) && this.updateImage(o, r);\n          }\n        }\n      }, i;\n    }(t.Evented),\n        d = m,\n        _ = m,\n        f = 1e20;\n\n    function m(t, e, i, o, r, a) {\n      this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = o || .25, this.fontFamily = r || "sans-serif", this.fontWeight = a || "normal", this.radius = i || 8;\n      var n = this.size = this.fontSize + 2 * this.buffer;\n      this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.d = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Int16Array(n), this.middle = Math.round(n / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));\n    }\n\n    function g(t, e, i, o, r, a, n) {\n      for (var s = 0; s < e; s++) {\n        for (var l = 0; l < i; l++) {\n          o[l] = t[l * e + s];\n        }\n\n        for (v(o, r, a, n, i), l = 0; l < i; l++) {\n          t[l * e + s] = r[l];\n        }\n      }\n\n      for (l = 0; l < i; l++) {\n        for (s = 0; s < e; s++) {\n          o[s] = t[l * e + s];\n        }\n\n        for (v(o, r, a, n, e), s = 0; s < e; s++) {\n          t[l * e + s] = Math.sqrt(r[s]);\n        }\n      }\n    }\n\n    function v(t, e, i, o, r) {\n      i[0] = 0, o[0] = -f, o[1] = +f;\n\n      for (var a = 1, n = 0; a < r; a++) {\n        for (var s = (t[a] + a * a - (t[i[n]] + i[n] * i[n])) / (2 * a - 2 * i[n]); s <= o[n];) {\n          n--, s = (t[a] + a * a - (t[i[n]] + i[n] * i[n])) / (2 * a - 2 * i[n]);\n        }\n\n        i[++n] = a, o[n] = s, o[n + 1] = +f;\n      }\n\n      for (a = 0, n = 0; a < r; a++) {\n        for (; o[n + 1] < a;) {\n          n++;\n        }\n\n        e[a] = (a - i[n]) * (a - i[n]) + t[i[n]];\n      }\n    }\n\n    m.prototype.draw = function (t) {\n      this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t, this.buffer, this.middle);\n\n      for (var e = this.ctx.getImageData(0, 0, this.size, this.size), i = new Uint8ClampedArray(this.size * this.size), o = 0; o < this.size * this.size; o++) {\n        var r = e.data[4 * o + 3] / 255;\n        this.gridOuter[o] = 1 === r ? 0 : 0 === r ? f : Math.pow(Math.max(0, .5 - r), 2), this.gridInner[o] = 1 === r ? f : 0 === r ? 0 : Math.pow(Math.max(0, r - .5), 2);\n      }\n\n      for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), o = 0; o < this.size * this.size; o++) {\n        i[o] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[o] - this.gridInner[o]) / this.radius + this.cutoff))));\n      }\n\n      return i;\n    }, d.default = _;\n\n    var y = function y(t, e) {\n      this.requestManager = t, this.localIdeographFontFamily = e, this.entries = {};\n    };\n\n    y.prototype.setURL = function (t) {\n      this.url = t;\n    }, y.prototype.getGlyphs = function (e, i) {\n      var o = this,\n          r = [];\n\n      for (var a in e) {\n        for (var n = 0, s = e[a]; n < s.length; n += 1) {\n          r.push({\n            stack: a,\n            id: s[n]\n          });\n        }\n      }\n\n      t.asyncAll(r, function (t, e) {\n        var i = t.stack,\n            r = t.id,\n            a = o.entries[i];\n        a || (a = o.entries[i] = {\n          glyphs: {},\n          requests: {},\n          ranges: {}\n        });\n        var n = a.glyphs[r];\n\n        if (void 0 === n) {\n          if (n = o._tinySDF(a, i, r)) return a.glyphs[r] = n, void e(null, {\n            stack: i,\n            id: r,\n            glyph: n\n          });\n          var s = Math.floor(r / 256);\n          if (256 * s > 65535) e(new Error("glyphs > 65535 not supported"));else if (a.ranges[s]) e(null, {\n            stack: i,\n            id: r,\n            glyph: n\n          });else {\n            var l = a.requests[s];\n            l || (l = a.requests[s] = [], y.loadGlyphRange(i, s, o.url, o.requestManager, function (t, e) {\n              if (e) {\n                for (var i in e) {\n                  o._doesCharSupportLocalGlyph(+i) || (a.glyphs[+i] = e[+i]);\n                }\n\n                a.ranges[s] = !0;\n              }\n\n              for (var r = 0, n = l; r < n.length; r += 1) {\n                (0, n[r])(t, e);\n              }\n\n              delete a.requests[s];\n            })), l.push(function (t, o) {\n              t ? e(t) : o && e(null, {\n                stack: i,\n                id: r,\n                glyph: o[r] || null\n              });\n            });\n          }\n        } else e(null, {\n          stack: i,\n          id: r,\n          glyph: n\n        });\n      }, function (t, e) {\n        if (t) i(t);else if (e) {\n          for (var o = {}, r = 0, a = e; r < a.length; r += 1) {\n            var n = a[r],\n                s = n.stack,\n                l = n.id,\n                c = n.glyph;\n            (o[s] || (o[s] = {}))[l] = c && {\n              id: c.id,\n              bitmap: c.bitmap.clone(),\n              metrics: c.metrics\n            };\n          }\n\n          i(null, o);\n        }\n      });\n    }, y.prototype._doesCharSupportLocalGlyph = function (e) {\n      return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e) || t.isChar["Hangul Syllables"](e) || t.isChar.Hiragana(e) || t.isChar.Katakana(e));\n    }, y.prototype._tinySDF = function (e, i, o) {\n      var r = this.localIdeographFontFamily;\n\n      if (r && this._doesCharSupportLocalGlyph(o)) {\n        var a = e.tinySDF;\n\n        if (!a) {\n          var n = "400";\n          /bold/i.test(i) ? n = "900" : /medium/i.test(i) ? n = "500" : /light/i.test(i) && (n = "200"), a = e.tinySDF = new y.TinySDF(24, 3, 8, .25, r, n);\n        }\n\n        return {\n          id: o,\n          bitmap: new t.AlphaImage({\n            width: 30,\n            height: 30\n          }, a.draw(String.fromCharCode(o))),\n          metrics: {\n            width: 24,\n            height: 24,\n            left: 0,\n            top: -8,\n            advance: 24\n          }\n        };\n      }\n    }, y.loadGlyphRange = function (e, i, o, r, a) {\n      var n = 256 * i,\n          s = n + 255,\n          l = r.transformRequest(r.normalizeGlyphsURL(o).replace("{fontstack}", e).replace("{range}", n + "-" + s), t.ResourceType.Glyphs);\n      t.getArrayBuffer(l, function (e, i) {\n        if (e) a(e);else if (i) {\n          for (var o = {}, r = 0, n = t.parseGlyphPBF(i); r < n.length; r += 1) {\n            var s = n[r];\n            o[s.id] = s;\n          }\n\n          a(null, o);\n        }\n      });\n    }, y.TinySDF = d;\n\n    var x = function x() {\n      this.specification = t.styleSpec.light.position;\n    };\n\n    x.prototype.possiblyEvaluate = function (e, i) {\n      return t.sphericalToCartesian(e.expression.evaluate(i));\n    }, x.prototype.interpolate = function (e, i, o) {\n      return {\n        x: t.number(e.x, i.x, o),\n        y: t.number(e.y, i.y, o),\n        z: t.number(e.z, i.z, o)\n      };\n    };\n\n    var b = new t.Properties({\n      anchor: new t.DataConstantProperty(t.styleSpec.light.anchor),\n      position: new x(),\n      color: new t.DataConstantProperty(t.styleSpec.light.color),\n      intensity: new t.DataConstantProperty(t.styleSpec.light.intensity)\n    }),\n        w = function (e) {\n      function i(i) {\n        e.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i), this._transitioning = this._transitionable.untransitioned();\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getLight = function () {\n        return this._transitionable.serialize();\n      }, i.prototype.setLight = function (e, i) {\n        if (void 0 === i && (i = {}), !this._validate(t.validateLight, e, i)) for (var o in e) {\n          var r = e[o];\n          t.endsWith(o, "-transition") ? this._transitionable.setTransition(o.slice(0, -"-transition".length), r) : this._transitionable.setValue(o, r);\n        }\n      }, i.prototype.updateTransitions = function (t) {\n        this._transitioning = this._transitionable.transitioned(t, this._transitioning);\n      }, i.prototype.hasTransition = function () {\n        return this._transitioning.hasTransition();\n      }, i.prototype.recalculate = function (t) {\n        this.properties = this._transitioning.possiblyEvaluate(t);\n      }, i.prototype._validate = function (e, i, o) {\n        return (!o || !1 !== o.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: t.styleSpec\n        })));\n      }, i;\n    }(t.Evented),\n        T = function T(t, e) {\n      this.width = t, this.height = e, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};\n    };\n\n    T.prototype.getDash = function (t, e) {\n      var i = t.join(",") + String(e);\n      return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)), this.dashEntry[i];\n    }, T.prototype.getDashRanges = function (t, e, i) {\n      var o = [],\n          r = t.length % 2 == 1 ? -t[t.length - 1] * i : 0,\n          a = t[0] * i,\n          n = !0;\n      o.push({\n        left: r,\n        right: a,\n        isDash: n,\n        zeroLength: 0 === t[0]\n      });\n\n      for (var s = t[0], l = 1; l < t.length; l++) {\n        var c = t[l];\n        o.push({\n          left: r = s * i,\n          right: a = (s += c) * i,\n          isDash: n = !n,\n          zeroLength: 0 === c\n        });\n      }\n\n      return o;\n    }, T.prototype.addRoundDash = function (t, e, i) {\n      for (var o = e / 2, r = -i; r <= i; r++) {\n        for (var a = this.width * (this.nextRow + i + r), n = 0, s = t[n], l = 0; l < this.width; l++) {\n          l / s.right > 1 && (s = t[++n]);\n          var c = Math.abs(l - s.left),\n              u = Math.abs(l - s.right),\n              h = Math.min(c, u),\n              p = void 0,\n              d = r / i * (o + 1);\n\n          if (s.isDash) {\n            var _ = o - Math.abs(d);\n\n            p = Math.sqrt(h * h + _ * _);\n          } else p = o - Math.sqrt(h * h + d * d);\n\n          this.data[a + l] = Math.max(0, Math.min(255, p + 128));\n        }\n      }\n    }, T.prototype.addRegularDash = function (t) {\n      for (var e = t.length - 1; e >= 0; --e) {\n        var i = t[e],\n            o = t[e + 1];\n        i.zeroLength ? t.splice(e, 1) : o && o.isDash === i.isDash && (o.left = i.left, t.splice(e, 1));\n      }\n\n      var r = t[0],\n          a = t[t.length - 1];\n      r.isDash === a.isDash && (r.left = a.left - this.width, a.right = r.right + this.width);\n\n      for (var n = this.width * this.nextRow, s = 0, l = t[s], c = 0; c < this.width; c++) {\n        c / l.right > 1 && (l = t[++s]);\n        var u = Math.abs(c - l.left),\n            h = Math.abs(c - l.right),\n            p = Math.min(u, h);\n        this.data[n + c] = Math.max(0, Math.min(255, (l.isDash ? p : -p) + 128));\n      }\n    }, T.prototype.addDash = function (e, i) {\n      var o = i ? 7 : 0,\n          r = 2 * o + 1;\n      if (this.nextRow + r > this.height) return t.warnOnce("LineAtlas out of space"), null;\n\n      for (var a = 0, n = 0; n < e.length; n++) {\n        a += e[n];\n      }\n\n      if (0 !== a) {\n        var s = this.width / a,\n            l = this.getDashRanges(e, this.width, s);\n        i ? this.addRoundDash(l, s, o) : this.addRegularDash(l);\n      }\n\n      var c = {\n        y: (this.nextRow + o + .5) / this.height,\n        height: 2 * o / this.height,\n        width: a\n      };\n      return this.nextRow += r, this.dirty = !0, c;\n    }, T.prototype.bind = function (t) {\n      var e = t.gl;\n      this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data));\n    };\n\n    var E = function e(i, o) {\n      this.workerPool = i, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();\n\n      for (var r = this.workerPool.acquire(this.id), a = 0; a < r.length; a++) {\n        var n = new e.Actor(r[a], o, this.id);\n        n.name = "Worker " + a, this.actors.push(n);\n      }\n    };\n\n    function I(e, i, o) {\n      var r = function r(_r2, a) {\n        if (_r2) return o(_r2);\n\n        if (a) {\n          var n = t.pick(t.extend(a, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);\n          a.vector_layers && (n.vectorLayers = a.vector_layers, n.vectorLayerIds = n.vectorLayers.map(function (t) {\n            return t.id;\n          })), n.tiles = i.canonicalizeTileset(n, e.url), o(null, n);\n        }\n      };\n\n      return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url), t.ResourceType.Source), r) : t.browser.frame(function () {\n        return r(null, e);\n      });\n    }\n\n    E.prototype.broadcast = function (e, i, o) {\n      t.asyncAll(this.actors, function (t, o) {\n        t.send(e, i, o);\n      }, o = o || function () {});\n    }, E.prototype.getActor = function () {\n      return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n    }, E.prototype.remove = function () {\n      this.actors.forEach(function (t) {\n        t.remove();\n      }), this.actors = [], this.workerPool.release(this.id);\n    }, E.Actor = t.Actor;\n\n    var P = function P(e, i, o) {\n      this.bounds = t.LngLatBounds.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = o || 24;\n    };\n\n    P.prototype.validateBounds = function (t) {\n      return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];\n    }, P.prototype.contains = function (e) {\n      var i = Math.pow(2, e.z),\n          o = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i),\n          r = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i),\n          a = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i),\n          n = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i);\n      return e.x >= o && e.x < a && e.y >= r && e.y < n;\n    };\n\n    var S = function (e) {\n      function i(i, o, r, a) {\n        if (e.call(this), this.id = i, this.dispatcher = r, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(o, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({\n          type: "vector"\n        }, o), this._collectResourceTiming = o.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");\n        this.setEventedParent(a);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this._loaded = !1, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._tileJSONRequest = I(this._options, this.map._requestManager, function (i, o) {\n          e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (t.extend(e, o), o.bounds && (e.tileBounds = new P(o.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(o.tiles, e.map._requestManager._customAccessToken), t.postMapLoadEvent(o.tiles, e.map._getMapId(), e.map._requestManager._skuToken, e.map._requestManager._customAccessToken), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "metadata"\n          })), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "content"\n          })));\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.hasTile = function (t) {\n        return !this.tileBounds || this.tileBounds.contains(t.canonical);\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.setSourceProperty = function (t) {\n        this._tileJSONRequest && this._tileJSONRequest.cancel(), t(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();\n      }, i.prototype.setTiles = function (t) {\n        var e = this;\n        return this.setSourceProperty(function () {\n          e._options.tiles = t;\n        }), this;\n      }, i.prototype.setUrl = function (t) {\n        var e = this;\n        return this.setSourceProperty(function () {\n          e.url = t, e._options.url = t;\n        }), this;\n      }, i.prototype.onRemove = function () {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }, i.prototype.serialize = function () {\n        return t.extend({}, this._options);\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme)),\n            r = {\n          request: this.map._requestManager.transformRequest(o, t.ResourceType.Tile),\n          uid: e.uid,\n          tileID: e.tileID,\n          zoom: e.tileID.overscaledZ,\n          tileSize: this.tileSize * e.tileID.overscaleFactor(),\n          type: this.type,\n          source: this.id,\n          pixelRatio: t.browser.devicePixelRatio,\n          showCollisionBoxes: this.map.showCollisionBoxes,\n          promoteId: this.promoteId\n        };\n\n        function a(o, r) {\n          return delete e.request, e.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (e.reloadCallback && (this.loadTile(e, e.reloadCallback), e.reloadCallback = null)));\n        }\n\n        r.request.collectResourceTiming = this._collectResourceTiming, e.actor && "expired" !== e.state ? "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", r, a.bind(this)) : (e.actor = this.dispatcher.getActor(), e.request = e.actor.send("loadTile", r, a.bind(this)));\n      }, i.prototype.abortTile = function (t) {\n        t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        }, void 0);\n      }, i.prototype.unloadTile = function (t) {\n        t.unloadVectorData(), t.actor && t.actor.send("removeTile", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        }, void 0);\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        C = function (e) {\n      function i(i, o, r, a) {\n        e.call(this), this.id = i, this.dispatcher = r, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.extend({\n          type: "raster"\n        }, o), t.extend(this, t.pick(o, ["url", "scheme", "tileSize"]));\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this._loaded = !1, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._tileJSONRequest = I(this._options, this.map._requestManager, function (i, o) {\n          e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (t.extend(e, o), o.bounds && (e.tileBounds = new P(o.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(o.tiles), t.postMapLoadEvent(o.tiles, e.map._getMapId(), e.map._requestManager._skuToken), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "metadata"\n          })), e.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "content"\n          })));\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.onRemove = function () {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }, i.prototype.serialize = function () {\n        return t.extend({}, this._options);\n      }, i.prototype.hasTile = function (t) {\n        return !this.tileBounds || this.tileBounds.contains(t.canonical);\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this,\n            r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);\n\n        e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), function (r, a) {\n          if (delete e.request, e.aborted) e.state = "unloaded", i(null);else if (r) e.state = "errored", i(r);else if (a) {\n            o.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n            var n = o.map.painter.context,\n                s = n.gl;\n            e.texture = o.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, {\n              useMipmap: !0\n            }) : (e.texture = new t.Texture(n, a, s.RGBA, {\n              useMipmap: !0\n            }), e.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), n.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax)), e.state = "loaded", t.cacheEntryPossiblyAdded(o.dispatcher), i(null);\n          }\n        });\n      }, i.prototype.abortTile = function (t, e) {\n        t.request && (t.request.cancel(), delete t.request), e();\n      }, i.prototype.unloadTile = function (t, e) {\n        t.texture && this.map.painter.saveTileTexture(t.texture), e();\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        z = function (e) {\n      function i(i, o, r, a) {\n        e.call(this, i, o, r, a), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({\n          type: "raster-dem"\n        }, o), this.encoding = o.encoding || "mapbox";\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.serialize = function () {\n        return {\n          type: "raster-dem",\n          url: this.url,\n          tileSize: this.tileSize,\n          tiles: this.tiles,\n          bounds: this.bounds,\n          encoding: this.encoding\n        };\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);\n\n        function r(t, o) {\n          t && (e.state = "errored", i(t)), o && (e.dem = o, e.needsHillshadePrepare = !0, e.state = "loaded", i(null));\n        }\n\n        e.request = t.getImage(this.map._requestManager.transformRequest(o, t.ResourceType.Tile), function (o, a) {\n          if (delete e.request, e.aborted) e.state = "unloaded", i(null);else if (o) e.state = "errored", i(o);else if (a) {\n            this.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n            var n = t.window.ImageBitmap && a instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a : t.browser.getImageData(a, 1),\n                s = {\n              uid: e.uid,\n              coord: e.tileID,\n              source: this.id,\n              rawImageData: n,\n              encoding: this.encoding\n            };\n            e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(), e.actor.send("loadDEMTile", s, r.bind(this)));\n          }\n        }.bind(this)), e.neighboringTiles = this._getNeighboringTiles(e.tileID);\n      }, i.prototype._getNeighboringTiles = function (e) {\n        var i = e.canonical,\n            o = Math.pow(2, i.z),\n            r = (i.x - 1 + o) % o,\n            a = 0 === i.x ? e.wrap - 1 : e.wrap,\n            n = (i.x + 1 + o) % o,\n            s = i.x + 1 === o ? e.wrap + 1 : e.wrap,\n            l = {};\n        return l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y).key] = {\n          backfilled: !1\n        }, i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y - 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y - 1).key] = {\n          backfilled: !1\n        }), i.y + 1 < o && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y + 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y + 1).key] = {\n          backfilled: !1\n        }), l;\n      }, i.prototype.unloadTile = function (t) {\n        t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && t.actor.send("removeDEMTile", {\n          uid: t.uid,\n          source: this.id\n        });\n      }, i;\n    }(C),\n        D = function (e) {\n      function i(i, o, r, a) {\n        e.call(this), this.id = i, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = r.getActor(), this.setEventedParent(a), this._data = o.data, this._options = t.extend({}, o), this._collectResourceTiming = o.collectResourceTiming, this._resourceTiming = [], void 0 !== o.maxzoom && (this.maxzoom = o.maxzoom), o.type && (this.type = o.type), o.attribution && (this.attribution = o.attribution), this.promoteId = o.promoteId;\n        var n = t.EXTENT / this.tileSize;\n        this.workerOptions = t.extend({\n          source: this.id,\n          cluster: o.cluster || !1,\n          geojsonVtOptions: {\n            buffer: (void 0 !== o.buffer ? o.buffer : 128) * n,\n            tolerance: (void 0 !== o.tolerance ? o.tolerance : .375) * n,\n            extent: t.EXTENT,\n            maxZoom: this.maxzoom,\n            lineMetrics: o.lineMetrics || !1,\n            generateId: o.generateId || !1\n          },\n          superclusterOptions: {\n            maxZoom: void 0 !== o.clusterMaxZoom ? Math.min(o.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1,\n            minPoints: Math.max(2, o.clusterMinPoints || 2),\n            extent: t.EXTENT,\n            radius: (o.clusterRadius || 50) * n,\n            log: !1,\n            generateId: o.generateId || !1\n          },\n          clusterProperties: o.clusterProperties,\n          filter: o.filter\n        }, o.workerOptions);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._updateWorkerData(function (i) {\n          if (i) e.fire(new t.ErrorEvent(i));else {\n            var o = {\n              dataType: "source",\n              sourceDataType: "metadata"\n            };\n            e._collectResourceTiming && e._resourceTiming && e._resourceTiming.length > 0 && (o.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new t.Event("data", o));\n          }\n        });\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.setData = function (e) {\n        var i = this;\n        return this._data = e, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this._updateWorkerData(function (e) {\n          if (e) i.fire(new t.ErrorEvent(e));else {\n            var o = {\n              dataType: "source",\n              sourceDataType: "content"\n            };\n            i._collectResourceTiming && i._resourceTiming && i._resourceTiming.length > 0 && (o.resourceTiming = i._resourceTiming, i._resourceTiming = []), i.fire(new t.Event("data", o));\n          }\n        }), this;\n      }, i.prototype.getClusterExpansionZoom = function (t, e) {\n        return this.actor.send("geojson.getClusterExpansionZoom", {\n          clusterId: t,\n          source: this.id\n        }, e), this;\n      }, i.prototype.getClusterChildren = function (t, e) {\n        return this.actor.send("geojson.getClusterChildren", {\n          clusterId: t,\n          source: this.id\n        }, e), this;\n      }, i.prototype.getClusterLeaves = function (t, e, i, o) {\n        return this.actor.send("geojson.getClusterLeaves", {\n          source: this.id,\n          clusterId: t,\n          limit: e,\n          offset: i\n        }, o), this;\n      }, i.prototype._updateWorkerData = function (e) {\n        var i = this;\n        this._loaded = !1;\n        var o = t.extend({}, this.workerOptions),\n            r = this._data;\n        "string" == typeof r ? (o.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r), t.ResourceType.Source), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(r), this.actor.send(this.type + ".loadData", o, function (t, r) {\n          i._removed || r && r.abandoned || (i._loaded = !0, r && r.resourceTiming && r.resourceTiming[i.id] && (i._resourceTiming = r.resourceTiming[i.id].slice(0)), i.actor.send(i.type + ".coalesce", {\n            source: o.source\n          }, null), e(t));\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.loadTile = function (e, i) {\n        var o = this,\n            r = e.actor ? "reloadTile" : "loadTile";\n        e.actor = this.actor, e.request = this.actor.send(r, {\n          type: this.type,\n          uid: e.uid,\n          tileID: e.tileID,\n          zoom: e.tileID.overscaledZ,\n          maxZoom: this.maxzoom,\n          tileSize: this.tileSize,\n          source: this.id,\n          pixelRatio: t.browser.devicePixelRatio,\n          showCollisionBoxes: this.map.showCollisionBoxes,\n          promoteId: this.promoteId\n        }, function (t, a) {\n          return delete e.request, e.unloadVectorData(), e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(a, o.map.painter, "reloadTile" === r), i(null));\n        });\n      }, i.prototype.abortTile = function (t) {\n        t.request && (t.request.cancel(), delete t.request), t.aborted = !0;\n      }, i.prototype.unloadTile = function (t) {\n        t.unloadVectorData(), this.actor.send("removeTile", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        });\n      }, i.prototype.onRemove = function () {\n        this._removed = !0, this.actor.send("removeSource", {\n          type: this.type,\n          source: this.id\n        });\n      }, i.prototype.serialize = function () {\n        return t.extend({}, this._options, {\n          type: this.type,\n          data: this._data\n        });\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        A = t.createLayout([{\n      name: "a_pos",\n      type: "Int16",\n      components: 2\n    }, {\n      name: "a_texture_pos",\n      type: "Int16",\n      components: 2\n    }]),\n        M = function (e) {\n      function i(t, i, o, r) {\n        e.call(this), this.id = t, this.dispatcher = o, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(r), this.options = i;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function (e, i) {\n        var o = this;\n        this._loaded = !1, this.fire(new t.Event("dataloading", {\n          dataType: "source"\n        })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function (r, a) {\n          o._loaded = !0, r ? o.fire(new t.ErrorEvent(r)) : a && (o.image = a, e && (o.coordinates = e), i && i(), o._finishLoading());\n        });\n      }, i.prototype.loaded = function () {\n        return this._loaded;\n      }, i.prototype.updateImage = function (t) {\n        var e = this;\n        return this.image && t.url ? (this.options.url = t.url, this.load(t.coordinates, function () {\n          e.texture = null;\n        }), this) : this;\n      }, i.prototype._finishLoading = function () {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", {\n          dataType: "source",\n          sourceDataType: "metadata"\n        })));\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load();\n      }, i.prototype.setCoordinates = function (e) {\n        var i = this;\n        this.coordinates = e;\n        var o = e.map(t.MercatorCoordinate.fromLngLat);\n        this.tileID = function (e) {\n          for (var i = 1 / 0, o = 1 / 0, r = -1 / 0, a = -1 / 0, n = 0, s = e; n < s.length; n += 1) {\n            var l = s[n];\n            i = Math.min(i, l.x), o = Math.min(o, l.y), r = Math.max(r, l.x), a = Math.max(a, l.y);\n          }\n\n          var c = Math.max(r - i, a - o),\n              u = Math.max(0, Math.floor(-Math.log(c) / Math.LN2)),\n              h = Math.pow(2, u);\n          return new t.CanonicalTileID(u, Math.floor((i + r) / 2 * h), Math.floor((o + a) / 2 * h));\n        }(o), this.minzoom = this.maxzoom = this.tileID.z;\n        var r = o.map(function (t) {\n          return i.tileID.getTilePoint(t)._round();\n        });\n        return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r[0].x, r[0].y, 0, 0), this._boundsArray.emplaceBack(r[1].x, r[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r[3].x, r[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r[2].x, r[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", {\n          dataType: "source",\n          sourceDataType: "content"\n        })), this;\n      }, i.prototype.prepare = function () {\n        if (0 !== Object.keys(this.tiles).length && this.image) {\n          var e = this.map.painter.context,\n              i = e.gl;\n\n          for (var o in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) {\n            var r = this.tiles[o];\n            "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture);\n          }\n        }\n      }, i.prototype.loadTile = function (t, e) {\n        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = "errored", e(null));\n      }, i.prototype.serialize = function () {\n        return {\n          type: "image",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }, i.prototype.hasTransition = function () {\n        return !1;\n      }, i;\n    }(t.Evented),\n        L = function (e) {\n      function i(t, i, o, r) {\n        e.call(this, t, i, o, r), this.roundZoom = !0, this.type = "video", this.options = i;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        var e = this;\n        this._loaded = !1;\n        var i = this.options;\n        this.urls = [];\n\n        for (var o = 0, r = i.urls; o < r.length; o += 1) {\n          this.urls.push(this.map._requestManager.transformRequest(r[o], t.ResourceType.Source).url);\n        }\n\n        t.getVideo(this.urls, function (i, o) {\n          e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (e.video = o, e.video.loop = !0, e.video.addEventListener("playing", function () {\n            e.map.triggerRepaint();\n          }), e.map && e.video.play(), e._finishLoading());\n        });\n      }, i.prototype.pause = function () {\n        this.video && this.video.pause();\n      }, i.prototype.play = function () {\n        this.video && this.video.play();\n      }, i.prototype.seek = function (e) {\n        if (this.video) {\n          var i = this.video.seekable;\n          e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i.start(0) + " and " + i.end(0) + "-second mark."))) : this.video.currentTime = e;\n        }\n      }, i.prototype.getVideo = function () {\n        return this.video;\n      }, i.prototype.onAdd = function (t) {\n        this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n      }, i.prototype.prepare = function () {\n        if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {\n          var e = this.map.painter.context,\n              i = e.gl;\n\n          for (var o in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) {\n            var r = this.tiles[o];\n            "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture);\n          }\n        }\n      }, i.prototype.serialize = function () {\n        return {\n          type: "video",\n          urls: this.urls,\n          coordinates: this.coordinates\n        };\n      }, i.prototype.hasTransition = function () {\n        return this.video && !this.video.paused;\n      }, i;\n    }(M),\n        R = function (e) {\n      function i(i, o, r, a) {\n        e.call(this, i, o, r, a), o.coordinates ? Array.isArray(o.coordinates) && 4 === o.coordinates.length && !o.coordinates.some(function (t) {\n          return !Array.isArray(t) || 2 !== t.length || t.some(function (t) {\n            return "number" != typeof t;\n          });\n        }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'"coordinates" property must be an array of 4 longitude/latitude array pairs\'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'missing required property "coordinates"\'))), o.animate && "boolean" != typeof o.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'optional "animate" property must be a boolean value\'))), o.canvas ? "string" == typeof o.canvas || o.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance\'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'missing required property "canvas"\'))), this.options = o, this.animate = void 0 === o.animate || o.animate;\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n        this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {\n          this._playing = !0, this.map.triggerRepaint();\n        }, this.pause = function () {\n          this._playing && (this.prepare(), this._playing = !1);\n        }, this._finishLoading());\n      }, i.prototype.getCanvas = function () {\n        return this.canvas;\n      }, i.prototype.onAdd = function (t) {\n        this.map = t, this.load(), this.canvas && this.animate && this.play();\n      }, i.prototype.onRemove = function () {\n        this.pause();\n      }, i.prototype.prepare = function () {\n        var e = !1;\n\n        if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {\n          var i = this.map.painter.context,\n              o = i.gl;\n\n          for (var r in this.boundsBuffer || (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, {\n            premultiply: !0\n          }) : this.texture = new t.Texture(i, this.canvas, o.RGBA, {\n            premultiply: !0\n          }), this.tiles) {\n            var a = this.tiles[r];\n            "loaded" !== a.state && (a.state = "loaded", a.texture = this.texture);\n          }\n        }\n      }, i.prototype.serialize = function () {\n        return {\n          type: "canvas",\n          coordinates: this.coordinates\n        };\n      }, i.prototype.hasTransition = function () {\n        return this._playing;\n      }, i.prototype._hasInvalidDimensions = function () {\n        for (var t = 0, e = [this.canvas.width, this.canvas.height]; t < e.length; t += 1) {\n          var i = e[t];\n          if (isNaN(i) || i <= 0) return !0;\n        }\n\n        return !1;\n      }, i;\n    }(M),\n        k = {\n      vector: S,\n      raster: C,\n      "raster-dem": z,\n      geojson: D,\n      video: L,\n      image: M,\n      canvas: R\n    };\n\n    function B(e, i) {\n      var o = t.identity([]);\n      return t.translate(o, o, [1, 1, 0]), t.scale(o, o, [.5 * e.width, .5 * e.height, 1]), t.multiply(o, o, e.calculatePosMatrix(i.toUnwrapped()));\n    }\n\n    function O(t, e, i, o, r, a) {\n      var n = function (t, e, i) {\n        if (t) for (var o = 0, r = t; o < r.length; o += 1) {\n          var a = e[r[o]];\n          if (a && a.source === i && "fill-extrusion" === a.type) return !0;\n        } else for (var n in e) {\n          var s = e[n];\n          if (s.source === i && "fill-extrusion" === s.type) return !0;\n        }\n        return !1;\n      }(r && r.layers, e, t.id),\n          s = a.maxPitchScaleFactor(),\n          l = t.tilesIn(o, s, n);\n\n      l.sort(F);\n\n      for (var c = [], u = 0, h = l; u < h.length; u += 1) {\n        var p = h[u];\n        c.push({\n          wrappedTileID: p.tileID.wrapped().key,\n          queryResults: p.tile.queryRenderedFeatures(e, i, t._state, p.queryGeometry, p.cameraQueryGeometry, p.scale, r, a, s, B(t.transform, p.tileID))\n        });\n      }\n\n      var d = function (t) {\n        for (var e = {}, i = {}, o = 0, r = t; o < r.length; o += 1) {\n          var a = r[o],\n              n = a.queryResults,\n              s = a.wrappedTileID,\n              l = i[s] = i[s] || {};\n\n          for (var c in n) {\n            for (var u = n[c], h = l[c] = l[c] || {}, p = e[c] = e[c] || [], d = 0, _ = u; d < _.length; d += 1) {\n              var f = _[d];\n              h[f.featureIndex] || (h[f.featureIndex] = !0, p.push(f));\n            }\n          }\n        }\n\n        return e;\n      }(c);\n\n      for (var _ in d) {\n        d[_].forEach(function (e) {\n          var i = e.feature,\n              o = t.getFeatureState(i.layer["source-layer"], i.id);\n          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = o;\n        });\n      }\n\n      return d;\n    }\n\n    function F(t, e) {\n      var i = t.tileID,\n          o = e.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n\n    var U = function U(t, e) {\n      this.max = t, this.onRemove = e, this.reset();\n    };\n\n    U.prototype.reset = function () {\n      for (var t in this.data) {\n        for (var e = 0, i = this.data[t]; e < i.length; e += 1) {\n          var o = i[e];\n          o.timeout && clearTimeout(o.timeout), this.onRemove(o.value);\n        }\n      }\n\n      return this.data = {}, this.order = [], this;\n    }, U.prototype.add = function (t, e, i) {\n      var o = this,\n          r = t.wrapped().key;\n      void 0 === this.data[r] && (this.data[r] = []);\n      var a = {\n        value: e,\n        timeout: void 0\n      };\n\n      if (void 0 !== i && (a.timeout = setTimeout(function () {\n        o.remove(t, a);\n      }, i)), this.data[r].push(a), this.order.push(r), this.order.length > this.max) {\n        var n = this._getAndRemoveByKey(this.order[0]);\n\n        n && this.onRemove(n);\n      }\n\n      return this;\n    }, U.prototype.has = function (t) {\n      return t.wrapped().key in this.data;\n    }, U.prototype.getAndRemove = function (t) {\n      return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;\n    }, U.prototype._getAndRemoveByKey = function (t) {\n      var e = this.data[t].shift();\n      return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;\n    }, U.prototype.getByKey = function (t) {\n      var e = this.data[t];\n      return e ? e[0].value : null;\n    }, U.prototype.get = function (t) {\n      return this.has(t) ? this.data[t.wrapped().key][0].value : null;\n    }, U.prototype.remove = function (t, e) {\n      if (!this.has(t)) return this;\n      var i = t.wrapped().key,\n          o = void 0 === e ? 0 : this.data[i].indexOf(e),\n          r = this.data[i][o];\n      return this.data[i].splice(o, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(r.value), this.order.splice(this.order.indexOf(i), 1), this;\n    }, U.prototype.setMaxSize = function (t) {\n      for (this.max = t; this.order.length > this.max;) {\n        var e = this._getAndRemoveByKey(this.order[0]);\n\n        e && this.onRemove(e);\n      }\n\n      return this;\n    }, U.prototype.filter = function (t) {\n      var e = [];\n\n      for (var i in this.data) {\n        for (var o = 0, r = this.data[i]; o < r.length; o += 1) {\n          var a = r[o];\n          t(a.value) || e.push(a);\n        }\n      }\n\n      for (var n = 0, s = e; n < s.length; n += 1) {\n        var l = s[n];\n        this.remove(l.value.tileID, l);\n      }\n    };\n\n    var N = function N(t, e, i) {\n      this.context = t;\n      var o = t.gl;\n      this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n    };\n\n    N.prototype.bind = function () {\n      this.context.bindElementBuffer.set(this.buffer);\n    }, N.prototype.updateData = function (t) {\n      var e = this.context.gl;\n      this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);\n    }, N.prototype.destroy = function () {\n      this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n    };\n\n    var Z = {\n      Int8: "BYTE",\n      Uint8: "UNSIGNED_BYTE",\n      Int16: "SHORT",\n      Uint16: "UNSIGNED_SHORT",\n      Int32: "INT",\n      Uint32: "UNSIGNED_INT",\n      Float32: "FLOAT"\n    },\n        q = function q(t, e, i, o) {\n      this.length = e.length, this.attributes = i, this.itemSize = e.bytesPerElement, this.dynamicDraw = o, this.context = t;\n      var r = t.gl;\n      this.buffer = r.createBuffer(), t.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n    };\n\n    q.prototype.bind = function () {\n      this.context.bindVertexBuffer.set(this.buffer);\n    }, q.prototype.updateData = function (t) {\n      var e = this.context.gl;\n      this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);\n    }, q.prototype.enableAttributes = function (t, e) {\n      for (var i = 0; i < this.attributes.length; i++) {\n        var o = e.attributes[this.attributes[i].name];\n        void 0 !== o && t.enableVertexAttribArray(o);\n      }\n    }, q.prototype.setVertexAttribPointers = function (t, e, i) {\n      for (var o = 0; o < this.attributes.length; o++) {\n        var r = this.attributes[o],\n            a = e.attributes[r.name];\n        void 0 !== a && t.vertexAttribPointer(a, r.components, t[Z[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));\n      }\n    }, q.prototype.destroy = function () {\n      this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n    };\n\n    var j = function j(t) {\n      this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n    };\n\n    j.prototype.get = function () {\n      return this.current;\n    }, j.prototype.set = function (t) {}, j.prototype.getDefault = function () {\n      return this.default;\n    }, j.prototype.setDefault = function () {\n      this.set(this.default);\n    };\n\n    var V = function (e) {\n      function i() {\n        e.apply(this, arguments);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () {\n        return t.Color.transparent;\n      }, i.prototype.set = function (t) {\n        var e = this.current;\n        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n      }, i;\n    }(j),\n        G = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 1;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        W = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 0;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        X = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return [!0, !0, !0, !0];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        H = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !0;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        K = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 255;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        Y = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        J = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        var t = this.gl;\n        return [t.KEEP, t.KEEP, t.KEEP];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        Q = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        $ = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return [0, 1];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        tt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        et = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.LESS;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        it = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        ot = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        var t = this.gl;\n        return [t.ONE, t.ZERO];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        rt = function (e) {\n      function i() {\n        e.apply(this, arguments);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () {\n        return t.Color.transparent;\n      }, i.prototype.set = function (t) {\n        var e = this.current;\n        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n      }, i;\n    }(j),\n        at = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.FUNC_ADD;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        nt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        st = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.BACK;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        lt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.CCW;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        ct = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        ut = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return this.gl.TEXTURE0;\n      }, e.prototype.set = function (t) {\n        (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        ht = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        var t = this.gl;\n        return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];\n      }, e.prototype.set = function (t) {\n        var e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        pt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindFramebuffer(e.FRAMEBUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        dt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindRenderbuffer(e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        _t = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindTexture(e.TEXTURE_2D, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        ft = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.bindBuffer(e.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        mt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        var e = this.gl;\n        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n      }, e;\n    }(j),\n        gt = function (t) {\n      function e(e) {\n        t.call(this, e), this.vao = e.extVertexArrayObject;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e.prototype.set = function (t) {\n        this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t), this.current = t, this.dirty = !1);\n      }, e;\n    }(j),\n        vt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return 4;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        yt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        xt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return !1;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          var e = this.gl;\n          e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(j),\n        bt = function (t) {\n      function e(e, i) {\n        t.call(this, e), this.context = e, this.parent = i;\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n        return null;\n      }, e;\n    }(j),\n        wt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.setDirty = function () {\n        this.dirty = !0;\n      }, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          this.context.bindFramebuffer.set(this.parent);\n          var e = this.gl;\n          e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(bt),\n        Tt = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n        if (t !== this.current || this.dirty) {\n          this.context.bindFramebuffer.set(this.parent);\n          var e = this.gl;\n          e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n        }\n      }, e;\n    }(bt),\n        Et = function Et(t, e, i, o) {\n      this.context = t, this.width = e, this.height = i;\n      var r = this.framebuffer = t.gl.createFramebuffer();\n      this.colorAttachment = new wt(t, r), o && (this.depthAttachment = new Tt(t, r));\n    };\n\n    Et.prototype.destroy = function () {\n      var t = this.context.gl,\n          e = this.colorAttachment.get();\n\n      if (e && t.deleteTexture(e), this.depthAttachment) {\n        var i = this.depthAttachment.get();\n        i && t.deleteRenderbuffer(i);\n      }\n\n      t.deleteFramebuffer(this.framebuffer);\n    };\n\n    var It = function It(t, e, i) {\n      this.func = t, this.mask = e, this.range = i;\n    };\n\n    It.ReadOnly = !1, It.ReadWrite = !0, It.disabled = new It(519, It.ReadOnly, [0, 1]);\n\n    var Pt = function Pt(t, e, i, o, r, a) {\n      this.test = t, this.ref = e, this.mask = i, this.fail = o, this.depthFail = r, this.pass = a;\n    };\n\n    Pt.disabled = new Pt({\n      func: 519,\n      mask: 0\n    }, 0, 0, 7680, 7680, 7680);\n\n    var St = function St(t, e, i) {\n      this.blendFunction = t, this.blendColor = e, this.mask = i;\n    };\n\n    St.disabled = new St(St.Replace = [1, 0], t.Color.transparent, [!1, !1, !1, !1]), St.unblended = new St(St.Replace, t.Color.transparent, [!0, !0, !0, !0]), St.alphaBlended = new St([1, 771], t.Color.transparent, [!0, !0, !0, !0]);\n\n    var Ct = function Ct(t, e, i) {\n      this.enable = t, this.mode = e, this.frontFace = i;\n    };\n\n    Ct.disabled = new Ct(!1, 1029, 2305), Ct.backCCW = new Ct(!0, 1029, 2305);\n\n    var zt = function zt(t) {\n      this.gl = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);\n    };\n\n    zt.prototype.setDefault = function () {\n      this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n    }, zt.prototype.setDirty = function () {\n      this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n    }, zt.prototype.createIndexBuffer = function (t, e) {\n      return new N(this, t, e);\n    }, zt.prototype.createVertexBuffer = function (t, e, i) {\n      return new q(this, t, e, i);\n    }, zt.prototype.createRenderbuffer = function (t, e, i) {\n      var o = this.gl,\n          r = o.createRenderbuffer();\n      return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, t, e, i), this.bindRenderbuffer.set(null), r;\n    }, zt.prototype.createFramebuffer = function (t, e, i) {\n      return new Et(this, t, e, i);\n    }, zt.prototype.clear = function (t) {\n      var e = t.color,\n          i = t.depth,\n          o = this.gl,\n          r = 0;\n      e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== i && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), o.clear(r);\n    }, zt.prototype.setCullFace = function (t) {\n      !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));\n    }, zt.prototype.setDepthMode = function (t) {\n      t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);\n    }, zt.prototype.setStencilMode = function (t) {\n      t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({\n        func: t.test.func,\n        ref: t.ref,\n        mask: t.test.mask\n      })) : this.stencilTest.set(!1);\n    }, zt.prototype.setColorMode = function (e) {\n      t.deepEqual(e.blendFunction, St.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);\n    }, zt.prototype.unbindVAO = function () {\n      this.extVertexArrayObject && this.bindVertexArrayOES.set(null);\n    };\n\n    var Dt = function (e) {\n      function i(i, o, r) {\n        var a = this;\n        e.call(this), this.id = i, this.dispatcher = r, this.on("data", function (t) {\n          "source" === t.dataType && "metadata" === t.sourceDataType && (a._sourceLoaded = !0), a._sourceLoaded && !a._paused && "source" === t.dataType && "content" === t.sourceDataType && (a.reload(), a.transform && a.update(a.transform));\n        }), this.on("error", function () {\n          a._sourceErrored = !0;\n        }), this._source = function (e, i, o, r) {\n          var a = new k[i.type](e, i, o, r);\n          if (a.id !== e) throw new Error("Expected Source id to be " + e + " instead of " + a.id);\n          return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a), a;\n        }(i, o, r, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.onAdd = function (t) {\n        this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t);\n      }, i.prototype.onRemove = function (t) {\n        this._source && this._source.onRemove && this._source.onRemove(t);\n      }, i.prototype.loaded = function () {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n\n        for (var t in this._tiles) {\n          var e = this._tiles[t];\n          if ("loaded" !== e.state && "errored" !== e.state) return !1;\n        }\n\n        return !0;\n      }, i.prototype.getSource = function () {\n        return this._source;\n      }, i.prototype.pause = function () {\n        this._paused = !0;\n      }, i.prototype.resume = function () {\n        if (this._paused) {\n          var t = this._shouldReloadOnResume;\n          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);\n        }\n      }, i.prototype._loadTile = function (t, e) {\n        return this._source.loadTile(t, e);\n      }, i.prototype._unloadTile = function (t) {\n        if (this._source.unloadTile) return this._source.unloadTile(t, function () {});\n      }, i.prototype._abortTile = function (t) {\n        if (this._source.abortTile) return this._source.abortTile(t, function () {});\n      }, i.prototype.serialize = function () {\n        return this._source.serialize();\n      }, i.prototype.prepare = function (t) {\n        for (var e in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {\n          var i = this._tiles[e];\n          i.upload(t), i.prepare(this.map.style.imageManager);\n        }\n      }, i.prototype.getIds = function () {\n        return t.values(this._tiles).map(function (t) {\n          return t.tileID;\n        }).sort(At).map(function (t) {\n          return t.key;\n        });\n      }, i.prototype.getRenderableIds = function (e) {\n        var i = this,\n            o = [];\n\n        for (var r in this._tiles) {\n          this._isIdRenderable(r, e) && o.push(this._tiles[r]);\n        }\n\n        return e ? o.sort(function (e, o) {\n          var r = e.tileID,\n              a = o.tileID,\n              n = new t.Point(r.canonical.x, r.canonical.y)._rotate(i.transform.angle),\n              s = new t.Point(a.canonical.x, a.canonical.y)._rotate(i.transform.angle);\n\n          return r.overscaledZ - a.overscaledZ || s.y - n.y || s.x - n.x;\n        }).map(function (t) {\n          return t.tileID.key;\n        }) : o.map(function (t) {\n          return t.tileID;\n        }).sort(At).map(function (t) {\n          return t.key;\n        });\n      }, i.prototype.hasRenderableParent = function (t) {\n        var e = this.findLoadedParent(t, 0);\n        return !!e && this._isIdRenderable(e.tileID.key);\n      }, i.prototype._isIdRenderable = function (t, e) {\n        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());\n      }, i.prototype.reload = function () {\n        if (this._paused) this._shouldReloadOnResume = !0;else for (var t in this._cache.reset(), this._tiles) {\n          "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading");\n        }\n      }, i.prototype._reloadTile = function (t, e) {\n        var i = this._tiles[t];\n        i && ("loading" !== i.state && (i.state = e), this._loadTile(i, this._tileLoaded.bind(this, i, t, e)));\n      }, i.prototype._tileLoaded = function (e, i, o, r) {\n        if (r) return e.state = "errored", void (404 !== r.status ? this._source.fire(new t.ErrorEvent(r, {\n          tile: e\n        })) : this.update(this.transform));\n        e.timeAdded = t.browser.now(), "expired" === o && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", {\n          dataType: "source",\n          tile: e,\n          coord: e.tileID\n        }));\n      }, i.prototype._backfillDEM = function (t) {\n        for (var e = this.getRenderableIds(), i = 0; i < e.length; i++) {\n          var o = e[i];\n\n          if (t.neighboringTiles && t.neighboringTiles[o]) {\n            var r = this.getTileByID(o);\n            a(t, r), a(r, t);\n          }\n        }\n\n        function a(t, e) {\n          t.needsHillshadePrepare = !0;\n          var i = e.tileID.canonical.x - t.tileID.canonical.x,\n              o = e.tileID.canonical.y - t.tileID.canonical.y,\n              r = Math.pow(2, t.tileID.canonical.z),\n              a = e.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + r) ? i += r : 1 === Math.abs(i - r) && (i -= r)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, o), t.neighboringTiles && t.neighboringTiles[a] && (t.neighboringTiles[a].backfilled = !0)));\n        }\n      }, i.prototype.getTile = function (t) {\n        return this.getTileByID(t.key);\n      }, i.prototype.getTileByID = function (t) {\n        return this._tiles[t];\n      }, i.prototype._retainLoadedChildren = function (t, e, i, o) {\n        for (var r in this._tiles) {\n          var a = this._tiles[r];\n\n          if (!(o[r] || !a.hasData() || a.tileID.overscaledZ <= e || a.tileID.overscaledZ > i)) {\n            for (var n = a.tileID; a && a.tileID.overscaledZ > e + 1;) {\n              var s = a.tileID.scaledTo(a.tileID.overscaledZ - 1);\n              (a = this._tiles[s.key]) && a.hasData() && (n = s);\n            }\n\n            for (var l = n; l.overscaledZ > e;) {\n              if (t[(l = l.scaledTo(l.overscaledZ - 1)).key]) {\n                o[n.key] = n;\n                break;\n              }\n            }\n          }\n        }\n      }, i.prototype.findLoadedParent = function (t, e) {\n        if (t.key in this._loadedParentTiles) {\n          var i = this._loadedParentTiles[t.key];\n          return i && i.tileID.overscaledZ >= e ? i : null;\n        }\n\n        for (var o = t.overscaledZ - 1; o >= e; o--) {\n          var r = t.scaledTo(o),\n              a = this._getLoadedTile(r);\n\n          if (a) return a;\n        }\n      }, i.prototype._getLoadedTile = function (t) {\n        var e = this._tiles[t.key];\n        return e && e.hasData() ? e : this._cache.getByKey(t.wrapped().key);\n      }, i.prototype.updateCacheSize = function (t) {\n        var e = Math.ceil(t.width / this._source.tileSize) + 1,\n            i = Math.ceil(t.height / this._source.tileSize) + 1,\n            o = Math.floor(e * i * 5),\n            r = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;\n\n        this._cache.setMaxSize(r);\n      }, i.prototype.handleWrapJump = function (t) {\n        var e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);\n\n        if (this._prevLng = t, e) {\n          var i = {};\n\n          for (var o in this._tiles) {\n            var r = this._tiles[o];\n            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e), i[r.tileID.key] = r;\n          }\n\n          for (var a in this._tiles = i, this._timers) {\n            clearTimeout(this._timers[a]), delete this._timers[a];\n          }\n\n          for (var n in this._tiles) {\n            this._setTileReloadTimer(n, this._tiles[n]);\n          }\n        }\n      }, i.prototype.update = function (e) {\n        var o = this;\n\n        if (this.transform = e, this._sourceLoaded && !this._paused) {\n          var r;\n          this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(function (e) {\n            return new t.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y);\n          }) : (r = e.coveringTiles({\n            tileSize: this._source.tileSize,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom,\n            reparseOverscaled: this._source.reparseOverscaled\n          }), this._source.hasTile && (r = r.filter(function (t) {\n            return o._source.hasTile(t);\n          }))) : r = [];\n\n          var a = e.coveringZoomLevel(this._source),\n              n = Math.max(a - i.maxOverzooming, this._source.minzoom),\n              s = Math.max(a + i.maxUnderzooming, this._source.minzoom),\n              l = this._updateRetainedTiles(r, a);\n\n          if (Mt(this._source.type)) {\n            for (var c = {}, u = {}, h = 0, p = Object.keys(l); h < p.length; h += 1) {\n              var d = p[h],\n                  _ = l[d],\n                  f = this._tiles[d];\n\n              if (f && !(f.fadeEndTime && f.fadeEndTime <= t.browser.now())) {\n                var m = this.findLoadedParent(_, n);\n                m && (this._addTile(m.tileID), c[m.tileID.key] = m.tileID), u[d] = _;\n              }\n            }\n\n            for (var g in this._retainLoadedChildren(u, a, s, l), c) {\n              l[g] || (this._coveredTiles[g] = !0, l[g] = c[g]);\n            }\n          }\n\n          for (var v in l) {\n            this._tiles[v].clearFadeHold();\n          }\n\n          for (var y = 0, x = t.keysDifference(this._tiles, l); y < x.length; y += 1) {\n            var b = x[y],\n                w = this._tiles[b];\n            w.hasSymbolBuckets && !w.holdingForFade() ? w.setHoldDuration(this.map._fadeDuration) : w.hasSymbolBuckets && !w.symbolFadeFinished() || this._removeTile(b);\n          }\n\n          this._updateLoadedParentTileCache();\n        }\n      }, i.prototype.releaseSymbolFadeTiles = function () {\n        for (var t in this._tiles) {\n          this._tiles[t].holdingForFade() && this._removeTile(t);\n        }\n      }, i.prototype._updateRetainedTiles = function (t, e) {\n        for (var o = {}, r = {}, a = Math.max(e - i.maxOverzooming, this._source.minzoom), n = Math.max(e + i.maxUnderzooming, this._source.minzoom), s = {}, l = 0, c = t; l < c.length; l += 1) {\n          var u = c[l],\n              h = this._addTile(u);\n\n          o[u.key] = u, h.hasData() || e < this._source.maxzoom && (s[u.key] = u);\n        }\n\n        this._retainLoadedChildren(s, e, n, o);\n\n        for (var p = 0, d = t; p < d.length; p += 1) {\n          var _ = d[p],\n              f = this._tiles[_.key];\n\n          if (!f.hasData()) {\n            if (e + 1 > this._source.maxzoom) {\n              var m = _.children(this._source.maxzoom)[0],\n                  g = this.getTile(m);\n\n              if (g && g.hasData()) {\n                o[m.key] = m;\n                continue;\n              }\n            } else {\n              var v = _.children(this._source.maxzoom);\n\n              if (o[v[0].key] && o[v[1].key] && o[v[2].key] && o[v[3].key]) continue;\n            }\n\n            for (var y = f.wasRequested(), x = _.overscaledZ - 1; x >= a; --x) {\n              var b = _.scaledTo(x);\n\n              if (r[b.key]) break;\n              if (r[b.key] = !0, !(f = this.getTile(b)) && y && (f = this._addTile(b)), f && (o[b.key] = b, y = f.wasRequested(), f.hasData())) break;\n            }\n          }\n        }\n\n        return o;\n      }, i.prototype._updateLoadedParentTileCache = function () {\n        for (var t in this._loadedParentTiles = {}, this._tiles) {\n          for (var e = [], i = void 0, o = this._tiles[t].tileID; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n\n            e.push(o.key);\n            var r = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(r)) break;\n            o = r;\n          }\n\n          for (var a = 0, n = e; a < n.length; a += 1) {\n            this._loadedParentTiles[n[a]] = i;\n          }\n        }\n      }, i.prototype._addTile = function (e) {\n        var i = this._tiles[e.key];\n        if (i) return i;\n        (i = this._cache.getAndRemove(e)) && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));\n        var o = Boolean(i);\n        return o || (i = new t.Tile(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, this._tileLoaded.bind(this, i, e.key, i.state))), i ? (i.uses++, this._tiles[e.key] = i, o || this._source.fire(new t.Event("dataloading", {\n          tile: i,\n          coord: i.tileID,\n          dataType: "source"\n        })), i) : null;\n      }, i.prototype._setTileReloadTimer = function (t, e) {\n        var i = this;\n        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);\n        var o = e.getExpiryTimeout();\n        o && (this._timers[t] = setTimeout(function () {\n          i._reloadTile(t, "expired"), delete i._timers[t];\n        }, o));\n      }, i.prototype._removeTile = function (t) {\n        var e = this._tiles[t];\n        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));\n      }, i.prototype.clearTiles = function () {\n        for (var t in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) {\n          this._removeTile(t);\n        }\n\n        this._cache.reset();\n      }, i.prototype.tilesIn = function (e, i, o) {\n        var r = this,\n            a = [],\n            n = this.transform;\n        if (!n) return a;\n\n        for (var s = o ? n.getCameraQueryGeometry(e) : e, l = e.map(function (t) {\n          return n.pointCoordinate(t);\n        }), c = s.map(function (t) {\n          return n.pointCoordinate(t);\n        }), u = this.getIds(), h = 1 / 0, p = 1 / 0, d = -1 / 0, _ = -1 / 0, f = 0, m = c; f < m.length; f += 1) {\n          var g = m[f];\n          h = Math.min(h, g.x), p = Math.min(p, g.y), d = Math.max(d, g.x), _ = Math.max(_, g.y);\n        }\n\n        for (var v = function v(e) {\n          var o = r._tiles[u[e]];\n\n          if (!o.holdingForFade()) {\n            var s = o.tileID,\n                f = Math.pow(2, n.zoom - o.tileID.overscaledZ),\n                m = i * o.queryPadding * t.EXTENT / o.tileSize / f,\n                g = [s.getTilePoint(new t.MercatorCoordinate(h, p)), s.getTilePoint(new t.MercatorCoordinate(d, _))];\n\n            if (g[0].x - m < t.EXTENT && g[0].y - m < t.EXTENT && g[1].x + m >= 0 && g[1].y + m >= 0) {\n              var v = l.map(function (t) {\n                return s.getTilePoint(t);\n              }),\n                  y = c.map(function (t) {\n                return s.getTilePoint(t);\n              });\n              a.push({\n                tile: o,\n                tileID: s,\n                queryGeometry: v,\n                cameraQueryGeometry: y,\n                scale: f\n              });\n            }\n          }\n        }, y = 0; y < u.length; y++) {\n          v(y);\n        }\n\n        return a;\n      }, i.prototype.getVisibleCoordinates = function (t) {\n        for (var e = this, i = this.getRenderableIds(t).map(function (t) {\n          return e._tiles[t].tileID;\n        }), o = 0, r = i; o < r.length; o += 1) {\n          var a = r[o];\n          a.posMatrix = this.transform.calculatePosMatrix(a.toUnwrapped());\n        }\n\n        return i;\n      }, i.prototype.hasTransition = function () {\n        if (this._source.hasTransition()) return !0;\n        if (Mt(this._source.type)) for (var e in this._tiles) {\n          var i = this._tiles[e];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= t.browser.now()) return !0;\n        }\n        return !1;\n      }, i.prototype.setFeatureState = function (t, e, i) {\n        this._state.updateState(t = t || "_geojsonTileLayer", e, i);\n      }, i.prototype.removeFeatureState = function (t, e, i) {\n        this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, i);\n      }, i.prototype.getFeatureState = function (t, e) {\n        return this._state.getState(t = t || "_geojsonTileLayer", e);\n      }, i.prototype.setDependencies = function (t, e, i) {\n        var o = this._tiles[t];\n        o && o.setDependencies(e, i);\n      }, i.prototype.reloadTilesForDependencies = function (t, e) {\n        for (var i in this._tiles) {\n          this._tiles[i].hasDependency(t, e) && this._reloadTile(i, "reloading");\n        }\n\n        this._cache.filter(function (i) {\n          return !i.hasDependency(t, e);\n        });\n      }, i;\n    }(t.Evented);\n\n    function At(t, e) {\n      var i = Math.abs(2 * t.wrap) - +(t.wrap < 0),\n          o = Math.abs(2 * e.wrap) - +(e.wrap < 0);\n      return t.overscaledZ - e.overscaledZ || o - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;\n    }\n\n    function Mt(t) {\n      return "raster" === t || "image" === t || "video" === t;\n    }\n\n    function Lt() {\n      return new t.window.Worker(Kr.workerUrl);\n    }\n\n    Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;\n\n    var Rt = "mapboxgl_preloaded_worker_pool",\n        kt = function kt() {\n      this.active = {};\n    };\n\n    kt.prototype.acquire = function (t) {\n      if (!this.workers) for (this.workers = []; this.workers.length < kt.workerCount;) {\n        this.workers.push(new Lt());\n      }\n      return this.active[t] = !0, this.workers.slice();\n    }, kt.prototype.release = function (t) {\n      delete this.active[t], 0 === this.numActive() && (this.workers.forEach(function (t) {\n        t.terminate();\n      }), this.workers = null);\n    }, kt.prototype.isPreloaded = function () {\n      return !!this.active[Rt];\n    }, kt.prototype.numActive = function () {\n      return Object.keys(this.active).length;\n    };\n    var Bt,\n        Ot = Math.floor(t.browser.hardwareConcurrency / 2);\n\n    function Ft() {\n      return Bt || (Bt = new kt()), Bt;\n    }\n\n    function Ut(e, i) {\n      var o = {};\n\n      for (var r in e) {\n        "ref" !== r && (o[r] = e[r]);\n      }\n\n      return t.refProperties.forEach(function (t) {\n        t in i && (o[t] = i[t]);\n      }), o;\n    }\n\n    function Nt(t) {\n      t = t.slice();\n\n      for (var e = Object.create(null), i = 0; i < t.length; i++) {\n        e[t[i].id] = t[i];\n      }\n\n      for (var o = 0; o < t.length; o++) {\n        "ref" in t[o] && (t[o] = Ut(t[o], e[t[o].ref]));\n      }\n\n      return t;\n    }\n\n    kt.workerCount = Math.max(Math.min(Ot, 6), 1);\n    var Zt = {\n      setStyle: "setStyle",\n      addLayer: "addLayer",\n      removeLayer: "removeLayer",\n      setPaintProperty: "setPaintProperty",\n      setLayoutProperty: "setLayoutProperty",\n      setFilter: "setFilter",\n      addSource: "addSource",\n      removeSource: "removeSource",\n      setGeoJSONSourceData: "setGeoJSONSourceData",\n      setLayerZoomRange: "setLayerZoomRange",\n      setLayerProperty: "setLayerProperty",\n      setCenter: "setCenter",\n      setZoom: "setZoom",\n      setBearing: "setBearing",\n      setPitch: "setPitch",\n      setSprite: "setSprite",\n      setGlyphs: "setGlyphs",\n      setTransition: "setTransition",\n      setLight: "setLight"\n    };\n\n    function qt(t, e, i) {\n      i.push({\n        command: Zt.addSource,\n        args: [t, e[t]]\n      });\n    }\n\n    function jt(t, e, i) {\n      e.push({\n        command: Zt.removeSource,\n        args: [t]\n      }), i[t] = !0;\n    }\n\n    function Vt(t, e, i, o) {\n      jt(t, i, o), qt(t, e, i);\n    }\n\n    function Gt(e, i, o) {\n      var r;\n\n      for (r in e[o]) {\n        if (e[o].hasOwnProperty(r) && "data" !== r && !t.deepEqual(e[o][r], i[o][r])) return !1;\n      }\n\n      for (r in i[o]) {\n        if (i[o].hasOwnProperty(r) && "data" !== r && !t.deepEqual(e[o][r], i[o][r])) return !1;\n      }\n\n      return !0;\n    }\n\n    function Wt(e, i, o, r, a, n) {\n      var s;\n\n      for (s in i = i || {}, e = e || {}) {\n        e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || o.push({\n          command: n,\n          args: [r, s, i[s], a]\n        }));\n      }\n\n      for (s in i) {\n        i.hasOwnProperty(s) && !e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || o.push({\n          command: n,\n          args: [r, s, i[s], a]\n        }));\n      }\n    }\n\n    function Xt(t) {\n      return t.id;\n    }\n\n    function Ht(t, e) {\n      return t[e.id] = e, t;\n    }\n\n    var Kt = function Kt(t, e) {\n      this.reset(t, e);\n    };\n\n    Kt.prototype.reset = function (t, e) {\n      this.points = t || [], this._distances = [0];\n\n      for (var i = 1; i < this.points.length; i++) {\n        this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);\n      }\n\n      this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n    }, Kt.prototype.lerp = function (e) {\n      if (1 === this.points.length) return this.points[0];\n      e = t.clamp(e, 0, 1);\n\n      for (var i = 1, o = this._distances[i], r = e * this.paddedLength + this.padding; o < r && i < this._distances.length;) {\n        o = this._distances[++i];\n      }\n\n      var a = i - 1,\n          n = this._distances[a],\n          s = o - n,\n          l = s > 0 ? (r - n) / s : 0;\n      return this.points[a].mult(1 - l).add(this.points[i].mult(l));\n    };\n\n    var Yt = function Yt(t, e, i) {\n      var o = this.boxCells = [],\n          r = this.circleCells = [];\n      this.xCellCount = Math.ceil(t / i), this.yCellCount = Math.ceil(e / i);\n\n      for (var a = 0; a < this.xCellCount * this.yCellCount; a++) {\n        o.push([]), r.push([]);\n      }\n\n      this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0;\n    };\n\n    function Jt(e, i, o, r, a) {\n      var n = t.create();\n      return i ? (t.scale(n, n, [1 / a, 1 / a, 1]), o || t.rotateZ(n, n, r.angle)) : t.multiply(n, r.labelPlaneMatrix, e), n;\n    }\n\n    function Qt(e, i, o, r, a) {\n      if (i) {\n        var n = t.clone(e);\n        return t.scale(n, n, [a, a, 1]), o || t.rotateZ(n, n, -r.angle), n;\n      }\n\n      return r.glCoordMatrix;\n    }\n\n    function $t(e, i) {\n      var o = [e.x, e.y, 0, 1];\n      ue(o, o, i);\n      var r = o[3];\n      return {\n        point: new t.Point(o[0] / r, o[1] / r),\n        signedDistanceFromCamera: r\n      };\n    }\n\n    function te(t, e) {\n      return .5 + t / e * .5;\n    }\n\n    function ee(t, e) {\n      var i = t[0] / t[3],\n          o = t[1] / t[3];\n      return i >= -e[0] && i <= e[0] && o >= -e[1] && o <= e[1];\n    }\n\n    function ie(e, i, o, r, a, n, s, l) {\n      var c = r ? e.textSizeData : e.iconSizeData,\n          u = t.evaluateSizeForZoom(c, o.transform.zoom),\n          h = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n          p = r ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;\n      p.clear();\n\n      for (var d = e.lineVertexArray, _ = r ? e.text.placedSymbolArray : e.icon.placedSymbolArray, f = o.transform.width / o.transform.height, m = !1, g = 0; g < _.length; g++) {\n        var v = _.get(g);\n\n        if (v.hidden || v.writingMode === t.WritingMode.vertical && !m) ce(v.numGlyphs, p);else {\n          m = !1;\n          var y = [v.anchorX, v.anchorY, 0, 1];\n\n          if (t.transformMat4(y, y, i), ee(y, h)) {\n            var x = te(o.transform.cameraToCenterDistance, y[3]),\n                b = t.evaluateSizeForFeature(c, u, v),\n                w = s ? b / x : b * x,\n                T = new t.Point(v.anchorX, v.anchorY),\n                E = $t(T, a).point,\n                I = {},\n                P = ae(v, w, !1, l, i, a, n, e.glyphOffsetArray, d, p, E, T, I, f);\n            m = P.useVertical, (P.notEnoughRoom || m || P.needsFlipping && ae(v, w, !0, l, i, a, n, e.glyphOffsetArray, d, p, E, T, I, f).notEnoughRoom) && ce(v.numGlyphs, p);\n          } else ce(v.numGlyphs, p);\n        }\n      }\n\n      r ? e.text.dynamicLayoutVertexBuffer.updateData(p) : e.icon.dynamicLayoutVertexBuffer.updateData(p);\n    }\n\n    function oe(t, e, i, o, r, a, n, s, l, c, u) {\n      var h = s.glyphStartIndex + s.numGlyphs,\n          p = s.lineStartIndex,\n          d = s.lineStartIndex + s.lineLength,\n          _ = e.getoffsetX(s.glyphStartIndex),\n          f = e.getoffsetX(h - 1),\n          m = se(t * _, i, o, r, a, n, s.segment, p, d, l, c, u);\n\n      if (!m) return null;\n      var g = se(t * f, i, o, r, a, n, s.segment, p, d, l, c, u);\n      return g ? {\n        first: m,\n        last: g\n      } : null;\n    }\n\n    function re(e, i, o, r) {\n      return e === t.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * r ? {\n        useVertical: !0\n      } : (e === t.WritingMode.vertical ? i.y < o.y : i.x > o.x) ? {\n        needsFlipping: !0\n      } : null;\n    }\n\n    function ae(e, i, o, r, a, n, s, l, c, u, h, p, d, _) {\n      var f,\n          m = i / 24,\n          g = e.lineOffsetX * m,\n          v = e.lineOffsetY * m;\n\n      if (e.numGlyphs > 1) {\n        var y = e.glyphStartIndex + e.numGlyphs,\n            x = e.lineStartIndex,\n            b = e.lineStartIndex + e.lineLength,\n            w = oe(m, l, g, v, o, h, p, e, c, n, d);\n        if (!w) return {\n          notEnoughRoom: !0\n        };\n        var T = $t(w.first.point, s).point,\n            E = $t(w.last.point, s).point;\n\n        if (r && !o) {\n          var I = re(e.writingMode, T, E, _);\n          if (I) return I;\n        }\n\n        f = [w.first];\n\n        for (var P = e.glyphStartIndex + 1; P < y - 1; P++) {\n          f.push(se(m * l.getoffsetX(P), g, v, o, h, p, e.segment, x, b, c, n, d));\n        }\n\n        f.push(w.last);\n      } else {\n        if (r && !o) {\n          var S = $t(p, a).point,\n              C = e.lineStartIndex + e.segment + 1,\n              z = new t.Point(c.getx(C), c.gety(C)),\n              D = $t(z, a),\n              A = D.signedDistanceFromCamera > 0 ? D.point : ne(p, z, S, 1, a),\n              M = re(e.writingMode, S, A, _);\n          if (M) return M;\n        }\n\n        var L = se(m * l.getoffsetX(e.glyphStartIndex), g, v, o, h, p, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, c, n, d);\n        if (!L) return {\n          notEnoughRoom: !0\n        };\n        f = [L];\n      }\n\n      for (var R = 0, k = f; R < k.length; R += 1) {\n        var B = k[R];\n        t.addDynamicAttributes(u, B.point, B.angle);\n      }\n\n      return {};\n    }\n\n    function ne(t, e, i, o, r) {\n      var a = $t(t.add(t.sub(e)._unit()), r).point,\n          n = i.sub(a);\n      return i.add(n._mult(o / n.mag()));\n    }\n\n    function se(e, i, o, r, a, n, s, l, c, u, h, p) {\n      var d = r ? e - i : e + i,\n          _ = d > 0 ? 1 : -1,\n          f = 0;\n\n      r && (_ *= -1, f = Math.PI), _ < 0 && (f += Math.PI);\n\n      for (var m = _ > 0 ? l + s : l + s + 1, g = a, v = a, y = 0, x = 0, b = Math.abs(d), w = []; y + x <= b;) {\n        if ((m += _) < l || m >= c) return null;\n\n        if (v = g, w.push(g), void 0 === (g = p[m])) {\n          var T = new t.Point(u.getx(m), u.gety(m)),\n              E = $t(T, h);\n          if (E.signedDistanceFromCamera > 0) g = p[m] = E.point;else {\n            var I = m - _;\n            g = ne(0 === y ? n : new t.Point(u.getx(I), u.gety(I)), T, v, b - y + 1, h);\n          }\n        }\n\n        y += x, x = v.dist(g);\n      }\n\n      var P = (b - y) / x,\n          S = g.sub(v),\n          C = S.mult(P)._add(v);\n\n      C._add(S._unit()._perp()._mult(o * _));\n\n      var z = f + Math.atan2(g.y - v.y, g.x - v.x);\n      return w.push(C), {\n        point: C,\n        angle: z,\n        path: w\n      };\n    }\n\n    Yt.prototype.keysLength = function () {\n      return this.boxKeys.length + this.circleKeys.length;\n    }, Yt.prototype.insert = function (t, e, i, o, r) {\n      this._forEachCell(e, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);\n    }, Yt.prototype.insertCircle = function (t, e, i, o) {\n      this._forEachCell(e - o, i - o, e + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(i), this.circles.push(o);\n    }, Yt.prototype._insertBoxCell = function (t, e, i, o, r, a) {\n      this.boxCells[r].push(a);\n    }, Yt.prototype._insertCircleCell = function (t, e, i, o, r, a) {\n      this.circleCells[r].push(a);\n    }, Yt.prototype._query = function (t, e, i, o, r, a) {\n      if (i < 0 || t > this.width || o < 0 || e > this.height) return !r && [];\n      var n = [];\n\n      if (t <= 0 && e <= 0 && this.width <= i && this.height <= o) {\n        if (r) return !0;\n\n        for (var s = 0; s < this.boxKeys.length; s++) {\n          n.push({\n            key: this.boxKeys[s],\n            x1: this.bboxes[4 * s],\n            y1: this.bboxes[4 * s + 1],\n            x2: this.bboxes[4 * s + 2],\n            y2: this.bboxes[4 * s + 3]\n          });\n        }\n\n        for (var l = 0; l < this.circleKeys.length; l++) {\n          var c = this.circles[3 * l],\n              u = this.circles[3 * l + 1],\n              h = this.circles[3 * l + 2];\n          n.push({\n            key: this.circleKeys[l],\n            x1: c - h,\n            y1: u - h,\n            x2: c + h,\n            y2: u + h\n          });\n        }\n\n        return a ? n.filter(a) : n;\n      }\n\n      return this._forEachCell(t, e, i, o, this._queryCell, n, {\n        hitTest: r,\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      }, a), r ? n.length > 0 : n;\n    }, Yt.prototype._queryCircle = function (t, e, i, o, r) {\n      var a = t - i,\n          n = t + i,\n          s = e - i,\n          l = e + i;\n      if (n < 0 || a > this.width || l < 0 || s > this.height) return !o && [];\n      var c = [];\n      return this._forEachCell(a, s, n, l, this._queryCellCircle, c, {\n        hitTest: o,\n        circle: {\n          x: t,\n          y: e,\n          radius: i\n        },\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      }, r), o ? c.length > 0 : c;\n    }, Yt.prototype.query = function (t, e, i, o, r) {\n      return this._query(t, e, i, o, !1, r);\n    }, Yt.prototype.hitTest = function (t, e, i, o, r) {\n      return this._query(t, e, i, o, !0, r);\n    }, Yt.prototype.hitTestCircle = function (t, e, i, o) {\n      return this._queryCircle(t, e, i, !0, o);\n    }, Yt.prototype._queryCell = function (t, e, i, o, r, a, n, s) {\n      var l = n.seenUids,\n          c = this.boxCells[r];\n      if (null !== c) for (var u = this.bboxes, h = 0, p = c; h < p.length; h += 1) {\n        var d = p[h];\n\n        if (!l.box[d]) {\n          l.box[d] = !0;\n\n          var _ = 4 * d;\n\n          if (t <= u[_ + 2] && e <= u[_ + 3] && i >= u[_ + 0] && o >= u[_ + 1] && (!s || s(this.boxKeys[d]))) {\n            if (n.hitTest) return a.push(!0), !0;\n            a.push({\n              key: this.boxKeys[d],\n              x1: u[_],\n              y1: u[_ + 1],\n              x2: u[_ + 2],\n              y2: u[_ + 3]\n            });\n          }\n        }\n      }\n      var f = this.circleCells[r];\n      if (null !== f) for (var m = this.circles, g = 0, v = f; g < v.length; g += 1) {\n        var y = v[g];\n\n        if (!l.circle[y]) {\n          l.circle[y] = !0;\n          var x = 3 * y;\n\n          if (this._circleAndRectCollide(m[x], m[x + 1], m[x + 2], t, e, i, o) && (!s || s(this.circleKeys[y]))) {\n            if (n.hitTest) return a.push(!0), !0;\n            var b = m[x],\n                w = m[x + 1],\n                T = m[x + 2];\n            a.push({\n              key: this.circleKeys[y],\n              x1: b - T,\n              y1: w - T,\n              x2: b + T,\n              y2: w + T\n            });\n          }\n        }\n      }\n    }, Yt.prototype._queryCellCircle = function (t, e, i, o, r, a, n, s) {\n      var l = n.circle,\n          c = n.seenUids,\n          u = this.boxCells[r];\n      if (null !== u) for (var h = this.bboxes, p = 0, d = u; p < d.length; p += 1) {\n        var _ = d[p];\n\n        if (!c.box[_]) {\n          c.box[_] = !0;\n          var f = 4 * _;\n          if (this._circleAndRectCollide(l.x, l.y, l.radius, h[f + 0], h[f + 1], h[f + 2], h[f + 3]) && (!s || s(this.boxKeys[_]))) return a.push(!0), !0;\n        }\n      }\n      var m = this.circleCells[r];\n      if (null !== m) for (var g = this.circles, v = 0, y = m; v < y.length; v += 1) {\n        var x = y[v];\n\n        if (!c.circle[x]) {\n          c.circle[x] = !0;\n          var b = 3 * x;\n          if (this._circlesCollide(g[b], g[b + 1], g[b + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[x]))) return a.push(!0), !0;\n        }\n      }\n    }, Yt.prototype._forEachCell = function (t, e, i, o, r, a, n, s) {\n      for (var l = this._convertToXCellCoord(t), c = this._convertToYCellCoord(e), u = this._convertToXCellCoord(i), h = this._convertToYCellCoord(o), p = l; p <= u; p++) {\n        for (var d = c; d <= h; d++) {\n          if (r.call(this, t, e, i, o, this.xCellCount * d + p, a, n, s)) return;\n        }\n      }\n    }, Yt.prototype._convertToXCellCoord = function (t) {\n      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));\n    }, Yt.prototype._convertToYCellCoord = function (t) {\n      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));\n    }, Yt.prototype._circlesCollide = function (t, e, i, o, r, a) {\n      var n = o - t,\n          s = r - e,\n          l = i + a;\n      return l * l > n * n + s * s;\n    }, Yt.prototype._circleAndRectCollide = function (t, e, i, o, r, a, n) {\n      var s = (a - o) / 2,\n          l = Math.abs(t - (o + s));\n      if (l > s + i) return !1;\n      var c = (n - r) / 2,\n          u = Math.abs(e - (r + c));\n      if (u > c + i) return !1;\n      if (l <= s || u <= c) return !0;\n      var h = l - s,\n          p = u - c;\n      return h * h + p * p <= i * i;\n    };\n    var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);\n\n    function ce(t, e) {\n      for (var i = 0; i < t; i++) {\n        var o = e.length;\n        e.resize(o + 4), e.float32.set(le, 3 * o);\n      }\n    }\n\n    function ue(t, e, i) {\n      var o = e[0],\n          r = e[1];\n      return t[0] = i[0] * o + i[4] * r + i[12], t[1] = i[1] * o + i[5] * r + i[13], t[3] = i[3] * o + i[7] * r + i[15], t;\n    }\n\n    var he = function he(t, e, i) {\n      void 0 === e && (e = new Yt(t.width + 200, t.height + 200, 25)), void 0 === i && (i = new Yt(t.width + 200, t.height + 200, 25)), this.transform = t, this.grid = e, this.ignoredGrid = i, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + 100, this.screenBottomBoundary = t.height + 100, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200;\n    };\n\n    function pe(e, i, o) {\n      return i * (t.EXTENT / (e.tileSize * Math.pow(2, o - e.tileID.overscaledZ)));\n    }\n\n    he.prototype.placeCollisionBox = function (t, e, i, o, r) {\n      var a = this.projectAndGetPerspectiveRatio(o, t.anchorPointX, t.anchorPointY),\n          n = i * a.perspectiveRatio,\n          s = t.x1 * n + a.point.x,\n          l = t.y1 * n + a.point.y,\n          c = t.x2 * n + a.point.x,\n          u = t.y2 * n + a.point.y;\n      return !this.isInsideGrid(s, l, c, u) || !e && this.grid.hitTest(s, l, c, u, r) ? {\n        box: [],\n        offscreen: !1\n      } : {\n        box: [s, l, c, u],\n        offscreen: this.isOffscreen(s, l, c, u)\n      };\n    }, he.prototype.placeCollisionCircles = function (e, i, o, r, a, n, s, l, c, u, h, p, d) {\n      var _ = [],\n          f = new t.Point(i.anchorX, i.anchorY),\n          m = $t(f, n),\n          g = te(this.transform.cameraToCenterDistance, m.signedDistanceFromCamera),\n          v = (u ? a / g : a * g) / t.ONE_EM,\n          y = $t(f, s).point,\n          x = oe(v, r, i.lineOffsetX * v, i.lineOffsetY * v, !1, y, f, i, o, s, {}),\n          b = !1,\n          w = !1,\n          T = !0;\n\n      if (x) {\n        for (var E = .5 * p * g + d, I = new t.Point(-100, -100), P = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), S = new Kt(), C = x.first, z = x.last, D = [], A = C.path.length - 1; A >= 1; A--) {\n          D.push(C.path[A]);\n        }\n\n        for (var M = 1; M < z.path.length; M++) {\n          D.push(z.path[M]);\n        }\n\n        var L = 2.5 * E;\n\n        if (l) {\n          var R = D.map(function (t) {\n            return $t(t, l);\n          });\n          D = R.some(function (t) {\n            return t.signedDistanceFromCamera <= 0;\n          }) ? [] : R.map(function (t) {\n            return t.point;\n          });\n        }\n\n        var k = [];\n\n        if (D.length > 0) {\n          for (var B = D[0].clone(), O = D[0].clone(), F = 1; F < D.length; F++) {\n            B.x = Math.min(B.x, D[F].x), B.y = Math.min(B.y, D[F].y), O.x = Math.max(O.x, D[F].x), O.y = Math.max(O.y, D[F].y);\n          }\n\n          k = B.x >= I.x && O.x <= P.x && B.y >= I.y && O.y <= P.y ? [D] : O.x < I.x || B.x > P.x || O.y < I.y || B.y > P.y ? [] : t.clipLine([D], I.x, I.y, P.x, P.y);\n        }\n\n        for (var U = 0, N = k; U < N.length; U += 1) {\n          var Z;\n          S.reset(N[U], .25 * E), Z = S.length <= .5 * E ? 1 : Math.ceil(S.paddedLength / L) + 1;\n\n          for (var q = 0; q < Z; q++) {\n            var j = q / Math.max(Z - 1, 1),\n                V = S.lerp(j),\n                G = V.x + 100,\n                W = V.y + 100;\n\n            _.push(G, W, E, 0);\n\n            var X = G - E,\n                H = W - E,\n                K = G + E,\n                Y = W + E;\n            if (T = T && this.isOffscreen(X, H, K, Y), w = w || this.isInsideGrid(X, H, K, Y), !e && this.grid.hitTestCircle(G, W, E, h) && (b = !0, !c)) return {\n              circles: [],\n              offscreen: !1,\n              collisionDetected: b\n            };\n          }\n        }\n      }\n\n      return {\n        circles: !c && b || !w ? [] : _,\n        offscreen: T,\n        collisionDetected: b\n      };\n    }, he.prototype.queryRenderedSymbols = function (e) {\n      if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n\n      for (var i = [], o = 1 / 0, r = 1 / 0, a = -1 / 0, n = -1 / 0, s = 0, l = e; s < l.length; s += 1) {\n        var c = l[s],\n            u = new t.Point(c.x + 100, c.y + 100);\n        o = Math.min(o, u.x), r = Math.min(r, u.y), a = Math.max(a, u.x), n = Math.max(n, u.y), i.push(u);\n      }\n\n      for (var h = {}, p = {}, d = 0, _ = this.grid.query(o, r, a, n).concat(this.ignoredGrid.query(o, r, a, n)); d < _.length; d += 1) {\n        var f = _[d],\n            m = f.key;\n\n        if (void 0 === h[m.bucketInstanceId] && (h[m.bucketInstanceId] = {}), !h[m.bucketInstanceId][m.featureIndex]) {\n          var g = [new t.Point(f.x1, f.y1), new t.Point(f.x2, f.y1), new t.Point(f.x2, f.y2), new t.Point(f.x1, f.y2)];\n          t.polygonIntersectsPolygon(i, g) && (h[m.bucketInstanceId][m.featureIndex] = !0, void 0 === p[m.bucketInstanceId] && (p[m.bucketInstanceId] = []), p[m.bucketInstanceId].push(m.featureIndex));\n        }\n      }\n\n      return p;\n    }, he.prototype.insertCollisionBox = function (t, e, i, o, r) {\n      (e ? this.ignoredGrid : this.grid).insert({\n        bucketInstanceId: i,\n        featureIndex: o,\n        collisionGroupID: r\n      }, t[0], t[1], t[2], t[3]);\n    }, he.prototype.insertCollisionCircles = function (t, e, i, o, r) {\n      for (var a = e ? this.ignoredGrid : this.grid, n = {\n        bucketInstanceId: i,\n        featureIndex: o,\n        collisionGroupID: r\n      }, s = 0; s < t.length; s += 4) {\n        a.insertCircle(n, t[s], t[s + 1], t[s + 2]);\n      }\n    }, he.prototype.projectAndGetPerspectiveRatio = function (e, i, o) {\n      var r = [i, o, 0, 1];\n      return ue(r, r, e), {\n        point: new t.Point((r[0] / r[3] + 1) / 2 * this.transform.width + 100, (-r[1] / r[3] + 1) / 2 * this.transform.height + 100),\n        perspectiveRatio: .5 + this.transform.cameraToCenterDistance / r[3] * .5\n      };\n    }, he.prototype.isOffscreen = function (t, e, i, o) {\n      return i < 100 || t >= this.screenRightBoundary || o < 100 || e > this.screenBottomBoundary;\n    }, he.prototype.isInsideGrid = function (t, e, i, o) {\n      return i >= 0 && t < this.gridRightBoundary && o >= 0 && e < this.gridBottomBoundary;\n    }, he.prototype.getViewportMatrix = function () {\n      var e = t.identity([]);\n      return t.translate(e, e, [-100, -100, 0]), e;\n    };\n\n    var de = function de(t, e, i, o) {\n      this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : o && i ? 1 : 0, this.placed = i;\n    };\n\n    de.prototype.isHidden = function () {\n      return 0 === this.opacity && !this.placed;\n    };\n\n    var _e = function _e(t, e, i, o, r) {\n      this.text = new de(t ? t.text : null, e, i, r), this.icon = new de(t ? t.icon : null, e, o, r);\n    };\n\n    _e.prototype.isHidden = function () {\n      return this.text.isHidden() && this.icon.isHidden();\n    };\n\n    var fe = function fe(t, e, i) {\n      this.text = t, this.icon = e, this.skipFade = i;\n    },\n        me = function me() {\n      this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];\n    },\n        ge = function ge(t, e, i, o, r) {\n      this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;\n    },\n        ve = function ve(t) {\n      this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};\n    };\n\n    function ye(e, i, o, r, a) {\n      var n = t.getAnchorAlignment(e),\n          s = -(n.horizontalAlign - .5) * i,\n          l = -(n.verticalAlign - .5) * o,\n          c = t.evaluateVariableOffset(e, r);\n      return new t.Point(s + c[0] * a, l + c[1] * a);\n    }\n\n    function xe(e, i, o, r, a, n) {\n      var s = e.x1,\n          l = e.x2,\n          c = e.y1,\n          u = e.y2,\n          h = e.anchorPointX,\n          p = e.anchorPointY,\n          d = new t.Point(i, o);\n      return r && d._rotate(a ? n : -n), {\n        x1: s + d.x,\n        y1: c + d.y,\n        x2: l + d.x,\n        y2: u + d.y,\n        anchorPointX: h,\n        anchorPointY: p\n      };\n    }\n\n    ve.prototype.get = function (t) {\n      if (this.crossSourceCollisions) return {\n        ID: 0,\n        predicate: null\n      };\n\n      if (!this.collisionGroups[t]) {\n        var e = ++this.maxGroupID;\n        this.collisionGroups[t] = {\n          ID: e,\n          predicate: function predicate(t) {\n            return t.collisionGroupID === e;\n          }\n        };\n      }\n\n      return this.collisionGroups[t];\n    };\n\n    var be = function be(t, e, i, o) {\n      this.transform = t.clone(), this.collisionIndex = new he(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new ve(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n    };\n\n    function we(t, e, i, o, r) {\n      t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0);\n    }\n\n    be.prototype.getBucketParts = function (e, i, o, r) {\n      var a = o.getBucket(i),\n          n = o.latestFeatureIndex;\n\n      if (a && n && i.id === a.layerIds[0]) {\n        var s = o.collisionBoxArray,\n            l = a.layers[0].layout,\n            c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n            u = o.tileSize / t.EXTENT,\n            h = this.transform.calculatePosMatrix(o.tileID.toUnwrapped()),\n            p = "map" === l.get("text-pitch-alignment"),\n            d = "map" === l.get("text-rotation-alignment"),\n            _ = pe(o, 1, this.transform.zoom),\n            f = Jt(h, p, d, this.transform, _),\n            m = null;\n\n        if (p) {\n          var g = Qt(h, p, d, this.transform, _);\n          m = t.multiply([], this.transform.labelPlaneMatrix, g);\n        }\n\n        this.retainedQueryData[a.bucketInstanceId] = new ge(a.bucketInstanceId, n, a.sourceLayerIndex, a.index, o.tileID);\n        var v = {\n          bucket: a,\n          layout: l,\n          posMatrix: h,\n          textLabelPlaneMatrix: f,\n          labelToScreenMatrix: m,\n          scale: c,\n          textPixelRatio: u,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: s,\n          partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a.textSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(a.sourceID)\n        };\n        if (r) for (var y = 0, x = a.sortKeyRanges; y < x.length; y += 1) {\n          var b = x[y];\n          e.push({\n            sortKey: b.sortKey,\n            symbolInstanceStart: b.symbolInstanceStart,\n            symbolInstanceEnd: b.symbolInstanceEnd,\n            parameters: v\n          });\n        } else e.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: a.symbolInstances.length,\n          parameters: v\n        });\n      }\n    }, be.prototype.attemptAnchorPlacement = function (t, e, i, o, r, a, n, s, l, c, u, h, p, d, _) {\n      var f,\n          m = [h.textOffset0, h.textOffset1],\n          g = ye(t, i, o, m, r),\n          v = this.collisionIndex.placeCollisionBox(xe(e, g.x, g.y, a, n, this.transform.angle), u, s, l, c.predicate);\n      if (!_ || 0 !== this.collisionIndex.placeCollisionBox(xe(_, g.x, g.y, a, n, this.transform.angle), u, s, l, c.predicate).box.length) return v.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[h.crossTileID] && this.prevPlacement.placements[h.crossTileID] && this.prevPlacement.placements[h.crossTileID].text && (f = this.prevPlacement.variableOffsets[h.crossTileID].anchor), this.variableOffsets[h.crossTileID] = {\n        textOffset: m,\n        width: i,\n        height: o,\n        anchor: t,\n        textBoxScale: r,\n        prevAnchor: f\n      }, this.markUsedJustification(p, t, h, d), p.allowVerticalPlacement && (this.markUsedOrientation(p, d, h), this.placedOrientations[h.crossTileID] = d), {\n        shift: g,\n        placedGlyphBoxes: v\n      }) : void 0;\n    }, be.prototype.placeLayerBucketPart = function (e, i, o) {\n      var r = this,\n          a = e.parameters,\n          n = a.bucket,\n          s = a.layout,\n          l = a.posMatrix,\n          c = a.textLabelPlaneMatrix,\n          u = a.labelToScreenMatrix,\n          h = a.textPixelRatio,\n          p = a.holdingForFade,\n          d = a.collisionBoxArray,\n          _ = a.partiallyEvaluatedTextSize,\n          f = a.collisionGroup,\n          m = s.get("text-optional"),\n          g = s.get("icon-optional"),\n          v = s.get("text-allow-overlap"),\n          y = s.get("icon-allow-overlap"),\n          x = "map" === s.get("text-rotation-alignment"),\n          b = "map" === s.get("text-pitch-alignment"),\n          w = "none" !== s.get("icon-text-fit"),\n          T = "viewport-y" === s.get("symbol-z-order"),\n          E = v && (y || !n.hasIconData() || g),\n          I = y && (v || !n.hasTextData() || m);\n      !n.collisionArrays && d && n.deserializeCollisionBoxes(d);\n\n      var P = function P(e, a) {\n        if (!i[e.crossTileID]) if (p) r.placements[e.crossTileID] = new fe(!1, !1, !1);else {\n          var d,\n              T = !1,\n              P = !1,\n              S = !0,\n              C = null,\n              z = {\n            box: null,\n            offscreen: null\n          },\n              D = {\n            box: null,\n            offscreen: null\n          },\n              A = null,\n              M = null,\n              L = 0,\n              R = 0,\n              k = 0;\n          a.textFeatureIndex ? L = a.textFeatureIndex : e.useRuntimeCollisionCircles && (L = e.featureIndex), a.verticalTextFeatureIndex && (R = a.verticalTextFeatureIndex);\n          var B = a.textBox;\n\n          if (B) {\n            var O = function O(i) {\n              var o = t.WritingMode.horizontal;\n\n              if (n.allowVerticalPlacement && !i && r.prevPlacement) {\n                var a = r.prevPlacement.placedOrientations[e.crossTileID];\n                a && (r.placedOrientations[e.crossTileID] = a, r.markUsedOrientation(n, o = a, e));\n              }\n\n              return o;\n            },\n                F = function F(i, o) {\n              if (n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && a.verticalTextBox) for (var r = 0, s = n.writingModes; r < s.length && (s[r] === t.WritingMode.vertical ? (z = o(), D = z) : z = i(), !(z && z.box && z.box.length)); r += 1) {\n                ;\n              } else z = i();\n            };\n\n            if (s.get("text-variable-anchor")) {\n              var U = s.get("text-variable-anchor");\n\n              if (r.prevPlacement && r.prevPlacement.variableOffsets[e.crossTileID]) {\n                var N = r.prevPlacement.variableOffsets[e.crossTileID];\n                U.indexOf(N.anchor) > 0 && (U = U.filter(function (t) {\n                  return t !== N.anchor;\n                })).unshift(N.anchor);\n              }\n\n              var Z = function Z(t, i, o) {\n                for (var a = t.x2 - t.x1, s = t.y2 - t.y1, c = e.textBoxScale, u = w && !y ? i : null, p = {\n                  box: [],\n                  offscreen: !1\n                }, d = v ? 2 * U.length : U.length, _ = 0; _ < d; ++_) {\n                  var m = r.attemptAnchorPlacement(U[_ % U.length], t, a, s, c, x, b, h, l, f, _ >= U.length, e, n, o, u);\n\n                  if (m && (p = m.placedGlyphBoxes) && p.box && p.box.length) {\n                    T = !0, C = m.shift;\n                    break;\n                  }\n                }\n\n                return p;\n              };\n\n              F(function () {\n                return Z(B, a.iconBox, t.WritingMode.horizontal);\n              }, function () {\n                var i = a.verticalTextBox;\n                return n.allowVerticalPlacement && !(z && z.box && z.box.length) && e.numVerticalGlyphVertices > 0 && i ? Z(i, a.verticalIconBox, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), z && (T = z.box, S = z.offscreen);\n              var q = O(z && z.box);\n\n              if (!T && r.prevPlacement) {\n                var j = r.prevPlacement.variableOffsets[e.crossTileID];\n                j && (r.variableOffsets[e.crossTileID] = j, r.markUsedJustification(n, j.anchor, e, q));\n              }\n            } else {\n              var V = function V(t, i) {\n                var o = r.collisionIndex.placeCollisionBox(t, v, h, l, f.predicate);\n                return o && o.box && o.box.length && (r.markUsedOrientation(n, i, e), r.placedOrientations[e.crossTileID] = i), o;\n              };\n\n              F(function () {\n                return V(B, t.WritingMode.horizontal);\n              }, function () {\n                var i = a.verticalTextBox;\n                return n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? V(i, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), O(z && z.box && z.box.length);\n            }\n          }\n\n          if (T = (d = z) && d.box && d.box.length > 0, S = d && d.offscreen, e.useRuntimeCollisionCircles) {\n            var G = n.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex),\n                W = t.evaluateSizeForFeature(n.textSizeData, _, G),\n                X = s.get("text-padding");\n            A = r.collisionIndex.placeCollisionCircles(v, G, n.lineVertexArray, n.glyphOffsetArray, W, l, c, u, o, b, f.predicate, e.collisionCircleDiameter, X), T = v || A.circles.length > 0 && !A.collisionDetected, S = S && A.offscreen;\n          }\n\n          if (a.iconFeatureIndex && (k = a.iconFeatureIndex), a.iconBox) {\n            var H = function H(t) {\n              var e = w && C ? xe(t, C.x, C.y, x, b, r.transform.angle) : t;\n              return r.collisionIndex.placeCollisionBox(e, y, h, l, f.predicate);\n            };\n\n            P = D && D.box && D.box.length && a.verticalIconBox ? (M = H(a.verticalIconBox)).box.length > 0 : (M = H(a.iconBox)).box.length > 0, S = S && M.offscreen;\n          }\n\n          var K = m || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices,\n              Y = g || 0 === e.numIconVertices;\n\n          if (K || Y ? Y ? K || (P = P && T) : T = P && T : P = T = P && T, T && d && d.box && r.collisionIndex.insertCollisionBox(d.box, s.get("text-ignore-placement"), n.bucketInstanceId, D && D.box && R ? R : L, f.ID), P && M && r.collisionIndex.insertCollisionBox(M.box, s.get("icon-ignore-placement"), n.bucketInstanceId, k, f.ID), A && (T && r.collisionIndex.insertCollisionCircles(A.circles, s.get("text-ignore-placement"), n.bucketInstanceId, L, f.ID), o)) {\n            var J = n.bucketInstanceId,\n                Q = r.collisionCircleArrays[J];\n            void 0 === Q && (Q = r.collisionCircleArrays[J] = new me());\n\n            for (var $ = 0; $ < A.circles.length; $ += 4) {\n              Q.circles.push(A.circles[$ + 0]), Q.circles.push(A.circles[$ + 1]), Q.circles.push(A.circles[$ + 2]), Q.circles.push(A.collisionDetected ? 1 : 0);\n            }\n          }\n\n          r.placements[e.crossTileID] = new fe(T || E, P || I, S || n.justReloaded), i[e.crossTileID] = !0;\n        }\n      };\n\n      if (T) for (var S = n.getSortedSymbolIndexes(this.transform.angle), C = S.length - 1; C >= 0; --C) {\n        var z = S[C];\n        P(n.symbolInstances.get(z), n.collisionArrays[z]);\n      } else for (var D = e.symbolInstanceStart; D < e.symbolInstanceEnd; D++) {\n        P(n.symbolInstances.get(D), n.collisionArrays[D]);\n      }\n\n      if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n        var A = this.collisionCircleArrays[n.bucketInstanceId];\n        t.invert(A.invProjMatrix, l), A.viewportMatrix = this.collisionIndex.getViewportMatrix();\n      }\n\n      n.justReloaded = !1;\n    }, be.prototype.markUsedJustification = function (e, i, o, r) {\n      var a;\n      a = r === t.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : {\n        left: o.leftJustifiedTextSymbolIndex,\n        center: o.centerJustifiedTextSymbolIndex,\n        right: o.rightJustifiedTextSymbolIndex\n      }[t.getAnchorJustification(i)];\n\n      for (var n = 0, s = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex]; n < s.length; n += 1) {\n        var l = s[n];\n        l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = a >= 0 && l !== a ? 0 : o.crossTileID);\n      }\n    }, be.prototype.markUsedOrientation = function (e, i, o) {\n      for (var r = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0, a = i === t.WritingMode.vertical ? i : 0, n = 0, s = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex]; n < s.length; n += 1) {\n        e.text.placedSymbolArray.get(s[n]).placedOrientation = r;\n      }\n\n      o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = a);\n    }, be.prototype.commit = function (t) {\n      this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;\n      var e = this.prevPlacement,\n          i = !1;\n      this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;\n      var o = e ? e.symbolFadeChange(t) : 1,\n          r = e ? e.opacities : {},\n          a = e ? e.variableOffsets : {},\n          n = e ? e.placedOrientations : {};\n\n      for (var s in this.placements) {\n        var l = this.placements[s],\n            c = r[s];\n        c ? (this.opacities[s] = new _e(c, o, l.text, l.icon), i = i || l.text !== c.text.placed || l.icon !== c.icon.placed) : (this.opacities[s] = new _e(null, o, l.text, l.icon, l.skipFade), i = i || l.text || l.icon);\n      }\n\n      for (var u in r) {\n        var h = r[u];\n\n        if (!this.opacities[u]) {\n          var p = new _e(h, o, !1, !1);\n          p.isHidden() || (this.opacities[u] = p, i = i || h.text.placed || h.icon.placed);\n        }\n      }\n\n      for (var d in a) {\n        this.variableOffsets[d] || !this.opacities[d] || this.opacities[d].isHidden() || (this.variableOffsets[d] = a[d]);\n      }\n\n      for (var _ in n) {\n        this.placedOrientations[_] || !this.opacities[_] || this.opacities[_].isHidden() || (this.placedOrientations[_] = n[_]);\n      }\n\n      i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t);\n    }, be.prototype.updateLayerOpacities = function (t, e) {\n      for (var i = {}, o = 0, r = e; o < r.length; o += 1) {\n        var a = r[o],\n            n = a.getBucket(t);\n        n && a.latestFeatureIndex && t.id === n.layerIds[0] && this.updateBucketOpacities(n, i, a.collisionBoxArray);\n      }\n    }, be.prototype.updateBucketOpacities = function (e, i, o) {\n      var r = this;\n      e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();\n      var a = e.layers[0].layout,\n          n = new _e(null, 0, !1, !1, !0),\n          s = a.get("text-allow-overlap"),\n          l = a.get("icon-allow-overlap"),\n          c = a.get("text-variable-anchor"),\n          u = "map" === a.get("text-rotation-alignment"),\n          h = "map" === a.get("text-pitch-alignment"),\n          p = "none" !== a.get("icon-text-fit"),\n          d = new _e(null, 0, s && (l || !e.hasIconData() || a.get("icon-optional")), l && (s || !e.hasTextData() || a.get("text-optional")), !0);\n      !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o);\n\n      for (var _ = function _(t, e, i) {\n        for (var o = 0; o < e / 4; o++) {\n          t.opacityVertexArray.emplaceBack(i);\n        }\n      }, f = function f(o) {\n        var a = e.symbolInstances.get(o),\n            s = a.numHorizontalGlyphVertices,\n            l = a.numVerticalGlyphVertices,\n            f = a.crossTileID,\n            m = r.opacities[f];\n        i[f] ? m = n : m || (r.opacities[f] = m = d), i[f] = !0;\n        var g = a.numIconVertices > 0,\n            v = r.placedOrientations[a.crossTileID],\n            y = v === t.WritingMode.vertical,\n            x = v === t.WritingMode.horizontal || v === t.WritingMode.horizontalOnly;\n\n        if (s > 0 || l > 0) {\n          var b = De(m.text);\n          _(e.text, s, y ? Ae : b), _(e.text, l, x ? Ae : b);\n          var w = m.text.isHidden();\n          [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(function (t) {\n            t >= 0 && (e.text.placedSymbolArray.get(t).hidden = w || y ? 1 : 0);\n          }), a.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = w || x ? 1 : 0);\n          var T = r.variableOffsets[a.crossTileID];\n          T && r.markUsedJustification(e, T.anchor, a, v);\n          var E = r.placedOrientations[a.crossTileID];\n          E && (r.markUsedJustification(e, "left", a, E), r.markUsedOrientation(e, E, a));\n        }\n\n        if (g) {\n          var I = De(m.icon),\n              P = !(p && a.verticalPlacedIconSymbolIndex && y);\n          a.placedIconSymbolIndex >= 0 && (_(e.icon, a.numIconVertices, P ? I : Ae), e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = m.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (_(e.icon, a.numVerticalIconVertices, P ? Ae : I), e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = m.icon.isHidden());\n        }\n\n        if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {\n          var S = e.collisionArrays[o];\n\n          if (S) {\n            var C = new t.Point(0, 0);\n\n            if (S.textBox || S.verticalTextBox) {\n              var z = !0;\n\n              if (c) {\n                var D = r.variableOffsets[f];\n                D ? (C = ye(D.anchor, D.width, D.height, D.textOffset, D.textBoxScale), u && C._rotate(h ? r.transform.angle : -r.transform.angle)) : z = !1;\n              }\n\n              S.textBox && we(e.textCollisionBox.collisionVertexArray, m.text.placed, !z || y, C.x, C.y), S.verticalTextBox && we(e.textCollisionBox.collisionVertexArray, m.text.placed, !z || x, C.x, C.y);\n            }\n\n            var A = Boolean(!x && S.verticalIconBox);\n            S.iconBox && we(e.iconCollisionBox.collisionVertexArray, m.icon.placed, A, p ? C.x : 0, p ? C.y : 0), S.verticalIconBox && we(e.iconCollisionBox.collisionVertexArray, m.icon.placed, !A, p ? C.x : 0, p ? C.y : 0);\n          }\n        }\n      }, m = 0; m < e.symbolInstances.length; m++) {\n        f(m);\n      }\n\n      if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.bucketInstanceId in this.collisionCircleArrays) {\n        var g = this.collisionCircleArrays[e.bucketInstanceId];\n        e.placementInvProjMatrix = g.invProjMatrix, e.placementViewportMatrix = g.viewportMatrix, e.collisionCircleArray = g.circles, delete this.collisionCircleArrays[e.bucketInstanceId];\n      }\n    }, be.prototype.symbolFadeChange = function (t) {\n      return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n    }, be.prototype.zoomAdjustment = function (t) {\n      return Math.max(0, (this.transform.zoom - t) / 1.5);\n    }, be.prototype.hasTransitions = function (t) {\n      return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;\n    }, be.prototype.stillRecent = function (t, e) {\n      var i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;\n      return this.zoomAtLastRecencyCheck = e, this.commitTime + this.fadeDuration * i > t;\n    }, be.prototype.setStale = function () {\n      this.stale = !0;\n    };\n    var Te = Math.pow(2, 25),\n        Ee = Math.pow(2, 24),\n        Ie = Math.pow(2, 17),\n        Pe = Math.pow(2, 16),\n        Se = Math.pow(2, 9),\n        Ce = Math.pow(2, 8),\n        ze = Math.pow(2, 1);\n\n    function De(t) {\n      if (0 === t.opacity && !t.placed) return 0;\n      if (1 === t.opacity && t.placed) return 4294967295;\n      var e = t.placed ? 1 : 0,\n          i = Math.floor(127 * t.opacity);\n      return i * Te + e * Ee + i * Ie + e * Pe + i * Se + e * Ce + i * ze + e;\n    }\n\n    var Ae = 0,\n        Me = function Me(t) {\n      this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];\n    };\n\n    Me.prototype.continuePlacement = function (t, e, i, o, r) {\n      for (var a = this._bucketParts; this._currentTileIndex < t.length;) {\n        if (e.getBucketParts(a, o, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;\n      }\n\n      for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      })); this._currentPartIndex < a.length;) {\n        if (e.placeLayerBucketPart(a[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, r()) return !0;\n      }\n\n      return !1;\n    };\n\n    var Le = function Le(t, e, i, o, r, a, n) {\n      this.placement = new be(t, r, a, n), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n    };\n\n    Le.prototype.isDone = function () {\n      return this._done;\n    }, Le.prototype.continuePlacement = function (e, i, o) {\n      for (var r = this, a = t.browser.now(), n = function n() {\n        var e = t.browser.now() - a;\n        return !r._forceFullPlacement && e > 2;\n      }; this._currentPlacementIndex >= 0;) {\n        var s = i[e[this._currentPlacementIndex]],\n            l = this.placement.collisionIndex.transform.zoom;\n\n        if ("symbol" === s.type && (!s.minzoom || s.minzoom <= l) && (!s.maxzoom || s.maxzoom > l)) {\n          if (this._inProgressLayer || (this._inProgressLayer = new Me(s)), this._inProgressLayer.continuePlacement(o[s.source], this.placement, this._showCollisionBoxes, s, n)) return;\n          delete this._inProgressLayer;\n        }\n\n        this._currentPlacementIndex--;\n      }\n\n      this._done = !0;\n    }, Le.prototype.commit = function (t) {\n      return this.placement.commit(t), this.placement;\n    };\n\n    var Re = 512 / t.EXTENT / 2,\n        ke = function ke(t, e, i) {\n      this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;\n\n      for (var o = 0; o < e.length; o++) {\n        var r = e.get(o),\n            a = r.key;\n        this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({\n          crossTileID: r.crossTileID,\n          coord: this.getScaledCoordinates(r, t)\n        });\n      }\n    };\n\n    ke.prototype.getScaledCoordinates = function (e, i) {\n      var o = Re / Math.pow(2, i.canonical.z - this.tileID.canonical.z);\n      return {\n        x: Math.floor((i.canonical.x * t.EXTENT + e.anchorX) * o),\n        y: Math.floor((i.canonical.y * t.EXTENT + e.anchorY) * o)\n      };\n    }, ke.prototype.findMatches = function (t, e, i) {\n      for (var o = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z), r = 0; r < t.length; r++) {\n        var a = t.get(r);\n\n        if (!a.crossTileID) {\n          var n = this.indexedSymbolInstances[a.key];\n          if (n) for (var s = this.getScaledCoordinates(a, e), l = 0, c = n; l < c.length; l += 1) {\n            var u = c[l];\n\n            if (Math.abs(u.coord.x - s.x) <= o && Math.abs(u.coord.y - s.y) <= o && !i[u.crossTileID]) {\n              i[u.crossTileID] = !0, a.crossTileID = u.crossTileID;\n              break;\n            }\n          }\n        }\n      }\n    };\n\n    var Be = function Be() {\n      this.maxCrossTileID = 0;\n    };\n\n    Be.prototype.generate = function () {\n      return ++this.maxCrossTileID;\n    };\n\n    var Oe = function Oe() {\n      this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n    };\n\n    Oe.prototype.handleWrapJump = function (t) {\n      var e = Math.round((t - this.lng) / 360);\n      if (0 !== e) for (var i in this.indexes) {\n        var o = this.indexes[i],\n            r = {};\n\n        for (var a in o) {\n          var n = o[a];\n          n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), r[n.tileID.key] = n;\n        }\n\n        this.indexes[i] = r;\n      }\n      this.lng = t;\n    }, Oe.prototype.addBucket = function (t, e, i) {\n      if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {\n        if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1;\n        this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);\n      }\n\n      for (var o = 0; o < e.symbolInstances.length; o++) {\n        e.symbolInstances.get(o).crossTileID = 0;\n      }\n\n      this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});\n      var r = this.usedCrossTileIDs[t.overscaledZ];\n\n      for (var a in this.indexes) {\n        var n = this.indexes[a];\n        if (Number(a) > t.overscaledZ) for (var s in n) {\n          var l = n[s];\n          l.tileID.isChildOf(t) && l.findMatches(e.symbolInstances, t, r);\n        } else {\n          var c = n[t.scaledTo(Number(a)).key];\n          c && c.findMatches(e.symbolInstances, t, r);\n        }\n      }\n\n      for (var u = 0; u < e.symbolInstances.length; u++) {\n        var h = e.symbolInstances.get(u);\n        h.crossTileID || (h.crossTileID = i.generate(), r[h.crossTileID] = !0);\n      }\n\n      return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new ke(t, e.symbolInstances, e.bucketInstanceId), !0;\n    }, Oe.prototype.removeBucketCrossTileIDs = function (t, e) {\n      for (var i in e.indexedSymbolInstances) {\n        for (var o = 0, r = e.indexedSymbolInstances[i]; o < r.length; o += 1) {\n          delete this.usedCrossTileIDs[t][r[o].crossTileID];\n        }\n      }\n    }, Oe.prototype.removeStaleBuckets = function (t) {\n      var e = !1;\n\n      for (var i in this.indexes) {\n        var o = this.indexes[i];\n\n        for (var r in o) {\n          t[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], e = !0);\n        }\n      }\n\n      return e;\n    };\n\n    var Fe = function Fe() {\n      this.layerIndexes = {}, this.crossTileIDs = new Be(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n    };\n\n    Fe.prototype.addLayer = function (t, e, i) {\n      var o = this.layerIndexes[t.id];\n      void 0 === o && (o = this.layerIndexes[t.id] = new Oe());\n      var r = !1,\n          a = {};\n      o.handleWrapJump(i);\n\n      for (var n = 0, s = e; n < s.length; n += 1) {\n        var l = s[n],\n            c = l.getBucket(t);\n        c && t.id === c.layerIds[0] && (c.bucketInstanceId || (c.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(l.tileID, c, this.crossTileIDs) && (r = !0), a[c.bucketInstanceId] = !0);\n      }\n\n      return o.removeStaleBuckets(a) && (r = !0), r;\n    }, Fe.prototype.pruneUnusedLayers = function (t) {\n      var e = {};\n\n      for (var i in t.forEach(function (t) {\n        e[t] = !0;\n      }), this.layerIndexes) {\n        e[i] || delete this.layerIndexes[i];\n      }\n    };\n\n    var Ue = function Ue(e, i) {\n      return t.emitValidationErrors(e, i && i.filter(function (t) {\n        return "source.canvas" !== t.identifier;\n      }));\n    },\n        Ne = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]),\n        Ze = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"]),\n        qe = function () {\n      var e = {},\n          i = t.styleSpec.$version;\n\n      for (var o in t.styleSpec.$root) {\n        var r,\n            a = t.styleSpec.$root[o];\n        if (a.required) null != (r = "version" === o ? i : "array" === a.type ? [] : {}) && (e[o] = r);\n      }\n\n      return e;\n    }(),\n        je = function (e) {\n      function i(o, r) {\n        var a = this;\n        void 0 === r && (r = {}), e.call(this), this.map = o, this.dispatcher = new E(Ft(), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new y(o._requestManager, r.localIdeographFontFamily), this.lineAtlas = new T(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());\n        var n = this;\n        this._rtlTextPluginCallback = i.registerForPluginStateChange(function (e) {\n          n.dispatcher.broadcast("syncRTLPluginState", {\n            pluginStatus: e.pluginStatus,\n            pluginURL: e.pluginURL\n          }, function (e, i) {\n            if (t.triggerPluginCompletionEvent(e), i && i.every(function (t) {\n              return t;\n            })) for (var o in n.sourceCaches) {\n              n.sourceCaches[o].reload();\n            }\n          });\n        }), this.on("data", function (t) {\n          if ("source" === t.dataType && "metadata" === t.sourceDataType) {\n            var e = a.sourceCaches[t.sourceId];\n\n            if (e) {\n              var i = e.getSource();\n              if (i && i.vectorLayerIds) for (var o in a._layers) {\n                var r = a._layers[o];\n                r.source === i.id && a._validateLayer(r);\n              }\n            }\n          }\n        });\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.loadURL = function (e, i) {\n        var o = this;\n        void 0 === i && (i = {}), this.fire(new t.Event("dataloading", {\n          dataType: "style"\n        }));\n        var r = "boolean" == typeof i.validate ? i.validate : !t.isMapboxURL(e);\n        e = this.map._requestManager.normalizeStyleURL(e, i.accessToken);\n\n        var a = this.map._requestManager.transformRequest(e, t.ResourceType.Style);\n\n        this._request = t.getJSON(a, function (e, i) {\n          o._request = null, e ? o.fire(new t.ErrorEvent(e)) : i && o._load(i, r);\n        });\n      }, i.prototype.loadJSON = function (e, i) {\n        var o = this;\n        void 0 === i && (i = {}), this.fire(new t.Event("dataloading", {\n          dataType: "style"\n        })), this._request = t.browser.frame(function () {\n          o._request = null, o._load(e, !1 !== i.validate);\n        });\n      }, i.prototype.loadEmpty = function () {\n        this.fire(new t.Event("dataloading", {\n          dataType: "style"\n        })), this._load(qe, !1);\n      }, i.prototype._load = function (e, i) {\n        if (!i || !Ue(this, t.validateStyle(e))) {\n          for (var o in this._loaded = !0, this.stylesheet = e, e.sources) {\n            this.addSource(o, e.sources[o], {\n              validate: !1\n            });\n          }\n\n          e.sprite ? this._loadSprite(e.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e.glyphs);\n          var r = Nt(this.stylesheet.layers);\n          this._order = r.map(function (t) {\n            return t.id;\n          }), this._layers = {}, this._serializedLayers = {};\n\n          for (var a = 0, n = r; a < n.length; a += 1) {\n            var s = n[a];\n            (s = t.createStyleLayer(s)).setEventedParent(this, {\n              layer: {\n                id: s.id\n              }\n            }), this._layers[s.id] = s, this._serializedLayers[s.id] = s.serialize();\n          }\n\n          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", {\n            dataType: "style"\n          })), this.fire(new t.Event("style.load"));\n        }\n      }, i.prototype._loadSprite = function (e) {\n        var i = this;\n\n        this._spriteRequest = function (e, i, o) {\n          var r,\n              a,\n              n,\n              s = t.browser.devicePixelRatio > 1 ? "@2x" : "",\n              l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, s, ".json"), t.ResourceType.SpriteJSON), function (t, e) {\n            l = null, n || (n = t, r = e, u());\n          }),\n              c = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, s, ".png"), t.ResourceType.SpriteImage), function (t, e) {\n            c = null, n || (n = t, a = e, u());\n          });\n\n          function u() {\n            if (n) o(n);else if (r && a) {\n              var e = t.browser.getImageData(a),\n                  i = {};\n\n              for (var s in r) {\n                var l = r[s],\n                    c = l.width,\n                    u = l.height,\n                    h = l.x,\n                    p = l.y,\n                    d = l.sdf,\n                    _ = l.pixelRatio,\n                    f = l.stretchX,\n                    m = l.stretchY,\n                    g = l.content,\n                    v = new t.RGBAImage({\n                  width: c,\n                  height: u\n                });\n                t.RGBAImage.copy(e, v, {\n                  x: h,\n                  y: p\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: c,\n                  height: u\n                }), i[s] = {\n                  data: v,\n                  pixelRatio: _,\n                  sdf: d,\n                  stretchX: f,\n                  stretchY: m,\n                  content: g\n                };\n              }\n\n              o(null, i);\n            }\n          }\n\n          return {\n            cancel: function cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n          };\n        }(e, this.map._requestManager, function (e, o) {\n          if (i._spriteRequest = null, e) i.fire(new t.ErrorEvent(e));else if (o) for (var r in o) {\n            i.imageManager.addImage(r, o[r]);\n          }\n          i.imageManager.setLoaded(!0), i._availableImages = i.imageManager.listImages(), i.dispatcher.broadcast("setImages", i._availableImages), i.fire(new t.Event("data", {\n            dataType: "style"\n          }));\n        });\n      }, i.prototype._validateLayer = function (e) {\n        var i = this.sourceCaches[e.source];\n\n        if (i) {\n          var o = e.sourceLayer;\n\n          if (o) {\n            var r = i.getSource();\n            ("geojson" === r.type || r.vectorLayerIds && -1 === r.vectorLayerIds.indexOf(o)) && this.fire(new t.ErrorEvent(new Error(\'Source layer "\' + o + \'" does not exist on source "\' + r.id + \'" as specified by style layer "\' + e.id + \'"\')));\n          }\n        }\n      }, i.prototype.loaded = function () {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._updatedSources).length) return !1;\n\n        for (var t in this.sourceCaches) {\n          if (!this.sourceCaches[t].loaded()) return !1;\n        }\n\n        return !!this.imageManager.isLoaded();\n      }, i.prototype._serializeLayers = function (t) {\n        for (var e = [], i = 0, o = t; i < o.length; i += 1) {\n          var r = this._layers[o[i]];\n          "custom" !== r.type && e.push(r.serialize());\n        }\n\n        return e;\n      }, i.prototype.hasTransitions = function () {\n        if (this.light && this.light.hasTransition()) return !0;\n\n        for (var t in this.sourceCaches) {\n          if (this.sourceCaches[t].hasTransition()) return !0;\n        }\n\n        for (var e in this._layers) {\n          if (this._layers[e].hasTransition()) return !0;\n        }\n\n        return !1;\n      }, i.prototype._checkLoaded = function () {\n        if (!this._loaded) throw new Error("Style is not done loading");\n      }, i.prototype.update = function (e) {\n        if (this._loaded) {\n          var i = this._changed;\n\n          if (this._changed) {\n            var o = Object.keys(this._updatedLayers),\n                r = Object.keys(this._removedLayers);\n\n            for (var a in (o.length || r.length) && this._updateWorkerLayers(o, r), this._updatedSources) {\n              var n = this._updatedSources[a];\n              "reload" === n ? this._reloadSource(a) : "clear" === n && this._clearSource(a);\n            }\n\n            for (var s in this._updateTilesForChangedImages(), this._updatedPaintProps) {\n              this._layers[s].updateTransitions(e);\n            }\n\n            this.light.updateTransitions(e), this._resetUpdates();\n          }\n\n          var l = {};\n\n          for (var c in this.sourceCaches) {\n            var u = this.sourceCaches[c];\n            l[c] = u.used, u.used = !1;\n          }\n\n          for (var h = 0, p = this._order; h < p.length; h += 1) {\n            var d = this._layers[p[h]];\n            d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0);\n          }\n\n          for (var _ in l) {\n            var f = this.sourceCaches[_];\n            l[_] !== f.used && f.fire(new t.Event("data", {\n              sourceDataType: "visibility",\n              dataType: "source",\n              sourceId: _\n            }));\n          }\n\n          this.light.recalculate(e), this.z = e.zoom, i && this.fire(new t.Event("data", {\n            dataType: "style"\n          }));\n        }\n      }, i.prototype._updateTilesForChangedImages = function () {\n        var t = Object.keys(this._changedImages);\n\n        if (t.length) {\n          for (var e in this.sourceCaches) {\n            this.sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t);\n          }\n\n          this._changedImages = {};\n        }\n      }, i.prototype._updateWorkerLayers = function (t, e) {\n        this.dispatcher.broadcast("updateLayers", {\n          layers: this._serializeLayers(t),\n          removedIds: e\n        });\n      }, i.prototype._resetUpdates = function () {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};\n      }, i.prototype.setState = function (e) {\n        var i = this;\n        if (this._checkLoaded(), Ue(this, t.validateStyle(e))) return !1;\n        (e = t.clone$1(e)).layers = Nt(e.layers);\n\n        var o = function (e, i) {\n          if (!e) return [{\n            command: Zt.setStyle,\n            args: [i]\n          }];\n          var o = [];\n\n          try {\n            if (!t.deepEqual(e.version, i.version)) return [{\n              command: Zt.setStyle,\n              args: [i]\n            }];\n            t.deepEqual(e.center, i.center) || o.push({\n              command: Zt.setCenter,\n              args: [i.center]\n            }), t.deepEqual(e.zoom, i.zoom) || o.push({\n              command: Zt.setZoom,\n              args: [i.zoom]\n            }), t.deepEqual(e.bearing, i.bearing) || o.push({\n              command: Zt.setBearing,\n              args: [i.bearing]\n            }), t.deepEqual(e.pitch, i.pitch) || o.push({\n              command: Zt.setPitch,\n              args: [i.pitch]\n            }), t.deepEqual(e.sprite, i.sprite) || o.push({\n              command: Zt.setSprite,\n              args: [i.sprite]\n            }), t.deepEqual(e.glyphs, i.glyphs) || o.push({\n              command: Zt.setGlyphs,\n              args: [i.glyphs]\n            }), t.deepEqual(e.transition, i.transition) || o.push({\n              command: Zt.setTransition,\n              args: [i.transition]\n            }), t.deepEqual(e.light, i.light) || o.push({\n              command: Zt.setLight,\n              args: [i.light]\n            });\n            var r = {},\n                a = [];\n            !function (e, i, o, r) {\n              var a;\n\n              for (a in i = i || {}, e = e || {}) {\n                e.hasOwnProperty(a) && (i.hasOwnProperty(a) || jt(a, o, r));\n              }\n\n              for (a in i) {\n                i.hasOwnProperty(a) && (e.hasOwnProperty(a) ? t.deepEqual(e[a], i[a]) || ("geojson" === e[a].type && "geojson" === i[a].type && Gt(e, i, a) ? o.push({\n                  command: Zt.setGeoJSONSourceData,\n                  args: [a, i[a].data]\n                }) : Vt(a, i, o, r)) : qt(a, i, o));\n              }\n            }(e.sources, i.sources, a, r);\n            var n = [];\n            e.layers && e.layers.forEach(function (t) {\n              r[t.source] ? o.push({\n                command: Zt.removeLayer,\n                args: [t.id]\n              }) : n.push(t);\n            }), o = o.concat(a), function (e, i, o) {\n              i = i || [];\n\n              var r,\n                  a,\n                  n,\n                  s,\n                  l,\n                  c,\n                  u,\n                  h = (e = e || []).map(Xt),\n                  p = i.map(Xt),\n                  d = e.reduce(Ht, {}),\n                  _ = i.reduce(Ht, {}),\n                  f = h.slice(),\n                  m = Object.create(null);\n\n              for (r = 0, a = 0; r < h.length; r++) {\n                _.hasOwnProperty(n = h[r]) ? a++ : (o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), f.splice(f.indexOf(n, a), 1));\n              }\n\n              for (r = 0, a = 0; r < p.length; r++) {\n                f[f.length - 1 - r] !== (n = p[p.length - 1 - r]) && (d.hasOwnProperty(n) ? (o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), f.splice(f.lastIndexOf(n, f.length - a), 1)) : a++, o.push({\n                  command: Zt.addLayer,\n                  args: [_[n], c = f[f.length - r]]\n                }), f.splice(f.length - r, 0, n), m[n] = !0);\n              }\n\n              for (r = 0; r < p.length; r++) {\n                if (s = d[n = p[r]], l = _[n], !m[n] && !t.deepEqual(s, l)) if (t.deepEqual(s.source, l.source) && t.deepEqual(s["source-layer"], l["source-layer"]) && t.deepEqual(s.type, l.type)) {\n                  for (u in Wt(s.layout, l.layout, o, n, null, Zt.setLayoutProperty), Wt(s.paint, l.paint, o, n, null, Zt.setPaintProperty), t.deepEqual(s.filter, l.filter) || o.push({\n                    command: Zt.setFilter,\n                    args: [n, l.filter]\n                  }), t.deepEqual(s.minzoom, l.minzoom) && t.deepEqual(s.maxzoom, l.maxzoom) || o.push({\n                    command: Zt.setLayerZoomRange,\n                    args: [n, l.minzoom, l.maxzoom]\n                  }), s) {\n                    s.hasOwnProperty(u) && "layout" !== u && "paint" !== u && "filter" !== u && "metadata" !== u && "minzoom" !== u && "maxzoom" !== u && (0 === u.indexOf("paint.") ? Wt(s[u], l[u], o, n, u.slice(6), Zt.setPaintProperty) : t.deepEqual(s[u], l[u]) || o.push({\n                      command: Zt.setLayerProperty,\n                      args: [n, u, l[u]]\n                    }));\n                  }\n\n                  for (u in l) {\n                    l.hasOwnProperty(u) && !s.hasOwnProperty(u) && "layout" !== u && "paint" !== u && "filter" !== u && "metadata" !== u && "minzoom" !== u && "maxzoom" !== u && (0 === u.indexOf("paint.") ? Wt(s[u], l[u], o, n, u.slice(6), Zt.setPaintProperty) : t.deepEqual(s[u], l[u]) || o.push({\n                      command: Zt.setLayerProperty,\n                      args: [n, u, l[u]]\n                    }));\n                  }\n                } else o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), c = f[f.lastIndexOf(n) + 1], o.push({\n                  command: Zt.addLayer,\n                  args: [l, c]\n                });\n              }\n            }(n, i.layers, o);\n          } catch (t) {\n            console.warn("Unable to compute style diff:", t), o = [{\n              command: Zt.setStyle,\n              args: [i]\n            }];\n          }\n\n          return o;\n        }(this.serialize(), e).filter(function (t) {\n          return !(t.command in Ze);\n        });\n\n        if (0 === o.length) return !1;\n        var r = o.filter(function (t) {\n          return !(t.command in Ne);\n        });\n        if (r.length > 0) throw new Error("Unimplemented: " + r.map(function (t) {\n          return t.command;\n        }).join(", ") + ".");\n        return o.forEach(function (t) {\n          "setTransition" !== t.command && i[t.command].apply(i, t.args);\n        }), this.stylesheet = e, !0;\n      }, i.prototype.addImage = function (e, i) {\n        if (this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));\n        this.imageManager.addImage(e, i), this._afterImageUpdated(e);\n      }, i.prototype.updateImage = function (t, e) {\n        this.imageManager.updateImage(t, e);\n      }, i.prototype.getImage = function (t) {\n        return this.imageManager.getImage(t);\n      }, i.prototype.removeImage = function (e) {\n        if (!this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));\n        this.imageManager.removeImage(e), this._afterImageUpdated(e);\n      }, i.prototype._afterImageUpdated = function (e) {\n        this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", {\n          dataType: "style"\n        }));\n      }, i.prototype.listImages = function () {\n        return this._checkLoaded(), this.imageManager.listImages();\n      }, i.prototype.addSource = function (e, i, o) {\n        var r = this;\n        if (void 0 === o && (o = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error("There is already a source with this ID");\n        if (!i.type) throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i).join(", ") + ".");\n\n        if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e, i, null, o))) {\n          this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n          var a = this.sourceCaches[e] = new Dt(e, i, this.dispatcher);\n          a.style = this, a.setEventedParent(this, function () {\n            return {\n              isSourceLoaded: r.loaded(),\n              source: a.serialize(),\n              sourceId: e\n            };\n          }), a.onAdd(this.map), this._changed = !0;\n        }\n      }, i.prototype.removeSource = function (e) {\n        if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID");\n\n        for (var i in this._layers) {\n          if (this._layers[i].source === e) return this.fire(new t.ErrorEvent(new Error(\'Source "\' + e + \'" cannot be removed while layer "\' + i + \'" is using it.\')));\n        }\n\n        var o = this.sourceCaches[e];\n        delete this.sourceCaches[e], delete this._updatedSources[e], o.fire(new t.Event("data", {\n          sourceDataType: "metadata",\n          dataType: "source",\n          sourceId: e\n        })), o.setEventedParent(null), o.clearTiles(), o.onRemove && o.onRemove(this.map), this._changed = !0;\n      }, i.prototype.setGeoJSONSourceData = function (t, e) {\n        this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0;\n      }, i.prototype.getSource = function (t) {\n        return this.sourceCaches[t] && this.sourceCaches[t].getSource();\n      }, i.prototype.addLayer = function (e, i, o) {\n        void 0 === o && (o = {}), this._checkLoaded();\n        var r = e.id;\n        if (this.getLayer(r)) this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + r + \'" already exists on this map\')));else {\n          var a;\n\n          if ("custom" === e.type) {\n            if (Ue(this, t.validateCustomStyleLayer(e))) return;\n            a = t.createStyleLayer(e);\n          } else {\n            if ("object" == typeof e.source && (this.addSource(r, e.source), e = t.clone$1(e), e = t.extend(e, {\n              source: r\n            })), this._validate(t.validateStyle.layer, "layers." + r, e, {\n              arrayIndex: -1\n            }, o)) return;\n            a = t.createStyleLayer(e), this._validateLayer(a), a.setEventedParent(this, {\n              layer: {\n                id: r\n              }\n            }), this._serializedLayers[a.id] = a.serialize();\n          }\n\n          var n = i ? this._order.indexOf(i) : this._order.length;\n          if (i && -1 === n) this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + i + \'" does not exist on this map.\')));else {\n            if (this._order.splice(n, 0, r), this._layerOrderChanged = !0, this._layers[r] = a, this._removedLayers[r] && a.source && "custom" !== a.type) {\n              var s = this._removedLayers[r];\n              delete this._removedLayers[r], s.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());\n            }\n\n            this._updateLayer(a), a.onAdd && a.onAdd(this.map);\n          }\n        }\n      }, i.prototype.moveLayer = function (e, i) {\n        if (this._checkLoaded(), this._changed = !0, this._layers[e]) {\n          if (e !== i) {\n            var o = this._order.indexOf(e);\n\n            this._order.splice(o, 1);\n\n            var r = i ? this._order.indexOf(i) : this._order.length;\n            i && -1 === r ? this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + i + \'" does not exist on this map.\'))) : (this._order.splice(r, 0, e), this._layerOrderChanged = !0);\n          }\n        } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be moved.")));\n      }, i.prototype.removeLayer = function (e) {\n        this._checkLoaded();\n\n        var i = this._layers[e];\n\n        if (i) {\n          i.setEventedParent(null);\n\n          var o = this._order.indexOf(e);\n\n          this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map);\n        } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be removed.")));\n      }, i.prototype.getLayer = function (t) {\n        return this._layers[t];\n      }, i.prototype.hasLayer = function (t) {\n        return t in this._layers;\n      }, i.prototype.setLayerZoomRange = function (e, i, o) {\n        this._checkLoaded();\n\n        var r = this.getLayer(e);\n        r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot have zoom extent.")));\n      }, i.prototype.setFilter = function (e, i, o) {\n        void 0 === o && (o = {}), this._checkLoaded();\n        var r = this.getLayer(e);\n\n        if (r) {\n          if (!t.deepEqual(r.filter, i)) return null == i ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(t.validateStyle.filter, "layers." + r.id + ".filter", i, null, o) || (r.filter = t.clone$1(i), this._updateLayer(r)));\n        } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be filtered.")));\n      }, i.prototype.getFilter = function (e) {\n        return t.clone$1(this.getLayer(e).filter);\n      }, i.prototype.setLayoutProperty = function (e, i, o, r) {\n        void 0 === r && (r = {}), this._checkLoaded();\n        var a = this.getLayer(e);\n        a ? t.deepEqual(a.getLayoutProperty(i), o) || (a.setLayoutProperty(i, o, r), this._updateLayer(a)) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be styled.")));\n      }, i.prototype.getLayoutProperty = function (e, i) {\n        var o = this.getLayer(e);\n        if (o) return o.getLayoutProperty(i);\n        this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style.")));\n      }, i.prototype.setPaintProperty = function (e, i, o, r) {\n        void 0 === r && (r = {}), this._checkLoaded();\n        var a = this.getLayer(e);\n        a ? t.deepEqual(a.getPaintProperty(i), o) || (a.setPaintProperty(i, o, r) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be styled.")));\n      }, i.prototype.getPaintProperty = function (t, e) {\n        return this.getLayer(t).getPaintProperty(e);\n      }, i.prototype.setFeatureState = function (e, i) {\n        this._checkLoaded();\n\n        var o = e.source,\n            r = e.sourceLayer,\n            a = this.sourceCaches[o];\n\n        if (void 0 !== a) {\n          var n = a.getSource().type;\n          "geojson" === n && r ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n || r ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a.setFeatureState(r, e.id, i)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n        } else this.fire(new t.ErrorEvent(new Error("The source \'" + o + "\' does not exist in the map\'s style.")));\n      }, i.prototype.removeFeatureState = function (e, i) {\n        this._checkLoaded();\n\n        var o = e.source,\n            r = this.sourceCaches[o];\n\n        if (void 0 !== r) {\n          var a = r.getSource().type,\n              n = "vector" === a ? e.sourceLayer : void 0;\n          "vector" !== a || n ? i && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : r.removeFeatureState(n, e.id, i) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n        } else this.fire(new t.ErrorEvent(new Error("The source \'" + o + "\' does not exist in the map\'s style.")));\n      }, i.prototype.getFeatureState = function (e) {\n        this._checkLoaded();\n\n        var i = e.source,\n            o = e.sourceLayer,\n            r = this.sourceCaches[i];\n\n        if (void 0 !== r) {\n          if ("vector" !== r.getSource().type || o) return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r.getFeatureState(o, e.id);\n          this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n        } else this.fire(new t.ErrorEvent(new Error("The source \'" + i + "\' does not exist in the map\'s style.")));\n      }, i.prototype.getTransition = function () {\n        return t.extend({\n          duration: 300,\n          delay: 0\n        }, this.stylesheet && this.stylesheet.transition);\n      }, i.prototype.serialize = function () {\n        return t.filterObject({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          light: this.stylesheet.light,\n          center: this.stylesheet.center,\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          sources: t.mapObject(this.sourceCaches, function (t) {\n            return t.serialize();\n          }),\n          layers: this._serializeLayers(this._order)\n        }, function (t) {\n          return void 0 !== t;\n        });\n      }, i.prototype._updateLayer = function (t) {\n        this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && "raster" !== this.sourceCaches[t.source].getSource().type && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._changed = !0;\n      }, i.prototype._flattenAndSortRenderedFeatures = function (t) {\n        for (var e = this, i = function i(t) {\n          return "fill-extrusion" === e._layers[t].type;\n        }, o = {}, r = [], a = this._order.length - 1; a >= 0; a--) {\n          var n = this._order[a];\n\n          if (i(n)) {\n            o[n] = a;\n\n            for (var s = 0, l = t; s < l.length; s += 1) {\n              var c = l[s][n];\n              if (c) for (var u = 0, h = c; u < h.length; u += 1) {\n                r.push(h[u]);\n              }\n            }\n          }\n        }\n\n        r.sort(function (t, e) {\n          return e.intersectionZ - t.intersectionZ;\n        });\n\n        for (var p = [], d = this._order.length - 1; d >= 0; d--) {\n          var _ = this._order[d];\n          if (i(_)) for (var f = r.length - 1; f >= 0; f--) {\n            var m = r[f].feature;\n            if (o[m.layer.id] < d) break;\n            p.push(m), r.pop();\n          } else for (var g = 0, v = t; g < v.length; g += 1) {\n            var y = v[g][_];\n            if (y) for (var x = 0, b = y; x < b.length; x += 1) {\n              p.push(b[x].feature);\n            }\n          }\n        }\n\n        return p;\n      }, i.prototype.queryRenderedFeatures = function (e, i, o) {\n        i && i.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i.filter, null, i);\n        var r = {};\n\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];\n\n          for (var a = 0, n = i.layers; a < n.length; a += 1) {\n            var s = n[a],\n                l = this._layers[s];\n            if (!l) return this.fire(new t.ErrorEvent(new Error("The layer \'" + s + "\' does not exist in the map\'s style and cannot be queried for features."))), [];\n            r[l.source] = !0;\n          }\n        }\n\n        var c = [];\n\n        for (var u in i.availableImages = this._availableImages, this.sourceCaches) {\n          i.layers && !r[u] || c.push(O(this.sourceCaches[u], this._layers, this._serializedLayers, e, i, o));\n        }\n\n        return this.placement && c.push(function (t, e, i, o, r, a, n) {\n          for (var s = {}, l = a.queryRenderedSymbols(o), c = [], u = 0, h = Object.keys(l).map(Number); u < h.length; u += 1) {\n            c.push(n[h[u]]);\n          }\n\n          c.sort(F);\n\n          for (var p = function p() {\n            var i = _[d],\n                o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, t);\n\n            for (var a in o) {\n              var n = s[a] = s[a] || [],\n                  c = o[a];\n              c.sort(function (t, e) {\n                var o = i.featureSortOrder;\n\n                if (o) {\n                  var r = o.indexOf(t.featureIndex);\n                  return o.indexOf(e.featureIndex) - r;\n                }\n\n                return e.featureIndex - t.featureIndex;\n              });\n\n              for (var u = 0, h = c; u < h.length; u += 1) {\n                n.push(h[u]);\n              }\n            }\n          }, d = 0, _ = c; d < _.length; d += 1) {\n            p();\n          }\n\n          var f = function f(e) {\n            s[e].forEach(function (o) {\n              var r = o.feature,\n                  a = i[t[e].source].getFeatureState(r.layer["source-layer"], r.id);\n              r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = a;\n            });\n          };\n\n          for (var m in s) {\n            f(m);\n          }\n\n          return s;\n        }(this._layers, this._serializedLayers, this.sourceCaches, e, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c);\n      }, i.prototype.querySourceFeatures = function (e, i) {\n        i && i.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i.filter, null, i);\n        var o = this.sourceCaches[e];\n        return o ? function (t, e) {\n          for (var i = t.getRenderableIds().map(function (e) {\n            return t.getTileByID(e);\n          }), o = [], r = {}, a = 0; a < i.length; a++) {\n            var n = i[a],\n                s = n.tileID.canonical.key;\n            r[s] || (r[s] = !0, n.querySourceFeatures(o, e));\n          }\n\n          return o;\n        }(o, i) : [];\n      }, i.prototype.addSourceType = function (t, e, o) {\n        return i.getSourceType(t) ? o(new Error(\'A source type called "\' + t + \'" already exists.\')) : (i.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {\n          name: t,\n          url: e.workerSourceURL\n        }, o) : o(null, null));\n      }, i.prototype.getLight = function () {\n        return this.light.getLight();\n      }, i.prototype.setLight = function (e, i) {\n        void 0 === i && (i = {}), this._checkLoaded();\n        var o = this.light.getLight(),\n            r = !1;\n\n        for (var a in e) {\n          if (!t.deepEqual(e[a], o[a])) {\n            r = !0;\n            break;\n          }\n        }\n\n        if (r) {\n          var n = {\n            now: t.browser.now(),\n            transition: t.extend({\n              duration: 300,\n              delay: 0\n            }, this.stylesheet.transition)\n          };\n          this.light.setLight(e, i), this.light.updateTransitions(n);\n        }\n      }, i.prototype._validate = function (e, i, o, r, a) {\n        return void 0 === a && (a = {}), (!a || !1 !== a.validate) && Ue(this, e.call(t.validateStyle, t.extend({\n          key: i,\n          style: this.serialize(),\n          value: o,\n          styleSpec: t.styleSpec\n        }, r)));\n      }, i.prototype._remove = function () {\n        for (var e in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) {\n          this._layers[e].setEventedParent(null);\n        }\n\n        for (var i in this.sourceCaches) {\n          this.sourceCaches[i].clearTiles(), this.sourceCaches[i].setEventedParent(null);\n        }\n\n        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();\n      }, i.prototype._clearSource = function (t) {\n        this.sourceCaches[t].clearTiles();\n      }, i.prototype._reloadSource = function (t) {\n        this.sourceCaches[t].resume(), this.sourceCaches[t].reload();\n      }, i.prototype._updateSources = function (t) {\n        for (var e in this.sourceCaches) {\n          this.sourceCaches[e].update(t);\n        }\n      }, i.prototype._generateCollisionBoxes = function () {\n        for (var t in this.sourceCaches) {\n          this._reloadSource(t);\n        }\n      }, i.prototype._updatePlacement = function (e, i, o, r, a) {\n        void 0 === a && (a = !1);\n\n        for (var n = !1, s = !1, l = {}, c = 0, u = this._order; c < u.length; c += 1) {\n          var h = this._layers[u[c]];\n\n          if ("symbol" === h.type) {\n            if (!l[h.source]) {\n              var p = this.sourceCaches[h.source];\n              l[h.source] = p.getRenderableIds(!0).map(function (t) {\n                return p.getTileByID(t);\n              }).sort(function (t, e) {\n                return e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1);\n              });\n            }\n\n            var d = this.crossTileSymbolIndex.addLayer(h, l[h.source], e.center.lng);\n            n = n || d;\n          }\n        }\n\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || 0 === o) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e.zoom)) && (this.pauseablePlacement = new Le(e, this._order, a, i, o, r, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s = !0), n && this.pauseablePlacement.placement.setStale()), s || n) for (var _ = 0, f = this._order; _ < f.length; _ += 1) {\n          var m = this._layers[f[_]];\n          "symbol" === m.type && this.placement.updateLayerOpacities(m, l[m.source]);\n        }\n        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());\n      }, i.prototype._releaseSymbolFadeTiles = function () {\n        for (var t in this.sourceCaches) {\n          this.sourceCaches[t].releaseSymbolFadeTiles();\n        }\n      }, i.prototype.getImages = function (t, e, i) {\n        this.imageManager.getImages(e.icons, i), this._updateTilesForChangedImages();\n        var o = this.sourceCaches[e.source];\n        o && o.setDependencies(e.tileID.key, e.type, e.icons);\n      }, i.prototype.getGlyphs = function (t, e, i) {\n        this.glyphManager.getGlyphs(e.stacks, i);\n      }, i.prototype.getResource = function (e, i, o) {\n        return t.makeRequest(i, o);\n      }, i;\n    }(t.Evented);\n\n    je.getSourceType = function (t) {\n      return k[t];\n    }, je.setSourceType = function (t, e) {\n      k[t] = e;\n    }, je.registerForPluginStateChange = t.registerForPluginStateChange;\n\n    var Ve = t.createLayout([{\n      name: "a_pos",\n      type: "Int16",\n      components: 2\n    }]),\n        Ge = gi("#ifdef GL_ES\\nprecision mediump float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif", "#ifdef GL_ES\\nprecision highp float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"),\n        We = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),\n        Xe = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),\n        He = gi("varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),\n        Ke = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),\n        Ye = gi("uniform highp float u_intensity;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),\n        Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(0.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),\n        Qe = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),\n        $e = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),\n        ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"),\n        ei = gi("#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_FragColor=color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),\n        ii = gi("varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),\n        oi = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),\n        ri = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),\n        ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),\n        ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\\n? a_pos\\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),\n        si = gi("#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),\n        li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\\n#define PI 3.141592653589793\\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),\n        ci = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),\n        ui = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),\n        hi = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),\n        pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),\n        di = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),\n        _i = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"),\n        fi = gi("#define SDF_PX 8.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),\n        mi = gi("#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");\n\n    function gi(t, e) {\n      var i = /#pragma mapbox: ([\\w]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n          o = e.match(/attribute ([\\w]+) ([\\w]+)/g),\n          r = t.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n          a = e.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n          n = a ? a.concat(r) : r,\n          s = {};\n      return {\n        fragmentSource: t = t.replace(i, function (t, e, i, o, r) {\n          return s[r] = !0, "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nvarying " + i + " " + o + " " + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "\\n#ifdef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n";\n        }),\n        vertexSource: e = e.replace(i, function (t, e, i, o, r) {\n          var a = "float" === o ? "vec2" : "vec4",\n              n = r.match(/color/) ? "color" : a;\n          return s[r] ? "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nuniform lowp float u_" + r + "_t;\\nattribute " + i + " " + a + " a_" + r + ";\\nvarying " + i + " " + o + " " + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "vec4" === n ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + r + " = a_" + r + ";\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + r + " = unpack_mix_" + n + "(a_" + r + ", u_" + r + "_t);\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nuniform lowp float u_" + r + "_t;\\nattribute " + i + " " + a + " a_" + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "vec4" === n ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = a_" + r + ";\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = unpack_mix_" + n + "(a_" + r + ", u_" + r + "_t);\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n";\n        }),\n        staticAttributes: o,\n        staticUniforms: n\n      };\n    }\n\n    var vi = Object.freeze({\n      __proto__: null,\n      prelude: Ge,\n      background: We,\n      backgroundPattern: Xe,\n      circle: He,\n      clippingMask: Ke,\n      heatmap: Ye,\n      heatmapTexture: Je,\n      collisionBox: Qe,\n      collisionCircle: $e,\n      debug: ti,\n      fill: ei,\n      fillOutline: ii,\n      fillOutlinePattern: oi,\n      fillPattern: ri,\n      fillExtrusion: ai,\n      fillExtrusionPattern: ni,\n      hillshadePrepare: si,\n      hillshade: li,\n      line: ci,\n      lineGradient: ui,\n      linePattern: hi,\n      lineSDF: pi,\n      raster: di,\n      symbolIcon: _i,\n      symbolSDF: fi,\n      symbolTextAndIcon: mi\n    }),\n        yi = function yi() {\n      this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;\n    };\n\n    function xi(t) {\n      for (var e = [], i = 0; i < t.length; i++) {\n        if (null !== t[i]) {\n          var o = t[i].split(" ");\n          e.push(o.pop());\n        }\n      }\n\n      return e;\n    }\n\n    yi.prototype.bind = function (t, e, i, o, r, a, n, s) {\n      this.context = t;\n\n      for (var l = this.boundPaintVertexBuffers.length !== o.length, c = 0; !l && c < o.length; c++) {\n        this.boundPaintVertexBuffers[c] !== o[c] && (l = !0);\n      }\n\n      t.extVertexArrayObject && this.vao && this.boundProgram === e && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === r && this.boundVertexOffset === a && this.boundDynamicVertexBuffer === n && this.boundDynamicVertexBuffer2 === s ? (t.bindVertexArrayOES.set(this.vao), n && n.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) : this.freshBind(e, i, o, r, a, n, s);\n    }, yi.prototype.freshBind = function (t, e, i, o, r, a, n) {\n      var s,\n          l = t.numAttributes,\n          c = this.context,\n          u = c.gl;\n      if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = n;else {\n        s = c.currentNumAttributes || 0;\n\n        for (var h = l; h < s; h++) {\n          u.disableVertexAttribArray(h);\n        }\n      }\n      e.enableAttributes(u, t);\n\n      for (var p = 0, d = i; p < d.length; p += 1) {\n        d[p].enableAttributes(u, t);\n      }\n\n      a && a.enableAttributes(u, t), n && n.enableAttributes(u, t), e.bind(), e.setVertexAttribPointers(u, t, r);\n\n      for (var _ = 0, f = i; _ < f.length; _ += 1) {\n        var m = f[_];\n        m.bind(), m.setVertexAttribPointers(u, t, r);\n      }\n\n      a && (a.bind(), a.setVertexAttribPointers(u, t, r)), o && o.bind(), n && (n.bind(), n.setVertexAttribPointers(u, t, r)), c.currentNumAttributes = l;\n    }, yi.prototype.destroy = function () {\n      this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);\n    };\n\n    var bi = function bi(t, e, i, o, r, a) {\n      var n = t.gl;\n      this.program = n.createProgram();\n\n      for (var s = xi(i.staticAttributes), l = o ? o.getBinderAttributes() : [], c = s.concat(l), u = i.staticUniforms ? xi(i.staticUniforms) : [], h = o ? o.getBinderUniforms() : [], p = [], d = 0, _ = u.concat(h); d < _.length; d += 1) {\n        var f = _[d];\n        p.indexOf(f) < 0 && p.push(f);\n      }\n\n      var m = o ? o.defines() : [];\n      a && m.push("#define OVERDRAW_INSPECTOR;");\n      var g = m.concat(Ge.fragmentSource, i.fragmentSource).join("\\n"),\n          v = m.concat(Ge.vertexSource, i.vertexSource).join("\\n"),\n          y = n.createShader(n.FRAGMENT_SHADER);\n      if (n.isContextLost()) this.failedToCreate = !0;else {\n        n.shaderSource(y, g), n.compileShader(y), n.attachShader(this.program, y);\n        var x = n.createShader(n.VERTEX_SHADER);\n        if (n.isContextLost()) this.failedToCreate = !0;else {\n          n.shaderSource(x, v), n.compileShader(x), n.attachShader(this.program, x), this.attributes = {};\n          var b = {};\n          this.numAttributes = c.length;\n\n          for (var w = 0; w < this.numAttributes; w++) {\n            c[w] && (n.bindAttribLocation(this.program, w, c[w]), this.attributes[c[w]] = w);\n          }\n\n          n.linkProgram(this.program), n.deleteShader(x), n.deleteShader(y);\n\n          for (var T = 0; T < p.length; T++) {\n            var E = p[T];\n\n            if (E && !b[E]) {\n              var I = n.getUniformLocation(this.program, E);\n              I && (b[E] = I);\n            }\n          }\n\n          this.fixedUniforms = r(t, b), this.binderUniforms = o ? o.getUniforms(t, b) : [];\n        }\n      }\n    };\n\n    function wi(t, e, i) {\n      var o = 1 / pe(i, 1, e.transform.tileZoom),\n          r = Math.pow(2, i.tileID.overscaledZ),\n          a = i.tileSize * Math.pow(2, e.transform.tileZoom) / r,\n          n = a * (i.tileID.canonical.x + i.tileID.wrap * r),\n          s = a * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture.size,\n        u_scale: [o, t.fromScale, t.toScale],\n        u_fade: t.t,\n        u_pixel_coord_upper: [n >> 16, s >> 16],\n        u_pixel_coord_lower: [65535 & n, 65535 & s]\n      };\n    }\n\n    bi.prototype.draw = function (t, e, i, o, r, a, n, s, l, c, u, h, p, d, _, f) {\n      var m,\n          g = t.gl;\n\n      if (!this.failedToCreate) {\n        for (var v in t.program.set(this.program), t.setDepthMode(i), t.setStencilMode(o), t.setColorMode(r), t.setCullFace(a), this.fixedUniforms) {\n          this.fixedUniforms[v].set(n[v]);\n        }\n\n        d && d.setUniforms(t, this.binderUniforms, h, {\n          zoom: p\n        });\n\n        for (var y = (m = {}, m[g.LINES] = 2, m[g.TRIANGLES] = 3, m[g.LINE_STRIP] = 1, m)[e], x = 0, b = u.get(); x < b.length; x += 1) {\n          var w = b[x],\n              T = w.vaos || (w.vaos = {});\n          (T[s] || (T[s] = new yi())).bind(t, this, l, d ? d.getPaintVertexBuffers() : [], c, w.vertexOffset, _, f), g.drawElements(e, w.primitiveLength * y, g.UNSIGNED_SHORT, w.primitiveOffset * y * 2);\n        }\n      }\n    };\n\n    var Ti = function Ti(e, i, o, r) {\n      var a = i.style.light,\n          n = a.properties.get("position"),\n          s = [n.x, n.y, n.z],\n          l = t.create$1();\n      "viewport" === a.properties.get("anchor") && t.fromRotation(l, -i.transform.angle), t.transformMat3(s, s, l);\n      var c = a.properties.get("color");\n      return {\n        u_matrix: e,\n        u_lightpos: s,\n        u_lightintensity: a.properties.get("intensity"),\n        u_lightcolor: [c.r, c.g, c.b],\n        u_vertical_gradient: +o,\n        u_opacity: r\n      };\n    },\n        Ei = function Ei(e, i, o, r, a, n, s) {\n      return t.extend(Ti(e, i, o, r), wi(n, i, s), {\n        u_height_factor: -Math.pow(2, a.overscaledZ) / s.tileSize / 8\n      });\n    },\n        Ii = function Ii(t) {\n      return {\n        u_matrix: t\n      };\n    },\n        Pi = function Pi(e, i, o, r) {\n      return t.extend(Ii(e), wi(o, i, r));\n    },\n        Si = function Si(t, e) {\n      return {\n        u_matrix: t,\n        u_world: e\n      };\n    },\n        Ci = function Ci(e, i, o, r, a) {\n      return t.extend(Pi(e, i, o, r), {\n        u_world: a\n      });\n    },\n        zi = function zi(e, i, o, r) {\n      var a,\n          n,\n          s = e.transform;\n\n      if ("map" === r.paint.get("circle-pitch-alignment")) {\n        var l = pe(o, 1, s.zoom);\n        a = !0, n = [l, l];\n      } else a = !1, n = s.pixelsToGLUnits;\n\n      return {\n        u_camera_to_center_distance: s.cameraToCenterDistance,\n        u_scale_with_map: +("map" === r.paint.get("circle-pitch-scale")),\n        u_matrix: e.translatePosMatrix(i.posMatrix, o, r.paint.get("circle-translate"), r.paint.get("circle-translate-anchor")),\n        u_pitch_with_map: +a,\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_extrude_scale: n\n      };\n    },\n        Di = function Di(t, e, i) {\n      var o = pe(i, 1, e.zoom),\n          r = Math.pow(2, e.zoom - i.tileID.overscaledZ),\n          a = i.tileID.overscaleFactor();\n      return {\n        u_matrix: t,\n        u_camera_to_center_distance: e.cameraToCenterDistance,\n        u_pixels_to_tile_units: o,\n        u_extrude_scale: [e.pixelsToGLUnits[0] / (o * r), e.pixelsToGLUnits[1] / (o * r)],\n        u_overscale_factor: a\n      };\n    },\n        Ai = function Ai(t, e, i) {\n      return {\n        u_matrix: t,\n        u_inv_matrix: e,\n        u_camera_to_center_distance: i.cameraToCenterDistance,\n        u_viewport_size: [i.width, i.height]\n      };\n    },\n        Mi = function Mi(t, e, i) {\n      return void 0 === i && (i = 1), {\n        u_matrix: t,\n        u_color: e,\n        u_overlay: 0,\n        u_overlay_scale: i\n      };\n    },\n        Li = function Li(t) {\n      return {\n        u_matrix: t\n      };\n    },\n        Ri = function Ri(t, e, i, o) {\n      return {\n        u_matrix: t,\n        u_extrude_scale: pe(e, 1, i),\n        u_intensity: o\n      };\n    },\n        ki = function ki(e, i, o) {\n      var r = e.transform;\n      return {\n        u_matrix: Ni(e, i, o),\n        u_ratio: 1 / pe(i, 1, r.zoom),\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_units_to_pixels: [1 / r.pixelsToGLUnits[0], 1 / r.pixelsToGLUnits[1]]\n      };\n    },\n        Bi = function Bi(e, i, o, r) {\n      return t.extend(ki(e, i, o), {\n        u_image: 0,\n        u_image_height: r\n      });\n    },\n        Oi = function Oi(e, i, o, r) {\n      var a = e.transform,\n          n = Ui(i, a);\n      return {\n        u_matrix: Ni(e, i, o),\n        u_texsize: i.imageAtlasTexture.size,\n        u_ratio: 1 / pe(i, 1, a.zoom),\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_image: 0,\n        u_scale: [n, r.fromScale, r.toScale],\n        u_fade: r.t,\n        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]]\n      };\n    },\n        Fi = function Fi(e, i, o, r, a) {\n      var n = e.lineAtlas,\n          s = Ui(i, e.transform),\n          l = "round" === o.layout.get("line-cap"),\n          c = n.getDash(r.from, l),\n          u = n.getDash(r.to, l),\n          h = c.width * a.fromScale,\n          p = u.width * a.toScale;\n      return t.extend(ki(e, i, o), {\n        u_patternscale_a: [s / h, -c.height / 2],\n        u_patternscale_b: [s / p, -u.height / 2],\n        u_sdfgamma: n.width / (256 * Math.min(h, p) * t.browser.devicePixelRatio) / 2,\n        u_image: 0,\n        u_tex_y_a: c.y,\n        u_tex_y_b: u.y,\n        u_mix: a.t\n      });\n    };\n\n    function Ui(t, e) {\n      return 1 / pe(t, 1, e.tileZoom);\n    }\n\n    function Ni(t, e, i) {\n      return t.translatePosMatrix(e.tileID.posMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));\n    }\n\n    var Zi = function Zi(t, e, i, o, r) {\n      return {\n        u_matrix: t,\n        u_tl_parent: e,\n        u_scale_parent: i,\n        u_buffer_scale: 1,\n        u_fade_t: o.mix,\n        u_opacity: o.opacity * r.paint.get("raster-opacity"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: r.paint.get("raster-brightness-min"),\n        u_brightness_high: r.paint.get("raster-brightness-max"),\n        u_saturation_factor: (n = r.paint.get("raster-saturation"), n > 0 ? 1 - 1 / (1.001 - n) : -n),\n        u_contrast_factor: (a = r.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a),\n        u_spin_weights: qi(r.paint.get("raster-hue-rotate"))\n      };\n      var a, n;\n    };\n\n    function qi(t) {\n      t *= Math.PI / 180;\n      var e = Math.sin(t),\n          i = Math.cos(t);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3];\n    }\n\n    var ji,\n        Vi = function Vi(t, e, i, o, r, a, n, s, l, c) {\n      var u = r.transform;\n      return {\n        u_is_size_zoom_constant: +("constant" === t || "source" === t),\n        u_is_size_feature_constant: +("constant" === t || "camera" === t),\n        u_size_t: e ? e.uSizeT : 0,\n        u_size: e ? e.uSize : 0,\n        u_camera_to_center_distance: u.cameraToCenterDistance,\n        u_pitch: u.pitch / 360 * 2 * Math.PI,\n        u_rotate_symbol: +i,\n        u_aspect_ratio: u.width / u.height,\n        u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,\n        u_matrix: a,\n        u_label_plane_matrix: n,\n        u_coord_matrix: s,\n        u_is_text: +l,\n        u_pitch_with_map: +o,\n        u_texsize: c,\n        u_texture: 0\n      };\n    },\n        Gi = function Gi(e, i, o, r, a, n, s, l, c, u, h) {\n      var p = a.transform;\n      return t.extend(Vi(e, i, o, r, a, n, s, l, c, u), {\n        u_gamma_scale: r ? Math.cos(p._pitch) * p.cameraToCenterDistance : 1,\n        u_device_pixel_ratio: t.browser.devicePixelRatio,\n        u_is_halo: +h\n      });\n    },\n        Wi = function Wi(e, i, o, r, a, n, s, l, c, u) {\n      return t.extend(Gi(e, i, o, r, a, n, s, l, !0, c, !0), {\n        u_texsize_icon: u,\n        u_texture_icon: 1\n      });\n    },\n        Xi = function Xi(t, e, i) {\n      return {\n        u_matrix: t,\n        u_opacity: e,\n        u_color: i\n      };\n    },\n        Hi = function Hi(e, i, o, r, a, n) {\n      return t.extend(function (t, e, i, o) {\n        var r = i.imageManager.getPattern(t.from.toString()),\n            a = i.imageManager.getPattern(t.to.toString()),\n            n = i.imageManager.getPixelSize(),\n            s = n.width,\n            l = n.height,\n            c = Math.pow(2, o.tileID.overscaledZ),\n            u = o.tileSize * Math.pow(2, i.transform.tileZoom) / c,\n            h = u * (o.tileID.canonical.x + o.tileID.wrap * c),\n            p = u * o.tileID.canonical.y;\n        return {\n          u_image: 0,\n          u_pattern_tl_a: r.tl,\n          u_pattern_br_a: r.br,\n          u_pattern_tl_b: a.tl,\n          u_pattern_br_b: a.br,\n          u_texsize: [s, l],\n          u_mix: e.t,\n          u_pattern_size_a: r.displaySize,\n          u_pattern_size_b: a.displaySize,\n          u_scale_a: e.fromScale,\n          u_scale_b: e.toScale,\n          u_tile_units_to_pixels: 1 / pe(o, 1, i.transform.tileZoom),\n          u_pixel_coord_upper: [h >> 16, p >> 16],\n          u_pixel_coord_lower: [65535 & h, 65535 & p]\n        };\n      }(r, n, o, a), {\n        u_matrix: e,\n        u_opacity: i\n      });\n    },\n        Ki = {\n      fillExtrusion: function fillExtrusion(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n          u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n          u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n          u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n          u_opacity: new t.Uniform1f(e, i.u_opacity)\n        };\n      },\n      fillExtrusionPattern: function fillExtrusionPattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n          u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n          u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n          u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n          u_height_factor: new t.Uniform1f(e, i.u_height_factor),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade),\n          u_opacity: new t.Uniform1f(e, i.u_opacity)\n        };\n      },\n      fill: function fill(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      fillPattern: function fillPattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade)\n        };\n      },\n      fillOutline: function fillOutline(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_world: new t.Uniform2f(e, i.u_world)\n        };\n      },\n      fillOutlinePattern: function fillOutlinePattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_world: new t.Uniform2f(e, i.u_world),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade)\n        };\n      },\n      circle: function circle(e, i) {\n        return {\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_scale_with_map: new t.Uniform1i(e, i.u_scale_with_map),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      collisionBox: function collisionBox(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pixels_to_tile_units: new t.Uniform1f(e, i.u_pixels_to_tile_units),\n          u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n          u_overscale_factor: new t.Uniform1f(e, i.u_overscale_factor)\n        };\n      },\n      collisionCircle: function collisionCircle(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_inv_matrix: new t.UniformMatrix4f(e, i.u_inv_matrix),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_viewport_size: new t.Uniform2f(e, i.u_viewport_size)\n        };\n      },\n      debug: function debug(e, i) {\n        return {\n          u_color: new t.UniformColor(e, i.u_color),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_overlay: new t.Uniform1i(e, i.u_overlay),\n          u_overlay_scale: new t.Uniform1f(e, i.u_overlay_scale)\n        };\n      },\n      clippingMask: function clippingMask(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      heatmap: function heatmap(e, i) {\n        return {\n          u_extrude_scale: new t.Uniform1f(e, i.u_extrude_scale),\n          u_intensity: new t.Uniform1f(e, i.u_intensity),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n        };\n      },\n      heatmapTexture: function heatmapTexture(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_world: new t.Uniform2f(e, i.u_world),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_color_ramp: new t.Uniform1i(e, i.u_color_ramp),\n          u_opacity: new t.Uniform1f(e, i.u_opacity)\n        };\n      },\n      hillshade: function hillshade(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_latrange: new t.Uniform2f(e, i.u_latrange),\n          u_light: new t.Uniform2f(e, i.u_light),\n          u_shadow: new t.UniformColor(e, i.u_shadow),\n          u_highlight: new t.UniformColor(e, i.u_highlight),\n          u_accent: new t.UniformColor(e, i.u_accent)\n        };\n      },\n      hillshadePrepare: function hillshadePrepare(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_dimension: new t.Uniform2f(e, i.u_dimension),\n          u_zoom: new t.Uniform1f(e, i.u_zoom),\n          u_unpack: new t.Uniform4f(e, i.u_unpack)\n        };\n      },\n      line: function line(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels)\n        };\n      },\n      lineGradient: function lineGradient(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_image_height: new t.Uniform1f(e, i.u_image_height)\n        };\n      },\n      linePattern: function linePattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n          u_scale: new t.Uniform3f(e, i.u_scale),\n          u_fade: new t.Uniform1f(e, i.u_fade)\n        };\n      },\n      lineSDF: function lineSDF(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_ratio: new t.Uniform1f(e, i.u_ratio),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n          u_patternscale_a: new t.Uniform2f(e, i.u_patternscale_a),\n          u_patternscale_b: new t.Uniform2f(e, i.u_patternscale_b),\n          u_sdfgamma: new t.Uniform1f(e, i.u_sdfgamma),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_tex_y_a: new t.Uniform1f(e, i.u_tex_y_a),\n          u_tex_y_b: new t.Uniform1f(e, i.u_tex_y_b),\n          u_mix: new t.Uniform1f(e, i.u_mix)\n        };\n      },\n      raster: function raster(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_tl_parent: new t.Uniform2f(e, i.u_tl_parent),\n          u_scale_parent: new t.Uniform1f(e, i.u_scale_parent),\n          u_buffer_scale: new t.Uniform1f(e, i.u_buffer_scale),\n          u_fade_t: new t.Uniform1f(e, i.u_fade_t),\n          u_opacity: new t.Uniform1f(e, i.u_opacity),\n          u_image0: new t.Uniform1i(e, i.u_image0),\n          u_image1: new t.Uniform1i(e, i.u_image1),\n          u_brightness_low: new t.Uniform1f(e, i.u_brightness_low),\n          u_brightness_high: new t.Uniform1f(e, i.u_brightness_high),\n          u_saturation_factor: new t.Uniform1f(e, i.u_saturation_factor),\n          u_contrast_factor: new t.Uniform1f(e, i.u_contrast_factor),\n          u_spin_weights: new t.Uniform3f(e, i.u_spin_weights)\n        };\n      },\n      symbolIcon: function symbolIcon(e, i) {\n        return {\n          u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n          u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n          u_size_t: new t.Uniform1f(e, i.u_size_t),\n          u_size: new t.Uniform1f(e, i.u_size),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pitch: new t.Uniform1f(e, i.u_pitch),\n          u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n          u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n          u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n          u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n          u_is_text: new t.Uniform1i(e, i.u_is_text),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_texture: new t.Uniform1i(e, i.u_texture)\n        };\n      },\n      symbolSDF: function symbolSDF(e, i) {\n        return {\n          u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n          u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n          u_size_t: new t.Uniform1f(e, i.u_size_t),\n          u_size: new t.Uniform1f(e, i.u_size),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pitch: new t.Uniform1f(e, i.u_pitch),\n          u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n          u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n          u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n          u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n          u_is_text: new t.Uniform1i(e, i.u_is_text),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_texture: new t.Uniform1i(e, i.u_texture),\n          u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n        };\n      },\n      symbolTextAndIcon: function symbolTextAndIcon(e, i) {\n        return {\n          u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n          u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n          u_size_t: new t.Uniform1f(e, i.u_size_t),\n          u_size: new t.Uniform1f(e, i.u_size),\n          u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n          u_pitch: new t.Uniform1f(e, i.u_pitch),\n          u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n          u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n          u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n          u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n          u_is_text: new t.Uniform1i(e, i.u_is_text),\n          u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_texsize_icon: new t.Uniform2f(e, i.u_texsize_icon),\n          u_texture: new t.Uniform1i(e, i.u_texture),\n          u_texture_icon: new t.Uniform1i(e, i.u_texture_icon),\n          u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n          u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n          u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n        };\n      },\n      background: function background(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_opacity: new t.Uniform1f(e, i.u_opacity),\n          u_color: new t.UniformColor(e, i.u_color)\n        };\n      },\n      backgroundPattern: function backgroundPattern(e, i) {\n        return {\n          u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n          u_opacity: new t.Uniform1f(e, i.u_opacity),\n          u_image: new t.Uniform1i(e, i.u_image),\n          u_pattern_tl_a: new t.Uniform2f(e, i.u_pattern_tl_a),\n          u_pattern_br_a: new t.Uniform2f(e, i.u_pattern_br_a),\n          u_pattern_tl_b: new t.Uniform2f(e, i.u_pattern_tl_b),\n          u_pattern_br_b: new t.Uniform2f(e, i.u_pattern_br_b),\n          u_texsize: new t.Uniform2f(e, i.u_texsize),\n          u_mix: new t.Uniform1f(e, i.u_mix),\n          u_pattern_size_a: new t.Uniform2f(e, i.u_pattern_size_a),\n          u_pattern_size_b: new t.Uniform2f(e, i.u_pattern_size_b),\n          u_scale_a: new t.Uniform1f(e, i.u_scale_a),\n          u_scale_b: new t.Uniform1f(e, i.u_scale_b),\n          u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n          u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n          u_tile_units_to_pixels: new t.Uniform1f(e, i.u_tile_units_to_pixels)\n        };\n      }\n    };\n\n    function Yi(e, i, o, r, a, n, s) {\n      for (var l = e.context, c = l.gl, u = e.useProgram("collisionBox"), h = [], p = 0, d = 0, _ = 0; _ < r.length; _++) {\n        var f = r[_],\n            m = i.getTile(f),\n            g = m.getBucket(o);\n\n        if (g) {\n          var v = f.posMatrix;\n          0 === a[0] && 0 === a[1] || (v = e.translatePosMatrix(f.posMatrix, m, a, n));\n          var y = s ? g.textCollisionBox : g.iconCollisionBox,\n              x = g.collisionCircleArray;\n\n          if (x.length > 0) {\n            var b = t.create(),\n                w = v;\n            t.mul(b, g.placementInvProjMatrix, e.transform.glCoordMatrix), t.mul(b, b, g.placementViewportMatrix), h.push({\n              circleArray: x,\n              circleOffset: d,\n              transform: w,\n              invTransform: b\n            }), d = p += x.length / 4;\n          }\n\n          y && u.draw(l, c.LINES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, Di(v, e.transform, m), o.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, null, e.transform.zoom, null, null, y.collisionVertexBuffer);\n        }\n      }\n\n      if (s && h.length) {\n        var T = e.useProgram("collisionCircle"),\n            E = new t.StructArrayLayout2f1f2i16();\n        E.resize(4 * p), E._trim();\n\n        for (var I = 0, P = 0, S = h; P < S.length; P += 1) {\n          for (var C = S[P], z = 0; z < C.circleArray.length / 4; z++) {\n            var D = 4 * z,\n                A = C.circleArray[D + 0],\n                M = C.circleArray[D + 1],\n                L = C.circleArray[D + 2],\n                R = C.circleArray[D + 3];\n            E.emplace(I++, A, M, L, R, 0), E.emplace(I++, A, M, L, R, 1), E.emplace(I++, A, M, L, R, 2), E.emplace(I++, A, M, L, R, 3);\n          }\n        }\n\n        (!ji || ji.length < 2 * p) && (ji = function (e) {\n          var i = 2 * e,\n              o = new t.StructArrayLayout3ui6();\n          o.resize(i), o._trim();\n\n          for (var r = 0; r < i; r++) {\n            var a = 6 * r;\n            o.uint16[a + 0] = 4 * r + 0, o.uint16[a + 1] = 4 * r + 1, o.uint16[a + 2] = 4 * r + 2, o.uint16[a + 3] = 4 * r + 2, o.uint16[a + 4] = 4 * r + 3, o.uint16[a + 5] = 4 * r + 0;\n          }\n\n          return o;\n        }(p));\n\n        for (var k = l.createIndexBuffer(ji, !0), B = l.createVertexBuffer(E, t.collisionCircleLayout.members, !0), O = 0, F = h; O < F.length; O += 1) {\n          var U = F[O],\n              N = Ai(U.transform, U.invTransform, e.transform);\n          T.draw(l, c.TRIANGLES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, N, o.id, B, k, t.SegmentVector.simpleSegment(0, 2 * U.circleOffset, U.circleArray.length, U.circleArray.length / 2), null, e.transform.zoom, null, null, null);\n        }\n\n        B.destroy(), k.destroy();\n      }\n    }\n\n    var Ji = t.identity(new Float32Array(16));\n\n    function Qi(e, i, o, r, a, n) {\n      var s = t.getAnchorAlignment(e),\n          l = -(s.horizontalAlign - .5) * i,\n          c = -(s.verticalAlign - .5) * o,\n          u = t.evaluateVariableOffset(e, r);\n      return new t.Point((l / a + u[0]) * n, (c / a + u[1]) * n);\n    }\n\n    function $i(e, i, o, r, a, n, s, l, c, u, h) {\n      var p = e.text.placedSymbolArray,\n          d = e.text.dynamicLayoutVertexArray,\n          _ = e.icon.dynamicLayoutVertexArray,\n          f = {};\n      d.clear();\n\n      for (var m = 0; m < p.length; m++) {\n        var g = p.get(m),\n            v = g.hidden || !g.crossTileID || e.allowVerticalPlacement && !g.placedOrientation ? null : r[g.crossTileID];\n\n        if (v) {\n          var y = new t.Point(g.anchorX, g.anchorY),\n              x = $t(y, o ? l : s),\n              b = te(n.cameraToCenterDistance, x.signedDistanceFromCamera),\n              w = a.evaluateSizeForFeature(e.textSizeData, u, g) * b / t.ONE_EM;\n          o && (w *= e.tilePixelRatio / c);\n\n          for (var T = Qi(v.anchor, v.width, v.height, v.textOffset, v.textBoxScale, w), E = o ? $t(y.add(T), s).point : x.point.add(i ? T.rotate(-n.angle) : T), I = e.allowVerticalPlacement && g.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, P = 0; P < g.numGlyphs; P++) {\n            t.addDynamicAttributes(d, E, I);\n          }\n\n          h && g.associatedIconIndex >= 0 && (f[g.associatedIconIndex] = {\n            shiftedAnchor: E,\n            angle: I\n          });\n        } else ce(g.numGlyphs, d);\n      }\n\n      if (h) {\n        _.clear();\n\n        for (var S = e.icon.placedSymbolArray, C = 0; C < S.length; C++) {\n          var z = S.get(C);\n          if (z.hidden) ce(z.numGlyphs, _);else {\n            var D = f[C];\n            if (D) for (var A = 0; A < z.numGlyphs; A++) {\n              t.addDynamicAttributes(_, D.shiftedAnchor, D.angle);\n            } else ce(z.numGlyphs, _);\n          }\n        }\n\n        e.icon.dynamicLayoutVertexBuffer.updateData(_);\n      }\n\n      e.text.dynamicLayoutVertexBuffer.updateData(d);\n    }\n\n    function to(t, e, i) {\n      return i.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon";\n    }\n\n    function eo(e, i, o, r, a, n, s, l, c, u, h, p) {\n      for (var d = e.context, _ = d.gl, f = e.transform, m = "map" === l, g = "map" === c, v = m && "point" !== o.layout.get("symbol-placement"), y = m && !g && !v, x = !o.layout.get("symbol-sort-key").isConstant(), b = !1, w = e.depthModeForSublayer(0, It.ReadOnly), T = o.layout.get("text-variable-anchor"), E = [], I = 0, P = r; I < P.length; I += 1) {\n        var S = P[I],\n            C = i.getTile(S),\n            z = C.getBucket(o);\n\n        if (z) {\n          var D = a ? z.text : z.icon;\n\n          if (D && D.segments.get().length) {\n            var A = D.programConfigurations.get(o.id),\n                M = a || z.sdfIcons,\n                L = a ? z.textSizeData : z.iconSizeData,\n                R = g || 0 !== f.pitch,\n                k = e.useProgram(to(M, a, z), A),\n                B = t.evaluateSizeForZoom(L, f.zoom),\n                O = void 0,\n                F = [0, 0],\n                U = void 0,\n                N = void 0,\n                Z = null,\n                q = void 0;\n            if (a) U = C.glyphAtlasTexture, N = _.LINEAR, O = C.glyphAtlasTexture.size, z.iconsInText && (F = C.imageAtlasTexture.size, Z = C.imageAtlasTexture, q = R || e.options.rotating || e.options.zooming || "composite" === L.kind || "camera" === L.kind ? _.LINEAR : _.NEAREST);else {\n              var j = 1 !== o.layout.get("icon-size").constantOr(0) || z.iconsNeedLinear;\n              U = C.imageAtlasTexture, N = M || e.options.rotating || e.options.zooming || j || R ? _.LINEAR : _.NEAREST, O = C.imageAtlasTexture.size;\n            }\n            var V = pe(C, 1, e.transform.zoom),\n                G = Jt(S.posMatrix, g, m, e.transform, V),\n                W = Qt(S.posMatrix, g, m, e.transform, V),\n                X = T && z.hasTextData(),\n                H = "none" !== o.layout.get("icon-text-fit") && X && z.hasIconData();\n            v && ie(z, S.posMatrix, e, a, G, W, g, u);\n            var K = e.translatePosMatrix(S.posMatrix, C, n, s),\n                Y = v || a && T || H ? Ji : G,\n                J = e.translatePosMatrix(W, C, n, s, !0),\n                Q = M && 0 !== o.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1),\n                $ = {\n              program: k,\n              buffers: D,\n              uniformValues: M ? z.iconsInText ? Wi(L.kind, B, y, g, e, K, Y, J, O, F) : Gi(L.kind, B, y, g, e, K, Y, J, a, O, !0) : Vi(L.kind, B, y, g, e, K, Y, J, a, O),\n              atlasTexture: U,\n              atlasTextureIcon: Z,\n              atlasInterpolation: N,\n              atlasInterpolationIcon: q,\n              isSDF: M,\n              hasHalo: Q\n            };\n\n            if (x && z.canOverlap) {\n              b = !0;\n\n              for (var tt = 0, et = D.segments.get(); tt < et.length; tt += 1) {\n                var it = et[tt];\n                E.push({\n                  segments: new t.SegmentVector([it]),\n                  sortKey: it.sortKey,\n                  state: $\n                });\n              }\n            } else E.push({\n              segments: D.segments,\n              sortKey: 0,\n              state: $\n            });\n          }\n        }\n      }\n\n      b && E.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n\n      for (var ot = 0, rt = E; ot < rt.length; ot += 1) {\n        var at = rt[ot],\n            nt = at.state;\n\n        if (d.activeTexture.set(_.TEXTURE0), nt.atlasTexture.bind(nt.atlasInterpolation, _.CLAMP_TO_EDGE), nt.atlasTextureIcon && (d.activeTexture.set(_.TEXTURE1), nt.atlasTextureIcon && nt.atlasTextureIcon.bind(nt.atlasInterpolationIcon, _.CLAMP_TO_EDGE)), nt.isSDF) {\n          var st = nt.uniformValues;\n          nt.hasHalo && (st.u_is_halo = 1, io(nt.buffers, at.segments, o, e, nt.program, w, h, p, st)), st.u_is_halo = 0;\n        }\n\n        io(nt.buffers, at.segments, o, e, nt.program, w, h, p, nt.uniformValues);\n      }\n    }\n\n    function io(t, e, i, o, r, a, n, s, l) {\n      var c = o.context;\n      r.draw(c, c.gl.TRIANGLES, a, n, s, Ct.disabled, l, i.id, t.layoutVertexBuffer, t.indexBuffer, e, i.paint, o.transform.zoom, t.programConfigurations.get(i.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer);\n    }\n\n    function oo(t, e, i, o, r, a, n) {\n      var s,\n          l,\n          c,\n          u,\n          h,\n          p = t.context.gl,\n          d = i.paint.get("fill-pattern"),\n          _ = d && d.constantOr(1),\n          f = i.getCrossfadeParameters();\n\n      n ? (l = _ && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s = p.LINES) : (l = _ ? "fillPattern" : "fill", s = p.TRIANGLES);\n\n      for (var m = 0, g = o; m < g.length; m += 1) {\n        var v = g[m],\n            y = e.getTile(v);\n\n        if (!_ || y.patternsLoaded()) {\n          var x = y.getBucket(i);\n\n          if (x) {\n            var b = x.programConfigurations.get(i.id),\n                w = t.useProgram(l, b);\n            _ && (t.context.activeTexture.set(p.TEXTURE0), y.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), b.updatePaintBuffers(f));\n            var T = d.constantOr(null);\n\n            if (T && y.imageAtlas) {\n              var E = y.imageAtlas,\n                  I = E.patternPositions[T.to.toString()],\n                  P = E.patternPositions[T.from.toString()];\n              I && P && b.setConstantPatternPositions(I, P);\n            }\n\n            var S = t.translatePosMatrix(v.posMatrix, y, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor"));\n\n            if (n) {\n              u = x.indexBuffer2, h = x.segments2;\n              var C = [p.drawingBufferWidth, p.drawingBufferHeight];\n              c = "fillOutlinePattern" === l && _ ? Ci(S, t, f, y, C) : Si(S, C);\n            } else u = x.indexBuffer, h = x.segments, c = _ ? Pi(S, t, f, y) : Ii(S);\n\n            w.draw(t.context, s, r, t.stencilModeForClipping(v), a, Ct.disabled, c, i.id, x.layoutVertexBuffer, u, h, i.paint, t.transform.zoom, b);\n          }\n        }\n      }\n    }\n\n    function ro(t, e, i, o, r, a, n) {\n      for (var s = t.context, l = s.gl, c = i.paint.get("fill-extrusion-pattern"), u = c.constantOr(1), h = i.getCrossfadeParameters(), p = i.paint.get("fill-extrusion-opacity"), d = 0, _ = o; d < _.length; d += 1) {\n        var f = _[d],\n            m = e.getTile(f),\n            g = m.getBucket(i);\n\n        if (g) {\n          var v = g.programConfigurations.get(i.id),\n              y = t.useProgram(u ? "fillExtrusionPattern" : "fillExtrusion", v);\n          u && (t.context.activeTexture.set(l.TEXTURE0), m.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers(h));\n          var x = c.constantOr(null);\n\n          if (x && m.imageAtlas) {\n            var b = m.imageAtlas,\n                w = b.patternPositions[x.to.toString()],\n                T = b.patternPositions[x.from.toString()];\n            w && T && v.setConstantPatternPositions(w, T);\n          }\n\n          var E = t.translatePosMatrix(f.posMatrix, m, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),\n              I = i.paint.get("fill-extrusion-vertical-gradient"),\n              P = u ? Ei(E, t, I, p, f, h, m) : Ti(E, t, I, p);\n          y.draw(s, s.gl.TRIANGLES, r, a, n, Ct.backCCW, P, i.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, i.paint, t.transform.zoom, v);\n        }\n      }\n    }\n\n    function ao(e, i, o, r, a, n) {\n      var s = e.context,\n          l = s.gl,\n          c = i.fbo;\n\n      if (c) {\n        var u = e.useProgram("hillshade");\n        s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get());\n\n        var h = function (e, i, o) {\n          var r = o.paint.get("hillshade-shadow-color"),\n              a = o.paint.get("hillshade-highlight-color"),\n              n = o.paint.get("hillshade-accent-color"),\n              s = o.paint.get("hillshade-illumination-direction") * (Math.PI / 180);\n          "viewport" === o.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle);\n          var l,\n              c,\n              u,\n              h = !e.options.moving;\n          return {\n            u_matrix: e.transform.calculatePosMatrix(i.tileID.toUnwrapped(), h),\n            u_image: 0,\n            u_latrange: (l = i.tileID, c = Math.pow(2, l.canonical.z), u = l.canonical.y, [new t.MercatorCoordinate(0, u / c).toLngLat().lat, new t.MercatorCoordinate(0, (u + 1) / c).toLngLat().lat]),\n            u_light: [o.paint.get("hillshade-exaggeration"), s],\n            u_shadow: r,\n            u_highlight: a,\n            u_accent: n\n          };\n        }(e, i, o);\n\n        u.draw(s, l.TRIANGLES, r, a, n, Ct.disabled, h, o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments);\n      }\n    }\n\n    function no(e, i, o, r, a, n) {\n      var s = e.context,\n          l = s.gl,\n          c = i.dem;\n\n      if (c && c.data) {\n        var u = c.dim,\n            h = c.stride,\n            p = c.getPixels();\n\n        if (s.activeTexture.set(l.TEXTURE1), s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(h), i.demTexture) {\n          var d = i.demTexture;\n          d.update(p, {\n            premultiply: !1\n          }), d.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n        } else i.demTexture = new t.Texture(s, p, l.RGBA, {\n          premultiply: !1\n        }), i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n\n        s.activeTexture.set(l.TEXTURE0);\n        var _ = i.fbo;\n\n        if (!_) {\n          var f = new t.Texture(s, {\n            width: u,\n            height: u,\n            data: null\n          }, l.RGBA);\n          f.bind(l.LINEAR, l.CLAMP_TO_EDGE), (_ = i.fbo = s.createFramebuffer(u, u, !0)).colorAttachment.set(f.texture);\n        }\n\n        s.bindFramebuffer.set(_.framebuffer), s.viewport.set([0, 0, u, u]), e.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, r, a, n, Ct.disabled, function (e, i) {\n          var o = i.stride,\n              r = t.create();\n          return t.ortho(r, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r, r, [0, -t.EXTENT, 0]), {\n            u_matrix: r,\n            u_image: 1,\n            u_dimension: [o, o],\n            u_zoom: e.overscaledZ,\n            u_unpack: i.getUnpackVector()\n          };\n        }(i.tileID, c), o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1;\n      }\n    }\n\n    function so(e, i, o, r, a) {\n      var n = r.paint.get("raster-fade-duration");\n\n      if (n > 0) {\n        var s = t.browser.now(),\n            l = (s - e.timeAdded) / n,\n            c = i ? (s - i.timeAdded) / n : -1,\n            u = o.getSource(),\n            h = a.coveringZoomLevel({\n          tileSize: u.tileSize,\n          roundZoom: u.roundZoom\n        }),\n            p = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e.tileID.overscaledZ - h),\n            d = p && e.refreshedUponExpiration ? 1 : t.clamp(p ? l : 1 - c, 0, 1);\n        return e.refreshedUponExpiration && l >= 1 && (e.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - d\n        } : {\n          opacity: d,\n          mix: 0\n        };\n      }\n\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n\n    var lo = new t.Color(1, 0, 0, 1),\n        co = new t.Color(0, 1, 0, 1),\n        uo = new t.Color(0, 0, 1, 1),\n        ho = new t.Color(1, 0, 1, 1),\n        po = new t.Color(0, 1, 1, 1);\n\n    function _o(t, e, i, o) {\n      mo(t, 0, e + i / 2, t.transform.width, i, o);\n    }\n\n    function fo(t, e, i, o) {\n      mo(t, e - i / 2, 0, i, t.transform.height, o);\n    }\n\n    function mo(e, i, o, r, a, n) {\n      var s = e.context,\n          l = s.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * t.browser.devicePixelRatio, o * t.browser.devicePixelRatio, r * t.browser.devicePixelRatio, a * t.browser.devicePixelRatio), s.clear({\n        color: n\n      }), l.disable(l.SCISSOR_TEST);\n    }\n\n    function go(e, i, o) {\n      var r = e.context,\n          a = r.gl,\n          n = o.posMatrix,\n          s = e.useProgram("debug"),\n          l = It.disabled,\n          c = Pt.disabled,\n          u = e.colorModeForRenderPass();\n      r.activeTexture.set(a.TEXTURE0), e.emptyTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), s.draw(r, a.LINE_STRIP, l, c, u, Ct.disabled, Mi(n, t.Color.red), "$debug", e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments);\n\n      var h = i.getTileByID(o.key).latestRawTileData,\n          p = Math.floor((h && h.byteLength || 0) / 1024),\n          d = i.getTile(o).tileSize,\n          _ = 512 / Math.min(d, 512) * (o.overscaledZ / e.transform.zoom) * .5,\n          f = o.canonical.toString();\n\n      o.overscaledZ !== o.canonical.z && (f += " => " + o.overscaledZ), function (t, e) {\n        t.initDebugOverlayCanvas();\n        var i = t.debugOverlayCanvas,\n            o = t.context.gl,\n            r = t.debugOverlayCanvas.getContext("2d");\n        r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(e, 5, 5), r.strokeText(e, 5, 5), t.debugOverlayTexture.update(i), t.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }(e, f + " " + p + "kb"), s.draw(r, a.TRIANGLES, l, c, St.alphaBlended, Ct.disabled, Mi(n, t.Color.transparent, _), "$debug", e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments);\n    }\n\n    var vo = {\n      symbol: function symbol(e, i, o, r, a) {\n        if ("translucent" === e.renderPass) {\n          var n = Pt.disabled,\n              s = e.colorModeForRenderPass();\n          o.layout.get("text-variable-anchor") && function (e, i, o, r, a, n, s) {\n            for (var l = i.transform, c = "map" === a, u = "map" === n, h = 0, p = e; h < p.length; h += 1) {\n              var d = p[h],\n                  _ = r.getTile(d),\n                  f = _.getBucket(o);\n\n              if (f && f.text && f.text.segments.get().length) {\n                var m = t.evaluateSizeForZoom(f.textSizeData, l.zoom),\n                    g = pe(_, 1, i.transform.zoom),\n                    v = Jt(d.posMatrix, u, c, i.transform, g),\n                    y = "none" !== o.layout.get("icon-text-fit") && f.hasIconData();\n\n                if (m) {\n                  var x = Math.pow(2, l.zoom - _.tileID.overscaledZ);\n                  $i(f, c, u, s, t.symbolSize, l, v, d.posMatrix, x, m, y);\n                }\n              }\n            }\n          }(r, e, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), a), 0 !== o.paint.get("icon-opacity").constantOr(1) && eo(e, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), n, s), 0 !== o.paint.get("text-opacity").constantOr(1) && eo(e, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), n, s), i.map.showCollisionBoxes && (Yi(e, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), Yi(e, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));\n        }\n      },\n      circle: function circle(e, i, o, r) {\n        if ("translucent" === e.renderPass) {\n          var a = o.paint.get("circle-opacity"),\n              n = o.paint.get("circle-stroke-width"),\n              s = o.paint.get("circle-stroke-opacity"),\n              l = !o.layout.get("circle-sort-key").isConstant();\n\n          if (0 !== a.constantOr(1) || 0 !== n.constantOr(1) && 0 !== s.constantOr(1)) {\n            for (var c = e.context, u = c.gl, h = e.depthModeForSublayer(0, It.ReadOnly), p = Pt.disabled, d = e.colorModeForRenderPass(), _ = [], f = 0; f < r.length; f++) {\n              var m = r[f],\n                  g = i.getTile(m),\n                  v = g.getBucket(o);\n\n              if (v) {\n                var y = v.programConfigurations.get(o.id),\n                    x = {\n                  programConfiguration: y,\n                  program: e.useProgram("circle", y),\n                  layoutVertexBuffer: v.layoutVertexBuffer,\n                  indexBuffer: v.indexBuffer,\n                  uniformValues: zi(e, m, g, o)\n                };\n                if (l) for (var b = 0, w = v.segments.get(); b < w.length; b += 1) {\n                  var T = w[b];\n\n                  _.push({\n                    segments: new t.SegmentVector([T]),\n                    sortKey: T.sortKey,\n                    state: x\n                  });\n                } else _.push({\n                  segments: v.segments,\n                  sortKey: 0,\n                  state: x\n                });\n              }\n            }\n\n            l && _.sort(function (t, e) {\n              return t.sortKey - e.sortKey;\n            });\n\n            for (var E = 0, I = _; E < I.length; E += 1) {\n              var P = I[E],\n                  S = P.state;\n              S.program.draw(c, u.TRIANGLES, h, p, d, Ct.disabled, S.uniformValues, o.id, S.layoutVertexBuffer, S.indexBuffer, P.segments, o.paint, e.transform.zoom, S.programConfiguration);\n            }\n          }\n        }\n      },\n      heatmap: function heatmap(e, i, o, r) {\n        if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === e.renderPass) {\n          var a = e.context,\n              n = a.gl,\n              s = Pt.disabled,\n              l = new St([n.ONE, n.ONE], t.Color.transparent, [!0, !0, !0, !0]);\n          !function (t, e, i) {\n            var o = t.gl;\n            t.activeTexture.set(o.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]);\n            var r = i.heatmapFbo;\n            if (r) o.bindTexture(o.TEXTURE_2D, r.colorAttachment.get()), t.bindFramebuffer.set(r.framebuffer);else {\n              var a = o.createTexture();\n              o.bindTexture(o.TEXTURE_2D, a), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), r = i.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4, !1), function (t, e, i, o) {\n                var r = t.gl;\n                r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e.width / 4, e.height / 4, 0, r.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : r.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n              }(t, e, a, r);\n            }\n          }(a, e, o), a.clear({\n            color: t.Color.transparent\n          });\n\n          for (var c = 0; c < r.length; c++) {\n            var u = r[c];\n\n            if (!i.hasRenderableParent(u)) {\n              var h = i.getTile(u),\n                  p = h.getBucket(o);\n\n              if (p) {\n                var d = p.programConfigurations.get(o.id);\n                e.useProgram("heatmap", d).draw(a, n.TRIANGLES, It.disabled, s, l, Ct.disabled, Ri(u.posMatrix, h, e.transform.zoom, o.paint.get("heatmap-intensity")), o.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, o.paint, e.transform.zoom, d);\n              }\n            }\n          }\n\n          a.viewport.set([0, 0, e.width, e.height]);\n        } else "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()), function (e, i) {\n          var o = e.context,\n              r = o.gl,\n              a = i.heatmapFbo;\n\n          if (a) {\n            o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);\n            var n = i.colorRampTexture;\n            n || (n = i.colorRampTexture = new t.Texture(o, i.colorRamp, r.RGBA)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(o, r.TRIANGLES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, function (e, i, o, r) {\n              var a = t.create();\n              t.ortho(a, 0, e.width, e.height, 0, 0, 1);\n              var n = e.context.gl;\n              return {\n                u_matrix: a,\n                u_world: [n.drawingBufferWidth, n.drawingBufferHeight],\n                u_image: 0,\n                u_color_ramp: 1,\n                u_opacity: i.paint.get("heatmap-opacity")\n              };\n            }(e, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom);\n          }\n        }(e, o));\n      },\n      line: function line(e, i, o, r) {\n        if ("translucent" === e.renderPass) {\n          var a = o.paint.get("line-opacity"),\n              n = o.paint.get("line-width");\n          if (0 !== a.constantOr(1) && 0 !== n.constantOr(1)) for (var s = e.depthModeForSublayer(0, It.ReadOnly), l = e.colorModeForRenderPass(), c = o.paint.get("line-dasharray"), u = o.paint.get("line-pattern"), h = u.constantOr(1), p = o.paint.get("line-gradient"), d = o.getCrossfadeParameters(), _ = h ? "linePattern" : c ? "lineSDF" : p ? "lineGradient" : "line", f = e.context, m = f.gl, g = !0, v = 0, y = r; v < y.length; v += 1) {\n            var x = y[v],\n                b = i.getTile(x);\n\n            if (!h || b.patternsLoaded()) {\n              var w = b.getBucket(o);\n\n              if (w) {\n                var T = w.programConfigurations.get(o.id),\n                    E = e.context.program.get(),\n                    I = e.useProgram(_, T),\n                    P = g || I.program !== E,\n                    S = u.constantOr(null);\n\n                if (S && b.imageAtlas) {\n                  var C = b.imageAtlas,\n                      z = C.patternPositions[S.to.toString()],\n                      D = C.patternPositions[S.from.toString()];\n                  z && D && T.setConstantPatternPositions(z, D);\n                }\n\n                var A = h ? Oi(e, b, o, d) : c ? Fi(e, b, o, c, d) : p ? Bi(e, b, o, w.lineClipsArray.length) : ki(e, b, o);\n                if (h) f.activeTexture.set(m.TEXTURE0), b.imageAtlasTexture.bind(m.LINEAR, m.CLAMP_TO_EDGE), T.updatePaintBuffers(d);else if (c && (P || e.lineAtlas.dirty)) f.activeTexture.set(m.TEXTURE0), e.lineAtlas.bind(f);else if (p) {\n                  var M = w.gradients[o.id],\n                      L = M.texture;\n\n                  if (o.gradientVersion !== M.version) {\n                    var R = 256;\n\n                    if (o.stepInterpolant) {\n                      var k = i.getSource().maxzoom,\n                          B = x.canonical.z === k ? Math.ceil(1 << e.transform.maxZoom - x.canonical.z) : 1;\n                      R = t.clamp(t.nextPowerOfTwo(w.maxLineLength / t.EXTENT * 1024 * B), 256, f.maxTextureSize);\n                    }\n\n                    M.gradient = t.renderColorRamp({\n                      expression: o.gradientExpression(),\n                      evaluationKey: "lineProgress",\n                      resolution: R,\n                      image: M.gradient || void 0,\n                      clips: w.lineClipsArray\n                    }), M.texture ? M.texture.update(M.gradient) : M.texture = new t.Texture(f, M.gradient, m.RGBA), M.version = o.gradientVersion, L = M.texture;\n                  }\n\n                  f.activeTexture.set(m.TEXTURE0), L.bind(o.stepInterpolant ? m.NEAREST : m.LINEAR, m.CLAMP_TO_EDGE);\n                }\n                I.draw(f, m.TRIANGLES, s, e.stencilModeForClipping(x), l, Ct.disabled, A, o.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, o.paint, e.transform.zoom, T, w.layoutVertexBuffer2), g = !1;\n              }\n            }\n          }\n        }\n      },\n      fill: function fill(e, i, o, r) {\n        var a = o.paint.get("fill-color"),\n            n = o.paint.get("fill-opacity");\n\n        if (0 !== n.constantOr(1)) {\n          var s = e.colorModeForRenderPass(),\n              l = o.paint.get("fill-pattern"),\n              c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === a.constantOr(t.Color.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";\n\n          if (e.renderPass === c) {\n            var u = e.depthModeForSublayer(1, "opaque" === e.renderPass ? It.ReadWrite : It.ReadOnly);\n            oo(e, i, o, r, u, s, !1);\n          }\n\n          if ("translucent" === e.renderPass && o.paint.get("fill-antialias")) {\n            var h = e.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);\n            oo(e, i, o, r, h, s, !0);\n          }\n        }\n      },\n      "fill-extrusion": function fillExtrusion(t, e, i, o) {\n        var r = i.paint.get("fill-extrusion-opacity");\n\n        if (0 !== r && "translucent" === t.renderPass) {\n          var a = new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D);\n          if (1 !== r || i.paint.get("fill-extrusion-pattern").constantOr(1)) ro(t, e, i, o, a, Pt.disabled, St.disabled), ro(t, e, i, o, a, t.stencilModeFor3D(), t.colorModeForRenderPass());else {\n            var n = t.colorModeForRenderPass();\n            ro(t, e, i, o, a, Pt.disabled, n);\n          }\n        }\n      },\n      hillshade: function hillshade(t, e, i, o) {\n        if ("offscreen" === t.renderPass || "translucent" === t.renderPass) {\n          for (var r = t.context, a = t.depthModeForSublayer(0, It.ReadOnly), n = t.colorModeForRenderPass(), s = "translucent" === t.renderPass ? t.stencilConfigForOverlap(o) : [{}, o], l = s[0], c = 0, u = s[1]; c < u.length; c += 1) {\n            var h = u[c],\n                p = e.getTile(h);\n            p.needsHillshadePrepare && "offscreen" === t.renderPass ? no(t, p, i, a, Pt.disabled, n) : "translucent" === t.renderPass && ao(t, p, i, a, l[h.overscaledZ], n);\n          }\n\n          r.viewport.set([0, 0, t.width, t.height]);\n        }\n      },\n      raster: function raster(t, e, i, o) {\n        if ("translucent" === t.renderPass && 0 !== i.paint.get("raster-opacity") && o.length) for (var r = t.context, a = r.gl, n = e.getSource(), s = t.useProgram("raster"), l = t.colorModeForRenderPass(), c = n instanceof M ? [{}, o] : t.stencilConfigForOverlap(o), u = c[0], h = c[1], p = h[h.length - 1].overscaledZ, d = !t.options.moving, _ = 0, f = h; _ < f.length; _ += 1) {\n          var m = f[_],\n              g = t.depthModeForSublayer(m.overscaledZ - p, 1 === i.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a.LESS),\n              v = e.getTile(m),\n              y = t.transform.calculatePosMatrix(m.toUnwrapped(), d);\n          v.registerFadeDuration(i.paint.get("raster-fade-duration"));\n          var x = e.findLoadedParent(m, 0),\n              b = so(v, x, e, i, t.transform),\n              w = void 0,\n              T = void 0,\n              E = "nearest" === i.paint.get("raster-resampling") ? a.NEAREST : a.LINEAR;\n          r.activeTexture.set(a.TEXTURE0), v.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), r.activeTexture.set(a.TEXTURE1), x ? (x.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), w = Math.pow(2, x.tileID.overscaledZ - v.tileID.overscaledZ), T = [v.tileID.canonical.x * w % 1, v.tileID.canonical.y * w % 1]) : v.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);\n          var I = Zi(y, T || [0, 0], w || 1, b, i);\n          n instanceof M ? s.draw(r, a.TRIANGLES, g, Pt.disabled, l, Ct.disabled, I, i.id, n.boundsBuffer, t.quadTriangleIndexBuffer, n.boundsSegments) : s.draw(r, a.TRIANGLES, g, u[m.overscaledZ], l, Ct.disabled, I, i.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments);\n        }\n      },\n      background: function background(t, e, i) {\n        var o = i.paint.get("background-color"),\n            r = i.paint.get("background-opacity");\n\n        if (0 !== r) {\n          var a = t.context,\n              n = a.gl,\n              s = t.transform,\n              l = s.tileSize,\n              c = i.paint.get("background-pattern");\n\n          if (!t.isPatternMissing(c)) {\n            var u = !c && 1 === o.a && 1 === r && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";\n\n            if (t.renderPass === u) {\n              var h = Pt.disabled,\n                  p = t.depthModeForSublayer(0, "opaque" === u ? It.ReadWrite : It.ReadOnly),\n                  d = t.colorModeForRenderPass(),\n                  _ = t.useProgram(c ? "backgroundPattern" : "background"),\n                  f = s.coveringTiles({\n                tileSize: l\n              });\n\n              c && (a.activeTexture.set(n.TEXTURE0), t.imageManager.bind(t.context));\n\n              for (var m = i.getCrossfadeParameters(), g = 0, v = f; g < v.length; g += 1) {\n                var y = v[g],\n                    x = t.transform.calculatePosMatrix(y.toUnwrapped()),\n                    b = c ? Hi(x, r, t, c, {\n                  tileID: y,\n                  tileSize: l\n                }, m) : Xi(x, r, o);\n\n                _.draw(a, n.TRIANGLES, p, h, d, Ct.disabled, b, i.id, t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments);\n              }\n            }\n          }\n        }\n      },\n      debug: function debug(t, e, i) {\n        for (var o = 0; o < i.length; o++) {\n          go(t, e, i[o]);\n        }\n      },\n      custom: function custom(t, e, i) {\n        var o = t.context,\n            r = i.implementation;\n\n        if ("offscreen" === t.renderPass) {\n          var a = r.prerender;\n          a && (t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), a.call(r, o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState());\n        } else if ("translucent" === t.renderPass) {\n          t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), o.setStencilMode(Pt.disabled);\n          var n = "3d" === r.renderingMode ? new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, It.ReadOnly);\n          o.setDepthMode(n), r.render(o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState(), o.bindFramebuffer.set(null);\n        }\n      }\n    },\n        yo = function yo(t, e) {\n      this.context = new zt(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {};\n    };\n\n    yo.prototype.resize = function (e, i) {\n      if (this.width = e * t.browser.devicePixelRatio, this.height = i * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var o = 0, r = this.style._order; o < r.length; o += 1) {\n        this.style._layers[r[o]].resize();\n      }\n    }, yo.prototype.setup = function () {\n      var e = this.context,\n          i = new t.StructArrayLayout2i4();\n      i.emplaceBack(0, 0), i.emplaceBack(t.EXTENT, 0), i.emplaceBack(0, t.EXTENT), i.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(i, Ve.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var o = new t.StructArrayLayout2i4();\n      o.emplaceBack(0, 0), o.emplaceBack(t.EXTENT, 0), o.emplaceBack(0, t.EXTENT), o.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e.createVertexBuffer(o, Ve.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);\n      var r = new t.StructArrayLayout4i8();\n      r.emplaceBack(0, 0, 0, 0), r.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(r, A.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var a = new t.StructArrayLayout2i4();\n      a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(a, Ve.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var n = new t.StructArrayLayout1ui2();\n      n.emplaceBack(0), n.emplaceBack(1), n.emplaceBack(3), n.emplaceBack(2), n.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(n);\n      var s = new t.StructArrayLayout3ui6();\n      s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s), this.emptyTexture = new t.Texture(e, {\n        width: 1,\n        height: 1,\n        data: new Uint8Array([0, 0, 0, 0])\n      }, e.gl.RGBA);\n      var l = this.context.gl;\n      this.stencilClearMode = new Pt({\n        func: l.ALWAYS,\n        mask: 0\n      }, 0, 255, l.ZERO, l.ZERO, l.ZERO);\n    }, yo.prototype.clearStencil = function () {\n      var e = this.context,\n          i = e.gl;\n      this.nextStencilID = 1, this.currentStencilSource = void 0;\n      var o = t.create();\n      t.ortho(o, 0, this.width, this.height, 0, 0, 1), t.scale(o, o, [i.drawingBufferWidth, i.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, i.TRIANGLES, It.disabled, this.stencilClearMode, St.disabled, Ct.disabled, Li(o), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n    }, yo.prototype._renderTileClippingMasks = function (t, e) {\n      if (this.currentStencilSource !== t.source && t.isTileClipped() && e && e.length) {\n        this.currentStencilSource = t.source;\n        var i = this.context,\n            o = i.gl;\n        this.nextStencilID + e.length > 256 && this.clearStencil(), i.setColorMode(St.disabled), i.setDepthMode(It.disabled);\n        var r = this.useProgram("clippingMask");\n        this._tileClippingMaskIDs = {};\n\n        for (var a = 0, n = e; a < n.length; a += 1) {\n          var s = n[a],\n              l = this._tileClippingMaskIDs[s.key] = this.nextStencilID++;\n          r.draw(i, o.TRIANGLES, It.disabled, new Pt({\n            func: o.ALWAYS,\n            mask: 0\n          }, l, 255, o.KEEP, o.KEEP, o.REPLACE), St.disabled, Ct.disabled, Li(s.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);\n        }\n      }\n    }, yo.prototype.stencilModeFor3D = function () {\n      this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n      var t = this.nextStencilID++,\n          e = this.context.gl;\n      return new Pt({\n        func: e.NOTEQUAL,\n        mask: 255\n      }, t, 255, e.KEEP, e.KEEP, e.REPLACE);\n    }, yo.prototype.stencilModeForClipping = function (t) {\n      var e = this.context.gl;\n      return new Pt({\n        func: e.EQUAL,\n        mask: 255\n      }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE);\n    }, yo.prototype.stencilConfigForOverlap = function (t) {\n      var e,\n          i = this.context.gl,\n          o = t.sort(function (t, e) {\n        return e.overscaledZ - t.overscaledZ;\n      }),\n          r = o[o.length - 1].overscaledZ,\n          a = o[0].overscaledZ - r + 1;\n\n      if (a > 1) {\n        this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();\n\n        for (var n = {}, s = 0; s < a; s++) {\n          n[s + r] = new Pt({\n            func: i.GEQUAL,\n            mask: 255\n          }, s + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);\n        }\n\n        return this.nextStencilID += a, [n, o];\n      }\n\n      return [(e = {}, e[r] = Pt.disabled, e), o];\n    }, yo.prototype.colorModeForRenderPass = function () {\n      var e = this.context.gl;\n      return this._showOverdrawInspector ? new St([e.CONSTANT_COLOR, e.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : "opaque" === this.renderPass ? St.unblended : St.alphaBlended;\n    }, yo.prototype.depthModeForSublayer = function (t, e, i) {\n      if (!this.opaquePassEnabledForLayer()) return It.disabled;\n      var o = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;\n      return new It(i || this.context.gl.LEQUAL, e, [o, o]);\n    }, yo.prototype.opaquePassEnabledForLayer = function () {\n      return this.currentLayer < this.opaquePassCutoff;\n    }, yo.prototype.render = function (e, i) {\n      var o = this;\n      this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();\n      var r = this.style._order,\n          a = this.style.sourceCaches;\n\n      for (var n in a) {\n        var s = a[n];\n        s.used && s.prepare(this.context);\n      }\n\n      var l,\n          c,\n          u = {},\n          h = {},\n          p = {};\n\n      for (var d in a) {\n        var _ = a[d];\n        u[d] = _.getVisibleCoordinates(), h[d] = u[d].slice().reverse(), p[d] = _.getVisibleCoordinates(!0).reverse();\n      }\n\n      this.opaquePassCutoff = 1 / 0;\n\n      for (var f = 0; f < r.length; f++) {\n        if (this.style._layers[r[f]].is3D()) {\n          this.opaquePassCutoff = f;\n          break;\n        }\n      }\n\n      this.renderPass = "offscreen";\n\n      for (var m = 0, g = r; m < g.length; m += 1) {\n        var v = this.style._layers[g[m]];\n\n        if (v.hasOffscreenPass() && !v.isHidden(this.transform.zoom)) {\n          var y = h[v.source];\n          ("custom" === v.type || y.length) && this.renderLayer(this, a[v.source], v, y);\n        }\n      }\n\n      for (this.context.bindFramebuffer.set(null), this.context.clear({\n        color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,\n        depth: 1\n      }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n        var x = this.style._layers[r[this.currentLayer]],\n            b = a[x.source],\n            w = u[x.source];\n        this._renderTileClippingMasks(x, w), this.renderLayer(this, b, x, w);\n      }\n\n      for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {\n        var T = this.style._layers[r[this.currentLayer]],\n            E = a[T.source],\n            I = ("symbol" === T.type ? p : h)[T.source];\n        this._renderTileClippingMasks(T, u[T.source]), this.renderLayer(this, E, T, I);\n      }\n\n      this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function (t) {\n        t.source && !t.isHidden(o.transform.zoom) && (t.source !== (c && c.id) && (c = o.style.sourceCaches[t.source]), (!l || l.getSource().maxzoom < c.getSource().maxzoom) && (l = c));\n      }), l && vo.debug(this, l, l.getVisibleCoordinates())), this.options.showPadding && function (t) {\n        var e = t.transform.padding;\n        _o(t, t.transform.height - (e.top || 0), 3, lo), _o(t, e.bottom || 0, 3, co), fo(t, e.left || 0, 3, uo), fo(t, t.transform.width - (e.right || 0), 3, ho);\n        var i = t.transform.centerPoint;\n        !function (t, e, i, o) {\n          mo(t, e - 1, i - 10, 2, 20, o), mo(t, e - 10, i - 1, 20, 2, o);\n        }(t, i.x, t.transform.height - i.y, po);\n      }(this), this.context.setDefault();\n    }, yo.prototype.renderLayer = function (t, e, i, o) {\n      i.isHidden(this.transform.zoom) || ("background" === i.type || "custom" === i.type || o.length) && (this.id = i.id, this.gpuTimingStart(i), vo[i.type](t, e, i, o, this.style.placement.variableOffsets), this.gpuTimingEnd());\n    }, yo.prototype.gpuTimingStart = function (t) {\n      if (this.options.gpuTiming) {\n        var e = this.context.extTimerQuery,\n            i = this.gpuTimers[t.id];\n        i || (i = this.gpuTimers[t.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: e.createQueryEXT()\n        }), i.calls++, e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query);\n      }\n    }, yo.prototype.gpuTimingEnd = function () {\n      if (this.options.gpuTiming) {\n        var t = this.context.extTimerQuery;\n        t.endQueryEXT(t.TIME_ELAPSED_EXT);\n      }\n    }, yo.prototype.collectGpuTimers = function () {\n      var t = this.gpuTimers;\n      return this.gpuTimers = {}, t;\n    }, yo.prototype.queryGpuTimers = function (t) {\n      var e = {};\n\n      for (var i in t) {\n        var o = t[i],\n            r = this.context.extTimerQuery,\n            a = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;\n        r.deleteQueryEXT(o.query), e[i] = a;\n      }\n\n      return e;\n    }, yo.prototype.translatePosMatrix = function (e, i, o, r, a) {\n      if (!o[0] && !o[1]) return e;\n      var n = a ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;\n\n      if (n) {\n        var s = Math.sin(n),\n            l = Math.cos(n);\n        o = [o[0] * l - o[1] * s, o[0] * s + o[1] * l];\n      }\n\n      var c = [a ? o[0] : pe(i, o[0], this.transform.zoom), a ? o[1] : pe(i, o[1], this.transform.zoom), 0],\n          u = new Float32Array(16);\n      return t.translate(u, e, c), u;\n    }, yo.prototype.saveTileTexture = function (t) {\n      var e = this._tileTextures[t.size[0]];\n      e ? e.push(t) : this._tileTextures[t.size[0]] = [t];\n    }, yo.prototype.getTileTexture = function (t) {\n      var e = this._tileTextures[t];\n      return e && e.length > 0 ? e.pop() : null;\n    }, yo.prototype.isPatternMissing = function (t) {\n      if (!t) return !1;\n      if (!t.from || !t.to) return !0;\n      var e = this.imageManager.getPattern(t.from.toString()),\n          i = this.imageManager.getPattern(t.to.toString());\n      return !e || !i;\n    }, yo.prototype.useProgram = function (t, e) {\n      this.cache = this.cache || {};\n      var i = "" + t + (e ? e.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");\n      return this.cache[i] || (this.cache[i] = new bi(this.context, t, vi[t], e, Ki[t], this._showOverdrawInspector)), this.cache[i];\n    }, yo.prototype.setCustomLayerDefaults = function () {\n      this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n    }, yo.prototype.setBaseState = function () {\n      var t = this.context.gl;\n      this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);\n    }, yo.prototype.initDebugOverlayCanvas = function () {\n      null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n    }, yo.prototype.destroy = function () {\n      this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();\n    };\n\n    var xo = function xo(t, e) {\n      this.points = t, this.planes = e;\n    };\n\n    xo.fromInvProjectionMatrix = function (e, i, o) {\n      var r = Math.pow(2, o),\n          a = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function (i) {\n        return t.transformMat4([], i, e);\n      }).map(function (e) {\n        return t.scale$1([], e, 1 / e[3] / i * r);\n      }),\n          n = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function (e) {\n        var i = t.sub([], a[e[0]], a[e[1]]),\n            o = t.sub([], a[e[2]], a[e[1]]),\n            r = t.normalize([], t.cross([], i, o)),\n            n = -t.dot(r, a[e[1]]);\n        return r.concat(n);\n      });\n      return new xo(a, n);\n    };\n\n    var bo = function bo(e, i) {\n      this.min = e, this.max = i, this.center = t.scale$2([], t.add([], this.min, this.max), .5);\n    };\n\n    bo.prototype.quadrant = function (e) {\n      for (var i = [e % 2 == 0, e < 2], o = t.clone$2(this.min), r = t.clone$2(this.max), a = 0; a < i.length; a++) {\n        o[a] = i[a] ? this.min[a] : this.center[a], r[a] = i[a] ? this.center[a] : this.max[a];\n      }\n\n      return r[2] = this.max[2], new bo(o, r);\n    }, bo.prototype.distanceX = function (t) {\n      return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n    }, bo.prototype.distanceY = function (t) {\n      return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n    }, bo.prototype.intersects = function (e) {\n      for (var i = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], o = !0, r = 0; r < e.planes.length; r++) {\n        for (var a = e.planes[r], n = 0, s = 0; s < i.length; s++) {\n          n += t.dot$1(a, i[s]) >= 0;\n        }\n\n        if (0 === n) return 0;\n        n !== i.length && (o = !1);\n      }\n\n      if (o) return 2;\n\n      for (var l = 0; l < 3; l++) {\n        for (var c = Number.MAX_VALUE, u = -Number.MAX_VALUE, h = 0; h < e.points.length; h++) {\n          var p = e.points[h][l] - this.min[l];\n          c = Math.min(c, p), u = Math.max(u, p);\n        }\n\n        if (u < 0 || c > this.max[l] - this.min[l]) return 0;\n      }\n\n      return 1;\n    };\n\n    var wo = function wo(t, e, i, o) {\n      if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");\n      this.top = t, this.bottom = e, this.left = i, this.right = o;\n    };\n\n    wo.prototype.interpolate = function (e, i, o) {\n      return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, o)), null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, o)), null != i.left && null != e.left && (this.left = t.number(e.left, i.left, o)), null != i.right && null != e.right && (this.right = t.number(e.right, i.right, o)), this;\n    }, wo.prototype.getCenter = function (e, i) {\n      var o = t.clamp((this.left + e - this.right) / 2, 0, e),\n          r = t.clamp((this.top + i - this.bottom) / 2, 0, i);\n      return new t.Point(o, r);\n    }, wo.prototype.equals = function (t) {\n      return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;\n    }, wo.prototype.clone = function () {\n      return new wo(this.top, this.bottom, this.left, this.right);\n    }, wo.prototype.toJSON = function () {\n      return {\n        top: this.top,\n        bottom: this.bottom,\n        left: this.left,\n        right: this.right\n      };\n    };\n\n    var To = function To(e, i, o, r, a) {\n      this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a || a, this._minZoom = e || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new wo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n    },\n        Eo = {\n      minZoom: {\n        configurable: !0\n      },\n      maxZoom: {\n        configurable: !0\n      },\n      minPitch: {\n        configurable: !0\n      },\n      maxPitch: {\n        configurable: !0\n      },\n      renderWorldCopies: {\n        configurable: !0\n      },\n      worldSize: {\n        configurable: !0\n      },\n      centerOffset: {\n        configurable: !0\n      },\n      size: {\n        configurable: !0\n      },\n      bearing: {\n        configurable: !0\n      },\n      pitch: {\n        configurable: !0\n      },\n      fov: {\n        configurable: !0\n      },\n      zoom: {\n        configurable: !0\n      },\n      center: {\n        configurable: !0\n      },\n      padding: {\n        configurable: !0\n      },\n      centerPoint: {\n        configurable: !0\n      },\n      unmodified: {\n        configurable: !0\n      },\n      point: {\n        configurable: !0\n      }\n    };\n\n    To.prototype.clone = function () {\n      var t = new To(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);\n      return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._calcMatrices(), t;\n    }, Eo.minZoom.get = function () {\n      return this._minZoom;\n    }, Eo.minZoom.set = function (t) {\n      this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));\n    }, Eo.maxZoom.get = function () {\n      return this._maxZoom;\n    }, Eo.maxZoom.set = function (t) {\n      this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));\n    }, Eo.minPitch.get = function () {\n      return this._minPitch;\n    }, Eo.minPitch.set = function (t) {\n      this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));\n    }, Eo.maxPitch.get = function () {\n      return this._maxPitch;\n    }, Eo.maxPitch.set = function (t) {\n      this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));\n    }, Eo.renderWorldCopies.get = function () {\n      return this._renderWorldCopies;\n    }, Eo.renderWorldCopies.set = function (t) {\n      void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t;\n    }, Eo.worldSize.get = function () {\n      return this.tileSize * this.scale;\n    }, Eo.centerOffset.get = function () {\n      return this.centerPoint._sub(this.size._div(2));\n    }, Eo.size.get = function () {\n      return new t.Point(this.width, this.height);\n    }, Eo.bearing.get = function () {\n      return -this.angle / Math.PI * 180;\n    }, Eo.bearing.set = function (e) {\n      var i = -t.wrap(e, -180, 180) * Math.PI / 180;\n      this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));\n    }, Eo.pitch.get = function () {\n      return this._pitch / Math.PI * 180;\n    }, Eo.pitch.set = function (e) {\n      var i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;\n      this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n    }, Eo.fov.get = function () {\n      return this._fov / Math.PI * 180;\n    }, Eo.fov.set = function (t) {\n      t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());\n    }, Eo.zoom.get = function () {\n      return this._zoom;\n    }, Eo.zoom.set = function (t) {\n      var e = Math.min(Math.max(t, this.minZoom), this.maxZoom);\n      this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom, this._constrain(), this._calcMatrices());\n    }, Eo.center.get = function () {\n      return this._center;\n    }, Eo.center.set = function (t) {\n      t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());\n    }, Eo.padding.get = function () {\n      return this._edgeInsets.toJSON();\n    }, Eo.padding.set = function (t) {\n      this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());\n    }, Eo.centerPoint.get = function () {\n      return this._edgeInsets.getCenter(this.width, this.height);\n    }, To.prototype.isPaddingEqual = function (t) {\n      return this._edgeInsets.equals(t);\n    }, To.prototype.interpolatePadding = function (t, e, i) {\n      this._unmodified = !1, this._edgeInsets.interpolate(t, e, i), this._constrain(), this._calcMatrices();\n    }, To.prototype.coveringZoomLevel = function (t) {\n      var e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));\n      return Math.max(0, e);\n    }, To.prototype.getVisibleUnwrappedCoordinates = function (e) {\n      var i = [new t.UnwrappedTileID(0, e)];\n      if (this._renderWorldCopies) for (var o = this.pointCoordinate(new t.Point(0, 0)), r = this.pointCoordinate(new t.Point(this.width, 0)), a = this.pointCoordinate(new t.Point(this.width, this.height)), n = this.pointCoordinate(new t.Point(0, this.height)), s = Math.floor(Math.min(o.x, r.x, a.x, n.x)), l = Math.floor(Math.max(o.x, r.x, a.x, n.x)), c = s - 1; c <= l + 1; c++) {\n        0 !== c && i.push(new t.UnwrappedTileID(c, e));\n      }\n      return i;\n    }, To.prototype.coveringTiles = function (e) {\n      var i = this.coveringZoomLevel(e),\n          o = i;\n      if (void 0 !== e.minzoom && i < e.minzoom) return [];\n      void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);\n      var r = t.MercatorCoordinate.fromLngLat(this.center),\n          a = Math.pow(2, i),\n          n = [a * r.x, a * r.y, 0],\n          s = xo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i),\n          l = e.minzoom || 0;\n      this.pitch <= 60 && this._edgeInsets.top < .1 && (l = i);\n\n      var c = function c(t) {\n        return {\n          aabb: new bo([t * a, 0, 0], [(t + 1) * a, a, 0]),\n          zoom: 0,\n          x: 0,\n          y: 0,\n          wrap: t,\n          fullyVisible: !1\n        };\n      },\n          u = [],\n          h = [],\n          p = i,\n          d = e.reparseOverscaled ? o : i;\n\n      if (this._renderWorldCopies) for (var _ = 1; _ <= 3; _++) {\n        u.push(c(-_)), u.push(c(_));\n      }\n\n      for (u.push(c(0)); u.length > 0;) {\n        var f = u.pop(),\n            m = f.x,\n            g = f.y,\n            v = f.fullyVisible;\n\n        if (!v) {\n          var y = f.aabb.intersects(s);\n          if (0 === y) continue;\n          v = 2 === y;\n        }\n\n        var x = f.aabb.distanceX(n),\n            b = f.aabb.distanceY(n),\n            w = Math.max(Math.abs(x), Math.abs(b));\n        if (f.zoom === p || w > 3 + (1 << p - f.zoom) - 2 && f.zoom >= l) h.push({\n          tileID: new t.OverscaledTileID(f.zoom === p ? d : f.zoom, f.wrap, f.zoom, m, g),\n          distanceSq: t.sqrLen([n[0] - .5 - m, n[1] - .5 - g])\n        });else for (var T = 0; T < 4; T++) {\n          var E = (m << 1) + T % 2,\n              I = (g << 1) + (T >> 1);\n          u.push({\n            aabb: f.aabb.quadrant(T),\n            zoom: f.zoom + 1,\n            x: E,\n            y: I,\n            wrap: f.wrap,\n            fullyVisible: v\n          });\n        }\n      }\n\n      return h.sort(function (t, e) {\n        return t.distanceSq - e.distanceSq;\n      }).map(function (t) {\n        return t.tileID;\n      });\n    }, To.prototype.resize = function (t, e) {\n      this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices();\n    }, Eo.unmodified.get = function () {\n      return this._unmodified;\n    }, To.prototype.zoomScale = function (t) {\n      return Math.pow(2, t);\n    }, To.prototype.scaleZoom = function (t) {\n      return Math.log(t) / Math.LN2;\n    }, To.prototype.project = function (e) {\n      var i = t.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude);\n      return new t.Point(t.mercatorXfromLng(e.lng) * this.worldSize, t.mercatorYfromLat(i) * this.worldSize);\n    }, To.prototype.unproject = function (e) {\n      return new t.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat();\n    }, Eo.point.get = function () {\n      return this.project(this.center);\n    }, To.prototype.setLocationAtPoint = function (e, i) {\n      var o = this.pointCoordinate(i),\n          r = this.pointCoordinate(this.centerPoint),\n          a = this.locationCoordinate(e),\n          n = new t.MercatorCoordinate(a.x - (o.x - r.x), a.y - (o.y - r.y));\n      this.center = this.coordinateLocation(n), this._renderWorldCopies && (this.center = this.center.wrap());\n    }, To.prototype.locationPoint = function (t) {\n      return this.coordinatePoint(this.locationCoordinate(t));\n    }, To.prototype.pointLocation = function (t) {\n      return this.coordinateLocation(this.pointCoordinate(t));\n    }, To.prototype.locationCoordinate = function (e) {\n      return t.MercatorCoordinate.fromLngLat(e);\n    }, To.prototype.coordinateLocation = function (t) {\n      return t.toLngLat();\n    }, To.prototype.pointCoordinate = function (e) {\n      var i = [e.x, e.y, 0, 1],\n          o = [e.x, e.y, 1, 1];\n      t.transformMat4(i, i, this.pixelMatrixInverse), t.transformMat4(o, o, this.pixelMatrixInverse);\n      var r = i[3],\n          a = o[3],\n          n = i[1] / r,\n          s = o[1] / a,\n          l = i[2] / r,\n          c = o[2] / a,\n          u = l === c ? 0 : (0 - l) / (c - l);\n      return new t.MercatorCoordinate(t.number(i[0] / r, o[0] / a, u) / this.worldSize, t.number(n, s, u) / this.worldSize);\n    }, To.prototype.coordinatePoint = function (e) {\n      var i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n      return t.transformMat4(i, i, this.pixelMatrix), new t.Point(i[0] / i[3], i[1] / i[3]);\n    }, To.prototype.getBounds = function () {\n      return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));\n    }, To.prototype.getMaxBounds = function () {\n      return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;\n    }, To.prototype.setMaxBounds = function (t) {\n      t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);\n    }, To.prototype.calculatePosMatrix = function (e, i) {\n      void 0 === i && (i = !1);\n      var o = e.key,\n          r = i ? this._alignedPosMatrixCache : this._posMatrixCache;\n      if (r[o]) return r[o];\n      var a = e.canonical,\n          n = this.worldSize / this.zoomScale(a.z),\n          s = a.x + Math.pow(2, a.z) * e.wrap,\n          l = t.identity(new Float64Array(16));\n      return t.translate(l, l, [s * n, a.y * n, 0]), t.scale(l, l, [n / t.EXTENT, n / t.EXTENT, 1]), t.multiply(l, i ? this.alignedProjMatrix : this.projMatrix, l), r[o] = new Float32Array(l), r[o];\n    }, To.prototype.customLayerMatrix = function () {\n      return this.mercatorMatrix.slice();\n    }, To.prototype._constrain = function () {\n      if (this.center && this.width && this.height && !this._constraining) {\n        this._constraining = !0;\n        var e,\n            i,\n            o,\n            r,\n            a = -90,\n            n = 90,\n            s = -180,\n            l = 180,\n            c = this.size,\n            u = this._unmodified;\n\n        if (this.latRange) {\n          var h = this.latRange;\n          a = t.mercatorYfromLat(h[1]) * this.worldSize, e = (n = t.mercatorYfromLat(h[0]) * this.worldSize) - a < c.y ? c.y / (n - a) : 0;\n        }\n\n        if (this.lngRange) {\n          var p = this.lngRange;\n          s = t.mercatorXfromLng(p[0]) * this.worldSize, i = (l = t.mercatorXfromLng(p[1]) * this.worldSize) - s < c.x ? c.x / (l - s) : 0;\n        }\n\n        var d = this.point,\n            _ = Math.max(i || 0, e || 0);\n\n        if (_) return this.center = this.unproject(new t.Point(i ? (l + s) / 2 : d.x, e ? (n + a) / 2 : d.y)), this.zoom += this.scaleZoom(_), this._unmodified = u, void (this._constraining = !1);\n\n        if (this.latRange) {\n          var f = d.y,\n              m = c.y / 2;\n          f - m < a && (r = a + m), f + m > n && (r = n - m);\n        }\n\n        if (this.lngRange) {\n          var g = d.x,\n              v = c.x / 2;\n          g - v < s && (o = s + v), g + v > l && (o = l - v);\n        }\n\n        void 0 === o && void 0 === r || (this.center = this.unproject(new t.Point(void 0 !== o ? o : d.x, void 0 !== r ? r : d.y))), this._unmodified = u, this._constraining = !1;\n      }\n    }, To.prototype._calcMatrices = function () {\n      if (this.height) {\n        var e = this.centerOffset;\n        this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height;\n        var i = Math.PI / 2 + this._pitch,\n            o = this._fov * (.5 + e.y / this.height),\n            r = Math.sin(o) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i - o, .01, Math.PI - .01)),\n            a = this.point,\n            n = a.x,\n            s = a.y,\n            l = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * r + this.cameraToCenterDistance),\n            c = this.height / 50,\n            u = new Float64Array(16);\n        t.perspective(u, this._fov, this.width / this.height, c, l), u[8] = 2 * -e.x / this.width, u[9] = 2 * e.y / this.height, t.scale(u, u, [1, -1, 1]), t.translate(u, u, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u, u, this._pitch), t.rotateZ(u, u, this.angle), t.translate(u, u, [-n, -s, 0]), this.mercatorMatrix = t.scale([], u, [this.worldSize, this.worldSize, this.worldSize]), t.scale(u, u, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = u, this.invProjMatrix = t.invert([], this.projMatrix);\n\n        var h = this.width % 2 / 2,\n            p = this.height % 2 / 2,\n            d = Math.cos(this.angle),\n            _ = Math.sin(this.angle),\n            f = n - Math.round(n) + d * h + _ * p,\n            m = s - Math.round(s) + d * p + _ * h,\n            g = new Float64Array(u);\n\n        if (t.translate(g, g, [f > .5 ? f - 1 : f, m > .5 ? m - 1 : m, 0]), this.alignedProjMatrix = g, u = t.create(), t.scale(u, u, [this.width / 2, -this.height / 2, 1]), t.translate(u, u, [1, -1, 0]), this.labelPlaneMatrix = u, u = t.create(), t.scale(u, u, [1, -1, 1]), t.translate(u, u, [-1, -1, 0]), t.scale(u, u, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(u = t.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix");\n        this.pixelMatrixInverse = u, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n      }\n    }, To.prototype.maxPitchScaleFactor = function () {\n      if (!this.pixelMatrixInverse) return 1;\n      var e = this.pointCoordinate(new t.Point(0, 0)),\n          i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n      return t.transformMat4(i, i, this.pixelMatrix)[3] / this.cameraToCenterDistance;\n    }, To.prototype.getCameraPoint = function () {\n      var e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n      return this.centerPoint.add(new t.Point(0, e));\n    }, To.prototype.getCameraQueryGeometry = function (e) {\n      var i = this.getCameraPoint();\n      if (1 === e.length) return [e[0], i];\n\n      for (var o = i.x, r = i.y, a = i.x, n = i.y, s = 0, l = e; s < l.length; s += 1) {\n        var c = l[s];\n        o = Math.min(o, c.x), r = Math.min(r, c.y), a = Math.max(a, c.x), n = Math.max(n, c.y);\n      }\n\n      return [new t.Point(o, r), new t.Point(a, r), new t.Point(a, n), new t.Point(o, n), new t.Point(o, r)];\n    }, Object.defineProperties(To.prototype, Eo);\n\n    var Io = function Io(e) {\n      var i, o, r, _a3;\n\n      this._hashName = e && encodeURIComponent(e), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i = this._updateHashUnthrottled.bind(this), o = !1, r = null, _a3 = function a() {\n        r = null, o && (i(), r = setTimeout(_a3, 300), o = !1);\n      }, function () {\n        return o = !0, r || _a3(), r;\n      });\n    };\n\n    Io.prototype.addTo = function (e) {\n      return this._map = e, t.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;\n    }, Io.prototype.remove = function () {\n      return t.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;\n    }, Io.prototype.getHashString = function (e) {\n      var i = this._map.getCenter(),\n          o = Math.round(100 * this._map.getZoom()) / 100,\n          r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n          a = Math.pow(10, r),\n          n = Math.round(i.lng * a) / a,\n          s = Math.round(i.lat * a) / a,\n          l = this._map.getBearing(),\n          c = this._map.getPitch(),\n          u = "";\n\n      if (u += e ? "/" + n + "/" + s + "/" + o : o + "/" + s + "/" + n, (l || c) && (u += "/" + Math.round(10 * l) / 10), c && (u += "/" + Math.round(c)), this._hashName) {\n        var h = this._hashName,\n            p = !1,\n            d = t.window.location.hash.slice(1).split("&").map(function (t) {\n          var e = t.split("=")[0];\n          return e === h ? (p = !0, e + "=" + u) : t;\n        }).filter(function (t) {\n          return t;\n        });\n        return p || d.push(h + "=" + u), "#" + d.join("&");\n      }\n\n      return "#" + u;\n    }, Io.prototype._getCurrentHash = function () {\n      var e,\n          i = this,\n          o = t.window.location.hash.replace("#", "");\n      return this._hashName ? (o.split("&").map(function (t) {\n        return t.split("=");\n      }).forEach(function (t) {\n        t[0] === i._hashName && (e = t);\n      }), (e && e[1] || "").split("/")) : o.split("/");\n    }, Io.prototype._onHashChange = function () {\n      var t = this._getCurrentHash();\n\n      if (t.length >= 3 && !t.some(function (t) {\n        return isNaN(t);\n      })) {\n        var e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing();\n        return this._map.jumpTo({\n          center: [+t[2], +t[1]],\n          zoom: +t[0],\n          bearing: e,\n          pitch: +(t[4] || 0)\n        }), !0;\n      }\n\n      return !1;\n    }, Io.prototype._updateHashUnthrottled = function () {\n      var e = t.window.location.href.replace(/(#.+)?$/, this.getHashString());\n\n      try {\n        t.window.history.replaceState(t.window.history.state, null, e);\n      } catch (t) {}\n    };\n\n    var Po = {\n      linearity: .3,\n      easing: t.bezier(0, 0, .3, 1)\n    },\n        So = t.extend({\n      deceleration: 2500,\n      maxSpeed: 1400\n    }, Po),\n        Co = t.extend({\n      deceleration: 20,\n      maxSpeed: 1400\n    }, Po),\n        zo = t.extend({\n      deceleration: 1e3,\n      maxSpeed: 360\n    }, Po),\n        Do = t.extend({\n      deceleration: 1e3,\n      maxSpeed: 90\n    }, Po),\n        Ao = function Ao(t) {\n      this._map = t, this.clear();\n    };\n\n    function Mo(t, e) {\n      (!t.duration || t.duration < e.duration) && (t.duration = e.duration, t.easing = e.easing);\n    }\n\n    function Lo(e, i, o) {\n      var r = o.maxSpeed,\n          a = o.linearity,\n          n = o.deceleration,\n          s = t.clamp(e * a / (i / 1e3), -r, r),\n          l = Math.abs(s) / (n * a);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: s * (l / 2)\n      };\n    }\n\n    Ao.prototype.clear = function () {\n      this._inertiaBuffer = [];\n    }, Ao.prototype.record = function (e) {\n      this._drainInertiaBuffer(), this._inertiaBuffer.push({\n        time: t.browser.now(),\n        settings: e\n      });\n    }, Ao.prototype._drainInertiaBuffer = function () {\n      for (var e = this._inertiaBuffer, i = t.browser.now(); e.length > 0 && i - e[0].time > 160;) {\n        e.shift();\n      }\n    }, Ao.prototype._onMoveEnd = function (e) {\n      if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {\n        for (var i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new t.Point(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        }, o = 0, r = this._inertiaBuffer; o < r.length; o += 1) {\n          var a = r[o].settings;\n          i.zoom += a.zoomDelta || 0, i.bearing += a.bearingDelta || 0, i.pitch += a.pitchDelta || 0, a.panDelta && i.pan._add(a.panDelta), a.around && (i.around = a.around), a.pinchAround && (i.pinchAround = a.pinchAround);\n        }\n\n        var n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n            s = {};\n\n        if (i.pan.mag()) {\n          var l = Lo(i.pan.mag(), n, t.extend({}, So, e || {}));\n          s.offset = i.pan.mult(l.amount / i.pan.mag()), s.center = this._map.transform.center, Mo(s, l);\n        }\n\n        if (i.zoom) {\n          var c = Lo(i.zoom, n, Co);\n          s.zoom = this._map.transform.zoom + c.amount, Mo(s, c);\n        }\n\n        if (i.bearing) {\n          var u = Lo(i.bearing, n, zo);\n          s.bearing = this._map.transform.bearing + t.clamp(u.amount, -179, 179), Mo(s, u);\n        }\n\n        if (i.pitch) {\n          var h = Lo(i.pitch, n, Do);\n          s.pitch = this._map.transform.pitch + h.amount, Mo(s, h);\n        }\n\n        if (s.zoom || s.bearing) {\n          var p = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          s.around = p ? this._map.unproject(p) : this._map.getCenter();\n        }\n\n        return this.clear(), t.extend(s, {\n          noMoveStart: !0\n        });\n      }\n    };\n\n    var Ro = function (e) {\n      function o(o, r, a, n) {\n        void 0 === n && (n = {});\n        var s = i.mousePos(r.getCanvasContainer(), a),\n            l = r.unproject(s);\n        e.call(this, o, t.extend({\n          point: s,\n          lngLat: l,\n          originalEvent: a\n        }, n)), this._defaultPrevented = !1, this.target = r;\n      }\n\n      e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o;\n      var r = {\n        defaultPrevented: {\n          configurable: !0\n        }\n      };\n      return o.prototype.preventDefault = function () {\n        this._defaultPrevented = !0;\n      }, r.defaultPrevented.get = function () {\n        return this._defaultPrevented;\n      }, Object.defineProperties(o.prototype, r), o;\n    }(t.Event),\n        ko = function (e) {\n      function o(o, r, a) {\n        var n = "touchend" === o ? a.changedTouches : a.touches,\n            s = i.touchPos(r.getCanvasContainer(), n),\n            l = s.map(function (t) {\n          return r.unproject(t);\n        }),\n            c = s.reduce(function (t, e, i, o) {\n          return t.add(e.div(o.length));\n        }, new t.Point(0, 0)),\n            u = r.unproject(c);\n        e.call(this, o, {\n          points: s,\n          point: c,\n          lngLats: l,\n          lngLat: u,\n          originalEvent: a\n        }), this._defaultPrevented = !1;\n      }\n\n      e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o;\n      var r = {\n        defaultPrevented: {\n          configurable: !0\n        }\n      };\n      return o.prototype.preventDefault = function () {\n        this._defaultPrevented = !0;\n      }, r.defaultPrevented.get = function () {\n        return this._defaultPrevented;\n      }, Object.defineProperties(o.prototype, r), o;\n    }(t.Event),\n        Bo = function (t) {\n      function e(e, i, o) {\n        t.call(this, e, {\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var i = {\n        defaultPrevented: {\n          configurable: !0\n        }\n      };\n      return e.prototype.preventDefault = function () {\n        this._defaultPrevented = !0;\n      }, i.defaultPrevented.get = function () {\n        return this._defaultPrevented;\n      }, Object.defineProperties(e.prototype, i), e;\n    }(t.Event),\n        Oo = function Oo(t, e) {\n      this._map = t, this._clickTolerance = e.clickTolerance;\n    };\n\n    Oo.prototype.reset = function () {\n      delete this._mousedownPos;\n    }, Oo.prototype.wheel = function (t) {\n      return this._firePreventable(new Bo(t.type, this._map, t));\n    }, Oo.prototype.mousedown = function (t, e) {\n      return this._mousedownPos = e, this._firePreventable(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseup = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.click = function (t, e) {\n      this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.dblclick = function (t) {\n      return this._firePreventable(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseover = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseout = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.touchstart = function (t) {\n      return this._firePreventable(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchmove = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchend = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchcancel = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype._firePreventable = function (t) {\n      if (this._map.fire(t), t.defaultPrevented) return {};\n    }, Oo.prototype.isEnabled = function () {\n      return !0;\n    }, Oo.prototype.isActive = function () {\n      return !1;\n    }, Oo.prototype.enable = function () {}, Oo.prototype.disable = function () {};\n\n    var Fo = function Fo(t) {\n      this._map = t;\n    };\n\n    Fo.prototype.reset = function () {\n      this._delayContextMenu = !1, delete this._contextMenuEvent;\n    }, Fo.prototype.mousemove = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Fo.prototype.mousedown = function () {\n      this._delayContextMenu = !0;\n    }, Fo.prototype.mouseup = function () {\n      this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ro("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n    }, Fo.prototype.contextmenu = function (t) {\n      this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Ro(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();\n    }, Fo.prototype.isEnabled = function () {\n      return !0;\n    }, Fo.prototype.isActive = function () {\n      return !1;\n    }, Fo.prototype.enable = function () {}, Fo.prototype.disable = function () {};\n\n    var Uo = function Uo(t, e) {\n      this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1;\n    };\n\n    function No(t, e) {\n      for (var i = {}, o = 0; o < t.length; o++) {\n        i[t[o].identifier] = e[o];\n      }\n\n      return i;\n    }\n\n    Uo.prototype.isEnabled = function () {\n      return !!this._enabled;\n    }, Uo.prototype.isActive = function () {\n      return !!this._active;\n    }, Uo.prototype.enable = function () {\n      this.isEnabled() || (this._enabled = !0);\n    }, Uo.prototype.disable = function () {\n      this.isEnabled() && (this._enabled = !1);\n    }, Uo.prototype.mousedown = function (t, e) {\n      this.isEnabled() && t.shiftKey && 0 === t.button && (i.disableDrag(), this._startPos = this._lastPos = e, this._active = !0);\n    }, Uo.prototype.mousemoveWindow = function (t, e) {\n      if (this._active) {\n        var o = e;\n\n        if (!(this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance)) {\n          var r = this._startPos;\n          this._lastPos = o, this._box || (this._box = i.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));\n          var a = Math.min(r.x, o.x),\n              n = Math.max(r.x, o.x),\n              s = Math.min(r.y, o.y),\n              l = Math.max(r.y, o.y);\n          i.setTransform(this._box, "translate(" + a + "px," + s + "px)"), this._box.style.width = n - a + "px", this._box.style.height = l - s + "px";\n        }\n      }\n    }, Uo.prototype.mouseupWindow = function (e, o) {\n      var r = this;\n\n      if (this._active && 0 === e.button) {\n        var a = this._startPos,\n            n = o;\n        if (this.reset(), i.suppressClick(), a.x !== n.x || a.y !== n.y) return this._map.fire(new t.Event("boxzoomend", {\n          originalEvent: e\n        })), {\n          cameraAnimation: function cameraAnimation(t) {\n            return t.fitScreenCoordinates(a, n, r._map.getBearing(), {\n              linear: !0\n            });\n          }\n        };\n\n        this._fireEvent("boxzoomcancel", e);\n      }\n    }, Uo.prototype.keydown = function (t) {\n      this._active && 27 === t.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t));\n    }, Uo.prototype.reset = function () {\n      this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos;\n    }, Uo.prototype._fireEvent = function (e, i) {\n      return this._map.fire(new t.Event(e, {\n        originalEvent: i\n      }));\n    };\n\n    var Zo = function Zo(t) {\n      this.reset(), this.numTouches = t.numTouches;\n    };\n\n    Zo.prototype.reset = function () {\n      delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;\n    }, Zo.prototype.touchstart = function (e, i, o) {\n      (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function (e) {\n        for (var i = new t.Point(0, 0), o = 0, r = e; o < r.length; o += 1) {\n          i._add(r[o]);\n        }\n\n        return i.div(e.length);\n      }(i), this.touches = No(o, i)));\n    }, Zo.prototype.touchmove = function (t, e, i) {\n      if (!this.aborted && this.centroid) {\n        var o = No(i, e);\n\n        for (var r in this.touches) {\n          var a = o[r];\n          (!a || a.dist(this.touches[r]) > 30) && (this.aborted = !0);\n        }\n      }\n    }, Zo.prototype.touchend = function (t, e, i) {\n      if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n        var o = !this.aborted && this.centroid;\n        if (this.reset(), o) return o;\n      }\n    };\n\n    var qo = function qo(t) {\n      this.singleTap = new Zo(t), this.numTaps = t.numTaps, this.reset();\n    };\n\n    qo.prototype.reset = function () {\n      this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();\n    }, qo.prototype.touchstart = function (t, e, i) {\n      this.singleTap.touchstart(t, e, i);\n    }, qo.prototype.touchmove = function (t, e, i) {\n      this.singleTap.touchmove(t, e, i);\n    }, qo.prototype.touchend = function (t, e, i) {\n      var o = this.singleTap.touchend(t, e, i);\n\n      if (o) {\n        var r = t.timeStamp - this.lastTime < 500,\n            a = !this.lastTap || this.lastTap.dist(o) < 30;\n        if (r && a || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n      }\n    };\n\n    var jo = function jo() {\n      this._zoomIn = new qo({\n        numTouches: 1,\n        numTaps: 2\n      }), this._zoomOut = new qo({\n        numTouches: 2,\n        numTaps: 1\n      }), this.reset();\n    };\n\n    jo.prototype.reset = function () {\n      this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n    }, jo.prototype.touchstart = function (t, e, i) {\n      this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i);\n    }, jo.prototype.touchmove = function (t, e, i) {\n      this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i);\n    }, jo.prototype.touchend = function (t, e, i) {\n      var o = this,\n          r = this._zoomIn.touchend(t, e, i),\n          a = this._zoomOut.touchend(t, e, i);\n\n      return r ? (this._active = !0, t.preventDefault(), setTimeout(function () {\n        return o.reset();\n      }, 0), {\n        cameraAnimation: function cameraAnimation(e) {\n          return e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() + 1,\n            around: e.unproject(r)\n          }, {\n            originalEvent: t\n          });\n        }\n      }) : a ? (this._active = !0, t.preventDefault(), setTimeout(function () {\n        return o.reset();\n      }, 0), {\n        cameraAnimation: function cameraAnimation(e) {\n          return e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() - 1,\n            around: e.unproject(a)\n          }, {\n            originalEvent: t\n          });\n        }\n      }) : void 0;\n    }, jo.prototype.touchcancel = function () {\n      this.reset();\n    }, jo.prototype.enable = function () {\n      this._enabled = !0;\n    }, jo.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, jo.prototype.isEnabled = function () {\n      return this._enabled;\n    }, jo.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var Vo = {\n      0: 1,\n      2: 2\n    },\n        Go = function Go(t) {\n      this.reset(), this._clickTolerance = t.clickTolerance || 1;\n    };\n\n    Go.prototype.reset = function () {\n      this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;\n    }, Go.prototype._correctButton = function (t, e) {\n      return !1;\n    }, Go.prototype._move = function (t, e) {\n      return {};\n    }, Go.prototype.mousedown = function (t, e) {\n      if (!this._lastPoint) {\n        var o = i.mouseButton(t);\n        this._correctButton(t, o) && (this._lastPoint = e, this._eventButton = o);\n      }\n    }, Go.prototype.mousemoveWindow = function (t, e) {\n      var i = this._lastPoint;\n      if (i) if (t.preventDefault(), function (t, e) {\n        var i = Vo[e];\n        return void 0 === t.buttons || (t.buttons & i) !== i;\n      }(t, this._eventButton)) this.reset();else if (this._moved || !(e.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e, this._move(i, e);\n    }, Go.prototype.mouseupWindow = function (t) {\n      this._lastPoint && i.mouseButton(t) === this._eventButton && (this._moved && i.suppressClick(), this.reset());\n    }, Go.prototype.enable = function () {\n      this._enabled = !0;\n    }, Go.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Go.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Go.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var Wo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.mousedown = function (e, i) {\n        t.prototype.mousedown.call(this, e, i), this._lastPoint && (this._active = !0);\n      }, e.prototype._correctButton = function (t, e) {\n        return 0 === e && !t.ctrlKey;\n      }, e.prototype._move = function (t, e) {\n        return {\n          around: e,\n          panDelta: e.sub(t)\n        };\n      }, e;\n    }(Go),\n        Xo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) {\n        return 0 === e && t.ctrlKey || 2 === e;\n      }, e.prototype._move = function (t, e) {\n        var i = .8 * (e.x - t.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }, e.prototype.contextmenu = function (t) {\n        t.preventDefault();\n      }, e;\n    }(Go),\n        Ho = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) {\n        return 0 === e && t.ctrlKey || 2 === e;\n      }, e.prototype._move = function (t, e) {\n        var i = -.5 * (e.y - t.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }, e.prototype.contextmenu = function (t) {\n        t.preventDefault();\n      }, e;\n    }(Go),\n        Ko = function Ko(t) {\n      this._minTouches = 1, this._clickTolerance = t.clickTolerance || 1, this.reset();\n    };\n\n    Ko.prototype.reset = function () {\n      this._active = !1, this._touches = {}, this._sum = new t.Point(0, 0);\n    }, Ko.prototype.touchstart = function (t, e, i) {\n      return this._calculateTransform(t, e, i);\n    }, Ko.prototype.touchmove = function (t, e, i) {\n      if (this._active && !(i.length < this._minTouches)) return t.preventDefault(), this._calculateTransform(t, e, i);\n    }, Ko.prototype.touchend = function (t, e, i) {\n      this._calculateTransform(t, e, i), this._active && i.length < this._minTouches && this.reset();\n    }, Ko.prototype.touchcancel = function () {\n      this.reset();\n    }, Ko.prototype._calculateTransform = function (e, i, o) {\n      o.length > 0 && (this._active = !0);\n      var r = No(o, i),\n          a = new t.Point(0, 0),\n          n = new t.Point(0, 0),\n          s = 0;\n\n      for (var l in r) {\n        var c = r[l],\n            u = this._touches[l];\n        u && (a._add(c), n._add(c.sub(u)), s++, r[l] = c);\n      }\n\n      if (this._touches = r, !(s < this._minTouches) && n.mag()) {\n        var h = n.div(s);\n        if (this._sum._add(h), !(this._sum.mag() < this._clickTolerance)) return {\n          around: a.div(s),\n          panDelta: h\n        };\n      }\n    }, Ko.prototype.enable = function () {\n      this._enabled = !0;\n    }, Ko.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Ko.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Ko.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var Yo = function Yo() {\n      this.reset();\n    };\n\n    function Jo(t, e, i) {\n      for (var o = 0; o < t.length; o++) {\n        if (t[o].identifier === i) return e[o];\n      }\n    }\n\n    function Qo(t, e) {\n      return Math.log(t / e) / Math.LN2;\n    }\n\n    Yo.prototype.reset = function () {\n      this._active = !1, delete this._firstTwoTouches;\n    }, Yo.prototype._start = function (t) {}, Yo.prototype._move = function (t, e, i) {\n      return {};\n    }, Yo.prototype.touchstart = function (t, e, i) {\n      this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([e[0], e[1]]));\n    }, Yo.prototype.touchmove = function (t, e, i) {\n      if (this._firstTwoTouches) {\n        t.preventDefault();\n        var o = this._firstTwoTouches,\n            r = o[1],\n            a = Jo(i, e, o[0]),\n            n = Jo(i, e, r);\n\n        if (a && n) {\n          var s = this._aroundCenter ? null : a.add(n).div(2);\n          return this._move([a, n], s, t);\n        }\n      }\n    }, Yo.prototype.touchend = function (t, e, o) {\n      if (this._firstTwoTouches) {\n        var r = this._firstTwoTouches,\n            a = r[1],\n            n = Jo(o, e, r[0]),\n            s = Jo(o, e, a);\n        n && s || (this._active && i.suppressClick(), this.reset());\n      }\n    }, Yo.prototype.touchcancel = function () {\n      this.reset();\n    }, Yo.prototype.enable = function (t) {\n      this._enabled = !0, this._aroundCenter = !!t && "center" === t.around;\n    }, Yo.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Yo.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Yo.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var $o = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), delete this._distance, delete this._startDistance;\n      }, e.prototype._start = function (t) {\n        this._startDistance = this._distance = t[0].dist(t[1]);\n      }, e.prototype._move = function (t, e) {\n        var i = this._distance;\n        if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Qo(this._distance, i),\n          pinchAround: e\n        };\n      }, e;\n    }(Yo);\n\n    function tr(t, e) {\n      return 180 * t.angleWith(e) / Math.PI;\n    }\n\n    var er = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;\n      }, e.prototype._start = function (t) {\n        this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);\n      }, e.prototype._move = function (t, e) {\n        var i = this._vector;\n        if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {\n          bearingDelta: tr(this._vector, i),\n          pinchAround: e\n        };\n      }, e.prototype._isBelowThreshold = function (t) {\n        this._minDiameter = Math.min(this._minDiameter, t.mag());\n        var e = 25 / (Math.PI * this._minDiameter) * 360,\n            i = tr(t, this._startVector);\n        return Math.abs(i) < e;\n      }, e;\n    }(Yo);\n\n    function ir(t) {\n      return Math.abs(t.y) > Math.abs(t.x);\n    }\n\n    var or = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;\n      }, e.prototype._start = function (t) {\n        this._lastPoints = t, ir(t[0].sub(t[1])) && (this._valid = !1);\n      }, e.prototype._move = function (t, e, i) {\n        var o = t[0].sub(this._lastPoints[0]),\n            r = t[1].sub(this._lastPoints[1]);\n        if (this._valid = this.gestureBeginsVertically(o, r, i.timeStamp), this._valid) return this._lastPoints = t, this._active = !0, {\n          pitchDelta: (o.y + r.y) / 2 * -.5\n        };\n      }, e.prototype.gestureBeginsVertically = function (t, e, i) {\n        if (void 0 !== this._valid) return this._valid;\n        var o = t.mag() >= 2,\n            r = e.mag() >= 2;\n\n        if (o || r) {\n          if (!o || !r) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n          var a = t.y > 0 == e.y > 0;\n          return ir(t) && ir(e) && a;\n        }\n      }, e;\n    }(Yo),\n        rr = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    },\n        ar = function ar() {\n      var t = rr;\n      this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;\n    };\n\n    function nr(t) {\n      return t * (2 - t);\n    }\n\n    ar.prototype.reset = function () {\n      this._active = !1;\n    }, ar.prototype.keydown = function (t) {\n      var e = this;\n\n      if (!(t.altKey || t.ctrlKey || t.metaKey)) {\n        var i = 0,\n            o = 0,\n            r = 0,\n            a = 0,\n            n = 0;\n\n        switch (t.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            i = 1;\n            break;\n\n          case 189:\n          case 109:\n          case 173:\n            i = -1;\n            break;\n\n          case 37:\n            t.shiftKey ? o = -1 : (t.preventDefault(), a = -1);\n            break;\n\n          case 39:\n            t.shiftKey ? o = 1 : (t.preventDefault(), a = 1);\n            break;\n\n          case 38:\n            t.shiftKey ? r = 1 : (t.preventDefault(), n = -1);\n            break;\n\n          case 40:\n            t.shiftKey ? r = -1 : (t.preventDefault(), n = 1);\n            break;\n\n          default:\n            return;\n        }\n\n        return this._rotationDisabled && (o = 0, r = 0), {\n          cameraAnimation: function cameraAnimation(s) {\n            var l = s.getZoom();\n            s.easeTo({\n              duration: 300,\n              easeId: "keyboardHandler",\n              easing: nr,\n              zoom: i ? Math.round(l) + i * (t.shiftKey ? 2 : 1) : l,\n              bearing: s.getBearing() + o * e._bearingStep,\n              pitch: s.getPitch() + r * e._pitchStep,\n              offset: [-a * e._panStep, -n * e._panStep],\n              center: s.getCenter()\n            }, {\n              originalEvent: t\n            });\n          }\n        };\n      }\n    }, ar.prototype.enable = function () {\n      this._enabled = !0;\n    }, ar.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, ar.prototype.isEnabled = function () {\n      return this._enabled;\n    }, ar.prototype.isActive = function () {\n      return this._active;\n    }, ar.prototype.disableRotation = function () {\n      this._rotationDisabled = !0;\n    }, ar.prototype.enableRotation = function () {\n      this._rotationDisabled = !1;\n    };\n\n    var sr = function sr(e, i) {\n      this._map = e, this._el = e.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this);\n    };\n\n    sr.prototype.setZoomRate = function (t) {\n      this._defaultZoomRate = t;\n    }, sr.prototype.setWheelZoomRate = function (t) {\n      this._wheelZoomRate = t;\n    }, sr.prototype.isEnabled = function () {\n      return !!this._enabled;\n    }, sr.prototype.isActive = function () {\n      return !!this._active || void 0 !== this._finishTimeout;\n    }, sr.prototype.isZooming = function () {\n      return !!this._zooming;\n    }, sr.prototype.enable = function (t) {\n      this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && "center" === t.around);\n    }, sr.prototype.disable = function () {\n      this.isEnabled() && (this._enabled = !1);\n    }, sr.prototype.wheel = function (e) {\n      if (this.isEnabled()) {\n        var i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY,\n            o = t.browser.now(),\n            r = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault();\n      }\n    }, sr.prototype._onTimeout = function (t) {\n      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);\n    }, sr.prototype._start = function (e) {\n      if (this._delta) {\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        var o = i.mousePos(this._el, e);\n        this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n    }, sr.prototype.renderFrame = function () {\n      var e = this;\n\n      if (this._frameId && (this._frameId = null, this.isActive())) {\n        var i = this._map.transform;\n\n        if (0 !== this._delta) {\n          var o = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate,\n              r = 2 / (1 + Math.exp(-Math.abs(this._delta * o)));\n          this._delta < 0 && 0 !== r && (r = 1 / r);\n          var a = "number" == typeof this._targetZoom ? i.zoomScale(this._targetZoom) : i.scale;\n          this._targetZoom = Math.min(i.maxZoom, Math.max(i.minZoom, i.scaleZoom(a * r))), "wheel" === this._type && (this._startZoom = i.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;\n        }\n\n        var n,\n            s = "number" == typeof this._targetZoom ? this._targetZoom : i.zoom,\n            l = this._startZoom,\n            c = this._easing,\n            u = !1;\n\n        if ("wheel" === this._type && l && c) {\n          var h = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1),\n              p = c(h);\n          n = t.number(l, s, p), h < 1 ? this._frameId || (this._frameId = !0) : u = !0;\n        } else n = s, u = !0;\n\n        return this._active = !0, u && (this._active = !1, this._finishTimeout = setTimeout(function () {\n          e._zooming = !1, e._handler._triggerRenderFrame(), delete e._targetZoom, delete e._finishTimeout;\n        }, 200)), {\n          noInertia: !0,\n          needsRenderFrame: !u,\n          zoomDelta: n - i.zoom,\n          around: this._aroundPoint,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n    }, sr.prototype._smoothOutEasing = function (e) {\n      var i = t.ease;\n\n      if (this._prevEase) {\n        var o = this._prevEase,\n            r = (t.browser.now() - o.start) / o.duration,\n            a = o.easing(r + .01) - o.easing(r),\n            n = .27 / Math.sqrt(a * a + 1e-4) * .01,\n            s = Math.sqrt(.0729 - n * n);\n        i = t.bezier(n, s, .25, 1);\n      }\n\n      return this._prevEase = {\n        start: t.browser.now(),\n        duration: e,\n        easing: i\n      }, i;\n    }, sr.prototype.reset = function () {\n      this._active = !1;\n    };\n\n    var lr = function lr(t, e) {\n      this._clickZoom = t, this._tapZoom = e;\n    };\n\n    lr.prototype.enable = function () {\n      this._clickZoom.enable(), this._tapZoom.enable();\n    }, lr.prototype.disable = function () {\n      this._clickZoom.disable(), this._tapZoom.disable();\n    }, lr.prototype.isEnabled = function () {\n      return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n    }, lr.prototype.isActive = function () {\n      return this._clickZoom.isActive() || this._tapZoom.isActive();\n    };\n\n    var cr = function cr() {\n      this.reset();\n    };\n\n    cr.prototype.reset = function () {\n      this._active = !1;\n    }, cr.prototype.dblclick = function (t, e) {\n      return t.preventDefault(), {\n        cameraAnimation: function cameraAnimation(i) {\n          i.easeTo({\n            duration: 300,\n            zoom: i.getZoom() + (t.shiftKey ? -1 : 1),\n            around: i.unproject(e)\n          }, {\n            originalEvent: t\n          });\n        }\n      };\n    }, cr.prototype.enable = function () {\n      this._enabled = !0;\n    }, cr.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, cr.prototype.isEnabled = function () {\n      return this._enabled;\n    }, cr.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var ur = function ur() {\n      this._tap = new qo({\n        numTouches: 1,\n        numTaps: 1\n      }), this.reset();\n    };\n\n    ur.prototype.reset = function () {\n      this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();\n    }, ur.prototype.touchstart = function (t, e, i) {\n      this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = e[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i));\n    }, ur.prototype.touchmove = function (t, e, i) {\n      if (this._tapTime) {\n        if (this._swipePoint) {\n          if (i[0].identifier !== this._swipeTouch) return;\n          var o = e[0],\n              r = o.y - this._swipePoint.y;\n          return this._swipePoint = o, t.preventDefault(), this._active = !0, {\n            zoomDelta: r / 128\n          };\n        }\n      } else this._tap.touchmove(t, e, i);\n    }, ur.prototype.touchend = function (t, e, i) {\n      this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp);\n    }, ur.prototype.touchcancel = function () {\n      this.reset();\n    }, ur.prototype.enable = function () {\n      this._enabled = !0;\n    }, ur.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, ur.prototype.isEnabled = function () {\n      return this._enabled;\n    }, ur.prototype.isActive = function () {\n      return this._active;\n    };\n\n    var hr = function hr(t, e, i) {\n      this._el = t, this._mousePan = e, this._touchPan = i;\n    };\n\n    hr.prototype.enable = function (t) {\n      this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");\n    }, hr.prototype.disable = function () {\n      this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");\n    }, hr.prototype.isEnabled = function () {\n      return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n    }, hr.prototype.isActive = function () {\n      return this._mousePan.isActive() || this._touchPan.isActive();\n    };\n\n    var pr = function pr(t, e, i) {\n      this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = e, this._mousePitch = i;\n    };\n\n    pr.prototype.enable = function () {\n      this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n    }, pr.prototype.disable = function () {\n      this._mouseRotate.disable(), this._mousePitch.disable();\n    }, pr.prototype.isEnabled = function () {\n      return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n    }, pr.prototype.isActive = function () {\n      return this._mouseRotate.isActive() || this._mousePitch.isActive();\n    };\n\n    var dr = function dr(t, e, i, o) {\n      this._el = t, this._touchZoom = e, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n    };\n\n    dr.prototype.enable = function (t) {\n      this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");\n    }, dr.prototype.disable = function () {\n      this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");\n    }, dr.prototype.isEnabled = function () {\n      return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n    }, dr.prototype.isActive = function () {\n      return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n    }, dr.prototype.disableRotation = function () {\n      this._rotationDisabled = !0, this._touchRotate.disable();\n    }, dr.prototype.enableRotation = function () {\n      this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n    };\n\n    var _r = function _r(t) {\n      return t.zoom || t.drag || t.pitch || t.rotate;\n    },\n        fr = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(t.Event);\n\n    function mr(t) {\n      return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta;\n    }\n\n    var gr = function gr(e, o) {\n      this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao(e), this._bearingSnap = o.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o), t.bindAll(["handleEvent", "handleWindowEvent"], this);\n      var r = this._el;\n      this._listeners = [[r, "touchstart", {\n        passive: !0\n      }], [r, "touchmove", {\n        passive: !1\n      }], [r, "touchend", void 0], [r, "touchcancel", void 0], [r, "mousedown", void 0], [r, "mousemove", void 0], [r, "mouseup", void 0], [t.window.document, "mousemove", {\n        capture: !0\n      }], [t.window.document, "mouseup", void 0], [r, "mouseover", void 0], [r, "mouseout", void 0], [r, "dblclick", void 0], [r, "click", void 0], [r, "keydown", {\n        capture: !1\n      }], [r, "keyup", void 0], [r, "wheel", {\n        passive: !1\n      }], [r, "contextmenu", void 0], [t.window, "blur", void 0]];\n\n      for (var a = 0, n = this._listeners; a < n.length; a += 1) {\n        var s = n[a],\n            l = s[0];\n        i.addEventListener(l, s[1], l === t.window.document ? this.handleWindowEvent : this.handleEvent, s[2]);\n      }\n    };\n\n    gr.prototype.destroy = function () {\n      for (var e = 0, o = this._listeners; e < o.length; e += 1) {\n        var r = o[e],\n            a = r[0];\n        i.removeEventListener(a, r[1], a === t.window.document ? this.handleWindowEvent : this.handleEvent, r[2]);\n      }\n    }, gr.prototype._addDefaultHandlers = function (t) {\n      var e = this._map,\n          i = e.getCanvasContainer();\n\n      this._add("mapEvent", new Oo(e, t));\n\n      var o = e.boxZoom = new Uo(e, t);\n\n      this._add("boxZoom", o);\n\n      var r = new jo(),\n          a = new cr();\n      e.doubleClickZoom = new lr(a, r), this._add("tapZoom", r), this._add("clickZoom", a);\n      var n = new ur();\n\n      this._add("tapDragZoom", n);\n\n      var s = e.touchPitch = new or();\n\n      this._add("touchPitch", s);\n\n      var l = new Xo(t),\n          c = new Ho(t);\n      e.dragRotate = new pr(t, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);\n      var u = new Wo(t),\n          h = new Ko(t);\n      e.dragPan = new hr(i, u, h), this._add("mousePan", u), this._add("touchPan", h, ["touchZoom", "touchRotate"]);\n      var p = new er(),\n          d = new $o();\n      e.touchZoomRotate = new dr(i, d, p, n), this._add("touchRotate", p, ["touchPan", "touchZoom"]), this._add("touchZoom", d, ["touchPan", "touchRotate"]);\n\n      var _ = e.scrollZoom = new sr(e, this);\n\n      this._add("scrollZoom", _, ["mousePan"]);\n\n      var f = e.keyboard = new ar();\n      this._add("keyboard", f), this._add("blockableMapEvent", new Fo(e));\n\n      for (var m = 0, g = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; m < g.length; m += 1) {\n        var v = g[m];\n        t.interactive && t[v] && e[v].enable(t[v]);\n      }\n    }, gr.prototype._add = function (t, e, i) {\n      this._handlers.push({\n        handlerName: t,\n        handler: e,\n        allowed: i\n      }), this._handlersById[t] = e;\n    }, gr.prototype.stop = function (t) {\n      if (!this._updatingCamera) {\n        for (var e = 0, i = this._handlers; e < i.length; e += 1) {\n          i[e].handler.reset();\n        }\n\n        this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];\n      }\n    }, gr.prototype.isActive = function () {\n      for (var t = 0, e = this._handlers; t < e.length; t += 1) {\n        if (e[t].handler.isActive()) return !0;\n      }\n\n      return !1;\n    }, gr.prototype.isZooming = function () {\n      return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n    }, gr.prototype.isRotating = function () {\n      return !!this._eventsInProgress.rotate;\n    }, gr.prototype.isMoving = function () {\n      return Boolean(_r(this._eventsInProgress)) || this.isZooming();\n    }, gr.prototype._blockedByActive = function (t, e, i) {\n      for (var o in t) {\n        if (o !== i && (!e || e.indexOf(o) < 0)) return !0;\n      }\n\n      return !1;\n    }, gr.prototype.handleWindowEvent = function (t) {\n      this.handleEvent(t, t.type + "Window");\n    }, gr.prototype._getMapTouches = function (t) {\n      for (var e = [], i = 0, o = t; i < o.length; i += 1) {\n        var r = o[i];\n        this._el.contains(r.target) && e.push(r);\n      }\n\n      return e;\n    }, gr.prototype.handleEvent = function (t, e) {\n      if ("blur" !== t.type) {\n        this._updatingCamera = !0;\n\n        for (var o = "renderFrame" === t.type ? void 0 : t, r = {\n          needsRenderFrame: !1\n        }, a = {}, n = {}, s = t.touches ? this._getMapTouches(t.touches) : void 0, l = s ? i.touchPos(this._el, s) : i.mousePos(this._el, t), c = 0, u = this._handlers; c < u.length; c += 1) {\n          var h = u[c],\n              p = h.handlerName,\n              d = h.handler,\n              _ = h.allowed;\n\n          if (d.isEnabled()) {\n            var f = void 0;\n            this._blockedByActive(n, _, p) ? d.reset() : d[e || t.type] && (f = d[e || t.type](t, l, s), this.mergeHandlerResult(r, a, f, p, o), f && f.needsRenderFrame && this._triggerRenderFrame()), (f || d.isActive()) && (n[p] = d);\n          }\n        }\n\n        var m = {};\n\n        for (var g in this._previousActiveHandlers) {\n          n[g] || (m[g] = o);\n        }\n\n        this._previousActiveHandlers = n, (Object.keys(m).length || mr(r)) && (this._changes.push([r, a, m]), this._triggerRenderFrame()), (Object.keys(n).length || mr(r)) && this._map._stop(!0), this._updatingCamera = !1;\n        var v = r.cameraAnimation;\n        v && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], v(this._map));\n      } else this.stop(!0);\n    }, gr.prototype.mergeHandlerResult = function (e, i, o, r, a) {\n      if (o) {\n        t.extend(e, o);\n        var n = {\n          handlerName: r,\n          originalEvent: o.originalEvent || a\n        };\n        void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);\n      }\n    }, gr.prototype._applyChanges = function () {\n      for (var e = {}, i = {}, o = {}, r = 0, a = this._changes; r < a.length; r += 1) {\n        var n = a[r],\n            s = n[0],\n            l = n[1],\n            c = n[2];\n        s.panDelta && (e.panDelta = (e.panDelta || new t.Point(0, 0))._add(s.panDelta)), s.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (e.around = s.around), void 0 !== s.pinchAround && (e.pinchAround = s.pinchAround), s.noInertia && (e.noInertia = s.noInertia), t.extend(i, l), t.extend(o, c);\n      }\n\n      this._updateMapTransform(e, i, o), this._changes = [];\n    }, gr.prototype._updateMapTransform = function (t, e, i) {\n      var o = this._map,\n          r = o.transform;\n      if (!mr(t)) return this._fireEvents(e, i, !0);\n      var a = t.panDelta,\n          n = t.zoomDelta,\n          s = t.bearingDelta,\n          l = t.pitchDelta,\n          c = t.around,\n          u = t.pinchAround;\n      void 0 !== u && (c = u), o._stop(!0), c = c || o.transform.centerPoint;\n      var h = r.pointLocation(a ? c.sub(a) : c);\n      s && (r.bearing += s), l && (r.pitch += l), n && (r.zoom += n), r.setLocationAtPoint(h, c), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(e, i, !0);\n    }, gr.prototype._fireEvents = function (e, i, o) {\n      var r = this,\n          a = _r(this._eventsInProgress),\n          n = _r(e),\n          s = {};\n\n      for (var l in e) {\n        this._eventsInProgress[l] || (s[l + "start"] = e[l].originalEvent), this._eventsInProgress[l] = e[l];\n      }\n\n      for (var c in !a && n && this._fireEvent("movestart", n.originalEvent), s) {\n        this._fireEvent(c, s[c]);\n      }\n\n      for (var u in n && this._fireEvent("move", n.originalEvent), e) {\n        this._fireEvent(u, e[u].originalEvent);\n      }\n\n      var h,\n          p = {};\n\n      for (var d in this._eventsInProgress) {\n        var _ = this._eventsInProgress[d],\n            f = _.handlerName,\n            m = _.originalEvent;\n        this._handlersById[f].isActive() || (delete this._eventsInProgress[d], p[d + "end"] = h = i[f] || m);\n      }\n\n      for (var g in p) {\n        this._fireEvent(g, p[g]);\n      }\n\n      var v = _r(this._eventsInProgress);\n\n      if (o && (a || n) && !v) {\n        this._updatingCamera = !0;\n\n        var y = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n            x = function x(t) {\n          return 0 !== t && -r._bearingSnap < t && t < r._bearingSnap;\n        };\n\n        y ? (x(y.bearing || this._map.getBearing()) && (y.bearing = 0), this._map.easeTo(y, {\n          originalEvent: h\n        })) : (this._map.fire(new t.Event("moveend", {\n          originalEvent: h\n        })), x(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n      }\n    }, gr.prototype._fireEvent = function (e, i) {\n      this._map.fire(new t.Event(e, i ? {\n        originalEvent: i\n      } : {}));\n    }, gr.prototype._requestFrame = function () {\n      var t = this;\n      return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function (e) {\n        delete t._frameId, t.handleEvent(new fr("renderFrame", {\n          timeStamp: e\n        })), t._applyChanges();\n      });\n    }, gr.prototype._triggerRenderFrame = function () {\n      void 0 === this._frameId && (this._frameId = this._requestFrame());\n    };\n\n    var vr = function (e) {\n      function i(i, o) {\n        e.call(this), this._moving = !1, this._zooming = !1, this.transform = i, this._bearingSnap = o.bearingSnap, t.bindAll(["_renderFrameCallback"], this);\n      }\n\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getCenter = function () {\n        return new t.LngLat(this.transform.center.lng, this.transform.center.lat);\n      }, i.prototype.setCenter = function (t, e) {\n        return this.jumpTo({\n          center: t\n        }, e);\n      }, i.prototype.panBy = function (e, i, o) {\n        return e = t.Point.convert(e).mult(-1), this.panTo(this.transform.center, t.extend({\n          offset: e\n        }, i), o);\n      }, i.prototype.panTo = function (e, i, o) {\n        return this.easeTo(t.extend({\n          center: e\n        }, i), o);\n      }, i.prototype.getZoom = function () {\n        return this.transform.zoom;\n      }, i.prototype.setZoom = function (t, e) {\n        return this.jumpTo({\n          zoom: t\n        }, e), this;\n      }, i.prototype.zoomTo = function (e, i, o) {\n        return this.easeTo(t.extend({\n          zoom: e\n        }, i), o);\n      }, i.prototype.zoomIn = function (t, e) {\n        return this.zoomTo(this.getZoom() + 1, t, e), this;\n      }, i.prototype.zoomOut = function (t, e) {\n        return this.zoomTo(this.getZoom() - 1, t, e), this;\n      }, i.prototype.getBearing = function () {\n        return this.transform.bearing;\n      }, i.prototype.setBearing = function (t, e) {\n        return this.jumpTo({\n          bearing: t\n        }, e), this;\n      }, i.prototype.getPadding = function () {\n        return this.transform.padding;\n      }, i.prototype.setPadding = function (t, e) {\n        return this.jumpTo({\n          padding: t\n        }, e), this;\n      }, i.prototype.rotateTo = function (e, i, o) {\n        return this.easeTo(t.extend({\n          bearing: e\n        }, i), o);\n      }, i.prototype.resetNorth = function (e, i) {\n        return this.rotateTo(0, t.extend({\n          duration: 1e3\n        }, e), i), this;\n      }, i.prototype.resetNorthPitch = function (e, i) {\n        return this.easeTo(t.extend({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, e), i), this;\n      }, i.prototype.snapToNorth = function (t, e) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this;\n      }, i.prototype.getPitch = function () {\n        return this.transform.pitch;\n      }, i.prototype.setPitch = function (t, e) {\n        return this.jumpTo({\n          pitch: t\n        }, e), this;\n      }, i.prototype.cameraForBounds = function (e, i) {\n        e = t.LngLatBounds.convert(e);\n        var o = i && i.bearing || 0;\n        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, i);\n      }, i.prototype._cameraForBoxAndBearing = function (e, i, o, r) {\n        var a = {\n          top: 0,\n          bottom: 0,\n          right: 0,\n          left: 0\n        };\n\n        if ("number" == typeof (r = t.extend({\n          padding: a,\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, r)).padding) {\n          var n = r.padding;\n          r.padding = {\n            top: n,\n            bottom: n,\n            right: n,\n            left: n\n          };\n        }\n\n        r.padding = t.extend(a, r.padding);\n\n        var s = this.transform,\n            l = s.padding,\n            c = s.project(t.LngLat.convert(e)),\n            u = s.project(t.LngLat.convert(i)),\n            h = c.rotate(-o * Math.PI / 180),\n            p = u.rotate(-o * Math.PI / 180),\n            d = new t.Point(Math.max(h.x, p.x), Math.max(h.y, p.y)),\n            _ = new t.Point(Math.min(h.x, p.x), Math.min(h.y, p.y)),\n            f = d.sub(_),\n            m = (s.width - (l.left + l.right + r.padding.left + r.padding.right)) / f.x,\n            g = (s.height - (l.top + l.bottom + r.padding.top + r.padding.bottom)) / f.y;\n\n        if (!(g < 0 || m < 0)) {\n          var v = Math.min(s.scaleZoom(s.scale * Math.min(m, g)), r.maxZoom),\n              y = "number" == typeof r.offset.x ? new t.Point(r.offset.x, r.offset.y) : t.Point.convert(r.offset),\n              x = new t.Point((r.padding.left - r.padding.right) / 2, (r.padding.top - r.padding.bottom) / 2).rotate(o * Math.PI / 180),\n              b = y.add(x).mult(s.scale / s.zoomScale(v));\n          return {\n            center: s.unproject(c.add(u).div(2).sub(b)),\n            zoom: v,\n            bearing: o\n          };\n        }\n\n        t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");\n      }, i.prototype.fitBounds = function (t, e, i) {\n        return this._fitInternal(this.cameraForBounds(t, e), e, i);\n      }, i.prototype.fitScreenCoordinates = function (e, i, o, r, a) {\n        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)), this.transform.pointLocation(t.Point.convert(i)), o, r), r, a);\n      }, i.prototype._fitInternal = function (e, i, o) {\n        return e ? (delete (i = t.extend(e, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n      }, i.prototype.jumpTo = function (e, i) {\n        this.stop();\n        var o = this.transform,\n            r = !1,\n            a = !1,\n            n = !1;\n        return "zoom" in e && o.zoom !== +e.zoom && (r = !0, o.zoom = +e.zoom), void 0 !== e.center && (o.center = t.LngLat.convert(e.center)), "bearing" in e && o.bearing !== +e.bearing && (a = !0, o.bearing = +e.bearing), "pitch" in e && o.pitch !== +e.pitch && (n = !0, o.pitch = +e.pitch), null == e.padding || o.isPaddingEqual(e.padding) || (o.padding = e.padding), this.fire(new t.Event("movestart", i)).fire(new t.Event("move", i)), r && this.fire(new t.Event("zoomstart", i)).fire(new t.Event("zoom", i)).fire(new t.Event("zoomend", i)), a && this.fire(new t.Event("rotatestart", i)).fire(new t.Event("rotate", i)).fire(new t.Event("rotateend", i)), n && this.fire(new t.Event("pitchstart", i)).fire(new t.Event("pitch", i)).fire(new t.Event("pitchend", i)), this.fire(new t.Event("moveend", i));\n      }, i.prototype.easeTo = function (e, i) {\n        var o = this;\n        this._stop(!1, e.easeId), (!1 === (e = t.extend({\n          offset: [0, 0],\n          duration: 500,\n          easing: t.ease\n        }, e)).animate || !e.essential && t.browser.prefersReducedMotion) && (e.duration = 0);\n\n        var r = this.transform,\n            a = this.getZoom(),\n            n = this.getBearing(),\n            s = this.getPitch(),\n            l = this.getPadding(),\n            c = "zoom" in e ? +e.zoom : a,\n            u = "bearing" in e ? this._normalizeBearing(e.bearing, n) : n,\n            h = "pitch" in e ? +e.pitch : s,\n            p = "padding" in e ? e.padding : r.padding,\n            d = t.Point.convert(e.offset),\n            _ = r.centerPoint.add(d),\n            f = r.pointLocation(_),\n            m = t.LngLat.convert(e.center || f);\n\n        this._normalizeCenter(m);\n\n        var g,\n            v,\n            y = r.project(f),\n            x = r.project(m).sub(y),\n            b = r.zoomScale(c - a);\n        e.around && (g = t.LngLat.convert(e.around), v = r.locationPoint(g));\n        var w = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = this._zooming || c !== a, this._rotating = this._rotating || n !== u, this._pitching = this._pitching || h !== s, this._padding = !r.isPaddingEqual(p), this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, w), this._ease(function (e) {\n          if (o._zooming && (r.zoom = t.number(a, c, e)), o._rotating && (r.bearing = t.number(n, u, e)), o._pitching && (r.pitch = t.number(s, h, e)), o._padding && (r.interpolatePadding(l, p, e), _ = r.centerPoint.add(d)), g) r.setLocationAtPoint(g, v);else {\n            var f = r.zoomScale(r.zoom - a),\n                m = c > a ? Math.min(2, b) : Math.max(.5, b),\n                w = Math.pow(m, 1 - e),\n                T = r.unproject(y.add(x.mult(e * w)).mult(f));\n            r.setLocationAtPoint(r.renderWorldCopies ? T.wrap() : T, _);\n          }\n\n          o._fireMoveEvents(i);\n        }, function (t) {\n          o._afterEase(i, t);\n        }, e), this;\n      }, i.prototype._prepareEase = function (e, i, o) {\n        void 0 === o && (o = {}), this._moving = !0, i || o.moving || this.fire(new t.Event("movestart", e)), this._zooming && !o.zooming && this.fire(new t.Event("zoomstart", e)), this._rotating && !o.rotating && this.fire(new t.Event("rotatestart", e)), this._pitching && !o.pitching && this.fire(new t.Event("pitchstart", e));\n      }, i.prototype._fireMoveEvents = function (e) {\n        this.fire(new t.Event("move", e)), this._zooming && this.fire(new t.Event("zoom", e)), this._rotating && this.fire(new t.Event("rotate", e)), this._pitching && this.fire(new t.Event("pitch", e));\n      }, i.prototype._afterEase = function (e, i) {\n        if (!this._easeId || !i || this._easeId !== i) {\n          delete this._easeId;\n          var o = this._zooming,\n              r = this._rotating,\n              a = this._pitching;\n          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new t.Event("zoomend", e)), r && this.fire(new t.Event("rotateend", e)), a && this.fire(new t.Event("pitchend", e)), this.fire(new t.Event("moveend", e));\n        }\n      }, i.prototype.flyTo = function (e, i) {\n        var o = this;\n\n        if (!e.essential && t.browser.prefersReducedMotion) {\n          var r = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]);\n          return this.jumpTo(r, i);\n        }\n\n        this.stop(), e = t.extend({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: t.ease\n        }, e);\n\n        var a = this.transform,\n            n = this.getZoom(),\n            s = this.getBearing(),\n            l = this.getPitch(),\n            c = this.getPadding(),\n            u = "zoom" in e ? t.clamp(+e.zoom, a.minZoom, a.maxZoom) : n,\n            h = "bearing" in e ? this._normalizeBearing(e.bearing, s) : s,\n            p = "pitch" in e ? +e.pitch : l,\n            d = "padding" in e ? e.padding : a.padding,\n            _ = a.zoomScale(u - n),\n            f = t.Point.convert(e.offset),\n            m = a.centerPoint.add(f),\n            g = a.pointLocation(m),\n            v = t.LngLat.convert(e.center || g);\n\n        this._normalizeCenter(v);\n\n        var y = a.project(g),\n            x = a.project(v).sub(y),\n            b = e.curve,\n            w = Math.max(a.width, a.height),\n            T = w / _,\n            E = x.mag();\n\n        if ("minZoom" in e) {\n          var I = t.clamp(Math.min(e.minZoom, n, u), a.minZoom, a.maxZoom),\n              P = w / a.zoomScale(I - n);\n          b = Math.sqrt(P / E * 2);\n        }\n\n        var S = b * b;\n\n        function C(t) {\n          var e = (T * T - w * w + (t ? -1 : 1) * S * S * E * E) / (2 * (t ? T : w) * S * E);\n          return Math.log(Math.sqrt(e * e + 1) - e);\n        }\n\n        function z(t) {\n          return (Math.exp(t) - Math.exp(-t)) / 2;\n        }\n\n        function D(t) {\n          return (Math.exp(t) + Math.exp(-t)) / 2;\n        }\n\n        var A = C(0),\n            M = function M(t) {\n          return D(A) / D(A + b * t);\n        },\n            L = function L(t) {\n          return w * ((D(A) * (z(e = A + b * t) / D(e)) - z(A)) / S) / E;\n          var e;\n        },\n            R = (C(1) - A) / b;\n\n        if (Math.abs(E) < 1e-6 || !isFinite(R)) {\n          if (Math.abs(w - T) < 1e-6) return this.easeTo(e, i);\n          var k = T < w ? -1 : 1;\n          R = Math.abs(Math.log(T / w)) / b, L = function L() {\n            return 0;\n          }, M = function M(t) {\n            return Math.exp(k * b * t);\n          };\n        }\n\n        return e.duration = "duration" in e ? +e.duration : 1e3 * R / ("screenSpeed" in e ? +e.screenSpeed / b : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = s !== h, this._pitching = p !== l, this._padding = !a.isPaddingEqual(d), this._prepareEase(i, !1), this._ease(function (e) {\n          var r = e * R,\n              _ = 1 / M(r);\n\n          a.zoom = 1 === e ? u : n + a.scaleZoom(_), o._rotating && (a.bearing = t.number(s, h, e)), o._pitching && (a.pitch = t.number(l, p, e)), o._padding && (a.interpolatePadding(c, d, e), m = a.centerPoint.add(f));\n          var g = 1 === e ? v : a.unproject(y.add(x.mult(L(r))).mult(_));\n          a.setLocationAtPoint(a.renderWorldCopies ? g.wrap() : g, m), o._fireMoveEvents(i);\n        }, function () {\n          return o._afterEase(i);\n        }, e), this;\n      }, i.prototype.isEasing = function () {\n        return !!this._easeFrameId;\n      }, i.prototype.stop = function () {\n        return this._stop();\n      }, i.prototype._stop = function (t, e) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {\n          var i = this._onEaseEnd;\n          delete this._onEaseEnd, i.call(this, e);\n        }\n\n        if (!t) {\n          var o = this.handlers;\n          o && o.stop(!1);\n        }\n\n        return this;\n      }, i.prototype._ease = function (e, i, o) {\n        !1 === o.animate || 0 === o.duration ? (e(1), i()) : (this._easeStart = t.browser.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }, i.prototype._renderFrameCallback = function () {\n        var e = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);\n        this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }, i.prototype._normalizeBearing = function (e, i) {\n        e = t.wrap(e, -180, 180);\n        var o = Math.abs(e - i);\n        return Math.abs(e - 360 - i) < o && (e -= 360), Math.abs(e + 360 - i) < o && (e += 360), e;\n      }, i.prototype._normalizeCenter = function (t) {\n        var e = this.transform;\n\n        if (e.renderWorldCopies && !e.lngRange) {\n          var i = t.lng - e.center.lng;\n          t.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n        }\n      }, i;\n    }(t.Evented),\n        yr = function yr(e) {\n      void 0 === e && (e = {}), this.options = e, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);\n    };\n\n    yr.prototype.getDefaultPosition = function () {\n      return "bottom-right";\n    }, yr.prototype.onAdd = function (t) {\n      var e = this.options && this.options.compact;\n      return this._map = t, this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = i.create("button", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.type = "button", this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e && this._container.classList.add("maplibregl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;\n    }, yr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n    }, yr.prototype._setElementTitle = function (t, e) {\n      var i = this._map._getUIString("AttributionControl." + e);\n\n      t.title = i, t.setAttribute("aria-label", i);\n    }, yr.prototype._toggleAttribution = function () {\n      this._container.classList.contains("maplibregl-compact-show") ? (this._container.classList.remove("maplibregl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("maplibregl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));\n    }, yr.prototype._updateEditLink = function () {\n      var e = this._editLink;\n      e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map"));\n      var i = [{\n        key: "owner",\n        value: this.styleOwner\n      }, {\n        key: "id",\n        value: this.styleId\n      }, {\n        key: "access_token",\n        value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN\n      }];\n\n      if (e) {\n        var o = i.reduce(function (t, e, o) {\n          return e.value && (t += e.key + "=" + e.value + (o < i.length - 1 ? "&" : "")), t;\n        }, "?");\n        e.href = t.config.FEEDBACK_URL + "/" + o + (this._map._hash ? this._map._hash.getHashString(!0) : ""), e.rel = "noopener nofollow", this._setElementTitle(e, "MapFeedback");\n      }\n    }, yr.prototype._updateData = function (t) {\n      !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(), this._updateEditLink());\n    }, yr.prototype._updateAttributions = function () {\n      if (this._map.style) {\n        var t = [];\n\n        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(function (t) {\n          return "string" != typeof t ? "" : t;\n        })) : "string" == typeof this.options.customAttribution && t.push(this.options.customAttribution)), this._map.style.stylesheet) {\n          var e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n\n        var i = this._map.style.sourceCaches;\n\n        for (var o in i) {\n          var r = i[o];\n\n          if (r.used) {\n            var a = r.getSource();\n            a.attribution && t.indexOf(a.attribution) < 0 && t.push(a.attribution);\n          }\n        }\n\n        t.sort(function (t, e) {\n          return t.length - e.length;\n        });\n        var n = (t = t.filter(function (e, i) {\n          for (var o = i + 1; o < t.length; o++) {\n            if (t[o].indexOf(e) >= 0) return !1;\n          }\n\n          return !0;\n        })).join(" | ");\n        n !== this._attribHTML && (this._attribHTML = n, t.length ? (this._innerContainer.innerHTML = n, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._editLink = null);\n      }\n    }, yr.prototype._updateCompact = function () {\n      this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("maplibregl-compact") : this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show");\n    };\n\n    var xr = function xr() {\n      t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);\n    };\n\n    xr.prototype.onAdd = function (t) {\n      this._map = t, this._container = i.create("div", "maplibregl-ctrl");\n      var e = i.create("a", "maplibregl-ctrl-logo");\n      return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://maplibre.org/", e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;\n    }, xr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);\n    }, xr.prototype.getDefaultPosition = function () {\n      return "bottom-left";\n    }, xr.prototype._updateLogo = function (t) {\n      t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");\n    }, xr.prototype._logoRequired = function () {\n      if (this._map.style) {\n        var t = this._map.style.sourceCaches;\n\n        for (var e in t) {\n          if (t[e].getSource().mapbox_logo) return !0;\n        }\n\n        return !1;\n      }\n    }, xr.prototype._updateCompact = function () {\n      var t = this._container.children;\n\n      if (t.length) {\n        var e = t[0];\n        this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("maplibregl-compact") : e.classList.remove("maplibregl-compact");\n      }\n    };\n\n    var br = function br() {\n      this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n    };\n\n    br.prototype.add = function (t) {\n      var e = ++this._id;\n      return this._queue.push({\n        callback: t,\n        id: e,\n        cancelled: !1\n      }), e;\n    }, br.prototype.remove = function (t) {\n      for (var e = this._currentlyRunning, i = 0, o = e ? this._queue.concat(e) : this._queue; i < o.length; i += 1) {\n        var r = o[i];\n        if (r.id === t) return void (r.cancelled = !0);\n      }\n    }, br.prototype.run = function (t) {\n      void 0 === t && (t = 0);\n      var e = this._currentlyRunning = this._queue;\n      this._queue = [];\n\n      for (var i = 0, o = e; i < o.length; i += 1) {\n        var r = o[i];\n        if (!r.cancelled && (r.callback(t), this._cleared)) break;\n      }\n\n      this._cleared = !1, this._currentlyRunning = !1;\n    }, br.prototype.clear = function () {\n      this._currentlyRunning && (this._cleared = !0), this._queue = [];\n    };\n\n    var wr = {\n      "AttributionControl.ToggleAttribution": "Toggle attribution",\n      "AttributionControl.MapFeedback": "Map feedback",\n      "FullscreenControl.Enter": "Enter fullscreen",\n      "FullscreenControl.Exit": "Exit fullscreen",\n      "GeolocateControl.FindMyLocation": "Find my location",\n      "GeolocateControl.LocationNotAvailable": "Location not available",\n      "LogoControl.Title": "Mapbox logo",\n      "NavigationControl.ResetBearing": "Reset bearing to north",\n      "NavigationControl.ZoomIn": "Zoom in",\n      "NavigationControl.ZoomOut": "Zoom out",\n      "ScaleControl.Feet": "ft",\n      "ScaleControl.Meters": "m",\n      "ScaleControl.Kilometers": "km",\n      "ScaleControl.Miles": "mi",\n      "ScaleControl.NauticalMiles": "nm"\n    },\n        Tr = t.window.HTMLImageElement,\n        Er = t.window.HTMLElement,\n        Ir = t.window.ImageBitmap,\n        Pr = {\n      center: [0, 0],\n      zoom: 0,\n      bearing: 0,\n      pitch: 0,\n      minZoom: -2,\n      maxZoom: 22,\n      minPitch: 0,\n      maxPitch: 60,\n      interactive: !0,\n      scrollZoom: !0,\n      boxZoom: !0,\n      dragRotate: !0,\n      dragPan: !0,\n      keyboard: !0,\n      doubleClickZoom: !0,\n      touchZoomRotate: !0,\n      touchPitch: !0,\n      bearingSnap: 7,\n      clickTolerance: 3,\n      pitchWithRotate: !0,\n      hash: !1,\n      attributionControl: !0,\n      failIfMajorPerformanceCaveat: !1,\n      preserveDrawingBuffer: !1,\n      trackResize: !0,\n      renderWorldCopies: !0,\n      refreshExpiredTiles: !0,\n      maxTileCacheSize: null,\n      localIdeographFontFamily: "sans-serif",\n      transformRequest: null,\n      accessToken: null,\n      fadeDuration: 300,\n      crossSourceCollisions: !0\n    },\n        Sr = function (o) {\n      function r(e) {\n        var i = this;\n        if (null != (e = t.extend({}, Pr, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");\n        if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");\n        if (null != e.minPitch && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");\n        if (null != e.maxPitch && e.maxPitch > 60) throw new Error("maxPitch must be less than or equal to 60");\n        var r = new To(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies);\n\n        if (o.call(this, r, e), this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new br(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wr, e.locale), this._clickTolerance = e.clickTolerance, this._requestManager = new t.RequestManager(e.transformRequest, e.accessToken), "string" == typeof e.container) {\n          if (this._container = t.window.document.getElementById(e.container), !this._container) throw new Error("Container \'" + e.container + "\' not found.");\n        } else {\n          if (!(e.container instanceof Er)) throw new Error("Invalid type: \'container\' must be a String or HTMLElement.");\n          this._container = e.container;\n        }\n\n        if (e.maxBounds && this.setMaxBounds(e.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");\n        this.on("move", function () {\n          return i._update(!1);\n        }), this.on("moveend", function () {\n          return i._update(!1);\n        }), this.on("zoom", function () {\n          return i._update(!0);\n        }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1), t.window.addEventListener("resize", this._onWindowResize, !1), t.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new gr(this, e), this._hash = e.hash && new Io("string" == typeof e.hash && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({\n          center: e.center,\n          zoom: e.zoom,\n          bearing: e.bearing,\n          pitch: e.pitch\n        }), e.bounds && (this.resize(), this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {\n          duration: 0\n        })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, e.style && this.setStyle(e.style, {\n          localIdeographFontFamily: e.localIdeographFontFamily\n        }), e.attributionControl && this.addControl(new yr({\n          customAttribution: e.customAttribution\n        })), this.addControl(new xr(), e.logoPosition), this.on("style.load", function () {\n          i.transform.unmodified && i.jumpTo(i.style.stylesheet);\n        }), this.on("data", function (e) {\n          i._update("style" === e.dataType), i.fire(new t.Event(e.dataType + "data", e));\n        }), this.on("dataloading", function (e) {\n          i.fire(new t.Event(e.dataType + "dataloading", e));\n        });\n      }\n\n      o && (r.__proto__ = o), (r.prototype = Object.create(o && o.prototype)).constructor = r;\n      var a = {\n        showTileBoundaries: {\n          configurable: !0\n        },\n        showPadding: {\n          configurable: !0\n        },\n        showCollisionBoxes: {\n          configurable: !0\n        },\n        showOverdrawInspector: {\n          configurable: !0\n        },\n        repaint: {\n          configurable: !0\n        },\n        vertices: {\n          configurable: !0\n        },\n        version: {\n          configurable: !0\n        }\n      };\n      return r.prototype._getMapId = function () {\n        return this._mapId;\n      }, r.prototype.addControl = function (e, i) {\n        if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));\n        var o = e.onAdd(this);\n\n        this._controls.push(e);\n\n        var r = this._controlPositions[i];\n        return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;\n      }, r.prototype.removeControl = function (e) {\n        if (!e || !e.onRemove) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));\n\n        var i = this._controls.indexOf(e);\n\n        return i > -1 && this._controls.splice(i, 1), e.onRemove(this), this;\n      }, r.prototype.hasControl = function (t) {\n        return this._controls.indexOf(t) > -1;\n      }, r.prototype.resize = function (e) {\n        var i = this._containerDimensions(),\n            o = i[0],\n            r = i[1];\n\n        this._resizeCanvas(o, r), this.transform.resize(o, r), this.painter.resize(o, r);\n        var a = !this._moving;\n        return a && (this.stop(), this.fire(new t.Event("movestart", e)).fire(new t.Event("move", e))), this.fire(new t.Event("resize", e)), a && this.fire(new t.Event("moveend", e)), this;\n      }, r.prototype.getBounds = function () {\n        return this.transform.getBounds();\n      }, r.prototype.getMaxBounds = function () {\n        return this.transform.getMaxBounds();\n      }, r.prototype.setMaxBounds = function (e) {\n        return this.transform.setMaxBounds(t.LngLatBounds.convert(e)), this._update();\n      }, r.prototype.setMinZoom = function (t) {\n        if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this;\n        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");\n      }, r.prototype.getMinZoom = function () {\n        return this.transform.minZoom;\n      }, r.prototype.setMaxZoom = function (t) {\n        if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this;\n        throw new Error("maxZoom must be greater than the current minZoom");\n      }, r.prototype.getMaxZoom = function () {\n        return this.transform.maxZoom;\n      }, r.prototype.setMinPitch = function (t) {\n        if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");\n        if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this;\n        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");\n      }, r.prototype.getMinPitch = function () {\n        return this.transform.minPitch;\n      }, r.prototype.setMaxPitch = function (t) {\n        if ((t = null == t ? 60 : t) > 60) throw new Error("maxPitch must be less than or equal to 60");\n        if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this;\n        throw new Error("maxPitch must be greater than the current minPitch");\n      }, r.prototype.getMaxPitch = function () {\n        return this.transform.maxPitch;\n      }, r.prototype.getRenderWorldCopies = function () {\n        return this.transform.renderWorldCopies;\n      }, r.prototype.setRenderWorldCopies = function (t) {\n        return this.transform.renderWorldCopies = t, this._update();\n      }, r.prototype.project = function (e) {\n        return this.transform.locationPoint(t.LngLat.convert(e));\n      }, r.prototype.unproject = function (e) {\n        return this.transform.pointLocation(t.Point.convert(e));\n      }, r.prototype.isMoving = function () {\n        return this._moving || this.handlers.isMoving();\n      }, r.prototype.isZooming = function () {\n        return this._zooming || this.handlers.isZooming();\n      }, r.prototype.isRotating = function () {\n        return this._rotating || this.handlers.isRotating();\n      }, r.prototype._createDelegatedListener = function (t, e, i) {\n        var o,\n            r = this;\n\n        if ("mouseenter" === t || "mouseover" === t) {\n          var a = !1;\n          return {\n            layer: e,\n            listener: i,\n            delegates: {\n              mousemove: function mousemove(o) {\n                var n = r.getLayer(e) ? r.queryRenderedFeatures(o.point, {\n                  layers: [e]\n                }) : [];\n                n.length ? a || (a = !0, i.call(r, new Ro(t, r, o.originalEvent, {\n                  features: n\n                }))) : a = !1;\n              },\n              mouseout: function mouseout() {\n                a = !1;\n              }\n            }\n          };\n        }\n\n        if ("mouseleave" === t || "mouseout" === t) {\n          var n = !1;\n          return {\n            layer: e,\n            listener: i,\n            delegates: {\n              mousemove: function mousemove(o) {\n                (r.getLayer(e) ? r.queryRenderedFeatures(o.point, {\n                  layers: [e]\n                }) : []).length ? n = !0 : n && (n = !1, i.call(r, new Ro(t, r, o.originalEvent)));\n              },\n              mouseout: function mouseout(e) {\n                n && (n = !1, i.call(r, new Ro(t, r, e.originalEvent)));\n              }\n            }\n          };\n        }\n\n        return {\n          layer: e,\n          listener: i,\n          delegates: (o = {}, o[t] = function (t) {\n            var o = r.getLayer(e) ? r.queryRenderedFeatures(t.point, {\n              layers: [e]\n            }) : [];\n            o.length && (t.features = o, i.call(r, t), delete t.features);\n          }, o)\n        };\n      }, r.prototype.on = function (t, e, i) {\n        if (void 0 === i) return o.prototype.on.call(this, t, e);\n\n        var r = this._createDelegatedListener(t, e, i);\n\n        for (var a in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(r), r.delegates) {\n          this.on(a, r.delegates[a]);\n        }\n\n        return this;\n      }, r.prototype.once = function (t, e, i) {\n        if (void 0 === i) return o.prototype.once.call(this, t, e);\n\n        var r = this._createDelegatedListener(t, e, i);\n\n        for (var a in r.delegates) {\n          this.once(a, r.delegates[a]);\n        }\n\n        return this;\n      }, r.prototype.off = function (t, e, i) {\n        var r = this;\n        return void 0 === i ? o.prototype.off.call(this, t, e) : (this._delegatedListeners && this._delegatedListeners[t] && function (o) {\n          for (var a = o[t], n = 0; n < a.length; n++) {\n            var s = a[n];\n\n            if (s.layer === e && s.listener === i) {\n              for (var l in s.delegates) {\n                r.off(l, s.delegates[l]);\n              }\n\n              return a.splice(n, 1), r;\n            }\n          }\n        }(this._delegatedListeners), this);\n      }, r.prototype.queryRenderedFeatures = function (e, i) {\n        if (!this.style) return [];\n        var o;\n        if (void 0 !== i || void 0 === e || e instanceof t.Point || Array.isArray(e) || (i = e, e = void 0), i = i || {}, (e = e || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e[0]) o = [t.Point.convert(e)];else {\n          var r = t.Point.convert(e[0]),\n              a = t.Point.convert(e[1]);\n          o = [r, new t.Point(a.x, r.y), a, new t.Point(r.x, a.y), r];\n        }\n        return this.style.queryRenderedFeatures(o, i, this.transform);\n      }, r.prototype.querySourceFeatures = function (t, e) {\n        return this.style.querySourceFeatures(t, e);\n      }, r.prototype.setStyle = function (e, i) {\n        return !1 !== (i = t.extend({}, {\n          localIdeographFontFamily: this._localIdeographFontFamily\n        }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e, i));\n      }, r.prototype.setTransformRequest = function (t) {\n        return this._requestManager.setTransformRequest(t), this;\n      }, r.prototype._getUIString = function (t) {\n        var e = this._locale[t];\n        if (null == e) throw new Error("Missing UI string \'" + t + "\'");\n        return e;\n      }, r.prototype._updateStyle = function (t, e) {\n        return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new je(this, e || {}), this.style.setEventedParent(this, {\n          style: this.style\n        }), "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this);\n      }, r.prototype._lazyInitEmptyStyle = function () {\n        this.style || (this.style = new je(this, {}), this.style.setEventedParent(this, {\n          style: this.style\n        }), this.style.loadEmpty());\n      }, r.prototype._diffStyle = function (e, i) {\n        var o = this;\n\n        if ("string" == typeof e) {\n          var r = this._requestManager.normalizeStyleURL(e),\n              a = this._requestManager.transformRequest(r, t.ResourceType.Style);\n\n          t.getJSON(a, function (e, r) {\n            e ? o.fire(new t.ErrorEvent(e)) : r && o._updateDiff(r, i);\n          });\n        } else "object" == typeof e && this._updateDiff(e, i);\n      }, r.prototype._updateDiff = function (e, i) {\n        try {\n          this.style.setState(e) && this._update(!0);\n        } catch (o) {\n          t.warnOnce("Unable to perform style diff: " + (o.message || o.error || o) + ".  Rebuilding the style from scratch."), this._updateStyle(e, i);\n        }\n      }, r.prototype.getStyle = function () {\n        if (this.style) return this.style.serialize();\n      }, r.prototype.isStyleLoaded = function () {\n        return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");\n      }, r.prototype.addSource = function (t, e) {\n        return this._lazyInitEmptyStyle(), this.style.addSource(t, e), this._update(!0);\n      }, r.prototype.isSourceLoaded = function (e) {\n        var i = this.style && this.style.sourceCaches[e];\n        if (void 0 !== i) return i.loaded();\n        this.fire(new t.ErrorEvent(new Error("There is no source with ID \'" + e + "\'")));\n      }, r.prototype.areTilesLoaded = function () {\n        var t = this.style && this.style.sourceCaches;\n\n        for (var e in t) {\n          var i = t[e]._tiles;\n\n          for (var o in i) {\n            var r = i[o];\n            if ("loaded" !== r.state && "errored" !== r.state) return !1;\n          }\n        }\n\n        return !0;\n      }, r.prototype.addSourceType = function (t, e, i) {\n        return this._lazyInitEmptyStyle(), this.style.addSourceType(t, e, i);\n      }, r.prototype.removeSource = function (t) {\n        return this.style.removeSource(t), this._update(!0);\n      }, r.prototype.getSource = function (t) {\n        return this.style.getSource(t);\n      }, r.prototype.addImage = function (e, i, o) {\n        void 0 === o && (o = {});\n        var r = o.pixelRatio;\n        void 0 === r && (r = 1);\n        var a = o.sdf;\n        void 0 === a && (a = !1);\n        var n = o.stretchX,\n            s = o.stretchY,\n            l = o.content;\n\n        if (this._lazyInitEmptyStyle(), i instanceof Tr || Ir && i instanceof Ir) {\n          var c = t.browser.getImageData(i);\n          this.style.addImage(e, {\n            data: new t.RGBAImage({\n              width: c.width,\n              height: c.height\n            }, c.data),\n            pixelRatio: r,\n            stretchX: n,\n            stretchY: s,\n            content: l,\n            sdf: a,\n            version: 0\n          });\n        } else {\n          if (void 0 === i.width || void 0 === i.height) return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));\n          var u = i;\n          this.style.addImage(e, {\n            data: new t.RGBAImage({\n              width: i.width,\n              height: i.height\n            }, new Uint8Array(i.data)),\n            pixelRatio: r,\n            stretchX: n,\n            stretchY: s,\n            content: l,\n            sdf: a,\n            version: 0,\n            userImage: u\n          }), u.onAdd && u.onAdd(this, e);\n        }\n      }, r.prototype.updateImage = function (e, i) {\n        var o = this.style.getImage(e);\n        if (!o) return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));\n        var r = i instanceof Tr || Ir && i instanceof Ir ? t.browser.getImageData(i) : i,\n            a = r.width,\n            n = r.height,\n            s = r.data;\n        return void 0 === a || void 0 === n ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a !== o.data.width || n !== o.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o.data.replace(s, !(i instanceof Tr || Ir && i instanceof Ir)), void this.style.updateImage(e, o));\n      }, r.prototype.hasImage = function (e) {\n        return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), !1);\n      }, r.prototype.removeImage = function (t) {\n        this.style.removeImage(t);\n      }, r.prototype.loadImage = function (e, i) {\n        t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), i);\n      }, r.prototype.listImages = function () {\n        return this.style.listImages();\n      }, r.prototype.addLayer = function (t, e) {\n        return this._lazyInitEmptyStyle(), this.style.addLayer(t, e), this._update(!0);\n      }, r.prototype.moveLayer = function (t, e) {\n        return this.style.moveLayer(t, e), this._update(!0);\n      }, r.prototype.removeLayer = function (t) {\n        return this.style.removeLayer(t), this._update(!0);\n      }, r.prototype.getLayer = function (t) {\n        return this.style.getLayer(t);\n      }, r.prototype.setLayerZoomRange = function (t, e, i) {\n        return this.style.setLayerZoomRange(t, e, i), this._update(!0);\n      }, r.prototype.setFilter = function (t, e, i) {\n        return void 0 === i && (i = {}), this.style.setFilter(t, e, i), this._update(!0);\n      }, r.prototype.getFilter = function (t) {\n        return this.style.getFilter(t);\n      }, r.prototype.setPaintProperty = function (t, e, i, o) {\n        return void 0 === o && (o = {}), this.style.setPaintProperty(t, e, i, o), this._update(!0);\n      }, r.prototype.getPaintProperty = function (t, e) {\n        return this.style.getPaintProperty(t, e);\n      }, r.prototype.setLayoutProperty = function (t, e, i, o) {\n        return void 0 === o && (o = {}), this.style.setLayoutProperty(t, e, i, o), this._update(!0);\n      }, r.prototype.getLayoutProperty = function (t, e) {\n        return this.style.getLayoutProperty(t, e);\n      }, r.prototype.setLight = function (t, e) {\n        return void 0 === e && (e = {}), this._lazyInitEmptyStyle(), this.style.setLight(t, e), this._update(!0);\n      }, r.prototype.getLight = function () {\n        return this.style.getLight();\n      }, r.prototype.setFeatureState = function (t, e) {\n        return this.style.setFeatureState(t, e), this._update();\n      }, r.prototype.removeFeatureState = function (t, e) {\n        return this.style.removeFeatureState(t, e), this._update();\n      }, r.prototype.getFeatureState = function (t) {\n        return this.style.getFeatureState(t);\n      }, r.prototype.getContainer = function () {\n        return this._container;\n      }, r.prototype.getCanvasContainer = function () {\n        return this._canvasContainer;\n      }, r.prototype.getCanvas = function () {\n        return this._canvas;\n      }, r.prototype._containerDimensions = function () {\n        var t = 0,\n            e = 0;\n        return this._container && (t = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [t, e];\n      }, r.prototype._setupContainer = function () {\n        var t = this._container;\n        t.classList.add("maplibregl-map");\n        var e = this._canvasContainer = i.create("div", "mapboxgl-canvas-container", t);\n        this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = i.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");\n\n        var o = this._containerDimensions();\n\n        this._resizeCanvas(o[0], o[1]);\n\n        var r = this._controlContainer = i.create("div", "maplibregl-control-container", t),\n            a = this._controlPositions = {};\n        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function (t) {\n          a[t] = i.create("div", "maplibregl-ctrl-" + t, r);\n        }), this._container.addEventListener("scroll", this._onMapScroll, !1);\n      }, r.prototype._resizeCanvas = function (e, i) {\n        var o = t.browser.devicePixelRatio || 1;\n        this._canvas.width = o * e, this._canvas.height = o * i, this._canvas.style.width = e + "px", this._canvas.style.height = i + "px";\n      }, r.prototype._setupPainter = function () {\n        var i = t.extend({}, e.webGLContextAttributes, {\n          failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n          preserveDrawingBuffer: this._preserveDrawingBuffer,\n          antialias: this._antialias || !1\n        }),\n            o = this._canvas.getContext("webgl", i) || this._canvas.getContext("experimental-webgl", i);\n\n        o ? (this.painter = new yo(o, this.transform), t.webpSupported.testSupport(o)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));\n      }, r.prototype._contextLost = function (e) {\n        e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", {\n          originalEvent: e\n        }));\n      }, r.prototype._contextRestored = function (e) {\n        this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", {\n          originalEvent: e\n        }));\n      }, r.prototype._onMapScroll = function (t) {\n        if (t.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n      }, r.prototype.loaded = function () {\n        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n      }, r.prototype._update = function (t) {\n        return this.style ? (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n      }, r.prototype._requestRenderFrame = function (t) {\n        return this._update(), this._renderTaskQueue.add(t);\n      }, r.prototype._cancelRenderFrame = function (t) {\n        this._renderTaskQueue.remove(t);\n      }, r.prototype._render = function (e) {\n        var i,\n            o = this,\n            r = 0,\n            a = this.painter.context.extTimerQuery;\n\n        if (this.listens("gpu-timing-frame") && (i = a.createQueryEXT(), a.beginQueryEXT(a.TIME_ELAPSED_EXT, i), r = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), !this._removed) {\n          var n = !1;\n\n          if (this.style && this._styleDirty) {\n            this._styleDirty = !1;\n            var s = this.transform.zoom,\n                l = t.browser.now();\n            this.style.zoomHistory.update(s, l);\n            var c = new t.EvaluationParameters(s, {\n              now: l,\n              fadeDuration: this._fadeDuration,\n              zoomHistory: this.style.zoomHistory,\n              transition: this.style.getTransition()\n            }),\n                u = c.crossFadingFactor();\n            1 === u && u === this._crossFadingFactor || (n = !0, this._crossFadingFactor = u), this.style.update(c);\n          }\n\n          if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showOverdrawInspector: this._showOverdrawInspector,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: this._fadeDuration,\n            showPadding: this.showPadding,\n            gpuTiming: !!this.listens("gpu-timing-layer")\n          }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {\n            var h = t.browser.now() - r;\n            a.endQueryEXT(a.TIME_ELAPSED_EXT, i), setTimeout(function () {\n              var e = a.getQueryObjectEXT(i, a.QUERY_RESULT_EXT) / 1e6;\n              a.deleteQueryEXT(i), o.fire(new t.Event("gpu-timing-frame", {\n                cpuTime: h,\n                gpuTime: e\n              }));\n            }, 50);\n          }\n\n          if (this.listens("gpu-timing-layer")) {\n            var p = this.painter.collectGpuTimers();\n            setTimeout(function () {\n              var e = o.painter.queryGpuTimers(p);\n              o.fire(new t.Event("gpu-timing-layer", {\n                layerTimes: e\n              }));\n            }, 50);\n          }\n\n          var d = this._sourcesDirty || this._styleDirty || this._placementDirty;\n          return d || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0), this;\n        }\n      }, r.prototype.remove = function () {\n        this._hash && this._hash.remove();\n\n        for (var e = 0, i = this._controls; e < i.length; e += 1) {\n          i[e].onRemove(this);\n        }\n\n        this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1), t.window.removeEventListener("orientationchange", this._onWindowResize, !1), t.window.removeEventListener("online", this._onWindowOnline, !1));\n        var o = this.painter.context.gl.getExtension("WEBGL_lose_context");\n        o && o.loseContext(), Cr(this._canvasContainer), Cr(this._controlContainer), this._container.classList.remove("maplibregl-map"), this._removed = !0, this.fire(new t.Event("remove"));\n      }, r.prototype.triggerRepaint = function () {\n        var e = this;\n        this.style && !this._frame && (this._frame = t.browser.frame(function (t) {\n          e._frame = null, e._render(t);\n        }));\n      }, r.prototype._onWindowOnline = function () {\n        this._update();\n      }, r.prototype._onWindowResize = function (t) {\n        this._trackResize && this.resize({\n          originalEvent: t\n        })._update();\n      }, a.showTileBoundaries.get = function () {\n        return !!this._showTileBoundaries;\n      }, a.showTileBoundaries.set = function (t) {\n        this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update());\n      }, a.showPadding.get = function () {\n        return !!this._showPadding;\n      }, a.showPadding.set = function (t) {\n        this._showPadding !== t && (this._showPadding = t, this._update());\n      }, a.showCollisionBoxes.get = function () {\n        return !!this._showCollisionBoxes;\n      }, a.showCollisionBoxes.set = function (t) {\n        this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update());\n      }, a.showOverdrawInspector.get = function () {\n        return !!this._showOverdrawInspector;\n      }, a.showOverdrawInspector.set = function (t) {\n        this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update());\n      }, a.repaint.get = function () {\n        return !!this._repaint;\n      }, a.repaint.set = function (t) {\n        this._repaint !== t && (this._repaint = t, this.triggerRepaint());\n      }, a.vertices.get = function () {\n        return !!this._vertices;\n      }, a.vertices.set = function (t) {\n        this._vertices = t, this._update();\n      }, r.prototype._setCacheLimits = function (e, i) {\n        t.setCacheLimits(e, i);\n      }, a.version.get = function () {\n        return t.version;\n      }, Object.defineProperties(r.prototype, a), r;\n    }(vr);\n\n    function Cr(t) {\n      t.parentNode && t.parentNode.removeChild(t);\n    }\n\n    var zr = {\n      showCompass: !0,\n      showZoom: !0,\n      visualizePitch: !1\n    },\n        Dr = function Dr(e) {\n      var o = this;\n      this.options = t.extend({}, zr, e), this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", function (t) {\n        return t.preventDefault();\n      }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", function (t) {\n        return o._map.zoomIn({}, {\n          originalEvent: t\n        });\n      }), i.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", function (t) {\n        return o._map.zoomOut({}, {\n          originalEvent: t\n        });\n      }), i.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass", function (t) {\n        o.options.visualizePitch ? o._map.resetNorthPitch({}, {\n          originalEvent: t\n        }) : o._map.resetNorth({}, {\n          originalEvent: t\n        });\n      }), this._compassIcon = i.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));\n    };\n\n    Dr.prototype._updateZoomButtons = function () {\n      var t = this._map.getZoom(),\n          e = t === this._map.getMaxZoom(),\n          i = t === this._map.getMinZoom();\n\n      this._zoomInButton.disabled = e, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", e.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());\n    }, Dr.prototype._rotateCompassArrow = function () {\n      var t = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";\n      this._compassIcon.style.transform = t;\n    }, Dr.prototype.onAdd = function (t) {\n      return this._map = t, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ar(this._map, this._compass, this.options.visualizePitch)), this._container;\n    }, Dr.prototype.onRemove = function () {\n      i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;\n    }, Dr.prototype._createButton = function (t, e) {\n      var o = i.create("button", t, this._container);\n      return o.type = "button", o.addEventListener("click", e), o;\n    }, Dr.prototype._setButtonTitle = function (t, e) {\n      var i = this._map._getUIString("NavigationControl." + e);\n\n      t.title = i, t.setAttribute("aria-label", i);\n    };\n\n    var Ar = function Ar(e, o, r) {\n      void 0 === r && (r = !1), this._clickTolerance = 10, this.element = o, this.mouseRotate = new Xo({\n        clickTolerance: e.dragRotate._mouseRotate._clickTolerance\n      }), this.map = e, r && (this.mousePitch = new Ho({\n        clickTolerance: e.dragRotate._mousePitch._clickTolerance\n      })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener(o, "mousedown", this.mousedown), i.addEventListener(o, "touchstart", this.touchstart, {\n        passive: !1\n      }), i.addEventListener(o, "touchmove", this.touchmove), i.addEventListener(o, "touchend", this.touchend), i.addEventListener(o, "touchcancel", this.reset);\n    };\n\n    function Mr(e, i, o) {\n      if (e = new t.LngLat(e.lng, e.lat), i) {\n        var r = new t.LngLat(e.lng - 360, e.lat),\n            a = new t.LngLat(e.lng + 360, e.lat),\n            n = o.locationPoint(e).distSqr(i);\n        o.locationPoint(r).distSqr(i) < n ? e = r : o.locationPoint(a).distSqr(i) < n && (e = a);\n      }\n\n      for (; Math.abs(e.lng - o.center.lng) > 180;) {\n        var s = o.locationPoint(e);\n        if (s.x >= 0 && s.y >= 0 && s.x <= o.width && s.y <= o.height) break;\n        e.lng > o.center.lng ? e.lng -= 360 : e.lng += 360;\n      }\n\n      return e;\n    }\n\n    Ar.prototype.down = function (t, e) {\n      this.mouseRotate.mousedown(t, e), this.mousePitch && this.mousePitch.mousedown(t, e), i.disableDrag();\n    }, Ar.prototype.move = function (t, e) {\n      var i = this.map,\n          o = this.mouseRotate.mousemoveWindow(t, e);\n\n      if (o && o.bearingDelta && i.setBearing(i.getBearing() + o.bearingDelta), this.mousePitch) {\n        var r = this.mousePitch.mousemoveWindow(t, e);\n        r && r.pitchDelta && i.setPitch(i.getPitch() + r.pitchDelta);\n      }\n    }, Ar.prototype.off = function () {\n      var t = this.element;\n      i.removeEventListener(t, "mousedown", this.mousedown), i.removeEventListener(t, "touchstart", this.touchstart, {\n        passive: !1\n      }), i.removeEventListener(t, "touchmove", this.touchmove), i.removeEventListener(t, "touchend", this.touchend), i.removeEventListener(t, "touchcancel", this.reset), this.offTemp();\n    }, Ar.prototype.offTemp = function () {\n      i.enableDrag(), i.removeEventListener(t.window, "mousemove", this.mousemove), i.removeEventListener(t.window, "mouseup", this.mouseup);\n    }, Ar.prototype.mousedown = function (e) {\n      this.down(t.extend({}, e, {\n        ctrlKey: !0,\n        preventDefault: function preventDefault() {\n          return e.preventDefault();\n        }\n      }), i.mousePos(this.element, e)), i.addEventListener(t.window, "mousemove", this.mousemove), i.addEventListener(t.window, "mouseup", this.mouseup);\n    }, Ar.prototype.mousemove = function (t) {\n      this.move(t, i.mousePos(this.element, t));\n    }, Ar.prototype.mouseup = function (t) {\n      this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();\n    }, Ar.prototype.touchstart = function (t) {\n      1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.down({\n        type: "mousedown",\n        button: 0,\n        ctrlKey: !0,\n        preventDefault: function preventDefault() {\n          return t.preventDefault();\n        }\n      }, this._startPos));\n    }, Ar.prototype.touchmove = function (t) {\n      1 !== t.targetTouches.length ? this.reset() : (this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.move({\n        preventDefault: function preventDefault() {\n          return t.preventDefault();\n        }\n      }, this._lastPos));\n    }, Ar.prototype.touchend = function (t) {\n      0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n    }, Ar.prototype.reset = function () {\n      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n    };\n    var Lr = {\n      center: "translate(-50%,-50%)",\n      top: "translate(-50%,0)",\n      "top-left": "translate(0,0)",\n      "top-right": "translate(-100%,0)",\n      bottom: "translate(-50%,-100%)",\n      "bottom-left": "translate(0,-100%)",\n      "bottom-right": "translate(-100%,-100%)",\n      left: "translate(0,-50%)",\n      right: "translate(-100%,-50%)"\n    };\n\n    function Rr(t, e, i) {\n      var o = t.classList;\n\n      for (var r in Lr) {\n        o.remove("maplibregl-" + i + "-anchor-" + r);\n      }\n\n      o.add("maplibregl-" + i + "-anchor-" + e);\n    }\n\n    var kr,\n        Br = function (e) {\n      function o(o, r) {\n        if (e.call(this), (o instanceof t.window.HTMLElement || r) && (o = t.extend({\n          element: o\n        }, r)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o && o.anchor || "center", this._color = o && o.color || "#3FB1CE", this._scale = o && o.scale || 1, this._draggable = o && o.draggable || !1, this._clickTolerance = o && o.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = o && o.rotation || 0, this._rotationAlignment = o && o.rotationAlignment || "auto", this._pitchAlignment = o && o.pitchAlignment && "auto" !== o.pitchAlignment ? o.pitchAlignment : this._rotationAlignment, o && o.element) this._element = o.element, this._offset = t.Point.convert(o && o.offset || [0, 0]);else {\n          this._defaultMarker = !0, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker");\n          var a = i.createNS("http://www.w3.org/2000/svg", "svg");\n          a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", "41px"), a.setAttributeNS(null, "width", "27px"), a.setAttributeNS(null, "viewBox", "0 0 27 41");\n          var n = i.createNS("http://www.w3.org/2000/svg", "g");\n          n.setAttributeNS(null, "stroke", "none"), n.setAttributeNS(null, "stroke-width", "1"), n.setAttributeNS(null, "fill", "none"), n.setAttributeNS(null, "fill-rule", "evenodd");\n          var s = i.createNS("http://www.w3.org/2000/svg", "g");\n          s.setAttributeNS(null, "fill-rule", "nonzero");\n          var l = i.createNS("http://www.w3.org/2000/svg", "g");\n          l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000");\n\n          for (var c = 0, u = [{\n            rx: "10.5",\n            ry: "5.25002273"\n          }, {\n            rx: "10.5",\n            ry: "5.25002273"\n          }, {\n            rx: "9.5",\n            ry: "4.77275007"\n          }, {\n            rx: "8.5",\n            ry: "4.29549936"\n          }, {\n            rx: "7.5",\n            ry: "3.81822308"\n          }, {\n            rx: "6.5",\n            ry: "3.34094679"\n          }, {\n            rx: "5.5",\n            ry: "2.86367051"\n          }, {\n            rx: "4.5",\n            ry: "2.38636864"\n          }]; c < u.length; c += 1) {\n            var h = u[c],\n                p = i.createNS("http://www.w3.org/2000/svg", "ellipse");\n            p.setAttributeNS(null, "opacity", "0.04"), p.setAttributeNS(null, "cx", "10.5"), p.setAttributeNS(null, "cy", "5.80029008"), p.setAttributeNS(null, "rx", h.rx), p.setAttributeNS(null, "ry", h.ry), l.appendChild(p);\n          }\n\n          var d = i.createNS("http://www.w3.org/2000/svg", "g");\n          d.setAttributeNS(null, "fill", this._color);\n\n          var _ = i.createNS("http://www.w3.org/2000/svg", "path");\n\n          _.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d.appendChild(_);\n          var f = i.createNS("http://www.w3.org/2000/svg", "g");\n          f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "fill", "#000000");\n          var m = i.createNS("http://www.w3.org/2000/svg", "path");\n          m.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f.appendChild(m);\n          var g = i.createNS("http://www.w3.org/2000/svg", "g");\n          g.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g.setAttributeNS(null, "fill", "#FFFFFF");\n          var v = i.createNS("http://www.w3.org/2000/svg", "g");\n          v.setAttributeNS(null, "transform", "translate(8.0, 8.0)");\n          var y = i.createNS("http://www.w3.org/2000/svg", "circle");\n          y.setAttributeNS(null, "fill", "#000000"), y.setAttributeNS(null, "opacity", "0.25"), y.setAttributeNS(null, "cx", "5.5"), y.setAttributeNS(null, "cy", "5.5"), y.setAttributeNS(null, "r", "5.4999962");\n          var x = i.createNS("http://www.w3.org/2000/svg", "circle");\n          x.setAttributeNS(null, "fill", "#FFFFFF"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962"), v.appendChild(y), v.appendChild(x), s.appendChild(l), s.appendChild(d), s.appendChild(f), s.appendChild(g), s.appendChild(v), a.appendChild(s), a.setAttributeNS(null, "height", 41 * this._scale + "px"), a.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a), this._offset = t.Point.convert(o && o.offset || [0, -14]);\n        }\n        this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", function (t) {\n          t.preventDefault();\n        }), this._element.addEventListener("mousedown", function (t) {\n          t.preventDefault();\n        }), Rr(this._element, this._anchor, "marker"), this._popup = null;\n      }\n\n      return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.addTo = function (t) {\n        return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;\n      }, o.prototype.remove = function () {\n        return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this;\n      }, o.prototype.getLngLat = function () {\n        return this._lngLat;\n      }, o.prototype.setLngLat = function (e) {\n        return this._lngLat = t.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;\n      }, o.prototype.getElement = function () {\n        return this._element;\n      }, o.prototype.setPopup = function (t) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {\n          if (!("offset" in t.options)) {\n            var e = Math.sqrt(Math.pow(13.5, 2) / 2);\n            t.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              "top-left": [0, 0],\n              "top-right": [0, 0],\n              bottom: [0, -38.1],\n              "bottom-left": [e, -1 * (24.6 + e)],\n              "bottom-right": [-e, -1 * (24.6 + e)],\n              left: [13.5, -24.6],\n              right: [-13.5, -24.6]\n            } : this._offset;\n          }\n\n          this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);\n        }\n\n        return this;\n      }, o.prototype._onKeyPress = function (t) {\n        var e = t.code,\n            i = t.charCode || t.keyCode;\n        "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup();\n      }, o.prototype._onMapClick = function (t) {\n        var e = t.originalEvent.target,\n            i = this._element;\n        this._popup && (e === i || i.contains(e)) && this.togglePopup();\n      }, o.prototype.getPopup = function () {\n        return this._popup;\n      }, o.prototype.togglePopup = function () {\n        var t = this._popup;\n        return t ? (t.isOpen() ? t.remove() : t.addTo(this._map), this) : this;\n      }, o.prototype._update = function (t) {\n        if (this._map) {\n          this._map.transform.renderWorldCopies && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);\n          var e = "";\n          "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");\n          var o = "";\n          "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o = "rotateX(0deg)" : "map" === this._pitchAlignment && (o = "rotateX(" + this._map.getPitch() + "deg)"), t && "moveend" !== t.type || (this._pos = this._pos.round()), i.setTransform(this._element, Lr[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o + " " + e);\n        }\n      }, o.prototype.getOffset = function () {\n        return this._offset;\n      }, o.prototype.setOffset = function (e) {\n        return this._offset = t.Point.convert(e), this._update(), this;\n      }, o.prototype._onMove = function (e) {\n        if (!this._isDragging) {\n          var i = this._clickTolerance || this._map._clickTolerance;\n          this._isDragging = e.point.dist(this._pointerdownPos) >= i;\n        }\n\n        this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));\n      }, o.prototype._onUp = function () {\n        this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";\n      }, o.prototype._addDragHandler = function (t) {\n        this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._pointerdownPos = t.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));\n      }, o.prototype.setDraggable = function (t) {\n        return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;\n      }, o.prototype.isDraggable = function () {\n        return this._draggable;\n      }, o.prototype.setRotation = function (t) {\n        return this._rotation = t || 0, this._update(), this;\n      }, o.prototype.getRotation = function () {\n        return this._rotation;\n      }, o.prototype.setRotationAlignment = function (t) {\n        return this._rotationAlignment = t || "auto", this._update(), this;\n      }, o.prototype.getRotationAlignment = function () {\n        return this._rotationAlignment;\n      }, o.prototype.setPitchAlignment = function (t) {\n        return this._pitchAlignment = t && "auto" !== t ? t : this._rotationAlignment, this._update(), this;\n      }, o.prototype.getPitchAlignment = function () {\n        return this._pitchAlignment;\n      }, o;\n    }(t.Evented),\n        Or = {\n      positionOptions: {\n        enableHighAccuracy: !1,\n        maximumAge: 0,\n        timeout: 6e3\n      },\n      fitBoundsOptions: {\n        maxZoom: 15\n      },\n      trackUserLocation: !1,\n      showAccuracyCircle: !0,\n      showUserLocation: !0\n    },\n        Fr = 0,\n        Ur = !1,\n        Nr = function (e) {\n      function o(i) {\n        e.call(this), this.options = t.extend({}, Or, i), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);\n      }\n\n      return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.onAdd = function (e) {\n        var o;\n        return this._map = e, this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), o = this._setupUI, void 0 !== kr ? o(kr) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({\n          name: "geolocation"\n        }).then(function (t) {\n          o(kr = "denied" !== t.state);\n        }) : o(kr = !!t.window.navigator.geolocation), this._container;\n      }, o.prototype.onRemove = function () {\n        void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fr = 0, Ur = !1;\n      }, o.prototype._isOutOfMapMaxBounds = function (t) {\n        var e = this._map.getMaxBounds(),\n            i = t.coords;\n\n        return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth());\n      }, o.prototype._setErrorState = function () {\n        switch (this._watchState) {\n          case "WAITING_ACTIVE":\n            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");\n            break;\n\n          case "ACTIVE_LOCK":\n            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");\n            break;\n\n          case "BACKGROUND":\n            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");\n        }\n      }, o.prototype._onSuccess = function (e) {\n        if (this._map) {\n          if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e)), this._updateMarker(), void this._finish();\n          if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {\n            case "WAITING_ACTIVE":\n            case "ACTIVE_LOCK":\n            case "ACTIVE_ERROR":\n              this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");\n              break;\n\n            case "BACKGROUND":\n            case "BACKGROUND_ERROR":\n              this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");\n          }\n          this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e)), this._finish();\n        }\n      }, o.prototype._updateCamera = function (e) {\n        var i = new t.LngLat(e.coords.longitude, e.coords.latitude),\n            o = e.coords.accuracy,\n            r = this._map.getBearing(),\n            a = t.extend({\n          bearing: r\n        }, this.options.fitBoundsOptions);\n\n        this._map.fitBounds(i.toBounds(o), a, {\n          geolocateSource: !0\n        });\n      }, o.prototype._updateMarker = function (e) {\n        if (e) {\n          var i = new t.LngLat(e.coords.longitude, e.coords.latitude);\n          this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n      }, o.prototype._updateCircleRadius = function () {\n        var t = this._map._container.clientHeight / 2,\n            e = this._map.unproject([0, t]),\n            i = this._map.unproject([1, t]),\n            o = e.distanceTo(i),\n            r = Math.ceil(2 * this._accuracy / o);\n\n        this._circleElement.style.width = r + "px", this._circleElement.style.height = r + "px";\n      }, o.prototype._onZoom = function () {\n        this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n      }, o.prototype._onError = function (e) {\n        if (this._map) {\n          if (this.options.trackUserLocation) if (1 === e.code) {\n            this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;\n\n            var i = this._map._getUIString("GeolocateControl.LocationNotAvailable");\n\n            this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), void 0 !== this._geolocationWatchID && this._clearWatch();\n          } else {\n            if (3 === e.code && Ur) return;\n\n            this._setErrorState();\n          }\n          "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.Event("error", e)), this._finish();\n        }\n      }, o.prototype._finish = function () {\n        this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n      }, o.prototype._setupUI = function (e) {\n        var o = this;\n\n        if (this._container.addEventListener("contextmenu", function (t) {\n          return t.preventDefault();\n        }), this._geolocateButton = i.create("button", "maplibregl-ctrl-geolocate", this._container), i.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", !1 === e) {\n          t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");\n\n          var r = this._map._getUIString("GeolocateControl.LocationNotAvailable");\n\n          this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);\n        } else {\n          var a = this._map._getUIString("GeolocateControl.FindMyLocation");\n\n          this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);\n        }\n\n        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Br(this._dotElement), this._circleElement = i.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Br({\n          element: this._circleElement,\n          pitchAlignment: "map"\n        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function (e) {\n          e.geolocateSource || "ACTIVE_LOCK" !== o._watchState || e.originalEvent && "resize" === e.originalEvent.type || (o._watchState = "BACKGROUND", o._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), o._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), o.fire(new t.Event("trackuserlocationend")));\n        });\n      }, o.prototype.trigger = function () {\n        if (!this._setup) return t.warnOnce("Geolocate control triggered before added to a map"), !1;\n\n        if (this.options.trackUserLocation) {\n          switch (this._watchState) {\n            case "OFF":\n              this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));\n              break;\n\n            case "WAITING_ACTIVE":\n            case "ACTIVE_LOCK":\n            case "ACTIVE_ERROR":\n            case "BACKGROUND_ERROR":\n              Fr--, Ur = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));\n              break;\n\n            case "BACKGROUND":\n              this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));\n          }\n\n          switch (this._watchState) {\n            case "WAITING_ACTIVE":\n              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");\n              break;\n\n            case "ACTIVE_LOCK":\n              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");\n\n              break;\n\n            case "ACTIVE_ERROR":\n              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");\n              break;\n\n            case "BACKGROUND":\n              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");\n\n              break;\n\n            case "BACKGROUND_ERROR":\n              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error");\n          }\n\n          if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n            var e;\n            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fr > 1 ? (e = {\n              maximumAge: 6e5,\n              timeout: 0\n            }, Ur = !0) : (e = this.options.positionOptions, Ur = !1), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e);\n          }\n        } else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n\n        return !0;\n      }, o.prototype._clearWatch = function () {\n        t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);\n      }, o;\n    }(t.Evented),\n        Zr = {\n      maxWidth: 100,\n      unit: "metric"\n    },\n        qr = function qr(e) {\n      this.options = t.extend({}, Zr, e), t.bindAll(["_onMove", "setUnit"], this);\n    };\n\n    function jr(t, e, i) {\n      var o = i && i.maxWidth || 100,\n          r = t._container.clientHeight / 2,\n          a = t.unproject([0, r]),\n          n = t.unproject([o, r]),\n          s = a.distanceTo(n);\n\n      if (i && "imperial" === i.unit) {\n        var l = 3.2808 * s;\n        l > 5280 ? Vr(e, o, l / 5280, t._getUIString("ScaleControl.Miles")) : Vr(e, o, l, t._getUIString("ScaleControl.Feet"));\n      } else i && "nautical" === i.unit ? Vr(e, o, s / 1852, t._getUIString("ScaleControl.NauticalMiles")) : s >= 1e3 ? Vr(e, o, s / 1e3, t._getUIString("ScaleControl.Kilometers")) : Vr(e, o, s, t._getUIString("ScaleControl.Meters"));\n    }\n\n    function Vr(t, e, i, o) {\n      var r,\n          a,\n          n,\n          s = (r = i, (a = Math.pow(10, ("" + Math.floor(r)).length - 1)) * (n = (n = r / a) >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : n >= 1 ? 1 : function (t) {\n        var e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));\n        return Math.round(t * e) / e;\n      }(n)));\n      t.style.width = e * (s / i) + "px", t.innerHTML = s + "&nbsp;" + o;\n    }\n\n    qr.prototype.getDefaultPosition = function () {\n      return "bottom-left";\n    }, qr.prototype._onMove = function () {\n      jr(this._map, this._container, this.options);\n    }, qr.prototype.onAdd = function (t) {\n      return this._map = t, this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;\n    }, qr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;\n    }, qr.prototype.setUnit = function (t) {\n      this.options.unit = t, jr(this._map, this._container, this.options);\n    };\n\n    var Gr = function Gr(e) {\n      this._fullscreen = !1, e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control \'container\' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");\n    };\n\n    Gr.prototype.onAdd = function (e) {\n      return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;\n    }, Gr.prototype.onRemove = function () {\n      i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n    }, Gr.prototype._checkFullscreenSupport = function () {\n      return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);\n    }, Gr.prototype._setupUI = function () {\n      var e = this._fullscreenButton = i.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);\n      i.create("span", "maplibregl-ctrl-icon", e).setAttribute("aria-hidden", !0), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n    }, Gr.prototype._updateTitle = function () {\n      var t = this._getTitle();\n\n      this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t;\n    }, Gr.prototype._getTitle = function () {\n      return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");\n    }, Gr.prototype._isFullscreen = function () {\n      return this._fullscreen;\n    }, Gr.prototype._changeIcon = function () {\n      (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle());\n    }, Gr.prototype._onClickFullscreen = function () {\n      this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n    };\n\n    var Wr = {\n      closeButton: !0,\n      closeOnClick: !0,\n      focusAfterOpen: !0,\n      className: "",\n      maxWidth: "240px"\n    },\n        Xr = ["a[href]", "[tabindex]:not([tabindex=\'-1\'])", "[contenteditable]:not([contenteditable=\'false\'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "),\n        Hr = function (e) {\n      function o(i) {\n        e.call(this), this.options = t.extend(Object.create(Wr), i), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);\n      }\n\n      return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.addTo = function (e) {\n        return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;\n      }, o.prototype.isOpen = function () {\n        return !!this._map;\n      }, o.prototype.remove = function () {\n        return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;\n      }, o.prototype.getLngLat = function () {\n        return this._lngLat;\n      }, o.prototype.setLngLat = function (e) {\n        return this._lngLat = t.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;\n      }, o.prototype.trackPointer = function () {\n        return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;\n      }, o.prototype.getElement = function () {\n        return this._container;\n      }, o.prototype.setText = function (e) {\n        return this.setDOMContent(t.window.document.createTextNode(e));\n      }, o.prototype.setHTML = function (e) {\n        var i,\n            o = t.window.document.createDocumentFragment(),\n            r = t.window.document.createElement("body");\n\n        for (r.innerHTML = e; i = r.firstChild;) {\n          o.appendChild(i);\n        }\n\n        return this.setDOMContent(o);\n      }, o.prototype.getMaxWidth = function () {\n        return this._container && this._container.style.maxWidth;\n      }, o.prototype.setMaxWidth = function (t) {\n        return this.options.maxWidth = t, this._update(), this;\n      }, o.prototype.setDOMContent = function (t) {\n        if (this._content) for (; this._content.hasChildNodes();) {\n          this._content.firstChild && this._content.removeChild(this._content.firstChild);\n        } else this._content = i.create("div", "maplibregl-popup-content", this._container);\n        return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this;\n      }, o.prototype.addClassName = function (t) {\n        this._container && this._container.classList.add(t);\n      }, o.prototype.removeClassName = function (t) {\n        this._container && this._container.classList.remove(t);\n      }, o.prototype.setOffset = function (t) {\n        return this.options.offset = t, this._update(), this;\n      }, o.prototype.toggleClassName = function (t) {\n        if (this._container) return this._container.classList.toggle(t);\n      }, o.prototype._createCloseButton = function () {\n        this.options.closeButton && (this._closeButton = i.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));\n      }, o.prototype._onMouseUp = function (t) {\n        this._update(t.point);\n      }, o.prototype._onMouseMove = function (t) {\n        this._update(t.point);\n      }, o.prototype._onDrag = function (t) {\n        this._update(t.point);\n      }, o.prototype._update = function (e) {\n        var o = this;\n\n        if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = i.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function (t) {\n          return o._container.classList.add(t);\n        }), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e)) {\n          var r = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat),\n              a = this.options.anchor,\n              n = function e(i) {\n            if (i) {\n              if ("number" == typeof i) {\n                var o = Math.round(Math.sqrt(.5 * Math.pow(i, 2)));\n                return {\n                  center: new t.Point(0, 0),\n                  top: new t.Point(0, i),\n                  "top-left": new t.Point(o, o),\n                  "top-right": new t.Point(-o, o),\n                  bottom: new t.Point(0, -i),\n                  "bottom-left": new t.Point(o, -o),\n                  "bottom-right": new t.Point(-o, -o),\n                  left: new t.Point(i, 0),\n                  right: new t.Point(-i, 0)\n                };\n              }\n\n              if (i instanceof t.Point || Array.isArray(i)) {\n                var r = t.Point.convert(i);\n                return {\n                  center: r,\n                  top: r,\n                  "top-left": r,\n                  "top-right": r,\n                  bottom: r,\n                  "bottom-left": r,\n                  "bottom-right": r,\n                  left: r,\n                  right: r\n                };\n              }\n\n              return {\n                center: t.Point.convert(i.center || [0, 0]),\n                top: t.Point.convert(i.top || [0, 0]),\n                "top-left": t.Point.convert(i["top-left"] || [0, 0]),\n                "top-right": t.Point.convert(i["top-right"] || [0, 0]),\n                bottom: t.Point.convert(i.bottom || [0, 0]),\n                "bottom-left": t.Point.convert(i["bottom-left"] || [0, 0]),\n                "bottom-right": t.Point.convert(i["bottom-right"] || [0, 0]),\n                left: t.Point.convert(i.left || [0, 0]),\n                right: t.Point.convert(i.right || [0, 0])\n              };\n            }\n\n            return e(new t.Point(0, 0));\n          }(this.options.offset);\n\n          if (!a) {\n            var s,\n                l = this._container.offsetWidth,\n                c = this._container.offsetHeight;\n            s = r.y + n.bottom.y < c ? ["top"] : r.y > this._map.transform.height - c ? ["bottom"] : [], r.x < l / 2 ? s.push("left") : r.x > this._map.transform.width - l / 2 && s.push("right"), a = 0 === s.length ? "bottom" : s.join("-");\n          }\n\n          var u = r.add(n[a]).round();\n          i.setTransform(this._container, Lr[a] + " translate(" + u.x + "px," + u.y + "px)"), Rr(this._container, a, "popup");\n        }\n      }, o.prototype._focusFirstElement = function () {\n        if (this.options.focusAfterOpen && this._container) {\n          var t = this._container.querySelector(Xr);\n\n          t && t.focus();\n        }\n      }, o.prototype._onClose = function () {\n        this.remove();\n      }, o;\n    }(t.Evented),\n        Kr = {\n      version: t.version,\n      supported: e,\n      setRTLTextPlugin: t.setRTLTextPlugin,\n      getRTLTextPluginStatus: t.getRTLTextPluginStatus,\n      Map: Sr,\n      NavigationControl: Dr,\n      GeolocateControl: Nr,\n      AttributionControl: yr,\n      ScaleControl: qr,\n      FullscreenControl: Gr,\n      Popup: Hr,\n      Marker: Br,\n      Style: je,\n      LngLat: t.LngLat,\n      LngLatBounds: t.LngLatBounds,\n      Point: t.Point,\n      MercatorCoordinate: t.MercatorCoordinate,\n      Evented: t.Evented,\n      config: t.config,\n      prewarm: function prewarm() {\n        Ft().acquire(Rt);\n      },\n      clearPrewarmedResources: function clearPrewarmedResources() {\n        var t = Bt;\n        t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Rt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));\n      },\n\n      get accessToken() {\n        return t.config.ACCESS_TOKEN;\n      },\n\n      set accessToken(e) {\n        t.config.ACCESS_TOKEN = e;\n      },\n\n      get baseApiUrl() {\n        return t.config.API_URL;\n      },\n\n      set baseApiUrl(e) {\n        t.config.API_URL = e;\n      },\n\n      get workerCount() {\n        return kt.workerCount;\n      },\n\n      set workerCount(t) {\n        kt.workerCount = t;\n      },\n\n      get maxParallelImageRequests() {\n        return t.config.MAX_PARALLEL_IMAGE_REQUESTS;\n      },\n\n      set maxParallelImageRequests(e) {\n        t.config.MAX_PARALLEL_IMAGE_REQUESTS = e;\n      },\n\n      clearStorage: function clearStorage(e) {\n        t.clearTileCache(e);\n      },\n      workerUrl: "",\n      addProtocol: function addProtocol(e, i) {\n        t.config.REGISTERED_PROTOCOLS[e] = i;\n      },\n      removeProtocol: function removeProtocol(e) {\n        delete t.config.REGISTERED_PROTOCOLS[e];\n      }\n    };\n\n    return Kr;\n  }); //\n\n  return maplibregl;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tYXBsaWJyZS1nbC9kaXN0L21hcGxpYnJlLWdsLmpzPzJjYjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQU8sQ0FBQyxJQUFrQzs7QUFFMUM7QUFDQTtBQUNBLEVBQUUsS0FBNEQsZ0NBQWdDLENBQXVIO0FBQ3JOLENBQUM7QUFDRDtBQUNBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wscURBQXFELCtCQUErQiwrQkFBK0I7QUFDbkg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtB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Q0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtB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QTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTs7QUFFQSw0QkFBNEIsY0FBYztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsd0RBQXdELGNBQWM7QUFDdEU7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUsseUNBQXlDO0FBQzlDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUCxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLHdEQUF3RDtBQUN4RCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLHFEQUFxRCxnQ0FBZ0M7QUFDbEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNULHdDQUF3QyxrQ0FBa0M7QUFDMUU7O0FBRUEsc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0Isb0JBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCLDRCQUE0QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUksSUFBSSxtSUFBbUksK0RBQStEO0FBQ3hRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLGlLQUFpSztBQUN4SztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU8scUNBQXFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxjQUFjO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSw0RkFBNEYsT0FBTztBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTCwyREFBMkQsT0FBTztBQUNsRTtBQUNBLE9BQU87QUFDUCx1QkFBdUIsT0FBTztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9ELG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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T0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCx3REFBd0QsY0FBYztBQUNySSwyREFBMkQsY0FBYztBQUN6RTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLGdGQUFnRixrTEFBa0wsa0RBQWtEOztBQUVwVCw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QThFO0FBQzlFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHVCQUF1QixhQUFhLHVCQUF1QjtBQUMzSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQLHVEQUF1RCxPQUFPLHNFQUFz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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxzVEFBc1Q7QUFDdFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNU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Q0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvR0FBb0cscUJBQXFCLDJCQUEyQiwwRkFBMEYsbUVBQW1FO0FBQ2pUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDRCQUE0QixxRkFBcUYsY0FBYztBQUMvSDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ01BQWdNLGNBQWM7QUFDOU07QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVB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Q3pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwZEFBMGQ7QUFDMWQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRXQUE0VyxZQUFZO0FBQ3hYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRSxvQkFBb0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCw0REFBNEQscUNBQXFDO0FBQ2pHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUNBQWlDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssc0NBQXNDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssc0NBQXNDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsUUFBUSxjQUFjO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHFDQUFxQztBQUM1QyxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssdUNBQXVDO0FBQzVDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FB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LE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrUEFBK1A7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCwrQkFBK0I7QUFDL0IsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDhGQUE4RixjQUFjO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlxQkFBaXFCO0FBQ2pxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBbUU7QUFDNUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXLEVBQUUsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUVBQW1FO0FBQ25FOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1Asa1FBQWtRO0FBQ2xRLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQSxDQUFDIiwiZmlsZSI6Ijk5MTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3QuanNcIik7XG5cbi8qIE1hcExpYnJlIEdMIEpTIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSAzLUNsYXVzZSBCU0QgTGljZW5zZS4gRnVsbCB0ZXh0IG9mIGxpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBsaWJyZS9tYXBsaWJyZS1nbC1qcy9ibG9iL3YxLjE1LjAvTElDRU5TRS50eHQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDogKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwubWFwbGlicmVnbCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICB2YXIgc2hhcmVkLCB3b3JrZXIsIG1hcGxpYnJlZ2w7IC8vIGRlZmluZSBnZXRzIGNhbGxlZCB0aHJlZSB0aW1lczogb25lIGZvciBlYWNoIGNodW5rLiB3ZSByZWx5IG9uIHRoZSBvcmRlclxuICAvLyB0aGV5J3JlIGltcG9ydGVkIHRvIGtub3cgd2hpY2ggaXMgd2hpY2hcblxuICBmdW5jdGlvbiBkZWZpbmUoXywgY2h1bmspIHtcbiAgICBpZiAoIXNoYXJlZCkge1xuICAgICAgc2hhcmVkID0gY2h1bms7XG4gICAgfSBlbHNlIGlmICghd29ya2VyKSB7XG4gICAgICB3b3JrZXIgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdvcmtlckJ1bmRsZVN0cmluZyA9ICd2YXIgc2hhcmVkQ2h1bmsgPSB7fTsgKCcgKyBzaGFyZWQgKyAnKShzaGFyZWRDaHVuayk7ICgnICsgd29ya2VyICsgJykoc2hhcmVkQ2h1bmspOyc7XG4gICAgICB2YXIgc2hhcmVkQ2h1bmsgPSB7fTtcbiAgICAgIHNoYXJlZChzaGFyZWRDaHVuayk7XG4gICAgICBtYXBsaWJyZWdsID0gY2h1bmsoc2hhcmVkQ2h1bmspO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbWFwbGlicmVnbC53b3JrZXJVcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd29ya2VyQnVuZGxlU3RyaW5nXSwge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIGUodCwgZSkge1xuICAgICAgcmV0dXJuIHQoZSA9IHtcbiAgICAgICAgZXhwb3J0czoge31cbiAgICAgIH0sIGUuZXhwb3J0cyksIGUuZXhwb3J0cztcbiAgICB9XG5cbiAgICB2YXIgciA9IG47XG5cbiAgICBmdW5jdGlvbiBuKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMuY3ggPSAzICogdCwgdGhpcy5ieCA9IDMgKiAociAtIHQpIC0gdGhpcy5jeCwgdGhpcy5heCA9IDEgLSB0aGlzLmN4IC0gdGhpcy5ieCwgdGhpcy5jeSA9IDMgKiBlLCB0aGlzLmJ5ID0gMyAqIChuIC0gZSkgLSB0aGlzLmN5LCB0aGlzLmF5ID0gMSAtIHRoaXMuY3kgLSB0aGlzLmJ5LCB0aGlzLnAxeCA9IHQsIHRoaXMucDF5ID0gbiwgdGhpcy5wMnggPSByLCB0aGlzLnAyeSA9IG47XG4gICAgfVxuXG4gICAgbi5wcm90b3R5cGUuc2FtcGxlQ3VydmVYID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xuICAgIH0sIG4ucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDtcbiAgICB9LCBuLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAoMyAqIHRoaXMuYXggKiB0ICsgMiAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG4gICAgfSwgbi5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsIG4sIGksIGEsIG87XG5cbiAgICAgIGZvciAodm9pZCAwID09PSBlICYmIChlID0gMWUtNiksIGkgPSB0LCBvID0gMDsgbyA8IDg7IG8rKykge1xuICAgICAgICBpZiAoYSA9IHRoaXMuc2FtcGxlQ3VydmVYKGkpIC0gdCwgTWF0aC5hYnMoYSkgPCBlKSByZXR1cm4gaTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgoaSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhzKSA8IDFlLTYpIGJyZWFrO1xuICAgICAgICBpIC09IGEgLyBzO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGkgPSB0KSA8IChyID0gMCkpIHJldHVybiByO1xuICAgICAgaWYgKGkgPiAobiA9IDEpKSByZXR1cm4gbjtcblxuICAgICAgZm9yICg7IHIgPCBuOykge1xuICAgICAgICBpZiAoYSA9IHRoaXMuc2FtcGxlQ3VydmVYKGkpLCBNYXRoLmFicyhhIC0gdCkgPCBlKSByZXR1cm4gaTtcbiAgICAgICAgdCA+IGEgPyByID0gaSA6IG4gPSBpLCBpID0gLjUgKiAobiAtIHIpICsgcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgbi5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgodCwgZSkpO1xuICAgIH07XG4gICAgdmFyIGkgPSBhO1xuXG4gICAgZnVuY3Rpb24gYSh0LCBlKSB7XG4gICAgICB0aGlzLnggPSB0LCB0aGlzLnkgPSBlO1xuICAgIH1cblxuICAgIGEucHJvdG90eXBlID0ge1xuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IGEodGhpcy54LCB0aGlzLnkpO1xuICAgICAgfSxcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHQpO1xuICAgICAgfSxcbiAgICAgIHN1YjogZnVuY3Rpb24gc3ViKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHQpO1xuICAgICAgfSxcbiAgICAgIG11bHRCeVBvaW50OiBmdW5jdGlvbiBtdWx0QnlQb2ludCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX211bHRCeVBvaW50KHQpO1xuICAgICAgfSxcbiAgICAgIGRpdkJ5UG9pbnQ6IGZ1bmN0aW9uIGRpdkJ5UG9pbnQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZCeVBvaW50KHQpO1xuICAgICAgfSxcbiAgICAgIG11bHQ6IGZ1bmN0aW9uIG11bHQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KHQpO1xuICAgICAgfSxcbiAgICAgIGRpdjogZnVuY3Rpb24gZGl2KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KHQpO1xuICAgICAgfSxcbiAgICAgIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKHQpO1xuICAgICAgfSxcbiAgICAgIHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gcm90YXRlQXJvdW5kKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlQXJvdW5kKHQsIGUpO1xuICAgICAgfSxcbiAgICAgIG1hdE11bHQ6IGZ1bmN0aW9uIG1hdE11bHQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KHQpO1xuICAgICAgfSxcbiAgICAgIHVuaXQ6IGZ1bmN0aW9uIHVuaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTtcbiAgICAgIH0sXG4gICAgICBwZXJwOiBmdW5jdGlvbiBwZXJwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9wZXJwKCk7XG4gICAgICB9LFxuICAgICAgcm91bmQ6IGZ1bmN0aW9uIHJvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xuICAgICAgfSxcbiAgICAgIG1hZzogZnVuY3Rpb24gbWFnKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgICB9LFxuICAgICAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHModCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSB0LnggJiYgdGhpcy55ID09PSB0Lnk7XG4gICAgICB9LFxuICAgICAgZGlzdDogZnVuY3Rpb24gZGlzdCh0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0U3FyKHQpKTtcbiAgICAgIH0sXG4gICAgICBkaXN0U3FyOiBmdW5jdGlvbiBkaXN0U3FyKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LnggLSB0aGlzLngsXG4gICAgICAgICAgICByID0gdC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZSAqIGUgKyByICogcjtcbiAgICAgIH0sXG4gICAgICBhbmdsZTogZnVuY3Rpb24gYW5nbGUoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICAgIH0sXG4gICAgICBhbmdsZVRvOiBmdW5jdGlvbiBhbmdsZVRvKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gdC55LCB0aGlzLnggLSB0LngpO1xuICAgICAgfSxcbiAgICAgIGFuZ2xlV2l0aDogZnVuY3Rpb24gYW5nbGVXaXRoKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKHQueCwgdC55KTtcbiAgICAgIH0sXG4gICAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uIGFuZ2xlV2l0aFNlcCh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueCAqIGUgLSB0aGlzLnkgKiB0LCB0aGlzLnggKiB0ICsgdGhpcy55ICogZSk7XG4gICAgICB9LFxuICAgICAgX21hdE11bHQ6IGZ1bmN0aW9uIF9tYXRNdWx0KHQpIHtcbiAgICAgICAgdmFyIGUgPSB0WzJdICogdGhpcy54ICsgdFszXSAqIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IHRbMF0gKiB0aGlzLnggKyB0WzFdICogdGhpcy55LCB0aGlzLnkgPSBlLCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9hZGQ6IGZ1bmN0aW9uIF9hZGQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICs9IHQueCwgdGhpcy55ICs9IHQueSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfc3ViOiBmdW5jdGlvbiBfc3ViKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAtPSB0LngsIHRoaXMueSAtPSB0LnksIHRoaXM7XG4gICAgICB9LFxuICAgICAgX211bHQ6IGZ1bmN0aW9uIF9tdWx0KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqPSB0LCB0aGlzLnkgKj0gdCwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfZGl2OiBmdW5jdGlvbiBfZGl2KHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAvPSB0LCB0aGlzLnkgLz0gdCwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfbXVsdEJ5UG9pbnQ6IGZ1bmN0aW9uIF9tdWx0QnlQb2ludCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKj0gdC54LCB0aGlzLnkgKj0gdC55LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9kaXZCeVBvaW50OiBmdW5jdGlvbiBfZGl2QnlQb2ludCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLz0gdC54LCB0aGlzLnkgLz0gdC55LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF91bml0OiBmdW5jdGlvbiBfdW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpdih0aGlzLm1hZygpKSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcGVycDogZnVuY3Rpb24gX3BlcnAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy55O1xuICAgICAgICByZXR1cm4gdGhpcy55ID0gdGhpcy54LCB0aGlzLnggPSAtdCwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcm90YXRlOiBmdW5jdGlvbiBfcm90YXRlKHQpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNvcyh0KSxcbiAgICAgICAgICAgIHIgPSBNYXRoLnNpbih0KSxcbiAgICAgICAgICAgIG4gPSByICogdGhpcy54ICsgZSAqIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IGUgKiB0aGlzLnggLSByICogdGhpcy55LCB0aGlzLnkgPSBuLCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9yb3RhdGVBcm91bmQ6IGZ1bmN0aW9uIF9yb3RhdGVBcm91bmQodCwgZSkge1xuICAgICAgICB2YXIgciA9IE1hdGguY29zKHQpLFxuICAgICAgICAgICAgbiA9IE1hdGguc2luKHQpLFxuICAgICAgICAgICAgaSA9IGUueSArIG4gKiAodGhpcy54IC0gZS54KSArIHIgKiAodGhpcy55IC0gZS55KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IGUueCArIHIgKiAodGhpcy54IC0gZS54KSAtIG4gKiAodGhpcy55IC0gZS55KSwgdGhpcy55ID0gaSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcm91bmQ6IGZ1bmN0aW9uIF9yb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzO1xuICAgICAgfVxuICAgIH0sIGEuY29udmVydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIGEgPyB0IDogQXJyYXkuaXNBcnJheSh0KSA/IG5ldyBhKHRbMF0sIHRbMV0pIDogdDtcbiAgICB9O1xuICAgIHZhciBvID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB7fSxcbiAgICAgICAgcyA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgICBmdW5jdGlvbiB1KHQsIGUsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gbmV3IHIodCwgZSwgbiwgaSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGEuc29sdmUodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsID0gdSguMjUsIC4xLCAuMjUsIDEpO1xuXG4gICAgZnVuY3Rpb24gcCh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4ociwgTWF0aC5tYXgoZSwgdCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGModCwgZSwgcikge1xuICAgICAgdmFyIG4gPSByIC0gZSxcbiAgICAgICAgICBpID0gKCh0IC0gZSkgJSBuICsgbikgJSBuICsgZTtcbiAgICAgIHJldHVybiBpID09PSBlID8gciA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaCh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIHIgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgci0tID4gMDspIHtcbiAgICAgICAgZVtyXSA9IGFyZ3VtZW50c1tyICsgMV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuXG4gICAgICAgIGZvciAodmFyIG8gaW4gYSkge1xuICAgICAgICAgIHRbb10gPSBhW29dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIHZhciBmID0gMTtcblxuICAgIGZ1bmN0aW9uIHkoKSB7XG4gICAgICByZXR1cm4gZisrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdChlKSB7XG4gICAgICAgIHJldHVybiBlID8gKGUgXiAxNiAqIE1hdGgucmFuZG9tKCkgPj4gZSAvIDQpLnRvU3RyaW5nKDE2KSA6IChbMWU3XSArIC1bMWUzXSArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoL1swMThdL2csIHQpO1xuICAgICAgfSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG0odCkge1xuICAgICAgcmV0dXJuICEhdCAmJiAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVs0XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaS50ZXN0KHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHYodCwgZSkge1xuICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGVbdF0gJiYgKGVbdF0gPSBlW3RdLmJpbmQoZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZyh0LCBlKSB7XG4gICAgICByZXR1cm4gLTEgIT09IHQuaW5kZXhPZihlLCB0Lmxlbmd0aCAtIGUubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB4KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdCkge1xuICAgICAgICBuW2ldID0gZS5jYWxsKHIgfHwgdGhpcywgdFtpXSwgaSwgdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGIodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiB0KSB7XG4gICAgICAgIGUuY2FsbChyIHx8IHRoaXMsIHRbaV0sIGksIHQpICYmIChuW2ldID0gdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHcodCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0Lm1hcCh3KSA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgdCA/IHgodCwgdykgOiB0O1xuICAgIH1cblxuICAgIHZhciBfID0ge307XG5cbiAgICBmdW5jdGlvbiBBKHQpIHtcbiAgICAgIF9bdF0gfHwgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKHQpLCBfW3RdID0gITApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFModCwgZSwgcikge1xuICAgICAgcmV0dXJuIChyLnkgLSB0LnkpICogKGUueCAtIHQueCkgPiAoZS55IC0gdC55KSAqIChyLnggLSB0LngpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGsodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gdC5sZW5ndGgsIGkgPSBuIC0gMSwgYSA9IHZvaWQgMCwgbyA9IHZvaWQgMDsgciA8IG47IGkgPSByKyspIHtcbiAgICAgICAgZSArPSAoKG8gPSB0W2ldKS54IC0gKGEgPSB0W3JdKS54KSAqIChhLnkgKyBvLnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJKCkge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHoodCkge1xuICAgICAgdmFyIGUgPSB7fTtcblxuICAgICAgaWYgKHQucmVwbGFjZSgvKD86XnwoPzpcXHMqXFwsXFxzKikpKFteXFx4MDAtXFx4MjBcXChcXCk8PkBcXCw7XFw6XFxcXFwiXFwvXFxbXFxdXFw/XFw9XFx7XFx9XFx4N0ZdKykoPzpcXD0oPzooW15cXHgwMC1cXHgyMFxcKFxcKTw+QFxcLDtcXDpcXFxcXCJcXC9cXFtcXF1cXD9cXD1cXHtcXH1cXHg3Rl0rKXwoPzpcXFwiKCg/OlteXCJcXFxcXXxcXFxcLikqKVxcXCIpKSk/L2csIGZ1bmN0aW9uICh0LCByLCBuLCBpKSB7XG4gICAgICAgIHZhciBhID0gbiB8fCBpO1xuICAgICAgICByZXR1cm4gZVtyXSA9ICFhIHx8IGEudG9Mb3dlckNhc2UoKSwgXCJcIjtcbiAgICAgIH0pLCBlW1wibWF4LWFnZVwiXSkge1xuICAgICAgICB2YXIgciA9IHBhcnNlSW50KGVbXCJtYXgtYWdlXCJdLCAxMCk7XG4gICAgICAgIGlzTmFOKHIpID8gZGVsZXRlIGVbXCJtYXgtYWdlXCJdIDogZVtcIm1heC1hZ2VcIl0gPSByO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBFKHQpIHtcbiAgICAgIGlmIChudWxsID09IEMpIHtcbiAgICAgICAgdmFyIGUgPSB0Lm5hdmlnYXRvciA/IHQubmF2aWdhdG9yLnVzZXJBZ2VudCA6IG51bGw7XG4gICAgICAgIEMgPSAhIXQuc2FmYXJpIHx8ICEoIWUgfHwgISgvXFxiKGlQYWR8aVBob25lfGlQb2QpXFxiLy50ZXN0KGUpIHx8IGUubWF0Y2goXCJTYWZhcmlcIikgJiYgIWUubWF0Y2goXCJDaHJvbWVcIikpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUCh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZSA9IG9bdF07XG4gICAgICAgIHJldHVybiBlLnNldEl0ZW0oXCJfbWFwYm94X3Rlc3RfXCIsIDEpLCBlLnJlbW92ZUl0ZW0oXCJfbWFwYm94X3Rlc3RfXCIpLCAhMDtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBNLFxuICAgICAgICBCLFxuICAgICAgICBULFxuICAgICAgICBWLFxuICAgICAgICBGID0gby5wZXJmb3JtYW5jZSAmJiBvLnBlcmZvcm1hbmNlLm5vdyA/IG8ucGVyZm9ybWFuY2Uubm93LmJpbmQoby5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdy5iaW5kKERhdGUpLFxuICAgICAgICBEID0gby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgby5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgby53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgby5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgTCA9IG8uY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgby5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCBvLndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IG8ubXNDYW5jZWxBbmltYXRpb25GcmFtZSxcbiAgICAgICAgUiA9IHtcbiAgICAgIG5vdzogRixcbiAgICAgIGZyYW1lOiBmdW5jdGlvbiBmcmFtZSh0KSB7XG4gICAgICAgIHZhciBlID0gRCh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBMKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uIGdldEltYWdlRGF0YSh0LCBlKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApO1xuICAgICAgICB2YXIgciA9IG8uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgIG4gPSByLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyAyZCBjb250ZXh0XCIpO1xuICAgICAgICByZXR1cm4gci53aWR0aCA9IHQud2lkdGgsIHIuaGVpZ2h0ID0gdC5oZWlnaHQsIG4uZHJhd0ltYWdlKHQsIDAsIDAsIHQud2lkdGgsIHQuaGVpZ2h0KSwgbi5nZXRJbWFnZURhdGEoLWUsIC1lLCB0LndpZHRoICsgMiAqIGUsIHQuaGVpZ2h0ICsgMiAqIGUpO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVVUkw6IGZ1bmN0aW9uIHJlc29sdmVVUkwodCkge1xuICAgICAgICByZXR1cm4gTSB8fCAoTSA9IG8uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpLCBNLmhyZWYgPSB0LCBNLmhyZWY7XG4gICAgICB9LFxuICAgICAgaGFyZHdhcmVDb25jdXJyZW5jeTogby5uYXZpZ2F0b3IgJiYgby5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCA0LFxuXG4gICAgICBnZXQgZGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIG8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH0sXG5cbiAgICAgIGdldCBwcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhby5tYXRjaE1lZGlhICYmIChudWxsID09IEIgJiYgKEIgPSBvLm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKSksIEIubWF0Y2hlcyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgICAgICBPID0ge1xuICAgICAgQVBJX1VSTDogXCJodHRwczovL2FwaS5tYXBib3guY29tXCIsXG5cbiAgICAgIGdldCBFVkVOVFNfVVJMKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5BUElfVVJMID8gMCA9PT0gdGhpcy5BUElfVVJMLmluZGV4T2YoXCJodHRwczovL2FwaS5tYXBib3guY25cIikgPyBcImh0dHBzOi8vZXZlbnRzLm1hcGJveC5jbi9ldmVudHMvdjJcIiA6IDAgPT09IHRoaXMuQVBJX1VSTC5pbmRleE9mKFwiaHR0cHM6Ly9hcGkubWFwYm94LmNvbVwiKSA/IFwiaHR0cHM6Ly9ldmVudHMubWFwYm94LmNvbS9ldmVudHMvdjJcIiA6IG51bGwgOiBudWxsO1xuICAgICAgfSxcblxuICAgICAgRkVFREJBQ0tfVVJMOiBcImh0dHBzOi8vYXBwcy5tYXBib3guY29tL2ZlZWRiYWNrXCIsXG4gICAgICBSRVFVSVJFX0FDQ0VTU19UT0tFTjogITAsXG4gICAgICBBQ0NFU1NfVE9LRU46IG51bGwsXG4gICAgICBNQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFM6IDE2LFxuICAgICAgUkVHSVNURVJFRF9QUk9UT0NPTFM6IHt9XG4gICAgfSxcbiAgICAgICAgVSA9IHtcbiAgICAgIHN1cHBvcnRlZDogITEsXG4gICAgICB0ZXN0U3VwcG9ydDogZnVuY3Rpb24gdGVzdFN1cHBvcnQodCkge1xuICAgICAgICAhaiAmJiBWICYmIChxID8gTih0KSA6IFQgPSB0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBqID0gITEsXG4gICAgICAgIHEgPSAhMTtcblxuICAgIGZ1bmN0aW9uIE4odCkge1xuICAgICAgdmFyIGUgPSB0LmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELCBlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsIDAsIHQuUkdCQSwgdC5SR0JBLCB0LlVOU0lHTkVEX0JZVEUsIFYpLCB0LmlzQ29udGV4dExvc3QoKSkgcmV0dXJuO1xuICAgICAgICBVLnN1cHBvcnRlZCA9ICEwO1xuICAgICAgfSBjYXRjaCAodCkge31cblxuICAgICAgdC5kZWxldGVUZXh0dXJlKGUpLCBqID0gITA7XG4gICAgfVxuXG4gICAgby5kb2N1bWVudCAmJiAoKFYgPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIikpLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFQgJiYgTihUKSwgVCA9IG51bGwsIHEgPSAhMDtcbiAgICB9LCBWLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBqID0gITAsIFQgPSBudWxsO1xuICAgIH0sIFYuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaDRBQUFCWFJVSlFWbEE0VEJFQUFBQXZBUUFBQUFmUS8vNzN2LytCaU9oL0FBQT1cIik7XG5cbiAgICB2YXIgSyA9IFwiMDFcIixcbiAgICAgICAgRyA9IGZ1bmN0aW9uIEcodCwgZSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuID0gdCwgdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gPSBlLCB0aGlzLl9jcmVhdGVTa3VUb2tlbigpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBaKHQpIHtcbiAgICAgIHJldHVybiAwID09PSB0LmluZGV4T2YoXCJtYXBib3g6XCIpO1xuICAgIH1cblxuICAgIEcucHJvdG90eXBlLl9jcmVhdGVTa3VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0ID0gXCJcIiwgZSA9IDA7IGUgPCAxMDsgZSsrKSB7XG4gICAgICAgICAgdCArPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCJbTWF0aC5mbG9vcig2MiAqIE1hdGgucmFuZG9tKCkpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW46IFtcIjFcIiwgSywgdF0uam9pbihcIlwiKSxcbiAgICAgICAgICB0b2tlbkV4cGlyZXNBdDogRGF0ZS5ub3coKSArIDQzMmU1XG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIHRoaXMuX3NrdVRva2VuID0gdC50b2tlbiwgdGhpcy5fc2t1VG9rZW5FeHBpcmVzQXQgPSB0LnRva2VuRXhwaXJlc0F0O1xuICAgIH0sIEcucHJvdG90eXBlLl9pc1NrdVRva2VuRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpID4gdGhpcy5fc2t1VG9rZW5FeHBpcmVzQXQ7XG4gICAgfSwgRy5wcm90b3R5cGUudHJhbnNmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuICYmIHRoaXMuX3RyYW5zZm9ybVJlcXVlc3RGbih0LCBlKSB8fCB7XG4gICAgICAgIHVybDogdFxuICAgICAgfTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgcmV0dXJuIHIucGF0aCA9IFwiL3N0eWxlcy92MVwiICsgci5wYXRoLCB0aGlzLl9tYWtlQVBJVVJMKHIsIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IGUpO1xuICAgIH0sIEcucHJvdG90eXBlLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgcmV0dXJuIHIucGF0aCA9IFwiL2ZvbnRzL3YxXCIgKyByLnBhdGgsIHRoaXMuX21ha2VBUElVUkwociwgdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgZSk7XG4gICAgfSwgRy5wcm90b3R5cGUubm9ybWFsaXplU291cmNlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICghWih0KSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgciA9IFkodCk7XG4gICAgICByZXR1cm4gci5wYXRoID0gXCIvdjQvXCIgKyByLmF1dGhvcml0eSArIFwiLmpzb25cIiwgci5wYXJhbXMucHVzaChcInNlY3VyZVwiKSwgdGhpcy5fbWFrZUFQSVVSTChyLCB0aGlzLl9jdXN0b21BY2Nlc3NUb2tlbiB8fCBlKTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVTcHJpdGVVUkwgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBZKHQpO1xuICAgICAgcmV0dXJuIFoodCkgPyAoaS5wYXRoID0gXCIvc3R5bGVzL3YxXCIgKyBpLnBhdGggKyBcIi9zcHJpdGVcIiArIGUgKyByLCB0aGlzLl9tYWtlQVBJVVJMKGksIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IG4pKSA6IChpLnBhdGggKz0gXCJcIiArIGUgKyByLCAkKGkpKTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVUaWxlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NrdVRva2VuRXhwaXJlZCgpICYmIHRoaXMuX2NyZWF0ZVNrdVRva2VuKCksIHQgJiYgIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgci5wYXRoID0gci5wYXRoLnJlcGxhY2UoLyhcXC4ocG5nfGpwZylcXGQqKSg/PSQpLywgKFIuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyIHx8IDUxMiA9PT0gZSA/IFwiQDJ4XCIgOiBcIlwiKSArIChVLnN1cHBvcnRlZCA/IFwiLndlYnBcIiA6IFwiJDFcIikpLCByLnBhdGggPSByLnBhdGgucmVwbGFjZSgvXi4rXFwvdjRcXC8vLCBcIi9cIiksIHIucGF0aCA9IFwiL3Y0XCIgKyByLnBhdGg7XG5cbiAgICAgIHZhciBuID0gdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgIHZhciBuID0gcltlXS5tYXRjaCgvXmFjY2Vzc190b2tlbj0oLiopJC8pO1xuICAgICAgICAgIGlmIChuKSByZXR1cm4gblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfShyLnBhcmFtcykgfHwgTy5BQ0NFU1NfVE9LRU47XG5cbiAgICAgIHJldHVybiBPLlJFUVVJUkVfQUNDRVNTX1RPS0VOICYmIG4gJiYgdGhpcy5fc2t1VG9rZW4gJiYgci5wYXJhbXMucHVzaChcInNrdT1cIiArIHRoaXMuX3NrdVRva2VuKSwgdGhpcy5fbWFrZUFQSVVSTChyLCBuKTtcbiAgICB9LCBHLnByb3RvdHlwZS5jYW5vbmljYWxpemVUaWxlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gWSh0KTtcbiAgICAgIGlmICghci5wYXRoLm1hdGNoKC8oXlxcL3Y0XFwvKS8pIHx8ICFyLnBhdGgubWF0Y2goL1xcLltcXHddKyQvKSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgbiA9IFwibWFwYm94Oi8vdGlsZXMvXCI7XG4gICAgICBuICs9IHIucGF0aC5yZXBsYWNlKFwiL3Y0L1wiLCBcIlwiKTtcbiAgICAgIHZhciBpID0gci5wYXJhbXM7XG4gICAgICByZXR1cm4gZSAmJiAoaSA9IGkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAhdC5tYXRjaCgvXmFjY2Vzc190b2tlbj0vKTtcbiAgICAgIH0pKSwgaS5sZW5ndGggJiYgKG4gKz0gXCI/XCIgKyBpLmpvaW4oXCImXCIpKSwgbjtcbiAgICB9LCBHLnByb3RvdHlwZS5jYW5vbmljYWxpemVUaWxlc2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAhIWUgJiYgWihlKSwgbiA9IFtdLCBpID0gMCwgYSA9IHQudGlsZXMgfHwgW107IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgSihvKSA/IG4ucHVzaCh0aGlzLmNhbm9uaWNhbGl6ZVRpbGVVUkwobywgcikpIDogbi5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBHLnByb3RvdHlwZS5fbWFrZUFQSVVSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IFwiU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYXBpLWRvY3VtZW50YXRpb24vI2FjY2Vzcy10b2tlbnMtYW5kLXRva2VuLXNjb3Blc1wiLFxuICAgICAgICAgIG4gPSBZKE8uQVBJX1VSTCk7XG5cbiAgICAgIGlmICh0LnByb3RvY29sID0gbi5wcm90b2NvbCwgdC5hdXRob3JpdHkgPSBuLmF1dGhvcml0eSwgXCJodHRwXCIgPT09IHQucHJvdG9jb2wpIHtcbiAgICAgICAgdmFyIGkgPSB0LnBhcmFtcy5pbmRleE9mKFwic2VjdXJlXCIpO1xuICAgICAgICBpID49IDAgJiYgdC5wYXJhbXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCIvXCIgIT09IG4ucGF0aCAmJiAodC5wYXRoID0gXCJcIiArIG4ucGF0aCArIHQucGF0aCksICFPLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSByZXR1cm4gJCh0KTtcbiAgICAgIGlmICghKGUgPSBlIHx8IE8uQUNDRVNTX1RPS0VOKSkgdGhyb3cgbmV3IEVycm9yKFwiQW4gQVBJIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCB0byB1c2UgTWFwYm94IEdMLiBcIiArIHIpO1xuICAgICAgaWYgKFwic1wiID09PSBlWzBdKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgYSBwdWJsaWMgYWNjZXNzIHRva2VuIChway4qKSB3aXRoIE1hcGJveCBHTCwgbm90IGEgc2VjcmV0IGFjY2VzcyB0b2tlbiAoc2suKikuIFwiICsgcik7XG4gICAgICByZXR1cm4gdC5wYXJhbXMgPSB0LnBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIC0xID09PSB0LmluZGV4T2YoXCJhY2Nlc3NfdG9rZW5cIik7XG4gICAgICB9KSwgdC5wYXJhbXMucHVzaChcImFjY2Vzc190b2tlbj1cIiArIGUpLCAkKHQpO1xuICAgIH0sIEcucHJvdG90eXBlLnNldFRyYW5zZm9ybVJlcXVlc3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuID0gdDtcbiAgICB9O1xuICAgIHZhciBYID0gL14oKGh0dHBzPzopP1xcL1xcLyk/KFteXFwvXStcXC4pP21hcGJveFxcLmMobnxvbSkoXFwvfFxcP3wkKS9pO1xuXG4gICAgZnVuY3Rpb24gSih0KSB7XG4gICAgICByZXR1cm4gWC50ZXN0KHQpO1xuICAgIH1cblxuICAgIHZhciBIID0gL14oXFx3Kyk6XFwvXFwvKFteLz9dKikoXFwvW14/XSspP1xcPz8oLispPy87XG5cbiAgICBmdW5jdGlvbiBZKHQpIHtcbiAgICAgIHZhciBlID0gdC5tYXRjaChIKTtcbiAgICAgIGlmICghZSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIFVSTCBvYmplY3RcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm90b2NvbDogZVsxXSxcbiAgICAgICAgYXV0aG9yaXR5OiBlWzJdLFxuICAgICAgICBwYXRoOiBlWzNdIHx8IFwiL1wiLFxuICAgICAgICBwYXJhbXM6IGVbNF0gPyBlWzRdLnNwbGl0KFwiJlwiKSA6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQodCkge1xuICAgICAgdmFyIGUgPSB0LnBhcmFtcy5sZW5ndGggPyBcIj9cIiArIHQucGFyYW1zLmpvaW4oXCImXCIpIDogXCJcIjtcbiAgICAgIHJldHVybiB0LnByb3RvY29sICsgXCI6Ly9cIiArIHQuYXV0aG9yaXR5ICsgdC5wYXRoICsgZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXKHQpIHtcbiAgICAgIGlmICghdCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZSA9IHQuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKCFlIHx8IDMgIT09IGUubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KG8uYXRvYihlWzFdKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgdC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgICB9KS5qb2luKFwiXCIpKSk7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBRID0gZnVuY3Rpb24gUSh0KSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmFub25JZCA9IG51bGwsIHRoaXMuZXZlbnREYXRhID0ge30sIHRoaXMucXVldWUgPSBbXSwgdGhpcy5wZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIFEucHJvdG90eXBlLmdldFN0b3JhZ2VLZXkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgciA9IFcoTy5BQ0NFU1NfVE9LRU4pO1xuICAgICAgcmV0dXJuIGUgPSByICYmIHIudSA/IG8uYnRvYShlbmNvZGVVUklDb21wb25lbnQoci51KS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoXCIweFwiICsgZSkpO1xuICAgICAgfSkpIDogTy5BQ0NFU1NfVE9LRU4gfHwgXCJcIiwgdCA/IFwibWFwYm94LmV2ZW50RGF0YS5cIiArIHQgKyBcIjpcIiArIGUgOiBcIm1hcGJveC5ldmVudERhdGE6XCIgKyBlO1xuICAgIH0sIFEucHJvdG90eXBlLmZldGNoRXZlbnREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBQKFwibG9jYWxTdG9yYWdlXCIpLFxuICAgICAgICAgIGUgPSB0aGlzLmdldFN0b3JhZ2VLZXkoKSxcbiAgICAgICAgICByID0gdGhpcy5nZXRTdG9yYWdlS2V5KFwidXVpZFwiKTtcbiAgICAgIGlmICh0KSB0cnkge1xuICAgICAgICB2YXIgbiA9IG8ubG9jYWxTdG9yYWdlLmdldEl0ZW0oZSk7XG4gICAgICAgIG4gJiYgKHRoaXMuZXZlbnREYXRhID0gSlNPTi5wYXJzZShuKSk7XG4gICAgICAgIHZhciBpID0gby5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShyKTtcbiAgICAgICAgaSAmJiAodGhpcy5hbm9uSWQgPSBpKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgQShcIlVuYWJsZSB0byByZWFkIGZyb20gTG9jYWxTdG9yYWdlXCIpO1xuICAgICAgfVxuICAgIH0sIFEucHJvdG90eXBlLnNhdmVFdmVudERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFAoXCJsb2NhbFN0b3JhZ2VcIiksXG4gICAgICAgICAgZSA9IHRoaXMuZ2V0U3RvcmFnZUtleSgpLFxuICAgICAgICAgIHIgPSB0aGlzLmdldFN0b3JhZ2VLZXkoXCJ1dWlkXCIpO1xuICAgICAgaWYgKHQpIHRyeSB7XG4gICAgICAgIG8ubG9jYWxTdG9yYWdlLnNldEl0ZW0ociwgdGhpcy5hbm9uSWQpLCBPYmplY3Qua2V5cyh0aGlzLmV2ZW50RGF0YSkubGVuZ3RoID49IDEgJiYgby5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLCBKU09OLnN0cmluZ2lmeSh0aGlzLmV2ZW50RGF0YSkpO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICBBKFwiVW5hYmxlIHRvIHdyaXRlIHRvIExvY2FsU3RvcmFnZVwiKTtcbiAgICAgIH1cbiAgICB9LCBRLnByb3RvdHlwZS5wcm9jZXNzUmVxdWVzdHMgPSBmdW5jdGlvbiAodCkge30sIFEucHJvdG90eXBlLnBvc3RFdmVudCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHRoaXM7XG5cbiAgICAgIGlmIChPLkVWRU5UU19VUkwpIHtcbiAgICAgICAgdmFyIGEgPSBZKE8uRVZFTlRTX1VSTCk7XG4gICAgICAgIGEucGFyYW1zLnB1c2goXCJhY2Nlc3NfdG9rZW49XCIgKyAobiB8fCBPLkFDQ0VTU19UT0tFTiB8fCBcIlwiKSk7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgIGV2ZW50OiB0aGlzLnR5cGUsXG4gICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUodCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBzZGtJZGVudGlmaWVyOiBcIm1hcGJveC1nbC1qc1wiLFxuICAgICAgICAgIHNka1ZlcnNpb246IFwiMS4xNS4wXCIsXG4gICAgICAgICAgc2t1SWQ6IEssXG4gICAgICAgICAgdXNlcklkOiB0aGlzLmFub25JZFxuICAgICAgICB9LFxuICAgICAgICAgICAgcyA9IGUgPyBoKG8sIGUpIDogbyxcbiAgICAgICAgICAgIHUgPSB7XG4gICAgICAgICAgdXJsOiAkKGEpLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShbc10pXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3QgPSBfdCh1LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGkucGVuZGluZ1JlcXVlc3QgPSBudWxsLCByKHQpLCBpLnNhdmVFdmVudERhdGEoKSwgaS5wcm9jZXNzUmVxdWVzdHMobik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFEucHJvdG90eXBlLnF1ZXVlUmVxdWVzdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2godCksIHRoaXMucHJvY2Vzc1JlcXVlc3RzKGUpO1xuICAgIH07XG5cbiAgICB2YXIgdHQsXG4gICAgICAgIGV0LFxuICAgICAgICBydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmNhbGwodGhpcywgXCJtYXAubG9hZFwiKSwgdGhpcy5zdWNjZXNzID0ge30sIHRoaXMuc2t1VG9rZW4gPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5wb3N0TWFwTG9hZEV2ZW50ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdGhpcy5za3VUb2tlbiA9IHIsIChPLkVWRU5UU19VUkwgJiYgbiB8fCBPLkFDQ0VTU19UT0tFTiAmJiBBcnJheS5pc0FycmF5KHQpICYmIHQuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBaKHQpIHx8IEoodCk7XG4gICAgICAgIH0pKSAmJiB0aGlzLnF1ZXVlUmVxdWVzdCh7XG4gICAgICAgICAgaWQ6IGUsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0sIG4pO1xuICAgICAgfSwgZS5wcm90b3R5cGUucHJvY2Vzc1JlcXVlc3RzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nUmVxdWVzdCAmJiAwICE9PSB0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciByID0gdGhpcy5xdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICBuID0gci5pZCxcbiAgICAgICAgICAgICAgaSA9IHIudGltZXN0YW1wO1xuICAgICAgICAgIG4gJiYgdGhpcy5zdWNjZXNzW25dIHx8ICh0aGlzLmFub25JZCB8fCB0aGlzLmZldGNoRXZlbnREYXRhKCksIG0odGhpcy5hbm9uSWQpIHx8ICh0aGlzLmFub25JZCA9IGQoKSksIHRoaXMucG9zdEV2ZW50KGksIHtcbiAgICAgICAgICAgIHNrdVRva2VuOiB0aGlzLnNrdVRva2VuXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQgfHwgbiAmJiAoZS5zdWNjZXNzW25dID0gITApO1xuICAgICAgICAgIH0sIHQpKTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KFEpLFxuICAgICAgICBudCA9IG5ldyAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgXCJhcHBVc2VyVHVybnN0aWxlXCIpLCB0aGlzLl9jdXN0b21BY2Nlc3NUb2tlbiA9IGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnBvc3RUdXJuc3RpbGVFdmVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIE8uRVZFTlRTX1VSTCAmJiBPLkFDQ0VTU19UT0tFTiAmJiBBcnJheS5pc0FycmF5KHQpICYmIHQuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBaKHQpIHx8IEoodCk7XG4gICAgICAgIH0pICYmIHRoaXMucXVldWVSZXF1ZXN0KERhdGUubm93KCksIGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucHJvY2Vzc1JlcXVlc3RzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nUmVxdWVzdCAmJiAwICE9PSB0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYW5vbklkICYmIHRoaXMuZXZlbnREYXRhLmxhc3RTdWNjZXNzICYmIHRoaXMuZXZlbnREYXRhLnRva2VuVSB8fCB0aGlzLmZldGNoRXZlbnREYXRhKCk7XG4gICAgICAgICAgdmFyIHIgPSBXKE8uQUNDRVNTX1RPS0VOKSxcbiAgICAgICAgICAgICAgbiA9IHIgPyByLnUgOiBPLkFDQ0VTU19UT0tFTixcbiAgICAgICAgICAgICAgaSA9IG4gIT09IHRoaXMuZXZlbnREYXRhLnRva2VuVTtcbiAgICAgICAgICBtKHRoaXMuYW5vbklkKSB8fCAodGhpcy5hbm9uSWQgPSBkKCksIGkgPSAhMCk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5ldmVudERhdGEubGFzdFN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IERhdGUodGhpcy5ldmVudERhdGEubGFzdFN1Y2Nlc3MpLFxuICAgICAgICAgICAgICAgIHMgPSBuZXcgRGF0ZShhKSxcbiAgICAgICAgICAgICAgICB1ID0gKGEgLSB0aGlzLmV2ZW50RGF0YS5sYXN0U3VjY2VzcykgLyA4NjRlNTtcbiAgICAgICAgICAgIGkgPSBpIHx8IHUgPj0gMSB8fCB1IDwgLTEgfHwgby5nZXREYXRlKCkgIT09IHMuZ2V0RGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpID0gITA7XG5cbiAgICAgICAgICBpZiAoIWkpIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0cygpO1xuICAgICAgICAgIHRoaXMucG9zdEV2ZW50KGEsIHtcbiAgICAgICAgICAgIFwiZW5hYmxlZC50ZWxlbWV0cnlcIjogITFcbiAgICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdCB8fCAoZS5ldmVudERhdGEubGFzdFN1Y2Nlc3MgPSBhLCBlLmV2ZW50RGF0YS50b2tlblUgPSBuKTtcbiAgICAgICAgICB9LCB0KTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KFEpKSgpLFxuICAgICAgICBpdCA9IG50LnBvc3RUdXJuc3RpbGVFdmVudC5iaW5kKG50KSxcbiAgICAgICAgYXQgPSBuZXcgcnQoKSxcbiAgICAgICAgb3QgPSBhdC5wb3N0TWFwTG9hZEV2ZW50LmJpbmQoYXQpLFxuICAgICAgICBzdCA9IDUwMCxcbiAgICAgICAgdXQgPSA1MDtcblxuICAgIGZ1bmN0aW9uIGx0KCkge1xuICAgICAgby5jYWNoZXMgJiYgIXR0ICYmICh0dCA9IG8uY2FjaGVzLm9wZW4oXCJtYXBib3gtdGlsZXNcIikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB0KHQpIHtcbiAgICAgIHZhciBlID0gdC5pbmRleE9mKFwiP1wiKTtcbiAgICAgIHJldHVybiBlIDwgMCA/IHQgOiB0LnNsaWNlKDAsIGUpO1xuICAgIH1cblxuICAgIHZhciBjdCxcbiAgICAgICAgaHQgPSAxIC8gMDtcblxuICAgIGZ1bmN0aW9uIGZ0KCkge1xuICAgICAgcmV0dXJuIG51bGwgPT0gY3QgJiYgKGN0ID0gby5PZmZzY3JlZW5DYW52YXMgJiYgbmV3IG8uT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoXCIyZFwiKSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG8uY3JlYXRlSW1hZ2VCaXRtYXApLCBjdDtcbiAgICB9XG5cbiAgICB2YXIgeXQgPSB7XG4gICAgICBVbmtub3duOiBcIlVua25vd25cIixcbiAgICAgIFN0eWxlOiBcIlN0eWxlXCIsXG4gICAgICBTb3VyY2U6IFwiU291cmNlXCIsXG4gICAgICBUaWxlOiBcIlRpbGVcIixcbiAgICAgIEdseXBoczogXCJHbHlwaHNcIixcbiAgICAgIFNwcml0ZUltYWdlOiBcIlNwcml0ZUltYWdlXCIsXG4gICAgICBTcHJpdGVKU09OOiBcIlNwcml0ZUpTT05cIixcbiAgICAgIEltYWdlOiBcIkltYWdlXCJcbiAgICB9O1xuICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKHl0KTtcblxuICAgIHZhciBkdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIHIsIG4pIHtcbiAgICAgICAgNDAxID09PSByICYmIEoobikgJiYgKGUgKz0gXCI6IHlvdSBtYXkgaGF2ZSBwcm92aWRlZCBhbiBpbnZhbGlkIE1hcGJveCBhY2Nlc3MgdG9rZW4uIFNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2FwaS1kb2N1bWVudGF0aW9uLyNhY2Nlc3MtdG9rZW5zLWFuZC10b2tlbi1zY29wZXNcIiksIHQuY2FsbCh0aGlzLCBlKSwgdGhpcy5zdGF0dXMgPSByLCB0aGlzLnVybCA9IG4sIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZSwgdGhpcy5tZXNzYWdlID0gZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBcIiAoXCIgKyB0aGlzLnN0YXR1cyArIFwiKTogXCIgKyB0aGlzLnVybDtcbiAgICAgIH0sIGU7XG4gICAgfShFcnJvciksXG4gICAgICAgIG10ID0gSSgpID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYud29ya2VyICYmIHNlbGYud29ya2VyLnJlZmVycmVyO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKFwiYmxvYjpcIiA9PT0gby5sb2NhdGlvbi5wcm90b2NvbCA/IG8ucGFyZW50IDogbykubG9jYXRpb24uaHJlZjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdnQodCwgZSkge1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgbiA9IG5ldyBvLkFib3J0Q29udHJvbGxlcigpLFxuICAgICAgICAgIGkgPSBuZXcgby5SZXF1ZXN0KHQudXJsLCB7XG4gICAgICAgIG1ldGhvZDogdC5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgYm9keTogdC5ib2R5LFxuICAgICAgICBjcmVkZW50aWFsczogdC5jcmVkZW50aWFscyxcbiAgICAgICAgaGVhZGVyczogdC5oZWFkZXJzLFxuICAgICAgICByZWZlcnJlcjogbXQoKSxcbiAgICAgICAgc2lnbmFsOiBuLnNpZ25hbFxuICAgICAgfSksXG4gICAgICAgICAgYSA9ICExLFxuICAgICAgICAgIHMgPSAhMSxcbiAgICAgICAgICB1ID0gKHIgPSBpLnVybCkuaW5kZXhPZihcInNrdT1cIikgPiAwICYmIEoocik7XG4gICAgICBcImpzb25cIiA9PT0gdC50eXBlICYmIGkuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXG4gICAgICB2YXIgbCA9IGZ1bmN0aW9uIGwociwgbiwgYSkge1xuICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICBpZiAociAmJiBcIlNlY3VyaXR5RXJyb3JcIiAhPT0gci5tZXNzYWdlICYmIEEociksIG4gJiYgYSkgcmV0dXJuIHAobik7XG4gICAgICAgICAgdmFyIGwgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIG8uZmV0Y2goaSkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgaWYgKHIub2spIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSB1ID8gci5jbG9uZSgpIDogbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHAociwgbiwgbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlKG5ldyBkdChyLnN0YXR1c1RleHQsIHIuc3RhdHVzLCB0LnVybCkpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAyMCAhPT0gdC5jb2RlICYmIGUobmV3IEVycm9yKHQubWVzc2FnZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgICAgIHAgPSBmdW5jdGlvbiBwKHIsIG4sIHUpIHtcbiAgICAgICAgKFwiYXJyYXlCdWZmZXJcIiA9PT0gdC50eXBlID8gci5hcnJheUJ1ZmZlcigpIDogXCJqc29uXCIgPT09IHQudHlwZSA/IHIuanNvbigpIDogci50ZXh0KCkpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBzIHx8IChuICYmIHUgJiYgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICAgIGlmIChsdCgpLCB0dCkge1xuICAgICAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGUuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IGUuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgby5IZWFkZXJzKClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5oZWFkZXJzLnNldChlLCB0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBpID0geihlLmhlYWRlcnMuZ2V0KFwiQ2FjaGUtQ29udHJvbFwiKSB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgaVtcIm5vLXN0b3JlXCJdIHx8IChpW1wibWF4LWFnZVwiXSAmJiBuLmhlYWRlcnMuc2V0KFwiRXhwaXJlc1wiLCBuZXcgRGF0ZShyICsgMWUzICogaVtcIm1heC1hZ2VcIl0pLnRvVVRDU3RyaW5nKCkpLCBuZXcgRGF0ZShuLmhlYWRlcnMuZ2V0KFwiRXhwaXJlc1wiKSkuZ2V0VGltZSgpIC0gciA8IDQyZTQgfHwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBldCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIG5ldyBSZXNwb25zZShuZXcgUmVhZGFibGVTdHJlYW0oKSksIGV0ID0gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgZXQgPSAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXQgPyBlKHQuYm9keSkgOiB0LmJsb2IoKS50aGVuKGUpO1xuICAgICAgICAgICAgICB9KGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgby5SZXNwb25zZShlLCBuKTtcbiAgICAgICAgICAgICAgICBsdCgpLCB0dCAmJiB0dC50aGVuKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5wdXQocHQodC51cmwpLCByKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEEodC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oaSwgbiwgdSksIGEgPSAhMCwgZShudWxsLCB0LCByLmhlYWRlcnMuZ2V0KFwiQ2FjaGUtQ29udHJvbFwiKSwgci5oZWFkZXJzLmdldChcIkV4cGlyZXNcIikpKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBzIHx8IGUobmV3IEVycm9yKHQubWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB1ID8gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKGx0KCksICF0dCkgcmV0dXJuIGUobnVsbCk7XG4gICAgICAgIHZhciByID0gcHQodC51cmwpO1xuICAgICAgICB0dC50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC5tYXRjaChyKS50aGVuKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICB2YXIgZSA9IG5ldyBEYXRlKHQuaGVhZGVycy5nZXQoXCJFeHBpcmVzXCIpIHx8IDApLFxuICAgICAgICAgICAgICAgICAgciA9IHoodC5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIikgfHwgXCJcIik7XG4gICAgICAgICAgICAgIHJldHVybiBlID4gRGF0ZS5ub3coKSAmJiAhcltcIm5vLWNhY2hlXCJdO1xuICAgICAgICAgICAgfShuKTtcblxuICAgICAgICAgICAgdC5kZWxldGUociksIGkgJiYgdC5wdXQociwgbi5jbG9uZSgpKSwgZShudWxsLCBuLCBpKTtcbiAgICAgICAgICB9KS5jYXRjaChlKTtcbiAgICAgICAgfSkuY2F0Y2goZSk7XG4gICAgICB9KGksIGwpIDogbChudWxsLCBudWxsKSwge1xuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICBzID0gITAsIGEgfHwgbi5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBndCxcbiAgICAgICAgeHQsXG4gICAgICAgIGJ0ID0gZnVuY3Rpb24gYnQodCwgZSkge1xuICAgICAgaWYgKC86XFwvXFwvLy50ZXN0KHQudXJsKSAmJiAhL15odHRwcz86fF5maWxlOi8udGVzdCh0LnVybCkpIHtcbiAgICAgICAgaWYgKEkoKSAmJiBzZWxmLndvcmtlciAmJiBzZWxmLndvcmtlci5hY3RvcikgcmV0dXJuIHNlbGYud29ya2VyLmFjdG9yLnNlbmQoXCJnZXRSZXNvdXJjZVwiLCB0LCBlKTtcblxuICAgICAgICBpZiAoIUkoKSkge1xuICAgICAgICAgIHZhciByID0gdC51cmwuc3Vic3RyaW5nKDAsIHQudXJsLmluZGV4T2YoXCI6Ly9cIikpO1xuICAgICAgICAgIHJldHVybiAoTy5SRUdJU1RFUkVEX1BST1RPQ09MU1tyXSB8fCB2dCkodCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCEoL15maWxlOi8udGVzdChuID0gdC51cmwpIHx8IC9eZmlsZTovLnRlc3QobXQoKSkgJiYgIS9eXFx3KzovLnRlc3QobikpKSB7XG4gICAgICAgIGlmIChvLmZldGNoICYmIG8uUmVxdWVzdCAmJiBvLkFib3J0Q29udHJvbGxlciAmJiBvLlJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwic2lnbmFsXCIpKSByZXR1cm4gdnQodCwgZSk7XG4gICAgICAgIGlmIChJKCkgJiYgc2VsZi53b3JrZXIgJiYgc2VsZi53b3JrZXIuYWN0b3IpIHJldHVybiBzZWxmLndvcmtlci5hY3Rvci5zZW5kKFwiZ2V0UmVzb3VyY2VcIiwgdCwgZSwgdm9pZCAwLCAhMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gbmV3IG8uWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICBmb3IgKHZhciBuIGluIHIub3Blbih0Lm1ldGhvZCB8fCBcIkdFVFwiLCB0LnVybCwgITApLCBcImFycmF5QnVmZmVyXCIgPT09IHQudHlwZSAmJiAoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCIpLCB0LmhlYWRlcnMpIHtcbiAgICAgICAgICByLnNldFJlcXVlc3RIZWFkZXIobiwgdC5oZWFkZXJzW25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcImpzb25cIiA9PT0gdC50eXBlICYmIChyLnJlc3BvbnNlVHlwZSA9IFwidGV4dFwiLCByLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpKSwgci53aXRoQ3JlZGVudGlhbHMgPSBcImluY2x1ZGVcIiA9PT0gdC5jcmVkZW50aWFscywgci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUobmV3IEVycm9yKHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9LCByLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoKHIuc3RhdHVzID49IDIwMCAmJiByLnN0YXR1cyA8IDMwMCB8fCAwID09PSByLnN0YXR1cykgJiYgbnVsbCAhPT0gci5yZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIG4gPSByLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKFwianNvblwiID09PSB0LnR5cGUpIHRyeSB7XG4gICAgICAgICAgICAgIG4gPSBKU09OLnBhcnNlKHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gZSh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUobnVsbCwgbiwgci5nZXRSZXNwb25zZUhlYWRlcihcIkNhY2hlLUNvbnRyb2xcIiksIHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJFeHBpcmVzXCIpKTtcbiAgICAgICAgICB9IGVsc2UgZShuZXcgZHQoci5zdGF0dXNUZXh0LCByLnN0YXR1cywgdC51cmwpKTtcbiAgICAgICAgfSwgci5zZW5kKHQuYm9keSksIHtcbiAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiByLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSh0LCBlKTtcbiAgICB9LFxuICAgICAgICB3dCA9IGZ1bmN0aW9uIHd0KHQsIGUpIHtcbiAgICAgIHJldHVybiBidChoKHQsIHtcbiAgICAgICAgdHlwZTogXCJhcnJheUJ1ZmZlclwiXG4gICAgICB9KSwgZSk7XG4gICAgfSxcbiAgICAgICAgX3QgPSBmdW5jdGlvbiBfdCh0LCBlKSB7XG4gICAgICByZXR1cm4gYnQoaCh0LCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgICAgIH0pLCBlKTtcbiAgICB9LFxuICAgICAgICBBdCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQUMwbEVRVlFZVjJOZ0FBSUFBQVVBQWFyVnlGRUFBQUFBU1VWT1JLNUNZSUk9XCI7XG5cbiAgICBndCA9IFtdLCB4dCA9IDA7XG5cbiAgICB2YXIgU3QgPSBmdW5jdGlvbiBTdCh0LCBlKSB7XG4gICAgICBpZiAoVS5zdXBwb3J0ZWQgJiYgKHQuaGVhZGVycyB8fCAodC5oZWFkZXJzID0ge30pLCB0LmhlYWRlcnMuYWNjZXB0ID0gXCJpbWFnZS93ZWJwLCovKlwiKSwgeHQgPj0gTy5NQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFMpIHtcbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtZXRlcnM6IHQsXG4gICAgICAgICAgY2FsbGJhY2s6IGUsXG4gICAgICAgICAgY2FuY2VsbGVkOiAhMSxcbiAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3QucHVzaChyKSwgcjtcbiAgICAgIH1cblxuICAgICAgeHQrKztcblxuICAgICAgdmFyIG4gPSAhMSxcbiAgICAgICAgICBpID0gZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgaWYgKCFuKSBmb3IgKG4gPSAhMCwgeHQtLTsgZ3QubGVuZ3RoICYmIHh0IDwgTy5NQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFM7KSB7XG4gICAgICAgICAgdmFyIHQgPSBndC5zaGlmdCgpO1xuICAgICAgICAgIHQuY2FuY2VsbGVkIHx8ICh0LmNhbmNlbCA9IFN0KHQucmVxdWVzdFBhcmFtZXRlcnMsIHQuY2FsbGJhY2spLmNhbmNlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAgICAgYSA9IHd0KHQsIGZ1bmN0aW9uICh0LCByLCBuLCBhKSB7XG4gICAgICAgIGkoKSwgdCA/IGUodCkgOiByICYmIChmdCgpID8gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IG5ldyBvLkJsb2IoW25ldyBVaW50OEFycmF5KHQpXSwge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG8uY3JlYXRlSW1hZ2VCaXRtYXAocikudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZShudWxsLCB0KTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZShuZXcgRXJyb3IoXCJDb3VsZCBub3QgbG9hZCBpbWFnZSBiZWNhdXNlIG9mIFwiICsgdC5tZXNzYWdlICsgXCIuIFBsZWFzZSBtYWtlIHN1cmUgdG8gdXNlIGEgc3VwcG9ydGVkIGltYWdlIHR5cGUgc3VjaCBhcyBQTkcgb3IgSlBFRy4gTm90ZSB0aGF0IFNWR3MgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfShyLCBlKSA6IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgICAgdmFyIGkgPSBuZXcgby5JbWFnZSgpLFxuICAgICAgICAgICAgICBhID0gby5VUkw7XG4gICAgICAgICAgaS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlKG51bGwsIGkpLCBhLnJldm9rZU9iamVjdFVSTChpLnNyYyksIGkub25sb2FkID0gbnVsbCwgby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpLnNyYyA9IEF0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgaS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGUobmV3IEVycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2UuIFBsZWFzZSBtYWtlIHN1cmUgdG8gdXNlIGEgc3VwcG9ydGVkIGltYWdlIHR5cGUgc3VjaCBhcyBQTkcgb3IgSlBFRy4gTm90ZSB0aGF0IFNWR3MgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBzID0gbmV3IG8uQmxvYihbbmV3IFVpbnQ4QXJyYXkodCldLCB7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlL3BuZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaS5jYWNoZUNvbnRyb2wgPSByLCBpLmV4cGlyZXMgPSBuLCBpLnNyYyA9IHQuYnl0ZUxlbmd0aCA/IGEuY3JlYXRlT2JqZWN0VVJMKHMpIDogQXQ7XG4gICAgICAgIH0ociwgZSwgbiwgYSkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgIGEuY2FuY2VsKCksIGkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24ga3QodCwgZSwgcikge1xuICAgICAgclt0XSAmJiAtMSAhPT0gclt0XS5pbmRleE9mKGUpIHx8IChyW3RdID0gclt0XSB8fCBbXSwgclt0XS5wdXNoKGUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJdCh0LCBlLCByKSB7XG4gICAgICBpZiAociAmJiByW3RdKSB7XG4gICAgICAgIHZhciBuID0gclt0XS5pbmRleE9mKGUpO1xuICAgICAgICAtMSAhPT0gbiAmJiByW3RdLnNwbGljZShuLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgenQgPSBmdW5jdGlvbiB6dCh0LCBlKSB7XG4gICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB7fSksIGgodGhpcywgZSksIHRoaXMudHlwZSA9IHQ7XG4gICAgfSxcbiAgICAgICAgQ3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgdC5jYWxsKHRoaXMsIFwiZXJyb3JcIiwgaCh7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSwgcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlO1xuICAgIH0oenQpLFxuICAgICAgICBFdCA9IGZ1bmN0aW9uIEV0KCkge307XG5cbiAgICBFdC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCB7fSwga3QodCwgZSwgdGhpcy5fbGlzdGVuZXJzKSwgdGhpcztcbiAgICB9LCBFdC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiBJdCh0LCBlLCB0aGlzLl9saXN0ZW5lcnMpLCBJdCh0LCBlLCB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzKSwgdGhpcztcbiAgICB9LCBFdC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25lVGltZUxpc3RlbmVycyA9IHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMgfHwge30sIGt0KHQsIGUsIHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMpLCB0aGlzO1xuICAgIH0sIEV0LnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKHQgPSBuZXcgenQodCwgZSB8fCB7fSkpO1xuICAgICAgdmFyIHIgPSB0LnR5cGU7XG5cbiAgICAgIGlmICh0aGlzLmxpc3RlbnMocikpIHtcbiAgICAgICAgdC50YXJnZXQgPSB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1tyXSA/IHRoaXMuX2xpc3RlbmVyc1tyXS5zbGljZSgpIDogW107IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgaVtuXS5jYWxsKHRoaXMsIHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYSA9IDAsIG8gPSB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzICYmIHRoaXMuX29uZVRpbWVMaXN0ZW5lcnNbcl0gPyB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzW3JdLnNsaWNlKCkgOiBbXTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICB2YXIgcyA9IG9bYV07XG4gICAgICAgICAgSXQociwgcywgdGhpcy5fb25lVGltZUxpc3RlbmVycyksIHMuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1ID0gdGhpcy5fZXZlbnRlZFBhcmVudDtcbiAgICAgICAgdSAmJiAoaCh0LCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMuX2V2ZW50ZWRQYXJlbnREYXRhID8gdGhpcy5fZXZlbnRlZFBhcmVudERhdGEoKSA6IHRoaXMuX2V2ZW50ZWRQYXJlbnREYXRhKSwgdS5maXJlKHQpKTtcbiAgICAgIH0gZWxzZSB0IGluc3RhbmNlb2YgQ3QgJiYgY29uc29sZS5lcnJvcih0LmVycm9yKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgRXQucHJvdG90eXBlLmxpc3RlbnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbdF0gJiYgdGhpcy5fbGlzdGVuZXJzW3RdLmxlbmd0aCA+IDAgfHwgdGhpcy5fb25lVGltZUxpc3RlbmVycyAmJiB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzW3RdICYmIHRoaXMuX29uZVRpbWVMaXN0ZW5lcnNbdF0ubGVuZ3RoID4gMCB8fCB0aGlzLl9ldmVudGVkUGFyZW50ICYmIHRoaXMuX2V2ZW50ZWRQYXJlbnQubGlzdGVucyh0KTtcbiAgICB9LCBFdC5wcm90b3R5cGUuc2V0RXZlbnRlZFBhcmVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXZlbnRlZFBhcmVudCA9IHQsIHRoaXMuX2V2ZW50ZWRQYXJlbnREYXRhID0gZSwgdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIFB0ID0ge1xuICAgICAgJHZlcnNpb246IDgsXG4gICAgICAkcm9vdDoge1xuICAgICAgICB2ZXJzaW9uOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczogWzhdXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIGJlYXJpbmc6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgcGVyaW9kOiAzNjAsXG4gICAgICAgICAgdW5pdHM6IFwiZGVncmVlc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHBpdGNoOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIlxuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgIHR5cGU6IFwibGlnaHRcIlxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VzOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwic291cmNlc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZToge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgZ2x5cGhzOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgdHlwZTogXCJ0cmFuc2l0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJsYXllclwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3VyY2VzOiB7XG4gICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgdHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc291cmNlOiBbXCJzb3VyY2VfdmVjdG9yXCIsIFwic291cmNlX3Jhc3RlclwiLCBcInNvdXJjZV9yYXN0ZXJfZGVtXCIsIFwic291cmNlX2dlb2pzb25cIiwgXCJzb3VyY2VfdmlkZW9cIiwgXCJzb3VyY2VfaW1hZ2VcIl0sXG4gICAgICBzb3VyY2VfdmVjdG9yOiB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2ZWN0b3I6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVzOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGJvdW5kczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgZGVmYXVsdDogWy0xODAsIC04NS4wNTExMjksIDE4MCwgODUuMDUxMTI5XVxuICAgICAgICB9LFxuICAgICAgICBzY2hlbWU6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHh5ejoge30sXG4gICAgICAgICAgICB0bXM6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInh5elwiXG4gICAgICAgIH0sXG4gICAgICAgIG1pbnpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbWF4em9vbToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMjJcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRpb246IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIHByb21vdGVJZDoge1xuICAgICAgICAgIHR5cGU6IFwicHJvbW90ZUlkXCJcbiAgICAgICAgfSxcbiAgICAgICAgdm9sYXRpbGU6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICB9LFxuICAgICAgICBcIipcIjoge1xuICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3VyY2VfcmFzdGVyOiB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICByYXN0ZXI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVzOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGJvdW5kczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgZGVmYXVsdDogWy0xODAsIC04NS4wNTExMjksIDE4MCwgODUuMDUxMTI5XVxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1heHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDIyXG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVTaXplOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiA1MTIsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZW1lOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB4eXo6IHt9LFxuICAgICAgICAgICAgdG1zOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ4eXpcIlxuICAgICAgICB9LFxuICAgICAgICBhdHRyaWJ1dGlvbjoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgdm9sYXRpbGU6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICB9LFxuICAgICAgICBcIipcIjoge1xuICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzb3VyY2VfcmFzdGVyX2RlbToge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgXCJyYXN0ZXItZGVtXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVzOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGJvdW5kczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgZGVmYXVsdDogWy0xODAsIC04NS4wNTExMjksIDE4MCwgODUuMDUxMTI5XVxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1heHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDIyXG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVTaXplOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiA1MTIsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCJcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRpb246IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVuY29kaW5nOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB0ZXJyYXJpdW06IHt9LFxuICAgICAgICAgICAgbWFwYm94OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBib3hcIlxuICAgICAgICB9LFxuICAgICAgICB2b2xhdGlsZToge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExXG4gICAgICAgIH0sXG4gICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvdXJjZV9nZW9qc29uOiB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBnZW9qc29uOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgIG1heHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDE4XG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0aW9uOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBidWZmZXI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEyOCxcbiAgICAgICAgICBtYXhpbXVtOiA1MTIsXG4gICAgICAgICAgbWluaW11bTogMFxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICB9LFxuICAgICAgICB0b2xlcmFuY2U6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IC4zNzVcbiAgICAgICAgfSxcbiAgICAgICAgY2x1c3Rlcjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExXG4gICAgICAgIH0sXG4gICAgICAgIGNsdXN0ZXJSYWRpdXM6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDUwLFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfSxcbiAgICAgICAgY2x1c3Rlck1heFpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsdXN0ZXJNaW5Qb2ludHM6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsdXN0ZXJQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgfSxcbiAgICAgICAgbGluZU1ldHJpY3M6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICB9LFxuICAgICAgICBnZW5lcmF0ZUlkOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITFcbiAgICAgICAgfSxcbiAgICAgICAgcHJvbW90ZUlkOiB7XG4gICAgICAgICAgdHlwZTogXCJwcm9tb3RlSWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc291cmNlX3ZpZGVvOiB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aWRlbzoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVybHM6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc291cmNlX2ltYWdlOiB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBpbWFnZToge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVybDoge1xuICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGF5ZXI6IHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIHJlcXVpcmVkOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBmaWxsOiB7fSxcbiAgICAgICAgICAgIGxpbmU6IHt9LFxuICAgICAgICAgICAgc3ltYm9sOiB7fSxcbiAgICAgICAgICAgIGNpcmNsZToge30sXG4gICAgICAgICAgICBoZWF0bWFwOiB7fSxcbiAgICAgICAgICAgIFwiZmlsbC1leHRydXNpb25cIjoge30sXG4gICAgICAgICAgICByYXN0ZXI6IHt9LFxuICAgICAgICAgICAgaGlsbHNoYWRlOiB7fSxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogITBcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic291cmNlLWxheWVyXCI6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1pbnpvb206IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMjRcbiAgICAgICAgfSxcbiAgICAgICAgbWF4em9vbToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAyNFxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBcImZpbHRlclwiXG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIHR5cGU6IFwibGF5b3V0XCJcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInBhaW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheW91dDogW1wibGF5b3V0X2ZpbGxcIiwgXCJsYXlvdXRfbGluZVwiLCBcImxheW91dF9jaXJjbGVcIiwgXCJsYXlvdXRfaGVhdG1hcFwiLCBcImxheW91dF9maWxsLWV4dHJ1c2lvblwiLCBcImxheW91dF9zeW1ib2xcIiwgXCJsYXlvdXRfcmFzdGVyXCIsIFwibGF5b3V0X2hpbGxzaGFkZVwiLCBcImxheW91dF9iYWNrZ3JvdW5kXCJdLFxuICAgICAgbGF5b3V0X2JhY2tncm91bmQ6IHtcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGF5b3V0X2ZpbGw6IHtcbiAgICAgICAgXCJmaWxsLXNvcnQta2V5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXlvdXRfY2lyY2xlOiB7XG4gICAgICAgIFwiY2lyY2xlLXNvcnQta2V5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXlvdXRfaGVhdG1hcDoge1xuICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImxheW91dF9maWxsLWV4dHJ1c2lvblwiOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheW91dF9saW5lOiB7XG4gICAgICAgIFwibGluZS1jYXBcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgYnV0dDoge30sXG4gICAgICAgICAgICByb3VuZDoge30sXG4gICAgICAgICAgICBzcXVhcmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImJ1dHRcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1qb2luXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGJldmVsOiB7fSxcbiAgICAgICAgICAgIHJvdW5kOiB7fSxcbiAgICAgICAgICAgIG1pdGVyOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtaXRlclwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtbWl0ZXItbGltaXRcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMixcbiAgICAgICAgICByZXF1aXJlczogW3tcbiAgICAgICAgICAgIFwibGluZS1qb2luXCI6IFwibWl0ZXJcIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLXJvdW5kLWxpbWl0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEuMDUsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcImxpbmUtam9pblwiOiBcInJvdW5kXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1zb3J0LWtleVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGF5b3V0X3N5bWJvbDoge1xuICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgcG9pbnQ6IHt9LFxuICAgICAgICAgICAgbGluZToge30sXG4gICAgICAgICAgICBcImxpbmUtY2VudGVyXCI6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInBvaW50XCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInN5bWJvbC1zcGFjaW5nXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDI1MCxcbiAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInN5bWJvbC1zb3J0LWtleVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzeW1ib2wtei1vcmRlclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBhdXRvOiB7fSxcbiAgICAgICAgICAgIFwidmlld3BvcnQteVwiOiB7fSxcbiAgICAgICAgICAgIHNvdXJjZToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwiYXV0b1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiLCBcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge30sXG4gICAgICAgICAgICBhdXRvOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tc2l6ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdW5pdHM6IFwiZmFjdG9yIG9mIHRoZSBvcmlnaW5hbCBpY29uIHNpemVcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXRleHQtZml0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG5vbmU6IHt9LFxuICAgICAgICAgICAgd2lkdGg6IHt9LFxuICAgICAgICAgICAgaGVpZ2h0OiB7fSxcbiAgICAgICAgICAgIGJvdGg6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm5vbmVcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiLCBcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiBbXCJib3RoXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgICAgICAgdG9rZW5zOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwge1xuICAgICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLW9mZnNldFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgY2VudGVyOiB7fSxcbiAgICAgICAgICAgIGxlZnQ6IHt9LFxuICAgICAgICAgICAgcmlnaHQ6IHt9LFxuICAgICAgICAgICAgdG9wOiB7fSxcbiAgICAgICAgICAgIGJvdHRvbToge30sXG4gICAgICAgICAgICBcInRvcC1sZWZ0XCI6IHt9LFxuICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjoge30sXG4gICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgICAgICAgXCJib3R0b20tcmlnaHRcIjoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1waXRjaC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgICAgICAgIGF1dG86IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgICAgICAgIGF1dG86IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgICAgICAgIGF1dG86IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1maWVsZFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtYXR0ZWRcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIlwiLFxuICAgICAgICAgIHRva2VuczogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1mb250XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZGVmYXVsdDogW1wiT3BlbiBTYW5zIFJlZ3VsYXJcIiwgXCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIl0sXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1zaXplXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDE2LFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1tYXgtd2lkdGhcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMTAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB1bml0czogXCJlbXNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEuMixcbiAgICAgICAgICB1bml0czogXCJlbXNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1sZXR0ZXItc3BhY2luZ1wiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIHVuaXRzOiBcImVtc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtanVzdGlmeVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBhdXRvOiB7fSxcbiAgICAgICAgICAgIGxlZnQ6IHt9LFxuICAgICAgICAgICAgY2VudGVyOiB7fSxcbiAgICAgICAgICAgIHJpZ2h0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJjZW50ZXJcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICBsZWZ0OiB7fSxcbiAgICAgICAgICAgIHJpZ2h0OiB7fSxcbiAgICAgICAgICAgIHRvcDoge30sXG4gICAgICAgICAgICBib3R0b206IHt9LFxuICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiB7fSxcbiAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IHt9LFxuICAgICAgICAgICAgXCJib3R0b20tbGVmdFwiOiB7fSxcbiAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wicG9pbnRcIl1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgY2VudGVyOiB7fSxcbiAgICAgICAgICAgIGxlZnQ6IHt9LFxuICAgICAgICAgICAgcmlnaHQ6IHt9LFxuICAgICAgICAgICAgdG9wOiB7fSxcbiAgICAgICAgICAgIGJvdHRvbToge30sXG4gICAgICAgICAgICBcInRvcC1sZWZ0XCI6IHt9LFxuICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjoge30sXG4gICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgICAgICAgXCJib3R0b20tcmlnaHRcIjoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgXCIhXCI6IFwidGV4dC12YXJpYWJsZS1hbmNob3JcIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtbWF4LWFuZ2xlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDQ1LFxuICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wibGluZVwiLCBcImxpbmUtY2VudGVyXCJdXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtd3JpdGluZy1tb2RlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDoge30sXG4gICAgICAgICAgICB2ZXJ0aWNhbDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXCJwb2ludFwiXVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXJvdGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWtlZXAtdXByaWdodFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVmYXVsdDogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBub25lOiB7fSxcbiAgICAgICAgICAgIHVwcGVyY2FzZToge30sXG4gICAgICAgICAgICBsb3dlcmNhc2U6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm5vbmVcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LW9mZnNldFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIHVuaXRzOiBcImVtc1wiLFxuICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgXCIhXCI6IFwidGV4dC1yYWRpYWwtb2Zmc2V0XCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCBcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXlvdXRfcmFzdGVyOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheW91dF9oaWxsc2hhZGU6IHtcbiAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgdmFsdWU6IFwiKlwiXG4gICAgICB9LFxuICAgICAgZmlsdGVyX29wZXJhdG9yOiB7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICBcIj09XCI6IHt9LFxuICAgICAgICAgIFwiIT1cIjoge30sXG4gICAgICAgICAgXCI+XCI6IHt9LFxuICAgICAgICAgIFwiPj1cIjoge30sXG4gICAgICAgICAgXCI8XCI6IHt9LFxuICAgICAgICAgIFwiPD1cIjoge30sXG4gICAgICAgICAgaW46IHt9LFxuICAgICAgICAgIFwiIWluXCI6IHt9LFxuICAgICAgICAgIGFsbDoge30sXG4gICAgICAgICAgYW55OiB7fSxcbiAgICAgICAgICBub25lOiB7fSxcbiAgICAgICAgICBoYXM6IHt9LFxuICAgICAgICAgIFwiIWhhc1wiOiB7fSxcbiAgICAgICAgICB3aXRoaW46IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeV90eXBlOiB7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICBQb2ludDoge30sXG4gICAgICAgICAgTGluZVN0cmluZzoge30sXG4gICAgICAgICAgUG9seWdvbjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICB0eXBlOiBcImV4cHJlc3Npb25cIlxuICAgICAgICB9LFxuICAgICAgICBzdG9wczoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJmdW5jdGlvbl9zdG9wXCJcbiAgICAgICAgfSxcbiAgICAgICAgYmFzZToge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiR6b29tXCJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaWRlbnRpdHk6IHt9LFxuICAgICAgICAgICAgZXhwb25lbnRpYWw6IHt9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IHt9LFxuICAgICAgICAgICAgY2F0ZWdvcmljYWw6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImV4cG9uZW50aWFsXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JTcGFjZToge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgcmdiOiB7fSxcbiAgICAgICAgICAgIGxhYjoge30sXG4gICAgICAgICAgICBoY2w6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInJnYlwiXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB0eXBlOiBcIipcIixcbiAgICAgICAgICByZXF1aXJlZDogITFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uX3N0b3A6IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICBtYXhpbXVtOiAyNCxcbiAgICAgICAgdmFsdWU6IFtcIm51bWJlclwiLCBcImNvbG9yXCJdLFxuICAgICAgICBsZW5ndGg6IDJcbiAgICAgIH0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgdmFsdWU6IFwiKlwiLFxuICAgICAgICBtaW5pbXVtOiAxXG4gICAgICB9LFxuICAgICAgbGlnaHQ6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCJ2aWV3cG9ydFwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBkZWZhdWx0OiBbMS4xNSwgMjEwLCAzMF0sXG4gICAgICAgICAgbGVuZ3RoOiAzLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiI2ZmZmZmZlwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMFxuICAgICAgICB9LFxuICAgICAgICBpbnRlbnNpdHk6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICAgICAgICBkZWZhdWx0OiAuNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludDogW1wicGFpbnRfZmlsbFwiLCBcInBhaW50X2xpbmVcIiwgXCJwYWludF9jaXJjbGVcIiwgXCJwYWludF9oZWF0bWFwXCIsIFwicGFpbnRfZmlsbC1leHRydXNpb25cIiwgXCJwYWludF9zeW1ib2xcIiwgXCJwYWludF9yYXN0ZXJcIiwgXCJwYWludF9oaWxsc2hhZGVcIiwgXCJwYWludF9iYWNrZ3JvdW5kXCJdLFxuICAgICAgcGFpbnRfZmlsbDoge1xuICAgICAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW3tcbiAgICAgICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiAhMFxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLXRyYW5zbGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJmaWxsLXRyYW5zbGF0ZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicGFpbnRfZmlsbC1leHRydXNpb25cIjoge1xuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICAgIGRlZmF1bHQ6IFswLCAwXSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIjoge1xuICAgICAgICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdW5pdHM6IFwibWV0ZXJzXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLWJhc2VcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHVuaXRzOiBcIm1ldGVyc1wiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZWZhdWx0OiAhMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludF9saW5lOiB7XG4gICAgICAgIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLXRyYW5zbGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJsaW5lLXRyYW5zbGF0ZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS13aWR0aFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1vZmZzZXRcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1ibHVyXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1kYXNoYXJyYXlcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcImxpbmUgd2lkdGhzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZS1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLWdyYWRpZW50XCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICBcIiFcIjogXCJsaW5lLWRhc2hhcnJheVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBzb3VyY2U6IFwiZ2VvanNvblwiLFxuICAgICAgICAgICAgaGFzOiB7XG4gICAgICAgICAgICAgIGxpbmVNZXRyaWNzOiAhMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJsaW5lLXByb2dyZXNzXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb2xvci1yYW1wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhaW50X2NpcmNsZToge1xuICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLWJsdXJcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLW9wYWNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImNpcmNsZS10cmFuc2xhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJjaXJjbGUtdHJhbnNsYXRlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImNpcmNsZS1zdHJva2Utd2lkdGhcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcImNpcmNsZS1zdHJva2Utb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludF9oZWF0bWFwOiB7XG4gICAgICAgIFwiaGVhdG1hcC1yYWRpdXNcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMzAsXG4gICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVhdG1hcC13ZWlnaHRcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoZWF0bWFwLWludGVuc2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImhlYXRtYXAtY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImhlYXRtYXAtZGVuc2l0eVwiXSwgMCwgXCJyZ2JhKDAsIDAsIDI1NSwgMClcIiwgLjEsIFwicm95YWxibHVlXCIsIC4zLCBcImN5YW5cIiwgLjUsIFwibGltZVwiLCAuNywgXCJ5ZWxsb3dcIiwgMSwgXCJyZWRcIl0sXG4gICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcImhlYXRtYXAtZGVuc2l0eVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhaW50X3N5bWJvbDoge1xuICAgICAgICBcImljb24tb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpY29uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImljb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwiaWNvbi10cmFuc2xhdGVcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIG92ZXJyaWRhYmxlOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtaGFsby13aWR0aFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtaGFsby1ibHVyXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCBcInRleHQtdHJhbnNsYXRlXCJdLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhaW50X3Jhc3Rlcjoge1xuICAgICAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcInJhc3Rlci1zYXR1cmF0aW9uXCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogLTEsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogLTEsXG4gICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyLXJlc2FtcGxpbmdcIjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgbGluZWFyOiB7fSxcbiAgICAgICAgICAgIG5lYXJlc3Q6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiBcImxpbmVhclwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAzMDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgICAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYWludF9oaWxsc2hhZGU6IHtcbiAgICAgICAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAzMzUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAzNTksXG4gICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IFwidmlld3BvcnRcIixcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAuNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiOiB7XG4gICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IHtcbiAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFpbnRfYmFja2dyb3VuZDoge1xuICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICByZXF1aXJlczogW3tcbiAgICAgICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9LFxuICAgICAgICBcImJhY2tncm91bmQtcGF0dGVyblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgZGVmYXVsdDogMzAwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IHtcbiAgICAgICAgXCJkYXRhLWRyaXZlblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjcm9zcy1mYWRlZFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiOiB7XG4gICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xvci1yYW1wXCI6IHtcbiAgICAgICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtY29uc3RhbnRcIjoge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN0YW50OiB7XG4gICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb21vdGVJZDoge1xuICAgICAgICBcIipcIjoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgICAgIE10ID0gZnVuY3Rpb24gTXQodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5tZXNzYWdlID0gKHQgPyB0ICsgXCI6IFwiIDogXCJcIikgKyByLCBuICYmICh0aGlzLmlkZW50aWZpZXIgPSBuKSwgbnVsbCAhPSBlICYmIGUuX19saW5lX18gJiYgKHRoaXMubGluZSA9IGUuX19saW5lX18pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBCdCh0KSB7XG4gICAgICB2YXIgZSA9IHQudmFsdWU7XG4gICAgICByZXR1cm4gZSA/IFtuZXcgTXQodC5rZXksIGUsIFwiY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4XCIpXSA6IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFR0KHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSBbXSwgciA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyByLS0gPiAwOykge1xuICAgICAgICBlW3JdID0gYXJndW1lbnRzW3IgKyAxXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSBlOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG5cbiAgICAgICAgZm9yICh2YXIgbyBpbiBhKSB7XG4gICAgICAgICAgdFtvXSA9IGFbb107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnQodCkge1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0IGluc3RhbmNlb2YgQm9vbGVhbiA/IHQudmFsdWVPZigpIDogdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGdCh0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIHQubWFwKEZ0KTtcblxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdCBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgICAgIHZhciBlID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgciBpbiB0KSB7XG4gICAgICAgICAgZVtyXSA9IEZ0KHRbcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBWdCh0KTtcbiAgICB9XG5cbiAgICB2YXIgRHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCByKSwgdGhpcy5tZXNzYWdlID0gciwgdGhpcy5rZXkgPSBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlO1xuICAgIH0oRXJyb3IpLFxuICAgICAgICBMdCA9IGZ1bmN0aW9uIEx0KHQsIGUpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IFtdKSwgdGhpcy5wYXJlbnQgPSB0LCB0aGlzLmJpbmRpbmdzID0ge307XG5cbiAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gZTsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgdmFyIGkgPSBuW3JdO1xuICAgICAgICB0aGlzLmJpbmRpbmdzW2lbMF1dID0gaVsxXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTHQucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IEx0KHRoaXMsIHQpO1xuICAgIH0sIEx0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMuYmluZGluZ3NbdF0pIHJldHVybiB0aGlzLmJpbmRpbmdzW3RdO1xuICAgICAgaWYgKHRoaXMucGFyZW50KSByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0KHQpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQgKyBcIiBub3QgZm91bmQgaW4gc2NvcGUuXCIpO1xuICAgIH0sIEx0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5iaW5kaW5nc1t0XSB8fCAhIXRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Lmhhcyh0KTtcbiAgICB9O1xuICAgIHZhciBSdCA9IHtcbiAgICAgIGtpbmQ6IFwibnVsbFwiXG4gICAgfSxcbiAgICAgICAgT3QgPSB7XG4gICAgICBraW5kOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICAgICAgVXQgPSB7XG4gICAgICBraW5kOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICAgICAganQgPSB7XG4gICAgICBraW5kOiBcImJvb2xlYW5cIlxuICAgIH0sXG4gICAgICAgIHF0ID0ge1xuICAgICAga2luZDogXCJjb2xvclwiXG4gICAgfSxcbiAgICAgICAgTnQgPSB7XG4gICAgICBraW5kOiBcIm9iamVjdFwiXG4gICAgfSxcbiAgICAgICAgS3QgPSB7XG4gICAgICBraW5kOiBcInZhbHVlXCJcbiAgICB9LFxuICAgICAgICBHdCA9IHtcbiAgICAgIGtpbmQ6IFwiY29sbGF0b3JcIlxuICAgIH0sXG4gICAgICAgIFp0ID0ge1xuICAgICAga2luZDogXCJmb3JtYXR0ZWRcIlxuICAgIH0sXG4gICAgICAgIFh0ID0ge1xuICAgICAga2luZDogXCJyZXNvbHZlZEltYWdlXCJcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSnQodCwgZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJhcnJheVwiLFxuICAgICAgICBpdGVtVHlwZTogdCxcbiAgICAgICAgTjogZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIdCh0KSB7XG4gICAgICBpZiAoXCJhcnJheVwiID09PSB0LmtpbmQpIHtcbiAgICAgICAgdmFyIGUgPSBIdCh0Lml0ZW1UeXBlKTtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQuTiA/IFwiYXJyYXk8XCIgKyBlICsgXCIsIFwiICsgdC5OICsgXCI+XCIgOiBcInZhbHVlXCIgPT09IHQuaXRlbVR5cGUua2luZCA/IFwiYXJyYXlcIiA6IFwiYXJyYXk8XCIgKyBlICsgXCI+XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LmtpbmQ7XG4gICAgfVxuXG4gICAgdmFyIFl0ID0gW1J0LCBPdCwgVXQsIGp0LCBxdCwgWnQsIE50LCBKdChLdCksIFh0XTtcblxuICAgIGZ1bmN0aW9uICR0KHQsIGUpIHtcbiAgICAgIGlmIChcImVycm9yXCIgPT09IGUua2luZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmIChcImFycmF5XCIgPT09IHQua2luZCkge1xuICAgICAgICBpZiAoXCJhcnJheVwiID09PSBlLmtpbmQgJiYgKDAgPT09IGUuTiAmJiBcInZhbHVlXCIgPT09IGUuaXRlbVR5cGUua2luZCB8fCAhJHQodC5pdGVtVHlwZSwgZS5pdGVtVHlwZSkpICYmIChcIm51bWJlclwiICE9IHR5cGVvZiB0Lk4gfHwgdC5OID09PSBlLk4pKSByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0LmtpbmQgPT09IGUua2luZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChcInZhbHVlXCIgPT09IHQua2luZCkgZm9yICh2YXIgciA9IDAsIG4gPSBZdDsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICBpZiAoISR0KG5bcl0sIGUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIEh0KHQpICsgXCIgYnV0IGZvdW5kIFwiICsgSHQoZSkgKyBcIiBpbnN0ZWFkLlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFd0KHQsIGUpIHtcbiAgICAgIHJldHVybiBlLnNvbWUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUua2luZCA9PT0gdC5raW5kO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUXQodCwgZSkge1xuICAgICAgcmV0dXJuIGUuc29tZShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCIgPT09IGUgPyBudWxsID09PSB0IDogXCJhcnJheVwiID09PSBlID8gQXJyYXkuaXNBcnJheSh0KSA6IFwib2JqZWN0XCIgPT09IGUgPyB0ICYmICFBcnJheS5pc0FycmF5KHQpICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgOiBlID09PSB0eXBlb2YgdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0ZSA9IGUoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0ge1xuICAgICAgICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdLFxuICAgICAgICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNSwgMV0sXG4gICAgICAgIGFxdWE6IFswLCAyNTUsIDI1NSwgMV0sXG4gICAgICAgIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgICAgICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1LCAxXSxcbiAgICAgICAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwLCAxXSxcbiAgICAgICAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICAgICAgIGJsYWNrOiBbMCwgMCwgMCwgMV0sXG4gICAgICAgIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNSwgMV0sXG4gICAgICAgIGJsdWU6IFswLCAwLCAyNTUsIDFdLFxuICAgICAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2LCAxXSxcbiAgICAgICAgYnJvd246IFsxNjUsIDQyLCA0MiwgMV0sXG4gICAgICAgIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAgICAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjAsIDFdLFxuICAgICAgICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDAsIDFdLFxuICAgICAgICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAgICAgICBjb3JhbDogWzI1NSwgMTI3LCA4MCwgMV0sXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzNywgMV0sXG4gICAgICAgIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICAgICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MCwgMV0sXG4gICAgICAgIGN5YW46IFswLCAyNTUsIDI1NSwgMV0sXG4gICAgICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5LCAxXSxcbiAgICAgICAgZGFya2N5YW46IFswLCAxMzksIDEzOSwgMV0sXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTEsIDFdLFxuICAgICAgICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAgICAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDAsIDFdLFxuICAgICAgICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAgICAgICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgICAgICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOSwgMV0sXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDcsIDFdLFxuICAgICAgICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAgICAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0LCAxXSxcbiAgICAgICAgZGFya3JlZDogWzEzOSwgMCwgMCwgMV0sXG4gICAgICAgIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgICAgICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0MywgMV0sXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOSwgMV0sXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5LCAxXSxcbiAgICAgICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzksIDFdLFxuICAgICAgICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDksIDFdLFxuICAgICAgICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAgICAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0NywgMV0sXG4gICAgICAgIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTUsIDFdLFxuICAgICAgICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICAgICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgICAgICAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NSwgMV0sXG4gICAgICAgIGZpcmVicmljazogWzE3OCwgMzQsIDM0LCAxXSxcbiAgICAgICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwLCAxXSxcbiAgICAgICAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNCwgMV0sXG4gICAgICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICAgICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjAsIDFdLFxuICAgICAgICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NSwgMV0sXG4gICAgICAgIGdvbGQ6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICAgICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMiwgMV0sXG4gICAgICAgIGdyYXk6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgICAgICAgZ3JlZW46IFswLCAxMjgsIDAsIDFdLFxuICAgICAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0NywgMV0sXG4gICAgICAgIGdyZXk6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgICAgICAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgICAgICAgaG90cGluazogWzI1NSwgMTA1LCAxODAsIDFdLFxuICAgICAgICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5MiwgMV0sXG4gICAgICAgIGluZGlnbzogWzc1LCAwLCAxMzAsIDFdLFxuICAgICAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDAsIDFdLFxuICAgICAgICBraGFraTogWzI0MCwgMjMwLCAxNDAsIDFdLFxuICAgICAgICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NSwgMV0sXG4gICAgICAgIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwLCAxXSxcbiAgICAgICAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICAgICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzAsIDFdLFxuICAgICAgICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOCwgMV0sXG4gICAgICAgIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTAsIDFdLFxuICAgICAgICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgICAgICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAgICAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgICAgICAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5MywgMV0sXG4gICAgICAgIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzAsIDFdLFxuICAgICAgICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwLCAxXSxcbiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgICAgICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyLCAxXSxcbiAgICAgICAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgICAgICAgbGltZTogWzAsIDI1NSwgMCwgMV0sXG4gICAgICAgIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwLCAxXSxcbiAgICAgICAgbGluZW46IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgICAgICAgbWFnZW50YTogWzI1NSwgMCwgMjU1LCAxXSxcbiAgICAgICAgbWFyb29uOiBbMTI4LCAwLCAwLCAxXSxcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAgICAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1LCAxXSxcbiAgICAgICAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExLCAxXSxcbiAgICAgICAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzLCAxXSxcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOCwgMV0sXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDQsIDFdLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzMsIDFdLFxuICAgICAgICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMiwgMV0sXG4gICAgICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTAsIDFdLFxuICAgICAgICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1LCAxXSxcbiAgICAgICAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgICAgICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczLCAxXSxcbiAgICAgICAgbmF2eTogWzAsIDAsIDEyOCwgMV0sXG4gICAgICAgIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgICAgICAgb2xpdmU6IFsxMjgsIDEyOCwgMCwgMV0sXG4gICAgICAgIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNSwgMV0sXG4gICAgICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwLCAxXSxcbiAgICAgICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMCwgMV0sXG4gICAgICAgIG9yY2hpZDogWzIxOCwgMTEyLCAyMTQsIDFdLFxuICAgICAgICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICAgICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTIsIDFdLFxuICAgICAgICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOCwgMV0sXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgICAgICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTMsIDFdLFxuICAgICAgICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1LCAxXSxcbiAgICAgICAgcGVydTogWzIwNSwgMTMzLCA2MywgMV0sXG4gICAgICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzLCAxXSxcbiAgICAgICAgcGx1bTogWzIyMSwgMTYwLCAyMjEsIDFdLFxuICAgICAgICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICAgICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4LCAxXSxcbiAgICAgICAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1MywgMV0sXG4gICAgICAgIHJlZDogWzI1NSwgMCwgMCwgMV0sXG4gICAgICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDMsIDFdLFxuICAgICAgICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjUsIDFdLFxuICAgICAgICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5LCAxXSxcbiAgICAgICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNCwgMV0sXG4gICAgICAgIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTYsIDFdLFxuICAgICAgICBzZWFncmVlbjogWzQ2LCAxMzksIDg3LCAxXSxcbiAgICAgICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4LCAxXSxcbiAgICAgICAgc2llbm5hOiBbMTYwLCA4MiwgNDUsIDFdLFxuICAgICAgICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgICAgICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzUsIDFdLFxuICAgICAgICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDUsIDFdLFxuICAgICAgICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgICAgICAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICAgICAgIHNub3c6IFsyNTUsIDI1MCwgMjUwLCAxXSxcbiAgICAgICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyNywgMV0sXG4gICAgICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MCwgMV0sXG4gICAgICAgIHRhbjogWzIxMCwgMTgwLCAxNDAsIDFdLFxuICAgICAgICB0ZWFsOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAgICAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNiwgMV0sXG4gICAgICAgIHRvbWF0bzogWzI1NSwgOTksIDcxLCAxXSxcbiAgICAgICAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgICAgICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOCwgMV0sXG4gICAgICAgIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OSwgMV0sXG4gICAgICAgIHdoaXRlOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICAgICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1LCAxXSxcbiAgICAgICAgeWVsbG93OiBbMjU1LCAyNTUsIDAsIDFdLFxuICAgICAgICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MCwgMV1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIG4odCkge1xuICAgICAgICByZXR1cm4gKHQgPSBNYXRoLnJvdW5kKHQpKSA8IDAgPyAwIDogdCA+IDI1NSA/IDI1NSA6IHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGkodCkge1xuICAgICAgICByZXR1cm4gbihcIiVcIiA9PT0gdFt0Lmxlbmd0aCAtIDFdID8gcGFyc2VGbG9hdCh0KSAvIDEwMCAqIDI1NSA6IHBhcnNlSW50KHQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYSh0KSB7XG4gICAgICAgIHJldHVybiAoZSA9IFwiJVwiID09PSB0W3QubGVuZ3RoIC0gMV0gPyBwYXJzZUZsb2F0KHQpIC8gMTAwIDogcGFyc2VGbG9hdCh0KSkgPCAwID8gMCA6IGUgPiAxID8gMSA6IGU7XG4gICAgICAgIHZhciBlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIHIgPCAwID8gciArPSAxIDogciA+IDEgJiYgKHIgLT0gMSksIDYgKiByIDwgMSA/IHQgKyAoZSAtIHQpICogciAqIDYgOiAyICogciA8IDEgPyBlIDogMyAqIHIgPCAyID8gdCArIChlIC0gdCkgKiAoMiAvIDMgLSByKSAqIDYgOiB0O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBlLnBhcnNlQ1NTQ29sb3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlLFxuICAgICAgICAgICAgICBzID0gdC5yZXBsYWNlKC8gL2csIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHMgaW4gcikgcmV0dXJuIHJbc10uc2xpY2UoKTtcbiAgICAgICAgICBpZiAoXCIjXCIgPT09IHNbMF0pIHJldHVybiA0ID09PSBzLmxlbmd0aCA/IChlID0gcGFyc2VJbnQocy5zdWJzdHIoMSksIDE2KSkgPj0gMCAmJiBlIDw9IDQwOTUgPyBbKDM4NDAgJiBlKSA+PiA0IHwgKDM4NDAgJiBlKSA+PiA4LCAyNDAgJiBlIHwgKDI0MCAmIGUpID4+IDQsIDE1ICYgZSB8ICgxNSAmIGUpIDw8IDQsIDFdIDogbnVsbCA6IDcgPT09IHMubGVuZ3RoICYmIChlID0gcGFyc2VJbnQocy5zdWJzdHIoMSksIDE2KSkgPj0gMCAmJiBlIDw9IDE2Nzc3MjE1ID8gWygxNjcxMTY4MCAmIGUpID4+IDE2LCAoNjUyODAgJiBlKSA+PiA4LCAyNTUgJiBlLCAxXSA6IG51bGw7XG4gICAgICAgICAgdmFyIHUgPSBzLmluZGV4T2YoXCIoXCIpLFxuICAgICAgICAgICAgICBsID0gcy5pbmRleE9mKFwiKVwiKTtcblxuICAgICAgICAgIGlmICgtMSAhPT0gdSAmJiBsICsgMSA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwID0gcy5zdWJzdHIoMCwgdSksXG4gICAgICAgICAgICAgICAgYyA9IHMuc3Vic3RyKHUgKyAxLCBsIC0gKHUgKyAxKSkuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgICAgIGggPSAxO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgICAgICAgY2FzZSBcInJnYmFcIjpcbiAgICAgICAgICAgICAgICBpZiAoNCAhPT0gYy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGggPSBhKGMucG9wKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAhPT0gYy5sZW5ndGggPyBudWxsIDogW2koY1swXSksIGkoY1sxXSksIGkoY1syXSksIGhdO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJoc2xhXCI6XG4gICAgICAgICAgICAgICAgaWYgKDQgIT09IGMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBoID0gYShjLnBvcCgpKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgICAgICAgICAgaWYgKDMgIT09IGMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IChwYXJzZUZsb2F0KGNbMF0pICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGEoY1sxXSksXG4gICAgICAgICAgICAgICAgICAgIGQgPSBhKGNbMl0pLFxuICAgICAgICAgICAgICAgICAgICBtID0gZCA8PSAuNSA/IGQgKiAoeSArIDEpIDogZCArIHkgLSBkICogeSxcbiAgICAgICAgICAgICAgICAgICAgdiA9IDIgKiBkIC0gbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW24oMjU1ICogbyh2LCBtLCBmICsgMSAvIDMpKSwgbigyNTUgKiBvKHYsIG0sIGYpKSwgbigyNTUgKiBvKHYsIG0sIGYgLSAxIC8gMykpLCBoXTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAodCkge31cbiAgICB9KS5wYXJzZUNTU0NvbG9yLFxuICAgICAgICBlZSA9IGZ1bmN0aW9uIGVlKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZvaWQgMCA9PT0gbiAmJiAobiA9IDEpLCB0aGlzLnIgPSB0LCB0aGlzLmcgPSBlLCB0aGlzLmIgPSByLCB0aGlzLmEgPSBuO1xuICAgIH07XG5cbiAgICBlZS5wYXJzZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIGVlKSByZXR1cm4gdDtcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgIHZhciBlID0gdGUodCk7XG4gICAgICAgICAgaWYgKGUpIHJldHVybiBuZXcgZWUoZVswXSAvIDI1NSAqIGVbM10sIGVbMV0gLyAyNTUgKiBlWzNdLCBlWzJdIC8gMjU1ICogZVszXSwgZVszXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMudG9BcnJheSgpLFxuICAgICAgICAgIGUgPSB0WzFdLFxuICAgICAgICAgIHIgPSB0WzJdLFxuICAgICAgICAgIG4gPSB0WzNdO1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIE1hdGgucm91bmQodFswXSkgKyBcIixcIiArIE1hdGgucm91bmQoZSkgKyBcIixcIiArIE1hdGgucm91bmQocikgKyBcIixcIiArIG4gKyBcIilcIjtcbiAgICB9LCBlZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5hO1xuICAgICAgcmV0dXJuIDAgPT09IHQgPyBbMCwgMCwgMCwgMF0gOiBbMjU1ICogdGhpcy5yIC8gdCwgMjU1ICogdGhpcy5nIC8gdCwgMjU1ICogdGhpcy5iIC8gdCwgdF07XG4gICAgfSwgZWUuYmxhY2sgPSBuZXcgZWUoMCwgMCwgMCwgMSksIGVlLndoaXRlID0gbmV3IGVlKDEsIDEsIDEsIDEpLCBlZS50cmFuc3BhcmVudCA9IG5ldyBlZSgwLCAwLCAwLCAwKSwgZWUucmVkID0gbmV3IGVlKDEsIDAsIDAsIDEpO1xuXG4gICAgdmFyIHJlID0gZnVuY3Rpb24gcmUodCwgZSwgcikge1xuICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IHQgPyBlID8gXCJ2YXJpYW50XCIgOiBcImNhc2VcIiA6IGUgPyBcImFjY2VudFwiIDogXCJiYXNlXCIsIHRoaXMubG9jYWxlID0gciwgdGhpcy5jb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSwge1xuICAgICAgICBzZW5zaXRpdml0eTogdGhpcy5zZW5zaXRpdml0eSxcbiAgICAgICAgdXNhZ2U6IFwic2VhcmNoXCJcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xsYXRvci5jb21wYXJlKHQsIGUpO1xuICAgIH0sIHJlLnByb3RvdHlwZS5yZXNvbHZlZExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10pLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICB9O1xuXG4gICAgdmFyIG5lID0gZnVuY3Rpb24gbmUodCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy50ZXh0ID0gdCwgdGhpcy5pbWFnZSA9IGUsIHRoaXMuc2NhbGUgPSByLCB0aGlzLmZvbnRTdGFjayA9IG4sIHRoaXMudGV4dENvbG9yID0gaTtcbiAgICB9LFxuICAgICAgICBpZSA9IGZ1bmN0aW9uIGllKHQpIHtcbiAgICAgIHRoaXMuc2VjdGlvbnMgPSB0O1xuICAgIH07XG5cbiAgICBpZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgaWUoW25ldyBuZSh0LCBudWxsLCBudWxsLCBudWxsLCBudWxsKV0pO1xuICAgIH0sIGllLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMuc2VjdGlvbnMubGVuZ3RoIHx8ICF0aGlzLnNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIDAgIT09IHQudGV4dC5sZW5ndGggfHwgdC5pbWFnZSAmJiAwICE9PSB0LmltYWdlLm5hbWUubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgfSwgaWUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIGllID8gdCA6IGllLmZyb21TdHJpbmcodCk7XG4gICAgfSwgaWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMuc2VjdGlvbnMubGVuZ3RoID8gXCJcIiA6IHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnRleHQ7XG4gICAgICB9KS5qb2luKFwiXCIpO1xuICAgIH0sIGllLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gW1wiZm9ybWF0XCJdLCBlID0gMCwgciA9IHRoaXMuc2VjdGlvbnM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXTtcbiAgICAgICAgaWYgKG4uaW1hZ2UpIHQucHVzaChbXCJpbWFnZVwiLCBuLmltYWdlLm5hbWVdKTtlbHNlIHtcbiAgICAgICAgICB0LnB1c2gobi50ZXh0KTtcbiAgICAgICAgICB2YXIgaSA9IHt9O1xuICAgICAgICAgIG4uZm9udFN0YWNrICYmIChpW1widGV4dC1mb250XCJdID0gW1wibGl0ZXJhbFwiLCBuLmZvbnRTdGFjay5zcGxpdChcIixcIildKSwgbi5zY2FsZSAmJiAoaVtcImZvbnQtc2NhbGVcIl0gPSBuLnNjYWxlKSwgbi50ZXh0Q29sb3IgJiYgKGlbXCJ0ZXh0LWNvbG9yXCJdID0gW1wicmdiYVwiXS5jb25jYXQobi50ZXh0Q29sb3IudG9BcnJheSgpKSksIHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgdmFyIGFlID0gZnVuY3Rpb24gYWUodCkge1xuICAgICAgdGhpcy5uYW1lID0gdC5uYW1lLCB0aGlzLmF2YWlsYWJsZSA9IHQuYXZhaWxhYmxlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvZSh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgdCAmJiB0ID49IDAgJiYgdCA8PSAyNTUgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgZSAmJiBlID49IDAgJiYgZSA8PSAyNTUgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgciAmJiByID49IDAgJiYgciA8PSAyNTUgPyB2b2lkIDAgPT09IG4gfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgbiAmJiBuID49IDAgJiYgbiA8PSAxID8gbnVsbCA6IFwiSW52YWxpZCByZ2JhIHZhbHVlIFtcIiArIFt0LCBlLCByLCBuXS5qb2luKFwiLCBcIikgKyBcIl06ICdhJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cIiA6IFwiSW52YWxpZCByZ2JhIHZhbHVlIFtcIiArIChcIm51bWJlclwiID09IHR5cGVvZiBuID8gW3QsIGUsIHIsIG5dIDogW3QsIGUsIHJdKS5qb2luKFwiLCBcIikgKyBcIl06ICdyJywgJ2cnLCBhbmQgJ2InIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUuXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2UodCkge1xuICAgICAgaWYgKG51bGwgPT09IHQpIHJldHVybiAhMDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSByZXR1cm4gITA7XG4gICAgICBpZiAoXCJib29sZWFuXCIgPT0gdHlwZW9mIHQpIHJldHVybiAhMDtcbiAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB0KSByZXR1cm4gITA7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGVlKSByZXR1cm4gITA7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIHJlKSByZXR1cm4gITA7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGllKSByZXR1cm4gITA7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGFlKSByZXR1cm4gITA7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICBpZiAoIXNlKHJbZV0pKSByZXR1cm4gITE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgIGZvciAodmFyIG4gaW4gdCkge1xuICAgICAgICAgIGlmICghc2UodFtuXSkpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVlKHQpIHtcbiAgICAgIGlmIChudWxsID09PSB0KSByZXR1cm4gUnQ7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgcmV0dXJuIFV0O1xuICAgICAgaWYgKFwiYm9vbGVhblwiID09IHR5cGVvZiB0KSByZXR1cm4ganQ7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgdCkgcmV0dXJuIE90O1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBlZSkgcmV0dXJuIHF0O1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiByZSkgcmV0dXJuIEd0O1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBpZSkgcmV0dXJuIFp0O1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBhZSkgcmV0dXJuIFh0O1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBmb3IgKHZhciBlLCByID0gdC5sZW5ndGgsIG4gPSAwLCBpID0gdDsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHVlKGlbbl0pO1xuXG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmIChlID09PSBhKSBjb250aW51ZTtcbiAgICAgICAgICAgIGUgPSBLdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUgPSBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEp0KGUgfHwgS3QsIHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGUodCkge1xuICAgICAgdmFyIGUgPSB0eXBlb2YgdDtcbiAgICAgIHJldHVybiBudWxsID09PSB0ID8gXCJcIiA6IFwic3RyaW5nXCIgPT09IGUgfHwgXCJudW1iZXJcIiA9PT0gZSB8fCBcImJvb2xlYW5cIiA9PT0gZSA/IFN0cmluZyh0KSA6IHQgaW5zdGFuY2VvZiBlZSB8fCB0IGluc3RhbmNlb2YgaWUgfHwgdCBpbnN0YW5jZW9mIGFlID8gdC50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkodCk7XG4gICAgfVxuXG4gICAgYWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9LCBhZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ID8gbmV3IGFlKHtcbiAgICAgICAgbmFtZTogdCxcbiAgICAgICAgYXZhaWxhYmxlOiAhMVxuICAgICAgfSkgOiBudWxsO1xuICAgIH0sIGFlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1wiaW1hZ2VcIiwgdGhpcy5uYW1lXTtcbiAgICB9O1xuXG4gICAgdmFyIHBlID0gZnVuY3Rpb24gcGUodCwgZSkge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy52YWx1ZSA9IGU7XG4gICAgfTtcblxuICAgIHBlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCInbGl0ZXJhbCcgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIGlmICghc2UodFsxXSkpIHJldHVybiBlLmVycm9yKFwiaW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIHZhciByID0gdFsxXSxcbiAgICAgICAgICBuID0gdWUociksXG4gICAgICAgICAgaSA9IGUuZXhwZWN0ZWRUeXBlO1xuICAgICAgcmV0dXJuIFwiYXJyYXlcIiAhPT0gbi5raW5kIHx8IDAgIT09IG4uTiB8fCAhaSB8fCBcImFycmF5XCIgIT09IGkua2luZCB8fCBcIm51bWJlclwiID09IHR5cGVvZiBpLk4gJiYgMCAhPT0gaS5OIHx8IChuID0gaSksIG5ldyBwZShuLCByKTtcbiAgICB9LCBwZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LCBwZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKCkge30sIHBlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIHBlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJhcnJheVwiID09PSB0aGlzLnR5cGUua2luZCB8fCBcIm9iamVjdFwiID09PSB0aGlzLnR5cGUua2luZCA/IFtcImxpdGVyYWxcIiwgdGhpcy52YWx1ZV0gOiB0aGlzLnZhbHVlIGluc3RhbmNlb2YgZWUgPyBbXCJyZ2JhXCJdLmNvbmNhdCh0aGlzLnZhbHVlLnRvQXJyYXkoKSkgOiB0aGlzLnZhbHVlIGluc3RhbmNlb2YgaWUgPyB0aGlzLnZhbHVlLnNlcmlhbGl6ZSgpIDogdGhpcy52YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGNlID0gZnVuY3Rpb24gY2UodCkge1xuICAgICAgdGhpcy5uYW1lID0gXCJFeHByZXNzaW9uRXZhbHVhdGlvbkVycm9yXCIsIHRoaXMubWVzc2FnZSA9IHQ7XG4gICAgfTtcblxuICAgIGNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICB2YXIgaGUgPSB7XG4gICAgICBzdHJpbmc6IFV0LFxuICAgICAgbnVtYmVyOiBPdCxcbiAgICAgIGJvb2xlYW46IGp0LFxuICAgICAgb2JqZWN0OiBOdFxuICAgIH0sXG4gICAgICAgIGZlID0gZnVuY3Rpb24gZmUodCwgZSkge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5hcmdzID0gZTtcbiAgICB9O1xuXG4gICAgZmUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgMikgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgbiA9IDEsXG4gICAgICAgICAgaSA9IHRbMF07XG5cbiAgICAgIGlmIChcImFycmF5XCIgPT09IGkpIHtcbiAgICAgICAgdmFyIGEsIG87XG5cbiAgICAgICAgaWYgKHQubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBzID0gdFsxXTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgcyB8fCAhKHMgaW4gaGUpIHx8IFwib2JqZWN0XCIgPT09IHMpIHJldHVybiBlLmVycm9yKCdUaGUgaXRlbSB0eXBlIGFyZ3VtZW50IG9mIFwiYXJyYXlcIiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIG51bWJlciwgYm9vbGVhbicsIDEpO1xuICAgICAgICAgIGEgPSBoZVtzXSwgbisrO1xuICAgICAgICB9IGVsc2UgYSA9IEt0O1xuXG4gICAgICAgIGlmICh0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdFsyXSAmJiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdFsyXSB8fCB0WzJdIDwgMCB8fCB0WzJdICE9PSBNYXRoLmZsb29yKHRbMl0pKSkgcmV0dXJuIGUuZXJyb3IoJ1RoZSBsZW5ndGggYXJndW1lbnQgdG8gXCJhcnJheVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxpdGVyYWwnLCAyKTtcbiAgICAgICAgICBvID0gdFsyXSwgbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9IEp0KGEsIG8pO1xuICAgICAgfSBlbHNlIHIgPSBoZVtpXTtcblxuICAgICAgZm9yICh2YXIgdSA9IFtdOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbCA9IGUucGFyc2UodFtuXSwgbiwgS3QpO1xuICAgICAgICBpZiAoIWwpIHJldHVybiBudWxsO1xuICAgICAgICB1LnB1c2gobCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgZmUociwgdSk7XG4gICAgfSwgZmUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5hcmdzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5hcmdzW2VdLmV2YWx1YXRlKHQpO1xuICAgICAgICBpZiAoISR0KHRoaXMudHlwZSwgdWUocikpKSByZXR1cm4gcjtcbiAgICAgICAgaWYgKGUgPT09IHRoaXMuYXJncy5sZW5ndGggLSAxKSB0aHJvdyBuZXcgY2UoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIFwiICsgSHQodGhpcy50eXBlKSArIFwiLCBidXQgZm91bmQgXCIgKyBIdCh1ZShyKSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgZmUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaCh0KTtcbiAgICB9LCBmZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSwgZmUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy50eXBlLFxuICAgICAgICAgIGUgPSBbdC5raW5kXTtcblxuICAgICAgaWYgKFwiYXJyYXlcIiA9PT0gdC5raW5kKSB7XG4gICAgICAgIHZhciByID0gdC5pdGVtVHlwZTtcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gci5raW5kIHx8IFwibnVtYmVyXCIgPT09IHIua2luZCB8fCBcImJvb2xlYW5cIiA9PT0gci5raW5kKSB7XG4gICAgICAgICAgZS5wdXNoKHIua2luZCk7XG4gICAgICAgICAgdmFyIG4gPSB0Lk47XG4gICAgICAgICAgKFwibnVtYmVyXCIgPT0gdHlwZW9mIG4gfHwgdGhpcy5hcmdzLmxlbmd0aCA+IDEpICYmIGUucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZS5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgdmFyIHllID0gZnVuY3Rpb24geWUodCkge1xuICAgICAgdGhpcy50eXBlID0gWnQsIHRoaXMuc2VjdGlvbnMgPSB0O1xuICAgIH07XG5cbiAgICB5ZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCAyKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgciA9IHRbMV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocikgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgcikgcmV0dXJuIGUuZXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi5cIik7XG5cbiAgICAgIGZvciAodmFyIG4gPSBbXSwgaSA9ICExLCBhID0gMTsgYSA8PSB0Lmxlbmd0aCAtIDE7ICsrYSkge1xuICAgICAgICB2YXIgbyA9IHRbYV07XG5cbiAgICAgICAgaWYgKGkgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbyAmJiAhQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICAgIGkgPSAhMTtcbiAgICAgICAgICB2YXIgcyA9IG51bGw7XG4gICAgICAgICAgaWYgKG9bXCJmb250LXNjYWxlXCJdICYmICEocyA9IGUucGFyc2Uob1tcImZvbnQtc2NhbGVcIl0sIDEsIE90KSkpIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciB1ID0gbnVsbDtcbiAgICAgICAgICBpZiAob1tcInRleHQtZm9udFwiXSAmJiAhKHUgPSBlLnBhcnNlKG9bXCJ0ZXh0LWZvbnRcIl0sIDEsIEp0KFV0KSkpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgbCA9IG51bGw7XG4gICAgICAgICAgaWYgKG9bXCJ0ZXh0LWNvbG9yXCJdICYmICEobCA9IGUucGFyc2Uob1tcInRleHQtY29sb3JcIl0sIDEsIHF0KSkpIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBwID0gbltuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHAuc2NhbGUgPSBzLCBwLmZvbnQgPSB1LCBwLnRleHRDb2xvciA9IGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGMgPSBlLnBhcnNlKHRbYV0sIDEsIEt0KTtcbiAgICAgICAgICBpZiAoIWMpIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBoID0gYy50eXBlLmtpbmQ7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IGggJiYgXCJ2YWx1ZVwiICE9PSBoICYmIFwibnVsbFwiICE9PSBoICYmIFwicmVzb2x2ZWRJbWFnZVwiICE9PSBoKSByZXR1cm4gZS5lcnJvcihcIkZvcm1hdHRlZCB0ZXh0IHR5cGUgbXVzdCBiZSAnc3RyaW5nJywgJ3ZhbHVlJywgJ2ltYWdlJyBvciAnbnVsbCcuXCIpO1xuICAgICAgICAgIGkgPSAhMCwgbi5wdXNoKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGMsXG4gICAgICAgICAgICBzY2FsZTogbnVsbCxcbiAgICAgICAgICAgIGZvbnQ6IG51bGwsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IHllKG4pO1xuICAgIH0sIHllLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IGllKHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByID0gZS5jb250ZW50LmV2YWx1YXRlKHQpO1xuICAgICAgICByZXR1cm4gdWUocikgPT09IFh0ID8gbmV3IG5lKFwiXCIsIHIsIG51bGwsIG51bGwsIG51bGwpIDogbmV3IG5lKGxlKHIpLCBudWxsLCBlLnNjYWxlID8gZS5zY2FsZS5ldmFsdWF0ZSh0KSA6IG51bGwsIGUuZm9udCA/IGUuZm9udC5ldmFsdWF0ZSh0KS5qb2luKFwiLFwiKSA6IG51bGwsIGUudGV4dENvbG9yID8gZS50ZXh0Q29sb3IuZXZhbHVhdGUodCkgOiBudWxsKTtcbiAgICAgIH0pKTtcbiAgICB9LCB5ZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5zZWN0aW9uczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICB0KG4uY29udGVudCksIG4uc2NhbGUgJiYgdChuLnNjYWxlKSwgbi5mb250ICYmIHQobi5mb250KSwgbi50ZXh0Q29sb3IgJiYgdChuLnRleHRDb2xvcik7XG4gICAgICB9XG4gICAgfSwgeWUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgeWUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSBbXCJmb3JtYXRcIl0sIGUgPSAwLCByID0gdGhpcy5zZWN0aW9uczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICB0LnB1c2gobi5jb250ZW50LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgdmFyIGkgPSB7fTtcbiAgICAgICAgbi5zY2FsZSAmJiAoaVtcImZvbnQtc2NhbGVcIl0gPSBuLnNjYWxlLnNlcmlhbGl6ZSgpKSwgbi5mb250ICYmIChpW1widGV4dC1mb250XCJdID0gbi5mb250LnNlcmlhbGl6ZSgpKSwgbi50ZXh0Q29sb3IgJiYgKGlbXCJ0ZXh0LWNvbG9yXCJdID0gbi50ZXh0Q29sb3Iuc2VyaWFsaXplKCkpLCB0LnB1c2goaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICB2YXIgZGUgPSBmdW5jdGlvbiBkZSh0KSB7XG4gICAgICB0aGlzLnR5cGUgPSBYdCwgdGhpcy5pbnB1dCA9IHQ7XG4gICAgfTtcblxuICAgIGRlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBVdCk7XG4gICAgICByZXR1cm4gciA/IG5ldyBkZShyKSA6IGUuZXJyb3IoXCJObyBpbWFnZSBuYW1lIHByb3ZpZGVkLlwiKTtcbiAgICB9LCBkZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpLFxuICAgICAgICAgIHIgPSBhZS5mcm9tU3RyaW5nKGUpO1xuICAgICAgcmV0dXJuIHIgJiYgdC5hdmFpbGFibGVJbWFnZXMgJiYgKHIuYXZhaWxhYmxlID0gdC5hdmFpbGFibGVJbWFnZXMuaW5kZXhPZihlKSA+IC0xKSwgcjtcbiAgICB9LCBkZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5pbnB1dCk7XG4gICAgfSwgZGUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXCJpbWFnZVwiLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuXG4gICAgdmFyIG1lID0ge1xuICAgICAgXCJ0by1ib29sZWFuXCI6IGp0LFxuICAgICAgXCJ0by1jb2xvclwiOiBxdCxcbiAgICAgIFwidG8tbnVtYmVyXCI6IE90LFxuICAgICAgXCJ0by1zdHJpbmdcIjogVXRcbiAgICB9LFxuICAgICAgICB2ZSA9IGZ1bmN0aW9uIHZlKHQsIGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuYXJncyA9IGU7XG4gICAgfTtcblxuICAgIHZlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8IDIpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciByID0gdFswXTtcbiAgICAgIGlmICgoXCJ0by1ib29sZWFuXCIgPT09IHIgfHwgXCJ0by1zdHJpbmdcIiA9PT0gcikgJiYgMiAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgb25lIGFyZ3VtZW50LlwiKTtcblxuICAgICAgZm9yICh2YXIgbiA9IG1lW3JdLCBpID0gW10sIGEgPSAxOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbyA9IGUucGFyc2UodFthXSwgYSwgS3QpO1xuICAgICAgICBpZiAoIW8pIHJldHVybiBudWxsO1xuICAgICAgICBpLnB1c2gobyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgdmUobiwgaSk7XG4gICAgfSwgdmUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmIChcImJvb2xlYW5cIiA9PT0gdGhpcy50eXBlLmtpbmQpIHJldHVybiBCb29sZWFuKHRoaXMuYXJnc1swXS5ldmFsdWF0ZSh0KSk7XG5cbiAgICAgIGlmIChcImNvbG9yXCIgPT09IHRoaXMudHlwZS5raW5kKSB7XG4gICAgICAgIGZvciAodmFyIGUsIHIsIG4gPSAwLCBpID0gdGhpcy5hcmdzOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgIGlmIChyID0gbnVsbCwgKGUgPSBpW25dLmV2YWx1YXRlKHQpKSBpbnN0YW5jZW9mIGVlKSByZXR1cm4gZTtcblxuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHQucGFyc2VDb2xvcihlKTtcbiAgICAgICAgICAgIGlmIChhKSByZXR1cm4gYTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZSkgJiYgIShyID0gZS5sZW5ndGggPCAzIHx8IGUubGVuZ3RoID4gNCA/IFwiSW52YWxpZCByYmdhIHZhbHVlIFwiICsgSlNPTi5zdHJpbmdpZnkoZSkgKyBcIjogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy5cIiA6IG9lKGVbMF0sIGVbMV0sIGVbMl0sIGVbM10pKSkgcmV0dXJuIG5ldyBlZShlWzBdIC8gMjU1LCBlWzFdIC8gMjU1LCBlWzJdIC8gMjU1LCBlWzNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBjZShyIHx8IFwiQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgJ1wiICsgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBlIDogU3RyaW5nKEpTT04uc3RyaW5naWZ5KGUpKSkgKyBcIidcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChcIm51bWJlclwiID09PSB0aGlzLnR5cGUua2luZCkge1xuICAgICAgICBmb3IgKHZhciBvID0gbnVsbCwgcyA9IDAsIHUgPSB0aGlzLmFyZ3M7IHMgPCB1Lmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IChvID0gdVtzXS5ldmFsdWF0ZSh0KSkpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBsID0gTnVtYmVyKG8pO1xuICAgICAgICAgIGlmICghaXNOYU4obCkpIHJldHVybiBsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IGNlKFwiQ291bGQgbm90IGNvbnZlcnQgXCIgKyBKU09OLnN0cmluZ2lmeShvKSArIFwiIHRvIG51bWJlci5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcImZvcm1hdHRlZFwiID09PSB0aGlzLnR5cGUua2luZCA/IGllLmZyb21TdHJpbmcobGUodGhpcy5hcmdzWzBdLmV2YWx1YXRlKHQpKSkgOiBcInJlc29sdmVkSW1hZ2VcIiA9PT0gdGhpcy50eXBlLmtpbmQgPyBhZS5mcm9tU3RyaW5nKGxlKHRoaXMuYXJnc1swXS5ldmFsdWF0ZSh0KSkpIDogbGUodGhpcy5hcmdzWzBdLmV2YWx1YXRlKHQpKTtcbiAgICB9LCB2ZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKHQpO1xuICAgIH0sIHZlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9LCB2ZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKFwiZm9ybWF0dGVkXCIgPT09IHRoaXMudHlwZS5raW5kKSByZXR1cm4gbmV3IHllKFt7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuYXJnc1swXSxcbiAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgIGZvbnQ6IG51bGwsXG4gICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgfV0pLnNlcmlhbGl6ZSgpO1xuICAgICAgaWYgKFwicmVzb2x2ZWRJbWFnZVwiID09PSB0aGlzLnR5cGUua2luZCkgcmV0dXJuIG5ldyBkZSh0aGlzLmFyZ3NbMF0pLnNlcmlhbGl6ZSgpO1xuICAgICAgdmFyIHQgPSBbXCJ0by1cIiArIHRoaXMudHlwZS5raW5kXTtcbiAgICAgIHJldHVybiB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICB0LnB1c2goZS5zZXJpYWxpemUoKSk7XG4gICAgICB9KSwgdDtcbiAgICB9O1xuXG4gICAgdmFyIGdlID0gW1wiVW5rbm93blwiLCBcIlBvaW50XCIsIFwiTGluZVN0cmluZ1wiLCBcIlBvbHlnb25cIl0sXG4gICAgICAgIHhlID0gZnVuY3Rpb24geGUoKSB7XG4gICAgICB0aGlzLmdsb2JhbHMgPSBudWxsLCB0aGlzLmZlYXR1cmUgPSBudWxsLCB0aGlzLmZlYXR1cmVTdGF0ZSA9IG51bGwsIHRoaXMuZm9ybWF0dGVkU2VjdGlvbiA9IG51bGwsIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9LCB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IG51bGwsIHRoaXMuY2Fub25pY2FsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgeGUucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiBcImlkXCIgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmlkIDogbnVsbDtcbiAgICB9LCB4ZS5wcm90b3R5cGUuZ2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSA/IFwibnVtYmVyXCIgPT0gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID8gZ2VbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsO1xuICAgIH0sIHhlLnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgXCJnZW9tZXRyeVwiIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5nZW9tZXRyeSA6IG51bGw7XG4gICAgfSwgeGUucHJvdG90eXBlLmNhbm9uaWNhbElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsO1xuICAgIH0sIHhlLnByb3RvdHlwZS5wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICB9LCB4ZS5wcm90b3R5cGUucGFyc2VDb2xvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3BhcnNlQ29sb3JDYWNoZVt0XTtcbiAgICAgIHJldHVybiBlIHx8IChlID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW3RdID0gZWUucGFyc2UodCkpLCBlO1xuICAgIH07XG5cbiAgICB2YXIgYmUgPSBmdW5jdGlvbiBiZSh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLm5hbWUgPSB0LCB0aGlzLnR5cGUgPSBlLCB0aGlzLl9ldmFsdWF0ZSA9IHIsIHRoaXMuYXJncyA9IG47XG4gICAgfTtcblxuICAgIGJlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGUodCwgdGhpcy5hcmdzKTtcbiAgICB9LCBiZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKHQpO1xuICAgIH0sIGJlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGJlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3RoaXMubmFtZV0uY29uY2F0KHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuc2VyaWFsaXplKCk7XG4gICAgICB9KSk7XG4gICAgfSwgYmUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgbiA9IHRbMF0sXG4gICAgICAgICAgaSA9IGJlLmRlZmluaXRpb25zW25dO1xuICAgICAgaWYgKCFpKSByZXR1cm4gZS5lcnJvcignVW5rbm93biBleHByZXNzaW9uIFwiJyArIG4gKyAnXCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG5cbiAgICAgIGZvciAodmFyIGEgPSBBcnJheS5pc0FycmF5KGkpID8gaVswXSA6IGkudHlwZSwgbyA9IEFycmF5LmlzQXJyYXkoaSkgPyBbW2lbMV0sIGlbMl1dXSA6IGkub3ZlcmxvYWRzLCBzID0gby5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdO1xuICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocikgfHwgci5sZW5ndGggPT09IHQubGVuZ3RoIC0gMTtcbiAgICAgIH0pLCB1ID0gbnVsbCwgbCA9IDAsIHAgPSBzOyBsIDwgcC5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHBbbF0sXG4gICAgICAgICAgICBoID0gY1swXSxcbiAgICAgICAgICAgIGYgPSBjWzFdO1xuICAgICAgICB1ID0gbmV3IHFlKGUucmVnaXN0cnksIGUucGF0aCwgbnVsbCwgZS5zY29wZSk7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IFtdLCBkID0gITEsIG0gPSAxOyBtIDwgdC5sZW5ndGg7IG0rKykge1xuICAgICAgICAgIHZhciB2ID0gdFttXSxcbiAgICAgICAgICAgICAgZyA9IEFycmF5LmlzQXJyYXkoaCkgPyBoW20gLSAxXSA6IGgudHlwZSxcbiAgICAgICAgICAgICAgeCA9IHUucGFyc2UodiwgMSArIHkubGVuZ3RoLCBnKTtcblxuICAgICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgZCA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeS5wdXNoKHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkKSBpZiAoQXJyYXkuaXNBcnJheShoKSAmJiBoLmxlbmd0aCAhPT0geS5sZW5ndGgpIHUuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGgubGVuZ3RoICsgXCIgYXJndW1lbnRzLCBidXQgZm91bmQgXCIgKyB5Lmxlbmd0aCArIFwiIGluc3RlYWQuXCIpO2Vsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgeS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgdmFyIHcgPSBBcnJheS5pc0FycmF5KGgpID8gaFtiXSA6IGgudHlwZSxcbiAgICAgICAgICAgICAgICBfID0geVtiXTtcbiAgICAgICAgICAgIHUuY29uY2F0KGIgKyAxKS5jaGVja1N1YnR5cGUodywgXy50eXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoMCA9PT0gdS5lcnJvcnMubGVuZ3RoKSByZXR1cm4gbmV3IGJlKG4sIGEsIGYsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgxID09PSBzLmxlbmd0aCkgKHIgPSBlLmVycm9ycykucHVzaC5hcHBseShyLCB1LmVycm9ycyk7ZWxzZSB7XG4gICAgICAgIGZvciAodmFyIEEgPSAocy5sZW5ndGggPyBzIDogbykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgcmV0dXJuIGUgPSB0WzBdLCBBcnJheS5pc0FycmF5KGUpID8gXCIoXCIgKyBlLm1hcChIdCkuam9pbihcIiwgXCIpICsgXCIpXCIgOiBcIihcIiArIEh0KGUudHlwZSkgKyBcIi4uLilcIjtcbiAgICAgICAgfSkuam9pbihcIiB8IFwiKSwgUyA9IFtdLCBrID0gMTsgayA8IHQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICB2YXIgSSA9IGUucGFyc2UodFtrXSwgMSArIFMubGVuZ3RoKTtcbiAgICAgICAgICBpZiAoIUkpIHJldHVybiBudWxsO1xuICAgICAgICAgIFMucHVzaChIdChJLnR5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUuZXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSBcIiArIEEgKyBcIiwgYnV0IGZvdW5kIChcIiArIFMuam9pbihcIiwgXCIpICsgXCIpIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgYmUucmVnaXN0ZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciBpbiBiZS5kZWZpbml0aW9ucyA9IGUsIGUpIHtcbiAgICAgICAgdFtyXSA9IGJlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd2UgPSBmdW5jdGlvbiB3ZSh0LCBlLCByKSB7XG4gICAgICB0aGlzLnR5cGUgPSBHdCwgdGhpcy5sb2NhbGUgPSByLCB0aGlzLmNhc2VTZW5zaXRpdmUgPSB0LCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSA9IGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9lKHQsIGUpIHtcbiAgICAgIHRbMF0gPSBNYXRoLm1pbih0WzBdLCBlWzBdKSwgdFsxXSA9IE1hdGgubWluKHRbMV0sIGVbMV0pLCB0WzJdID0gTWF0aC5tYXgodFsyXSwgZVswXSksIHRbM10gPSBNYXRoLm1heCh0WzNdLCBlWzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBZSh0LCBlKSB7XG4gICAgICByZXR1cm4gISh0WzBdIDw9IGVbMF0gfHwgdFsyXSA+PSBlWzJdIHx8IHRbMV0gPD0gZVsxXSB8fCB0WzNdID49IGVbM10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNlKHQsIGUpIHtcbiAgICAgIHZhciByID0gKDE4MCArIHRbMF0pIC8gMzYwLFxuICAgICAgICAgIG4gPSAoMTgwIC0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgdFsxXSAqIE1hdGguUEkgLyAzNjApKSkgLyAzNjAsXG4gICAgICAgICAgaSA9IE1hdGgucG93KDIsIGUueik7XG4gICAgICByZXR1cm4gW01hdGgucm91bmQociAqIGkgKiA4MTkyKSwgTWF0aC5yb3VuZChuICogaSAqIDgxOTIpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZSh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gZVsxXSA+IHRbMV0gIT0gclsxXSA+IHRbMV0gJiYgdFswXSA8IChyWzBdIC0gZVswXSkgKiAodFsxXSAtIGVbMV0pIC8gKHJbMV0gLSBlWzFdKSArIGVbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSWUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciwgbiwgaSwgYSwgbywgcywgdSwgbCA9ICExLCBwID0gMCwgYyA9IGUubGVuZ3RoOyBwIDwgYzsgcCsrKSB7XG4gICAgICAgIGZvciAodmFyIGggPSBlW3BdLCBmID0gMCwgeSA9IGgubGVuZ3RoOyBmIDwgeSAtIDE7IGYrKykge1xuICAgICAgICAgIGlmICgoYSA9IChyID0gdClbMF0gLSAobiA9IGhbZl0pWzBdKSAqICh1ID0gclsxXSAtIChpID0gaFtmICsgMV0pWzFdKSAtIChzID0gclswXSAtIGlbMF0pICogKG8gPSByWzFdIC0gblsxXSkgPT0gMCAmJiBhICogcyA8PSAwICYmIG8gKiB1IDw9IDApIHJldHVybiAhMTtcbiAgICAgICAgICBrZSh0LCBoW2ZdLCBoW2YgKyAxXSkgJiYgKGwgPSAhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGlmIChJZSh0LCBlW3JdKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ2UodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBuWzBdIC0gclswXSxcbiAgICAgICAgICBhID0gblsxXSAtIHJbMV0sXG4gICAgICAgICAgbyA9ICh0WzBdIC0gclswXSkgKiBhIC0gaSAqICh0WzFdIC0gclsxXSksXG4gICAgICAgICAgcyA9IChlWzBdIC0gclswXSkgKiBhIC0gaSAqIChlWzFdIC0gclsxXSk7XG4gICAgICByZXR1cm4gbyA+IDAgJiYgcyA8IDAgfHwgbyA8IDAgJiYgcyA+IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRWUodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSByOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBhID0gaVtuXSwgbyA9IDA7IG8gPCBhLmxlbmd0aCAtIDE7ICsrbykge1xuICAgICAgICAgIGlmICgwICE9IChjID0gWyhwID0gYVtvICsgMV0pWzBdIC0gKGwgPSBhW29dKVswXSwgcFsxXSAtIGxbMV1dKVswXSAqIChoID0gWyh1ID0gZSlbMF0gLSAocyA9IHQpWzBdLCB1WzFdIC0gc1sxXV0pWzFdIC0gY1sxXSAqIGhbMF0gJiYgQ2UocywgdSwgbCwgcCkgJiYgQ2UobCwgcCwgcywgdSkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcywgdSwgbCwgcCwgYywgaDtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQZSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgaWYgKCFJZSh0W3JdLCBlKSkgcmV0dXJuICExO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoIC0gMTsgKytuKSB7XG4gICAgICAgIGlmIChFZSh0W25dLCB0W24gKyAxXSwgZSkpIHJldHVybiAhMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE1lKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICBpZiAoUGUodCwgZVtyXSkpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEJlKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgbyA9IDA7IG8gPCB0W2ldLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgdmFyIHMgPSBTZSh0W2ldW29dLCByKTtcbiAgICAgICAgICBfZShlLCBzKSwgYS5wdXNoKHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbi5wdXNoKGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUZSh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IEJlKHRbaV0sIGUsIHIpO1xuICAgICAgICBuLnB1c2goYSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFZlKHQsIGUsIHIsIG4pIHtcbiAgICAgIGlmICh0WzBdIDwgclswXSB8fCB0WzBdID4gclsyXSkge1xuICAgICAgICB2YXIgaSA9IC41ICogbixcbiAgICAgICAgICAgIGEgPSB0WzBdIC0gclswXSA+IGkgPyAtbiA6IHJbMF0gLSB0WzBdID4gaSA/IG4gOiAwO1xuICAgICAgICAwID09PSBhICYmIChhID0gdFswXSAtIHJbMl0gPiBpID8gLW4gOiByWzJdIC0gdFswXSA+IGkgPyBuIDogMCksIHRbMF0gKz0gYTtcbiAgICAgIH1cblxuICAgICAgX2UoZSwgdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRmUodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDgxOTIgKiBNYXRoLnBvdygyLCBuLnopLCBhID0gWzgxOTIgKiBuLngsIDgxOTIgKiBuLnldLCBvID0gW10sIHMgPSAwLCB1ID0gdDsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IDAsIHAgPSB1W3NdOyBsIDwgcC5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgICAgIHZhciBjID0gcFtsXSxcbiAgICAgICAgICAgICAgaCA9IFtjLnggKyBhWzBdLCBjLnkgKyBhWzFdXTtcbiAgICAgICAgICBWZShoLCBlLCByLCBpKSwgby5wdXNoKGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERlKHQsIGUsIHIsIG4pIHtcbiAgICAgIGZvciAodmFyIGksIGEgPSA4MTkyICogTWF0aC5wb3coMiwgbi56KSwgbyA9IFs4MTkyICogbi54LCA4MTkyICogbi55XSwgcyA9IFtdLCB1ID0gMCwgbCA9IHQ7IHUgPCBsLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSBbXSwgYyA9IDAsIGggPSBsW3VdOyBjIDwgaC5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgIHZhciBmID0gaFtjXSxcbiAgICAgICAgICAgICAgeSA9IFtmLnggKyBvWzBdLCBmLnkgKyBvWzFdXTtcbiAgICAgICAgICBfZShlLCB5KSwgcC5wdXNoKHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5wdXNoKHApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZVsyXSAtIGVbMF0gPD0gYSAvIDIpIHtcbiAgICAgICAgKGkgPSBlKVswXSA9IGlbMV0gPSAxIC8gMCwgaVsyXSA9IGlbM10gPSAtMSAvIDA7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9IDAsIG0gPSBzOyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIHYgPSAwLCBnID0gbVtkXTsgdiA8IGcubGVuZ3RoOyB2ICs9IDEpIHtcbiAgICAgICAgICAgIFZlKGdbdl0sIGUsIHIsIGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB3ZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoMiAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciByID0gdFsxXTtcbiAgICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiByIHx8IEFycmF5LmlzQXJyYXkocikpIHJldHVybiBlLmVycm9yKFwiQ29sbGF0b3Igb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB2YXIgbiA9IGUucGFyc2Uodm9pZCAwICE9PSByW1wiY2FzZS1zZW5zaXRpdmVcIl0gJiYgcltcImNhc2Utc2Vuc2l0aXZlXCJdLCAxLCBqdCk7XG4gICAgICBpZiAoIW4pIHJldHVybiBudWxsO1xuICAgICAgdmFyIGkgPSBlLnBhcnNlKHZvaWQgMCAhPT0gcltcImRpYWNyaXRpYy1zZW5zaXRpdmVcIl0gJiYgcltcImRpYWNyaXRpYy1zZW5zaXRpdmVcIl0sIDEsIGp0KTtcbiAgICAgIGlmICghaSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgYSA9IG51bGw7XG4gICAgICByZXR1cm4gci5sb2NhbGUgJiYgIShhID0gZS5wYXJzZShyLmxvY2FsZSwgMSwgVXQpKSA/IG51bGwgOiBuZXcgd2UobiwgaSwgYSk7XG4gICAgfSwgd2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgcmUodGhpcy5jYXNlU2Vuc2l0aXZlLmV2YWx1YXRlKHQpLCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5ldmFsdWF0ZSh0KSwgdGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZSh0KSA6IG51bGwpO1xuICAgIH0sIHdlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmNhc2VTZW5zaXRpdmUpLCB0KHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlKSwgdGhpcy5sb2NhbGUgJiYgdCh0aGlzLmxvY2FsZSk7XG4gICAgfSwgd2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgd2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0ge307XG4gICAgICByZXR1cm4gdFtcImNhc2Utc2Vuc2l0aXZlXCJdID0gdGhpcy5jYXNlU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpLCB0W1wiZGlhY3JpdGljLXNlbnNpdGl2ZVwiXSA9IHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpLCB0aGlzLmxvY2FsZSAmJiAodC5sb2NhbGUgPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKSksIFtcImNvbGxhdG9yXCIsIHRdO1xuICAgIH07XG5cbiAgICB2YXIgTGUgPSBmdW5jdGlvbiBMZSh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSBqdCwgdGhpcy5nZW9qc29uID0gdCwgdGhpcy5nZW9tZXRyaWVzID0gZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmUodCkge1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBiZSkge1xuICAgICAgICBpZiAoXCJnZXRcIiA9PT0gdC5uYW1lICYmIDEgPT09IHQuYXJncy5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwiZmVhdHVyZS1zdGF0ZVwiID09PSB0Lm5hbWUpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwiaGFzXCIgPT09IHQubmFtZSAmJiAxID09PSB0LmFyZ3MubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcInByb3BlcnRpZXNcIiA9PT0gdC5uYW1lIHx8IFwiZ2VvbWV0cnktdHlwZVwiID09PSB0Lm5hbWUgfHwgXCJpZFwiID09PSB0Lm5hbWUpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKC9eZmlsdGVyLS8udGVzdCh0Lm5hbWUpKSByZXR1cm4gITE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0IGluc3RhbmNlb2YgTGUpIHJldHVybiAhMTtcbiAgICAgIHZhciBlID0gITA7XG4gICAgICByZXR1cm4gdC5lYWNoQ2hpbGQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZSAmJiAhUmUodCkgJiYgKGUgPSAhMSk7XG4gICAgICB9KSwgZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPZSh0KSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGJlICYmIFwiZmVhdHVyZS1zdGF0ZVwiID09PSB0Lm5hbWUpIHJldHVybiAhMTtcbiAgICAgIHZhciBlID0gITA7XG4gICAgICByZXR1cm4gdC5lYWNoQ2hpbGQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZSAmJiAhT2UodCkgJiYgKGUgPSAhMSk7XG4gICAgICB9KSwgZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVZSh0LCBlKSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGJlICYmIGUuaW5kZXhPZih0Lm5hbWUpID49IDApIHJldHVybiAhMTtcbiAgICAgIHZhciByID0gITA7XG4gICAgICByZXR1cm4gdC5lYWNoQ2hpbGQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgciAmJiAhVWUodCwgZSkgJiYgKHIgPSAhMSk7XG4gICAgICB9KSwgcjtcbiAgICB9XG5cbiAgICBMZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoMiAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcblxuICAgICAgaWYgKHNlKHRbMV0pKSB7XG4gICAgICAgIHZhciByID0gdFsxXTtcbiAgICAgICAgaWYgKFwiRmVhdHVyZUNvbGxlY3Rpb25cIiA9PT0gci50eXBlKSBmb3IgKHZhciBuID0gMDsgbiA8IHIuZmVhdHVyZXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICB2YXIgaSA9IHIuZmVhdHVyZXNbbl0uZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgICBpZiAoXCJQb2x5Z29uXCIgPT09IGkgfHwgXCJNdWx0aVBvbHlnb25cIiA9PT0gaSkgcmV0dXJuIG5ldyBMZShyLCByLmZlYXR1cmVzW25dLmdlb21ldHJ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChcIkZlYXR1cmVcIiA9PT0gci50eXBlKSB7XG4gICAgICAgICAgdmFyIGEgPSByLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgaWYgKFwiUG9seWdvblwiID09PSBhIHx8IFwiTXVsdGlQb2x5Z29uXCIgPT09IGEpIHJldHVybiBuZXcgTGUociwgci5nZW9tZXRyeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJQb2x5Z29uXCIgPT09IHIudHlwZSB8fCBcIk11bHRpUG9seWdvblwiID09PSByLnR5cGUpIHJldHVybiBuZXcgTGUociwgcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlLmVycm9yKFwiJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyB2YWxpZCBnZW9qc29uIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvbHlnb24gZ2VvbWV0cnkgdHlwZS5cIik7XG4gICAgfSwgTGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmIChudWxsICE9IHQuZ2VvbWV0cnkoKSAmJiBudWxsICE9IHQuY2Fub25pY2FsSUQoKSkge1xuICAgICAgICBpZiAoXCJQb2ludFwiID09PSB0Lmdlb21ldHJ5VHlwZSgpKSByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSxcbiAgICAgICAgICAgICAgbiA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSxcbiAgICAgICAgICAgICAgaSA9IHQuY2Fub25pY2FsSUQoKTtcblxuICAgICAgICAgIGlmIChcIlBvbHlnb25cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IEJlKGUuY29vcmRpbmF0ZXMsIG4sIGkpLFxuICAgICAgICAgICAgICAgIG8gPSBGZSh0Lmdlb21ldHJ5KCksIHIsIG4sIGkpO1xuICAgICAgICAgICAgaWYgKCFBZShyLCBuKSkgcmV0dXJuICExO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgdSA9IG87IHMgPCB1Lmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghSWUodVtzXSwgYSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJNdWx0aVBvbHlnb25cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgICAgICB2YXIgbCA9IFRlKGUuY29vcmRpbmF0ZXMsIG4sIGkpLFxuICAgICAgICAgICAgICAgIHAgPSBGZSh0Lmdlb21ldHJ5KCksIHIsIG4sIGkpO1xuICAgICAgICAgICAgaWYgKCFBZShyLCBuKSkgcmV0dXJuICExO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgaCA9IHA7IGMgPCBoLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghemUoaFtjXSwgbCkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0odCwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgICAgaWYgKFwiTGluZVN0cmluZ1wiID09PSB0Lmdlb21ldHJ5VHlwZSgpKSByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSxcbiAgICAgICAgICAgICAgbiA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSxcbiAgICAgICAgICAgICAgaSA9IHQuY2Fub25pY2FsSUQoKTtcblxuICAgICAgICAgIGlmIChcIlBvbHlnb25cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IEJlKGUuY29vcmRpbmF0ZXMsIG4sIGkpLFxuICAgICAgICAgICAgICAgIG8gPSBEZSh0Lmdlb21ldHJ5KCksIHIsIG4sIGkpO1xuICAgICAgICAgICAgaWYgKCFBZShyLCBuKSkgcmV0dXJuICExO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgdSA9IG87IHMgPCB1Lmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghUGUodVtzXSwgYSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJNdWx0aVBvbHlnb25cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgICAgICB2YXIgbCA9IFRlKGUuY29vcmRpbmF0ZXMsIG4sIGkpLFxuICAgICAgICAgICAgICAgIHAgPSBEZSh0Lmdlb21ldHJ5KCksIHIsIG4sIGkpO1xuICAgICAgICAgICAgaWYgKCFBZShyLCBuKSkgcmV0dXJuICExO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgaCA9IHA7IGMgPCBoLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghTWUoaFtjXSwgbCkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0odCwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIExlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAoKSB7fSwgTGUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgTGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXCJ3aXRoaW5cIiwgdGhpcy5nZW9qc29uXTtcbiAgICB9O1xuXG4gICAgdmFyIGplID0gZnVuY3Rpb24gamUodCwgZSkge1xuICAgICAgdGhpcy50eXBlID0gZS50eXBlLCB0aGlzLm5hbWUgPSB0LCB0aGlzLmJvdW5kRXhwcmVzc2lvbiA9IGU7XG4gICAgfTtcblxuICAgIGplLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiB0WzFdKSByZXR1cm4gZS5lcnJvcihcIid2YXInIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIgPSB0WzFdO1xuICAgICAgcmV0dXJuIGUuc2NvcGUuaGFzKHIpID8gbmV3IGplKHIsIGUuc2NvcGUuZ2V0KHIpKSA6IGUuZXJyb3IoJ1Vua25vd24gdmFyaWFibGUgXCInICsgciArICdcIi4gTWFrZSBzdXJlIFwiJyArIHIgKyAnXCIgaGFzIGJlZW4gYm91bmQgaW4gYW4gZW5jbG9zaW5nIFwibGV0XCIgZXhwcmVzc2lvbiBiZWZvcmUgdXNpbmcgaXQuJywgMSk7XG4gICAgfSwgamUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvdW5kRXhwcmVzc2lvbi5ldmFsdWF0ZSh0KTtcbiAgICB9LCBqZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKCkge30sIGplLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGplLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1widmFyXCIsIHRoaXMubmFtZV07XG4gICAgfTtcblxuICAgIHZhciBxZSA9IGZ1bmN0aW9uIHFlKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IFtdKSwgdm9pZCAwID09PSBuICYmIChuID0gbmV3IEx0KCkpLCB2b2lkIDAgPT09IGkgJiYgKGkgPSBbXSksIHRoaXMucmVnaXN0cnkgPSB0LCB0aGlzLnBhdGggPSBlLCB0aGlzLmtleSA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIHQgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCJcIiksIHRoaXMuc2NvcGUgPSBuLCB0aGlzLmVycm9ycyA9IGksIHRoaXMuZXhwZWN0ZWRUeXBlID0gcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTmUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciwgbiA9IHQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBuLCBvID0gMDsgaSA8PSBhOykge1xuICAgICAgICBpZiAoKHIgPSB0W28gPSBNYXRoLmZsb29yKChpICsgYSkgLyAyKV0pIDw9IGUpIHtcbiAgICAgICAgICBpZiAobyA9PT0gbiB8fCBlIDwgdFtvICsgMV0pIHJldHVybiBvO1xuICAgICAgICAgIGkgPSBvICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIShyID4gZSkpIHRocm93IG5ldyBjZShcIklucHV0IGlzIG5vdCBhIG51bWJlci5cIik7XG4gICAgICAgICAgYSA9IG8gLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHFlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBpICYmIChpID0ge30pLCBlID8gdGhpcy5jb25jYXQoZSwgciwgbikuX3BhcnNlKHQsIGkpIDogdGhpcy5fcGFyc2UodCwgaSk7XG4gICAgfSwgcWUucHJvdG90eXBlLl9wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmdW5jdGlvbiByKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXNzZXJ0XCIgPT09IHIgPyBuZXcgZmUoZSwgW3RdKSA6IFwiY29lcmNlXCIgPT09IHIgPyBuZXcgdmUoZSwgW3RdKSA6IHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChudWxsICE9PSB0ICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgJiYgXCJib29sZWFuXCIgIT0gdHlwZW9mIHQgJiYgXCJudW1iZXJcIiAhPSB0eXBlb2YgdCB8fCAodCA9IFtcImxpdGVyYWxcIiwgdF0pLCBBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgIGlmICgwID09PSB0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuZXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbXV0uJyk7XG4gICAgICAgIHZhciBuID0gdFswXTtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIG4pIHJldHVybiB0aGlzLmVycm9yKFwiRXhwcmVzc2lvbiBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIHR5cGVvZiBuICsgJyBpbnN0ZWFkLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLicsIDApLCBudWxsO1xuICAgICAgICB2YXIgaSA9IHRoaXMucmVnaXN0cnlbbl07XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICB2YXIgYSA9IGkucGFyc2UodCwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFhKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGlmICh0aGlzLmV4cGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmV4cGVjdGVkVHlwZSxcbiAgICAgICAgICAgICAgICBzID0gYS50eXBlO1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IG8ua2luZCAmJiBcIm51bWJlclwiICE9PSBvLmtpbmQgJiYgXCJib29sZWFuXCIgIT09IG8ua2luZCAmJiBcIm9iamVjdFwiICE9PSBvLmtpbmQgJiYgXCJhcnJheVwiICE9PSBvLmtpbmQgfHwgXCJ2YWx1ZVwiICE9PSBzLmtpbmQpIHtcbiAgICAgICAgICAgICAgaWYgKFwiY29sb3JcIiAhPT0gby5raW5kICYmIFwiZm9ybWF0dGVkXCIgIT09IG8ua2luZCAmJiBcInJlc29sdmVkSW1hZ2VcIiAhPT0gby5raW5kIHx8IFwidmFsdWVcIiAhPT0gcy5raW5kICYmIFwic3RyaW5nXCIgIT09IHMua2luZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrU3VidHlwZShvLCBzKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBhID0gcihhLCBvLCBlLnR5cGVBbm5vdGF0aW9uIHx8IFwiY29lcmNlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGEgPSByKGEsIG8sIGUudHlwZUFubm90YXRpb24gfHwgXCJhc3NlcnRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIHBlKSAmJiBcInJlc29sdmVkSW1hZ2VcIiAhPT0gYS50eXBlLmtpbmQgJiYgZnVuY3Rpb24gdChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGplKSByZXR1cm4gdChlLmJvdW5kRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGJlICYmIFwiZXJyb3JcIiA9PT0gZS5uYW1lKSByZXR1cm4gITE7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHdlKSByZXR1cm4gITE7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIExlKSByZXR1cm4gITE7XG4gICAgICAgICAgICB2YXIgciA9IGUgaW5zdGFuY2VvZiB2ZSB8fCBlIGluc3RhbmNlb2YgZmUsXG4gICAgICAgICAgICAgICAgbiA9ICEwO1xuICAgICAgICAgICAgcmV0dXJuIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG4gPSByID8gbiAmJiB0KGUpIDogbiAmJiBlIGluc3RhbmNlb2YgcGU7XG4gICAgICAgICAgICB9KSwgISFuICYmIFJlKGUpICYmIFVlKGUsIFtcInpvb21cIiwgXCJoZWF0bWFwLWRlbnNpdHlcIiwgXCJsaW5lLXByb2dyZXNzXCIsIFwiYWNjdW11bGF0ZWRcIiwgXCJpcy1zdXBwb3J0ZWQtc2NyaXB0XCJdKTtcbiAgICAgICAgICB9KGEpKSB7XG4gICAgICAgICAgICB2YXIgdSA9IG5ldyB4ZSgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhID0gbmV3IHBlKGEudHlwZSwgYS5ldmFsdWF0ZSh1KSk7XG4gICAgICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKHQubWVzc2FnZSksIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW5rbm93biBleHByZXNzaW9uIFwiJyArIG4gKyAnXCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVycm9yKHZvaWQgMCA9PT0gdCA/IFwiJ3VuZGVmaW5lZCcgdmFsdWUgaW52YWxpZC4gVXNlIG51bGwgaW5zdGVhZC5cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgPyAnQmFyZSBvYmplY3RzIGludmFsaWQuIFVzZSBbXCJsaXRlcmFsXCIsIHsuLi59XSBpbnN0ZWFkLicgOiBcIkV4cGVjdGVkIGFuIGFycmF5LCBidXQgZm91bmQgXCIgKyB0eXBlb2YgdCArIFwiIGluc3RlYWQuXCIpO1xuICAgIH0sIHFlLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBcIm51bWJlclwiID09IHR5cGVvZiB0ID8gdGhpcy5wYXRoLmNvbmNhdCh0KSA6IHRoaXMucGF0aCxcbiAgICAgICAgICBpID0gciA/IHRoaXMuc2NvcGUuY29uY2F0KHIpIDogdGhpcy5zY29wZTtcbiAgICAgIHJldHVybiBuZXcgcWUodGhpcy5yZWdpc3RyeSwgbiwgZSB8fCBudWxsLCBpLCB0aGlzLmVycm9ycyk7XG4gICAgfSwgcWUucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSBbXSwgciA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyByLS0gPiAwOykge1xuICAgICAgICBlW3JdID0gYXJndW1lbnRzW3IgKyAxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG4gPSBcIlwiICsgdGhpcy5rZXkgKyBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyB0ICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRHQobiwgdCkpO1xuICAgIH0sIHFlLnByb3RvdHlwZS5jaGVja1N1YnR5cGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSAkdCh0LCBlKTtcbiAgICAgIHJldHVybiByICYmIHRoaXMuZXJyb3IociksIHI7XG4gICAgfTtcblxuICAgIHZhciBLZSA9IGZ1bmN0aW9uIEtlKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5wdXQgPSBlLCB0aGlzLmxhYmVscyA9IFtdLCB0aGlzLm91dHB1dHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSByOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl0sXG4gICAgICAgICAgICBvID0gYVsxXTtcbiAgICAgICAgdGhpcy5sYWJlbHMucHVzaChhWzBdKSwgdGhpcy5vdXRwdXRzLnB1c2gobyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEdlKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0ICogKDEgLSByKSArIGUgKiByO1xuICAgIH1cblxuICAgIEtlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCAtIDEgPCA0KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIuXCIpO1xuICAgICAgaWYgKCh0Lmxlbmd0aCAtIDEpICUgMiAhPSAwKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICB2YXIgciA9IGUucGFyc2UodFsxXSwgMSwgT3QpO1xuICAgICAgaWYgKCFyKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBuID0gW10sXG4gICAgICAgICAgaSA9IG51bGw7XG4gICAgICBlLmV4cGVjdGVkVHlwZSAmJiBcInZhbHVlXCIgIT09IGUuZXhwZWN0ZWRUeXBlLmtpbmQgJiYgKGkgPSBlLmV4cGVjdGVkVHlwZSk7XG5cbiAgICAgIGZvciAodmFyIGEgPSAxOyBhIDwgdC5sZW5ndGg7IGEgKz0gMikge1xuICAgICAgICB2YXIgbyA9IDEgPT09IGEgPyAtMSAvIDAgOiB0W2FdLFxuICAgICAgICAgICAgcyA9IHRbYSArIDFdLFxuICAgICAgICAgICAgdSA9IGEsXG4gICAgICAgICAgICBsID0gYSArIDE7XG4gICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBvKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCB1KTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoICYmIG5bbi5sZW5ndGggLSAxXVswXSA+PSBvKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCB1KTtcbiAgICAgICAgdmFyIHAgPSBlLnBhcnNlKHMsIGwsIGkpO1xuICAgICAgICBpZiAoIXApIHJldHVybiBudWxsO1xuICAgICAgICBpID0gaSB8fCBwLnR5cGUsIG4ucHVzaChbbywgcF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEtlKGksIHIsIG4pO1xuICAgIH0sIEtlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubGFiZWxzLFxuICAgICAgICAgIHIgPSB0aGlzLm91dHB1dHM7XG4gICAgICBpZiAoMSA9PT0gZS5sZW5ndGgpIHJldHVybiByWzBdLmV2YWx1YXRlKHQpO1xuICAgICAgdmFyIG4gPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKG4gPD0gZVswXSkgcmV0dXJuIHJbMF0uZXZhbHVhdGUodCk7XG4gICAgICB2YXIgaSA9IGUubGVuZ3RoO1xuICAgICAgcmV0dXJuIG4gPj0gZVtpIC0gMV0gPyByW2kgLSAxXS5ldmFsdWF0ZSh0KSA6IHJbTmUoZSwgbildLmV2YWx1YXRlKHQpO1xuICAgIH0sIEtlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KTtcblxuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0aGlzLm91dHB1dHM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHQocltlXSk7XG4gICAgICB9XG4gICAgfSwgS2UucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH0sIEtlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gW1wic3RlcFwiLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXSwgZSA9IDA7IGUgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGUrKykge1xuICAgICAgICBlID4gMCAmJiB0LnB1c2godGhpcy5sYWJlbHNbZV0pLCB0LnB1c2godGhpcy5vdXRwdXRzW2VdLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB2YXIgWmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIG51bWJlcjogR2UsXG4gICAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IodCwgZSwgcikge1xuICAgICAgICByZXR1cm4gbmV3IGVlKEdlKHQuciwgZS5yLCByKSwgR2UodC5nLCBlLmcsIHIpLCBHZSh0LmIsIGUuYiwgciksIEdlKHQuYSwgZS5hLCByKSk7XG4gICAgICB9LFxuICAgICAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIHQubWFwKGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgcmV0dXJuIEdlKHQsIGVbbl0sIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAgICAgWGUgPSA2IC8gMjkgKiAzICogKDYgLyAyOSksXG4gICAgICAgIEplID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgICAgSGUgPSAxODAgLyBNYXRoLlBJO1xuXG4gICAgZnVuY3Rpb24gWWUodCkge1xuICAgICAgcmV0dXJuIHQgPiAuMDA4ODU2NDUxNjc5MDM1NjMxID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIFhlICsgNCAvIDI5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRlKHQpIHtcbiAgICAgIHJldHVybiB0ID4gNiAvIDI5ID8gdCAqIHQgKiB0IDogWGUgKiAodCAtIDQgLyAyOSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2UodCkge1xuICAgICAgcmV0dXJuIDI1NSAqICh0IDw9IC4wMDMxMzA4ID8gMTIuOTIgKiB0IDogMS4wNTUgKiBNYXRoLnBvdyh0LCAxIC8gMi40KSAtIC4wNTUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFFlKHQpIHtcbiAgICAgIHJldHVybiAodCAvPSAyNTUpIDw9IC4wNDA0NSA/IHQgLyAxMi45MiA6IE1hdGgucG93KCh0ICsgLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cih0KSB7XG4gICAgICB2YXIgZSA9IFFlKHQuciksXG4gICAgICAgICAgciA9IFFlKHQuZyksXG4gICAgICAgICAgbiA9IFFlKHQuYiksXG4gICAgICAgICAgaSA9IFllKCguNDEyNDU2NCAqIGUgKyAuMzU3NTc2MSAqIHIgKyAuMTgwNDM3NSAqIG4pIC8gLjk1MDQ3KSxcbiAgICAgICAgICBhID0gWWUoKC4yMTI2NzI5ICogZSArIC43MTUxNTIyICogciArIC4wNzIxNzUgKiBuKSAvIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbDogMTE2ICogYSAtIDE2LFxuICAgICAgICBhOiA1MDAgKiAoaSAtIGEpLFxuICAgICAgICBiOiAyMDAgKiAoYSAtIFllKCguMDE5MzMzOSAqIGUgKyAuMTE5MTkyICogciArIC45NTAzMDQxICogbikgLyAxLjA4ODgzKSksXG4gICAgICAgIGFscGhhOiB0LmFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXIodCkge1xuICAgICAgdmFyIGUgPSAodC5sICsgMTYpIC8gMTE2LFxuICAgICAgICAgIHIgPSBpc05hTih0LmEpID8gZSA6IGUgKyB0LmEgLyA1MDAsXG4gICAgICAgICAgbiA9IGlzTmFOKHQuYikgPyBlIDogZSAtIHQuYiAvIDIwMDtcbiAgICAgIHJldHVybiBlID0gMSAqICRlKGUpLCByID0gLjk1MDQ3ICogJGUociksIG4gPSAxLjA4ODgzICogJGUobiksIG5ldyBlZShXZSgzLjI0MDQ1NDIgKiByIC0gMS41MzcxMzg1ICogZSAtIC40OTg1MzE0ICogbiksIFdlKC0uOTY5MjY2ICogciArIDEuODc2MDEwOCAqIGUgKyAuMDQxNTU2ICogbiksIFdlKC4wNTU2NDM0ICogciAtIC4yMDQwMjU5ICogZSArIDEuMDU3MjI1MiAqIG4pLCB0LmFscGhhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBycih0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUgLSB0O1xuICAgICAgcmV0dXJuIHQgKyByICogKG4gPiAxODAgfHwgbiA8IC0xODAgPyBuIC0gMzYwICogTWF0aC5yb3VuZChuIC8gMzYwKSA6IG4pO1xuICAgIH1cblxuICAgIHZhciBuciA9IHtcbiAgICAgIGZvcndhcmQ6IHRyLFxuICAgICAgcmV2ZXJzZTogZXIsXG4gICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodCwgZSwgcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGw6IEdlKHQubCwgZS5sLCByKSxcbiAgICAgICAgICBhOiBHZSh0LmEsIGUuYSwgciksXG4gICAgICAgICAgYjogR2UodC5iLCBlLmIsIHIpLFxuICAgICAgICAgIGFscGhhOiBHZSh0LmFscGhhLCBlLmFscGhhLCByKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGlyID0ge1xuICAgICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCh0KSB7XG4gICAgICAgIHZhciBlID0gdHIodCksXG4gICAgICAgICAgICByID0gZS5sLFxuICAgICAgICAgICAgbiA9IGUuYSxcbiAgICAgICAgICAgIGkgPSBlLmIsXG4gICAgICAgICAgICBhID0gTWF0aC5hdGFuMihpLCBuKSAqIEhlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IGEgPCAwID8gYSArIDM2MCA6IGEsXG4gICAgICAgICAgYzogTWF0aC5zcXJ0KG4gKiBuICsgaSAqIGkpLFxuICAgICAgICAgIGw6IHIsXG4gICAgICAgICAgYWxwaGE6IHQuYVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UodCkge1xuICAgICAgICB2YXIgZSA9IHQuaCAqIEplLFxuICAgICAgICAgICAgciA9IHQuYztcbiAgICAgICAgcmV0dXJuIGVyKHtcbiAgICAgICAgICBsOiB0LmwsXG4gICAgICAgICAgYTogTWF0aC5jb3MoZSkgKiByLFxuICAgICAgICAgIGI6IE1hdGguc2luKGUpICogcixcbiAgICAgICAgICBhbHBoYTogdC5hbHBoYVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodCwgZSwgcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IHJyKHQuaCwgZS5oLCByKSxcbiAgICAgICAgICBjOiBHZSh0LmMsIGUuYywgciksXG4gICAgICAgICAgbDogR2UodC5sLCBlLmwsIHIpLFxuICAgICAgICAgIGFscGhhOiBHZSh0LmFscGhhLCBlLmFscGhhLCByKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGFyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICBsYWI6IG5yLFxuICAgICAgaGNsOiBpclxuICAgIH0pLFxuICAgICAgICBvciA9IGZ1bmN0aW9uIG9yKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMub3BlcmF0b3IgPSBlLCB0aGlzLmludGVycG9sYXRpb24gPSByLCB0aGlzLmlucHV0ID0gbiwgdGhpcy5sYWJlbHMgPSBbXSwgdGhpcy5vdXRwdXRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGEgPSAwLCBvID0gaTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgdmFyIHMgPSBvW2FdLFxuICAgICAgICAgICAgdSA9IHNbMV07XG4gICAgICAgIHRoaXMubGFiZWxzLnB1c2goc1swXSksIHRoaXMub3V0cHV0cy5wdXNoKHUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzcih0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IG4gLSByLFxuICAgICAgICAgIGEgPSB0IC0gcjtcbiAgICAgIHJldHVybiAwID09PSBpID8gMCA6IDEgPT09IGUgPyBhIC8gaSA6IChNYXRoLnBvdyhlLCBhKSAtIDEpIC8gKE1hdGgucG93KGUsIGkpIC0gMSk7XG4gICAgfVxuXG4gICAgb3IuaW50ZXJwb2xhdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh0LCBlLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9IDA7XG4gICAgICBpZiAoXCJleHBvbmVudGlhbFwiID09PSB0Lm5hbWUpIGEgPSBzcihlLCB0LmJhc2UsIG4sIGkpO2Vsc2UgaWYgKFwibGluZWFyXCIgPT09IHQubmFtZSkgYSA9IHNyKGUsIDEsIG4sIGkpO2Vsc2UgaWYgKFwiY3ViaWMtYmV6aWVyXCIgPT09IHQubmFtZSkge1xuICAgICAgICB2YXIgbyA9IHQuY29udHJvbFBvaW50cztcbiAgICAgICAgYSA9IG5ldyByKG9bMF0sIG9bMV0sIG9bMl0sIG9bM10pLnNvbHZlKHNyKGUsIDEsIG4sIGkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH0sIG9yLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdFswXSxcbiAgICAgICAgICBuID0gdFsxXSxcbiAgICAgICAgICBpID0gdFsyXSxcbiAgICAgICAgICBhID0gdC5zbGljZSgzKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShuKSB8fCAwID09PSBuLmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhbiBpbnRlcnBvbGF0aW9uIHR5cGUgZXhwcmVzc2lvbi5cIiwgMSk7XG4gICAgICBpZiAoXCJsaW5lYXJcIiA9PT0gblswXSkgbiA9IHtcbiAgICAgICAgbmFtZTogXCJsaW5lYXJcIlxuICAgICAgfTtlbHNlIGlmIChcImV4cG9uZW50aWFsXCIgPT09IG5bMF0pIHtcbiAgICAgICAgdmFyIG8gPSBuWzFdO1xuICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgbykgcmV0dXJuIGUuZXJyb3IoXCJFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGEgbnVtZXJpYyBiYXNlLlwiLCAxLCAxKTtcbiAgICAgICAgbiA9IHtcbiAgICAgICAgICBuYW1lOiBcImV4cG9uZW50aWFsXCIsXG4gICAgICAgICAgYmFzZTogb1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFwiY3ViaWMtYmV6aWVyXCIgIT09IG5bMF0pIHJldHVybiBlLmVycm9yKFwiVW5rbm93biBpbnRlcnBvbGF0aW9uIHR5cGUgXCIgKyBTdHJpbmcoblswXSksIDEsIDApO1xuICAgICAgICB2YXIgcyA9IG4uc2xpY2UoMSk7XG4gICAgICAgIGlmICg0ICE9PSBzLmxlbmd0aCB8fCBzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIiAhPSB0eXBlb2YgdCB8fCB0IDwgMCB8fCB0ID4gMTtcbiAgICAgICAgfSkpIHJldHVybiBlLmVycm9yKFwiQ3ViaWMgYmV6aWVyIGludGVycG9sYXRpb24gcmVxdWlyZXMgZm91ciBudW1lcmljIGFyZ3VtZW50cyB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXCIsIDEpO1xuICAgICAgICBuID0ge1xuICAgICAgICAgIG5hbWU6IFwiY3ViaWMtYmV6aWVyXCIsXG4gICAgICAgICAgY29udHJvbFBvaW50czogc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHQubGVuZ3RoIC0gMSA8IDQpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5IFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIi5cIik7XG4gICAgICBpZiAoKHQubGVuZ3RoIC0gMSkgJSAyICE9IDApIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtcbiAgICAgIGlmICghKGkgPSBlLnBhcnNlKGksIDIsIE90KSkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHUgPSBbXSxcbiAgICAgICAgICBsID0gbnVsbDtcbiAgICAgIFwiaW50ZXJwb2xhdGUtaGNsXCIgPT09IHIgfHwgXCJpbnRlcnBvbGF0ZS1sYWJcIiA9PT0gciA/IGwgPSBxdCA6IGUuZXhwZWN0ZWRUeXBlICYmIFwidmFsdWVcIiAhPT0gZS5leHBlY3RlZFR5cGUua2luZCAmJiAobCA9IGUuZXhwZWN0ZWRUeXBlKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBhLmxlbmd0aDsgcCArPSAyKSB7XG4gICAgICAgIHZhciBjID0gYVtwXSxcbiAgICAgICAgICAgIGggPSBhW3AgKyAxXSxcbiAgICAgICAgICAgIGYgPSBwICsgMyxcbiAgICAgICAgICAgIHkgPSBwICsgNDtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGMpIHJldHVybiBlLmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCBmKTtcbiAgICAgICAgaWYgKHUubGVuZ3RoICYmIHVbdS5sZW5ndGggLSAxXVswXSA+PSBjKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgZik7XG4gICAgICAgIHZhciBkID0gZS5wYXJzZShoLCB5LCBsKTtcbiAgICAgICAgaWYgKCFkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbCA9IGwgfHwgZC50eXBlLCB1LnB1c2goW2MsIGRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT09IGwua2luZCB8fCBcImNvbG9yXCIgPT09IGwua2luZCB8fCBcImFycmF5XCIgPT09IGwua2luZCAmJiBcIm51bWJlclwiID09PSBsLml0ZW1UeXBlLmtpbmQgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgbC5OID8gbmV3IG9yKGwsIHIsIG4sIGksIHUpIDogZS5lcnJvcihcIlR5cGUgXCIgKyBIdChsKSArIFwiIGlzIG5vdCBpbnRlcnBvbGF0YWJsZS5cIik7XG4gICAgfSwgb3IucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5sYWJlbHMsXG4gICAgICAgICAgciA9IHRoaXMub3V0cHV0cztcbiAgICAgIGlmICgxID09PSBlLmxlbmd0aCkgcmV0dXJuIHJbMF0uZXZhbHVhdGUodCk7XG4gICAgICB2YXIgbiA9IHRoaXMuaW5wdXQuZXZhbHVhdGUodCk7XG4gICAgICBpZiAobiA8PSBlWzBdKSByZXR1cm4gclswXS5ldmFsdWF0ZSh0KTtcbiAgICAgIHZhciBpID0gZS5sZW5ndGg7XG4gICAgICBpZiAobiA+PSBlW2kgLSAxXSkgcmV0dXJuIHJbaSAtIDFdLmV2YWx1YXRlKHQpO1xuICAgICAgdmFyIGEgPSBOZShlLCBuKSxcbiAgICAgICAgICBvID0gb3IuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb24sIG4sIGVbYV0sIGVbYSArIDFdKSxcbiAgICAgICAgICBzID0gclthXS5ldmFsdWF0ZSh0KSxcbiAgICAgICAgICB1ID0gclthICsgMV0uZXZhbHVhdGUodCk7XG4gICAgICByZXR1cm4gXCJpbnRlcnBvbGF0ZVwiID09PSB0aGlzLm9wZXJhdG9yID8gWmVbdGhpcy50eXBlLmtpbmQudG9Mb3dlckNhc2UoKV0ocywgdSwgbykgOiBcImludGVycG9sYXRlLWhjbFwiID09PSB0aGlzLm9wZXJhdG9yID8gaXIucmV2ZXJzZShpci5pbnRlcnBvbGF0ZShpci5mb3J3YXJkKHMpLCBpci5mb3J3YXJkKHUpLCBvKSkgOiBuci5yZXZlcnNlKG5yLmludGVycG9sYXRlKG5yLmZvcndhcmQocyksIG5yLmZvcndhcmQodSksIG8pKTtcbiAgICB9LCBvci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5pbnB1dCk7XG5cbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5vdXRwdXRzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB0KHJbZV0pO1xuICAgICAgfVxuICAgIH0sIG9yLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9LCBvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQ7XG4gICAgICB0ID0gXCJsaW5lYXJcIiA9PT0gdGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPyBbXCJsaW5lYXJcIl0gOiBcImV4cG9uZW50aWFsXCIgPT09IHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID8gMSA9PT0gdGhpcy5pbnRlcnBvbGF0aW9uLmJhc2UgPyBbXCJsaW5lYXJcIl0gOiBbXCJleHBvbmVudGlhbFwiLCB0aGlzLmludGVycG9sYXRpb24uYmFzZV0gOiBbXCJjdWJpYy1iZXppZXJcIl0uY29uY2F0KHRoaXMuaW50ZXJwb2xhdGlvbi5jb250cm9sUG9pbnRzKTtcblxuICAgICAgZm9yICh2YXIgZSA9IFt0aGlzLm9wZXJhdG9yLCB0LCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXSwgciA9IDA7IHIgPCB0aGlzLmxhYmVscy5sZW5ndGg7IHIrKykge1xuICAgICAgICBlLnB1c2godGhpcy5sYWJlbHNbcl0sIHRoaXMub3V0cHV0c1tyXS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH07XG5cbiAgICB2YXIgdXIgPSBmdW5jdGlvbiB1cih0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmFyZ3MgPSBlO1xuICAgIH07XG5cbiAgICB1ci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCAyKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgciA9IG51bGwsXG4gICAgICAgICAgbiA9IGUuZXhwZWN0ZWRUeXBlO1xuICAgICAgbiAmJiBcInZhbHVlXCIgIT09IG4ua2luZCAmJiAociA9IG4pO1xuXG4gICAgICBmb3IgKHZhciBpID0gW10sIGEgPSAwLCBvID0gdC5zbGljZSgxKTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgdmFyIHMgPSBlLnBhcnNlKG9bYV0sIDEgKyBpLmxlbmd0aCwgciwgdm9pZCAwLCB7XG4gICAgICAgICAgdHlwZUFubm90YXRpb246IFwib21pdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXMpIHJldHVybiBudWxsO1xuICAgICAgICByID0gciB8fCBzLnR5cGUsIGkucHVzaChzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHUgPSBuICYmIGkuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gJHQobiwgdC50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyB1cih1ID8gS3QgOiByLCBpKTtcbiAgICB9LCB1ci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSwgciA9IG51bGwsIG4gPSAwLCBpID0gMCwgYSA9IHRoaXMuYXJnczsgaSA8IGEubGVuZ3RoICYmIChuKyssIChyID0gYVtpXS5ldmFsdWF0ZSh0KSkgJiYgciBpbnN0YW5jZW9mIGFlICYmICFyLmF2YWlsYWJsZSAmJiAoZSB8fCAoZSA9IHIubmFtZSksIHIgPSBudWxsLCBuID09PSB0aGlzLmFyZ3MubGVuZ3RoICYmIChyID0gZSkpLCBudWxsID09PSByKTsgaSArPSAxKSB7XG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgdXIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaCh0KTtcbiAgICB9LCB1ci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSwgdXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gW1wiY29hbGVzY2VcIl07XG4gICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdC5wdXNoKGUuc2VyaWFsaXplKCkpO1xuICAgICAgfSksIHQ7XG4gICAgfTtcblxuICAgIHZhciBsciA9IGZ1bmN0aW9uIGxyKHQsIGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5iaW5kaW5ncyA9IFtdLmNvbmNhdCh0KSwgdGhpcy5yZXN1bHQgPSBlO1xuICAgIH07XG5cbiAgICBsci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LmV2YWx1YXRlKHQpO1xuICAgIH0sIGxyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0aGlzLmJpbmRpbmdzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB0KHJbZV1bMV0pO1xuICAgICAgfVxuXG4gICAgICB0KHRoaXMucmVzdWx0KTtcbiAgICB9LCBsci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCA0KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuXG4gICAgICBmb3IgKHZhciByID0gW10sIG4gPSAxOyBuIDwgdC5sZW5ndGggLSAxOyBuICs9IDIpIHtcbiAgICAgICAgdmFyIGkgPSB0W25dO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIHR5cGVvZiBpICsgXCIgaW5zdGVhZC5cIiwgbik7XG4gICAgICAgIGlmICgvW15hLXpBLVowLTlfXS8udGVzdChpKSkgcmV0dXJuIGUuZXJyb3IoXCJWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciAnXycuXCIsIG4pO1xuICAgICAgICB2YXIgYSA9IGUucGFyc2UodFtuICsgMV0sIG4gKyAxKTtcbiAgICAgICAgaWYgKCFhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgci5wdXNoKFtpLCBhXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvID0gZS5wYXJzZSh0W3QubGVuZ3RoIC0gMV0sIHQubGVuZ3RoIC0gMSwgZS5leHBlY3RlZFR5cGUsIHIpO1xuICAgICAgcmV0dXJuIG8gPyBuZXcgbHIociwgbykgOiBudWxsO1xuICAgIH0sIGxyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm91dHB1dERlZmluZWQoKTtcbiAgICB9LCBsci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IFtcImxldFwiXSwgZSA9IDAsIHIgPSB0aGlzLmJpbmRpbmdzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV07XG4gICAgICAgIHQucHVzaChuWzBdLCBuWzFdLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQucHVzaCh0aGlzLnJlc3VsdC5zZXJpYWxpemUoKSksIHQ7XG4gICAgfTtcblxuICAgIHZhciBwciA9IGZ1bmN0aW9uIHByKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5kZXggPSBlLCB0aGlzLmlucHV0ID0gcjtcbiAgICB9O1xuXG4gICAgcHIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDMgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIE90KSxcbiAgICAgICAgICBuID0gZS5wYXJzZSh0WzJdLCAyLCBKdChlLmV4cGVjdGVkVHlwZSB8fCBLdCkpO1xuICAgICAgcmV0dXJuIHIgJiYgbiA/IG5ldyBwcihuLnR5cGUuaXRlbVR5cGUsIHIsIG4pIDogbnVsbDtcbiAgICB9LCBwci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmluZGV4LmV2YWx1YXRlKHQpLFxuICAgICAgICAgIHIgPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKGUgPCAwKSB0aHJvdyBuZXcgY2UoXCJBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiBcIiArIGUgKyBcIiA8IDAuXCIpO1xuICAgICAgaWYgKGUgPj0gci5sZW5ndGgpIHRocm93IG5ldyBjZShcIkFycmF5IGluZGV4IG91dCBvZiBib3VuZHM6IFwiICsgZSArIFwiID4gXCIgKyAoci5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmIChlICE9PSBNYXRoLmZsb29yKGUpKSB0aHJvdyBuZXcgY2UoXCJBcnJheSBpbmRleCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBmb3VuZCBcIiArIGUgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHJldHVybiByW2VdO1xuICAgIH0sIHByLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmluZGV4KSwgdCh0aGlzLmlucHV0KTtcbiAgICB9LCBwci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBwci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtcImF0XCIsIHRoaXMuaW5kZXguc2VyaWFsaXplKCksIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuICAgIH07XG5cbiAgICB2YXIgY3IgPSBmdW5jdGlvbiBjcih0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSBqdCwgdGhpcy5uZWVkbGUgPSB0LCB0aGlzLmhheXN0YWNrID0gZTtcbiAgICB9O1xuXG4gICAgY3IucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDMgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIEt0KSxcbiAgICAgICAgICBuID0gZS5wYXJzZSh0WzJdLCAyLCBLdCk7XG4gICAgICByZXR1cm4gciAmJiBuID8gV3Qoci50eXBlLCBbanQsIFV0LCBPdCwgUnQsIEt0XSkgPyBuZXcgY3IociwgbikgOiBlLmVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgXCIgKyBIdChyLnR5cGUpICsgXCIgaW5zdGVhZFwiKSA6IG51bGw7XG4gICAgfSwgY3IucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUodCksXG4gICAgICAgICAgciA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUodCk7XG4gICAgICBpZiAoIXIpIHJldHVybiAhMTtcbiAgICAgIGlmICghUXQoZSwgW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcIm51bGxcIl0pKSB0aHJvdyBuZXcgY2UoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIiArIEh0KHVlKGUpKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgaWYgKCFRdChyLCBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSkpIHRocm93IG5ldyBjZShcIkV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kIFwiICsgSHQodWUocikpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICByZXR1cm4gci5pbmRleE9mKGUpID49IDA7XG4gICAgfSwgY3IucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMubmVlZGxlKSwgdCh0aGlzLmhheXN0YWNrKTtcbiAgICB9LCBjci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9LCBjci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtcImluXCIsIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLCB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuXG4gICAgdmFyIGhyID0gZnVuY3Rpb24gaHIodCwgZSwgcikge1xuICAgICAgdGhpcy50eXBlID0gT3QsIHRoaXMubmVlZGxlID0gdCwgdGhpcy5oYXlzdGFjayA9IGUsIHRoaXMuZnJvbUluZGV4ID0gcjtcbiAgICB9O1xuXG4gICAgaHIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDw9IDIgfHwgdC5sZW5ndGggPj0gNSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCAzIG9yIDQgYXJndW1lbnRzLCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIEt0KSxcbiAgICAgICAgICBuID0gZS5wYXJzZSh0WzJdLCAyLCBLdCk7XG4gICAgICBpZiAoIXIgfHwgIW4pIHJldHVybiBudWxsO1xuICAgICAgaWYgKCFXdChyLnR5cGUsIFtqdCwgVXQsIE90LCBSdCwgS3RdKSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIiArIEh0KHIudHlwZSkgKyBcIiBpbnN0ZWFkXCIpO1xuXG4gICAgICBpZiAoNCA9PT0gdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGkgPSBlLnBhcnNlKHRbM10sIDMsIE90KTtcbiAgICAgICAgcmV0dXJuIGkgPyBuZXcgaHIociwgbiwgaSkgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGhyKHIsIG4pO1xuICAgIH0sIGhyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubmVlZGxlLmV2YWx1YXRlKHQpLFxuICAgICAgICAgIHIgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKCFRdChlLCBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwibnVsbFwiXSkpIHRocm93IG5ldyBjZShcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiICsgSHQodWUoZSkpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICBpZiAoIVF0KHIsIFtcInN0cmluZ1wiLCBcImFycmF5XCJdKSkgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIgKyBIdCh1ZShyKSkgKyBcIiBpbnN0ZWFkLlwiKTtcblxuICAgICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5mcm9tSW5kZXguZXZhbHVhdGUodCk7XG4gICAgICAgIHJldHVybiByLmluZGV4T2YoZSwgbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByLmluZGV4T2YoZSk7XG4gICAgfSwgaHIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMubmVlZGxlKSwgdCh0aGlzLmhheXN0YWNrKSwgdGhpcy5mcm9tSW5kZXggJiYgdCh0aGlzLmZyb21JbmRleCk7XG4gICAgfSwgaHIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgaHIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChudWxsICE9IHRoaXMuZnJvbUluZGV4ICYmIHZvaWQgMCAhPT0gdGhpcy5mcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmZyb21JbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcImluZGV4LW9mXCIsIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLCB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpLCB0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcImluZGV4LW9mXCIsIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLCB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuXG4gICAgdmFyIGZyID0gZnVuY3Rpb24gZnIodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdGhpcy5pbnB1dFR5cGUgPSB0LCB0aGlzLnR5cGUgPSBlLCB0aGlzLmlucHV0ID0gciwgdGhpcy5jYXNlcyA9IG4sIHRoaXMub3V0cHV0cyA9IGksIHRoaXMub3RoZXJ3aXNlID0gYTtcbiAgICB9O1xuXG4gICAgZnIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgNSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmICh0Lmxlbmd0aCAlIDIgIT0gMSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIHIsIG47XG4gICAgICBlLmV4cGVjdGVkVHlwZSAmJiBcInZhbHVlXCIgIT09IGUuZXhwZWN0ZWRUeXBlLmtpbmQgJiYgKG4gPSBlLmV4cGVjdGVkVHlwZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSB7fSwgYSA9IFtdLCBvID0gMjsgbyA8IHQubGVuZ3RoIC0gMTsgbyArPSAyKSB7XG4gICAgICAgIHZhciBzID0gdFtvXSxcbiAgICAgICAgICAgIHUgPSB0W28gKyAxXTtcbiAgICAgICAgQXJyYXkuaXNBcnJheShzKSB8fCAocyA9IFtzXSk7XG4gICAgICAgIHZhciBsID0gZS5jb25jYXQobyk7XG4gICAgICAgIGlmICgwID09PSBzLmxlbmd0aCkgcmV0dXJuIGwuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYnJhbmNoIGxhYmVsLlwiKTtcblxuICAgICAgICBmb3IgKHZhciBwID0gMCwgYyA9IHM7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgdmFyIGggPSBjW3BdO1xuICAgICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBoICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGgpIHJldHVybiBsLmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIG51bWJlcnMgb3Igc3RyaW5ncy5cIik7XG4gICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGggJiYgTWF0aC5hYnMoaCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgcmV0dXJuIGwuZXJyb3IoXCJCcmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlcnMgbm8gbGFyZ2VyIHRoYW4gXCIgKyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiArIFwiLlwiKTtcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgaCAmJiBNYXRoLmZsb29yKGgpICE9PSBoKSByZXR1cm4gbC5lcnJvcihcIk51bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLlwiKTtcblxuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICBpZiAobC5jaGVja1N1YnR5cGUociwgdWUoaCkpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgciA9IHVlKGgpO1xuXG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaVtTdHJpbmcoaCldKSByZXR1cm4gbC5lcnJvcihcIkJyYW5jaCBsYWJlbHMgbXVzdCBiZSB1bmlxdWUuXCIpO1xuICAgICAgICAgIGlbU3RyaW5nKGgpXSA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBlLnBhcnNlKHUsIG8sIG4pO1xuICAgICAgICBpZiAoIWYpIHJldHVybiBudWxsO1xuICAgICAgICBuID0gbiB8fCBmLnR5cGUsIGEucHVzaChmKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHkgPSBlLnBhcnNlKHRbMV0sIDEsIEt0KTtcbiAgICAgIGlmICgheSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZCA9IGUucGFyc2UodFt0Lmxlbmd0aCAtIDFdLCB0Lmxlbmd0aCAtIDEsIG4pO1xuICAgICAgcmV0dXJuIGQgPyBcInZhbHVlXCIgIT09IHkudHlwZS5raW5kICYmIGUuY29uY2F0KDEpLmNoZWNrU3VidHlwZShyLCB5LnR5cGUpID8gbnVsbCA6IG5ldyBmcihyLCBuLCB5LCBpLCBhLCBkKSA6IG51bGw7XG4gICAgfSwgZnIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KTtcbiAgICAgIHJldHVybiAodWUoZSkgPT09IHRoaXMuaW5wdXRUeXBlICYmIHRoaXMub3V0cHV0c1t0aGlzLmNhc2VzW2VdXSB8fCB0aGlzLm90aGVyd2lzZSkuZXZhbHVhdGUodCk7XG4gICAgfSwgZnIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMuaW5wdXQpLCB0aGlzLm91dHB1dHMuZm9yRWFjaCh0KSwgdCh0aGlzLm90aGVyd2lzZSk7XG4gICAgfSwgZnIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pICYmIHRoaXMub3RoZXJ3aXNlLm91dHB1dERlZmluZWQoKTtcbiAgICB9LCBmci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IHRoaXMsIGUgPSBbXCJtYXRjaFwiLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXSwgciA9IFtdLCBuID0ge30sIGkgPSAwLCBhID0gT2JqZWN0LmtleXModGhpcy5jYXNlcykuc29ydCgpOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IGFbaV07XG4gICAgICAgIHZvaWQgMCA9PT0gKGMgPSBuW3RoaXMuY2FzZXNbb11dKSA/IChuW3RoaXMuY2FzZXNbb11dID0gci5sZW5ndGgsIHIucHVzaChbdGhpcy5jYXNlc1tvXSwgW29dXSkpIDogcltjXVsxXS5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBzID0gZnVuY3Rpb24gcyhlKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiID09PSB0LmlucHV0VHlwZS5raW5kID8gTnVtYmVyKGUpIDogZTtcbiAgICAgIH0sIHUgPSAwLCBsID0gcjsgdSA8IGwubGVuZ3RoOyB1ICs9IDEpIHtcbiAgICAgICAgdmFyIHAgPSBsW3VdLFxuICAgICAgICAgICAgYyA9IHBbMF0sXG4gICAgICAgICAgICBoID0gcFsxXTtcbiAgICAgICAgZS5wdXNoKDEgPT09IGgubGVuZ3RoID8gcyhoWzBdKSA6IGgubWFwKHMpKSwgZS5wdXNoKHRoaXMub3V0cHV0c1tvdXRwdXRJbmRleCQxXS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlLnB1c2godGhpcy5vdGhlcndpc2Uuc2VyaWFsaXplKCkpLCBlO1xuICAgIH07XG5cbiAgICB2YXIgeXIgPSBmdW5jdGlvbiB5cih0LCBlLCByKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmJyYW5jaGVzID0gZSwgdGhpcy5vdGhlcndpc2UgPSByO1xuICAgIH07XG5cbiAgICB5ci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCA0KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIuXCIpO1xuICAgICAgaWYgKHQubGVuZ3RoICUgMiAhPSAwKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciByO1xuICAgICAgZS5leHBlY3RlZFR5cGUgJiYgXCJ2YWx1ZVwiICE9PSBlLmV4cGVjdGVkVHlwZS5raW5kICYmIChyID0gZS5leHBlY3RlZFR5cGUpO1xuXG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAxOyBpIDwgdC5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGEgPSBlLnBhcnNlKHRbaV0sIGksIGp0KTtcbiAgICAgICAgaWYgKCFhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG8gPSBlLnBhcnNlKHRbaSArIDFdLCBpICsgMSwgcik7XG4gICAgICAgIGlmICghbykgcmV0dXJuIG51bGw7XG4gICAgICAgIG4ucHVzaChbYSwgb10pLCByID0gciB8fCBvLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzID0gZS5wYXJzZSh0W3QubGVuZ3RoIC0gMV0sIHQubGVuZ3RoIC0gMSwgcik7XG4gICAgICByZXR1cm4gcyA/IG5ldyB5cihyLCBuLCBzKSA6IG51bGw7XG4gICAgfSwgeXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5icmFuY2hlczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdLFxuICAgICAgICAgICAgaSA9IG5bMV07XG4gICAgICAgIGlmIChuWzBdLmV2YWx1YXRlKHQpKSByZXR1cm4gaS5ldmFsdWF0ZSh0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMub3RoZXJ3aXNlLmV2YWx1YXRlKHQpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0aGlzLmJyYW5jaGVzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV0sXG4gICAgICAgICAgICBpID0gblsxXTtcbiAgICAgICAgdChuWzBdKSwgdChpKTtcbiAgICAgIH1cblxuICAgICAgdCh0aGlzLm90aGVyd2lzZSk7XG4gICAgfSwgeXIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5icmFuY2hlcy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdFsxXS5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSwgeXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gW1wiY2FzZVwiXTtcbiAgICAgIHJldHVybiB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICB0LnB1c2goZS5zZXJpYWxpemUoKSk7XG4gICAgICB9KSwgdDtcbiAgICB9O1xuXG4gICAgdmFyIGRyID0gZnVuY3Rpb24gZHIodCwgZSwgciwgbikge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5pbnB1dCA9IGUsIHRoaXMuYmVnaW5JbmRleCA9IHIsIHRoaXMuZW5kSW5kZXggPSBuO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtcih0LCBlKSB7XG4gICAgICByZXR1cm4gXCI9PVwiID09PSB0IHx8IFwiIT1cIiA9PT0gdCA/IFwiYm9vbGVhblwiID09PSBlLmtpbmQgfHwgXCJzdHJpbmdcIiA9PT0gZS5raW5kIHx8IFwibnVtYmVyXCIgPT09IGUua2luZCB8fCBcIm51bGxcIiA9PT0gZS5raW5kIHx8IFwidmFsdWVcIiA9PT0gZS5raW5kIDogXCJzdHJpbmdcIiA9PT0gZS5raW5kIHx8IFwibnVtYmVyXCIgPT09IGUua2luZCB8fCBcInZhbHVlXCIgPT09IGUua2luZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2cih0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gMCA9PT0gbi5jb21wYXJlKGUsIHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gXCI9PVwiICE9PSB0ICYmIFwiIT1cIiAhPT0gdDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkodCwgZSwgcikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IGp0LCB0aGlzLmxocyA9IHQsIHRoaXMucmhzID0gZSwgdGhpcy5jb2xsYXRvciA9IHIsIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gXCJ2YWx1ZVwiID09PSB0LnR5cGUua2luZCB8fCBcInZhbHVlXCIgPT09IGUudHlwZS5raW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGkucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGlmICgzICE9PSB0Lmxlbmd0aCAmJiA0ICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlwiKTtcbiAgICAgICAgICB2YXIgciA9IHRbMF0sXG4gICAgICAgICAgICAgIGEgPSBlLnBhcnNlKHRbMV0sIDEsIEt0KTtcbiAgICAgICAgICBpZiAoIWEpIHJldHVybiBudWxsO1xuICAgICAgICAgIGlmICghbXIociwgYS50eXBlKSkgcmV0dXJuIGUuY29uY2F0KDEpLmVycm9yKCdcIicgKyByICsgXCJcXFwiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICdcIiArIEh0KGEudHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgIHZhciBvID0gZS5wYXJzZSh0WzJdLCAyLCBLdCk7XG4gICAgICAgICAgaWYgKCFvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoIW1yKHIsIG8udHlwZSkpIHJldHVybiBlLmNvbmNhdCgyKS5lcnJvcignXCInICsgciArIFwiXFxcIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAnXCIgKyBIdChvLnR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICBpZiAoYS50eXBlLmtpbmQgIT09IG8udHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gYS50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiICE9PSBvLnR5cGUua2luZCkgcmV0dXJuIGUuZXJyb3IoXCJDYW5ub3QgY29tcGFyZSB0eXBlcyAnXCIgKyBIdChhLnR5cGUpICsgXCInIGFuZCAnXCIgKyBIdChvLnR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICBuICYmIChcInZhbHVlXCIgPT09IGEudHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gby50eXBlLmtpbmQgPyBhID0gbmV3IGZlKG8udHlwZSwgW2FdKSA6IFwidmFsdWVcIiAhPT0gYS50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiID09PSBvLnR5cGUua2luZCAmJiAobyA9IG5ldyBmZShhLnR5cGUsIFtvXSkpKTtcbiAgICAgICAgICB2YXIgcyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoNCA9PT0gdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSBhLnR5cGUua2luZCAmJiBcInN0cmluZ1wiICE9PSBvLnR5cGUua2luZCAmJiBcInZhbHVlXCIgIT09IGEudHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gby50eXBlLmtpbmQpIHJldHVybiBlLmVycm9yKFwiQ2Fubm90IHVzZSBjb2xsYXRvciB0byBjb21wYXJlIG5vbi1zdHJpbmcgdHlwZXMuXCIpO1xuICAgICAgICAgICAgaWYgKCEocyA9IGUucGFyc2UodFszXSwgMywgR3QpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBpKGEsIG8sIHMpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmxocy5ldmFsdWF0ZShpKSxcbiAgICAgICAgICAgICAgbyA9IHRoaXMucmhzLmV2YWx1YXRlKGkpO1xuXG4gICAgICAgICAgaWYgKG4gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gdWUoYSksXG4gICAgICAgICAgICAgICAgdSA9IHVlKG8pO1xuICAgICAgICAgICAgaWYgKHMua2luZCAhPT0gdS5raW5kIHx8IFwic3RyaW5nXCIgIT09IHMua2luZCAmJiBcIm51bWJlclwiICE9PSBzLmtpbmQpIHRocm93IG5ldyBjZSgnRXhwZWN0ZWQgYXJndW1lbnRzIGZvciBcIicgKyB0ICsgJ1wiIHRvIGJlIChzdHJpbmcsIHN0cmluZykgb3IgKG51bWJlciwgbnVtYmVyKSwgYnV0IGZvdW5kICgnICsgcy5raW5kICsgXCIsIFwiICsgdS5raW5kICsgXCIpIGluc3RlYWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmNvbGxhdG9yICYmICFuICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgbCA9IHVlKGEpLFxuICAgICAgICAgICAgICAgIHAgPSB1ZShvKTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSBsLmtpbmQgfHwgXCJzdHJpbmdcIiAhPT0gcC5raW5kKSByZXR1cm4gZShpLCBhLCBvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXRvciA/IHIoaSwgYSwgbywgdGhpcy5jb2xsYXRvci5ldmFsdWF0ZShpKSkgOiBlKGksIGEsIG8pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHQodGhpcy5saHMpLCB0KHRoaXMucmhzKSwgdGhpcy5jb2xsYXRvciAmJiB0KHRoaXMuY29sbGF0b3IpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gW3RdO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZS5wdXNoKHQuc2VyaWFsaXplKCkpO1xuICAgICAgICAgIH0pLCBlO1xuICAgICAgICB9LCBpO1xuICAgICAgfSgpO1xuICAgIH1cblxuICAgIGRyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8PSAyIHx8IHQubGVuZ3RoID49IDUpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBLdCksXG4gICAgICAgICAgbiA9IGUucGFyc2UodFsyXSwgMiwgT3QpO1xuICAgICAgaWYgKCFyIHx8ICFuKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICghV3Qoci50eXBlLCBbSnQoS3QpLCBVdCwgS3RdKSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kIFwiICsgSHQoci50eXBlKSArIFwiIGluc3RlYWRcIik7XG5cbiAgICAgIGlmICg0ID09PSB0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaSA9IGUucGFyc2UodFszXSwgMywgT3QpO1xuICAgICAgICByZXR1cm4gaSA/IG5ldyBkcihyLnR5cGUsIHIsIG4sIGkpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBkcihyLnR5cGUsIHIsIG4pO1xuICAgIH0sIGRyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUodCksXG4gICAgICAgICAgciA9IHRoaXMuYmVnaW5JbmRleC5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmICghUXQoZSwgW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0pKSB0aHJvdyBuZXcgY2UoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kIFwiICsgSHQodWUoZSkpICsgXCIgaW5zdGVhZC5cIik7XG5cbiAgICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5lbmRJbmRleC5ldmFsdWF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIGUuc2xpY2Uociwgbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlLnNsaWNlKHIpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KSwgdCh0aGlzLmJlZ2luSW5kZXgpLCB0aGlzLmVuZEluZGV4ICYmIHQodGhpcy5lbmRJbmRleCk7XG4gICAgfSwgZHIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZHIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChudWxsICE9IHRoaXMuZW5kSW5kZXggJiYgdm9pZCAwICE9PSB0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5lbmRJbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcInNsaWNlXCIsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKSwgdF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXCJzbGljZVwiLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpLCB0aGlzLmJlZ2luSW5kZXguc2VyaWFsaXplKCldO1xuICAgIH07XG5cbiAgICB2YXIgeHIgPSBncihcIj09XCIsIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gZSA9PT0gcjtcbiAgICB9LCB2ciksXG4gICAgICAgIGJyID0gZ3IoXCIhPVwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgIT09IHI7XG4gICAgfSwgZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiAhdnIoMCwgZSwgciwgbik7XG4gICAgfSksXG4gICAgICAgIHdyID0gZ3IoXCI8XCIsIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gZSA8IHI7XG4gICAgfSwgZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBuLmNvbXBhcmUoZSwgcikgPCAwO1xuICAgIH0pLFxuICAgICAgICBfciA9IGdyKFwiPlwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgPiByO1xuICAgIH0sIGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gbi5jb21wYXJlKGUsIHIpID4gMDtcbiAgICB9KSxcbiAgICAgICAgQXIgPSBncihcIjw9XCIsIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gZSA8PSByO1xuICAgIH0sIGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gbi5jb21wYXJlKGUsIHIpIDw9IDA7XG4gICAgfSksXG4gICAgICAgIFNyID0gZ3IoXCI+PVwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgPj0gcjtcbiAgICB9LCBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG4uY29tcGFyZShlLCByKSA+PSAwO1xuICAgIH0pLFxuICAgICAgICBrciA9IGZ1bmN0aW9uIGtyKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHRoaXMudHlwZSA9IFV0LCB0aGlzLm51bWJlciA9IHQsIHRoaXMubG9jYWxlID0gZSwgdGhpcy5jdXJyZW5jeSA9IHIsIHRoaXMubWluRnJhY3Rpb25EaWdpdHMgPSBuLCB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID0gaTtcbiAgICB9O1xuXG4gICAga3IucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDMgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIHR3byBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIE90KTtcbiAgICAgIGlmICghcikgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbiA9IHRbMl07XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgbiB8fCBBcnJheS5pc0FycmF5KG4pKSByZXR1cm4gZS5lcnJvcihcIk51bWJlckZvcm1hdCBvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIHZhciBpID0gbnVsbDtcbiAgICAgIGlmIChuLmxvY2FsZSAmJiAhKGkgPSBlLnBhcnNlKG4ubG9jYWxlLCAxLCBVdCkpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBhID0gbnVsbDtcbiAgICAgIGlmIChuLmN1cnJlbmN5ICYmICEoYSA9IGUucGFyc2Uobi5jdXJyZW5jeSwgMSwgVXQpKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbyA9IG51bGw7XG4gICAgICBpZiAobltcIm1pbi1mcmFjdGlvbi1kaWdpdHNcIl0gJiYgIShvID0gZS5wYXJzZShuW1wibWluLWZyYWN0aW9uLWRpZ2l0c1wiXSwgMSwgT3QpKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcyA9IG51bGw7XG4gICAgICByZXR1cm4gbltcIm1heC1mcmFjdGlvbi1kaWdpdHNcIl0gJiYgIShzID0gZS5wYXJzZShuW1wibWF4LWZyYWN0aW9uLWRpZ2l0c1wiXSwgMSwgT3QpKSA/IG51bGwgOiBuZXcga3IociwgaSwgYSwgbywgcyk7XG4gICAgfSwga3IucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZSh0KSA6IFtdLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLmN1cnJlbmN5ID8gXCJjdXJyZW5jeVwiIDogXCJkZWNpbWFsXCIsXG4gICAgICAgIGN1cnJlbmN5OiB0aGlzLmN1cnJlbmN5ID8gdGhpcy5jdXJyZW5jeS5ldmFsdWF0ZSh0KSA6IHZvaWQgMCxcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID8gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZSh0KSA6IHZvaWQgMCxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID8gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZSh0KSA6IHZvaWQgMFxuICAgICAgfSkuZm9ybWF0KHRoaXMubnVtYmVyLmV2YWx1YXRlKHQpKTtcbiAgICB9LCBrci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5udW1iZXIpLCB0aGlzLmxvY2FsZSAmJiB0KHRoaXMubG9jYWxlKSwgdGhpcy5jdXJyZW5jeSAmJiB0KHRoaXMuY3VycmVuY3kpLCB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzICYmIHQodGhpcy5taW5GcmFjdGlvbkRpZ2l0cyksIHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgJiYgdCh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKTtcbiAgICB9LCBrci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBrci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsZSAmJiAodC5sb2NhbGUgPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKSksIHRoaXMuY3VycmVuY3kgJiYgKHQuY3VycmVuY3kgPSB0aGlzLmN1cnJlbmN5LnNlcmlhbGl6ZSgpKSwgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyAmJiAodFtcIm1pbi1mcmFjdGlvbi1kaWdpdHNcIl0gPSB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpKSwgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyAmJiAodFtcIm1heC1mcmFjdGlvbi1kaWdpdHNcIl0gPSB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpKSwgW1wibnVtYmVyLWZvcm1hdFwiLCB0aGlzLm51bWJlci5zZXJpYWxpemUoKSwgdF07XG4gICAgfTtcblxuICAgIHZhciBJciA9IGZ1bmN0aW9uIElyKHQpIHtcbiAgICAgIHRoaXMudHlwZSA9IE90LCB0aGlzLmlucHV0ID0gdDtcbiAgICB9O1xuXG4gICAgSXIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDIgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIDEgYXJndW1lbnQsIGJ1dCBmb3VuZCBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICB2YXIgciA9IGUucGFyc2UodFsxXSwgMSk7XG4gICAgICByZXR1cm4gciA/IFwiYXJyYXlcIiAhPT0gci50eXBlLmtpbmQgJiYgXCJzdHJpbmdcIiAhPT0gci50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiICE9PSByLnR5cGUua2luZCA/IGUuZXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kIFwiICsgSHQoci50eXBlKSArIFwiIGluc3RlYWQuXCIpIDogbmV3IElyKHIpIDogbnVsbDtcbiAgICB9LCBJci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiBlLmxlbmd0aDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSByZXR1cm4gZS5sZW5ndGg7XG4gICAgICB0aHJvdyBuZXcgY2UoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kIFwiICsgSHQodWUoZSkpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgfSwgSXIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMuaW5wdXQpO1xuICAgIH0sIElyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIElyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtcImxlbmd0aFwiXTtcbiAgICAgIHJldHVybiB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICB0LnB1c2goZS5zZXJpYWxpemUoKSk7XG4gICAgICB9KSwgdDtcbiAgICB9O1xuICAgIHZhciB6ciA9IHtcbiAgICAgIFwiPT1cIjogeHIsXG4gICAgICBcIiE9XCI6IGJyLFxuICAgICAgXCI+XCI6IF9yLFxuICAgICAgXCI8XCI6IHdyLFxuICAgICAgXCI+PVwiOiBTcixcbiAgICAgIFwiPD1cIjogQXIsXG4gICAgICBhcnJheTogZmUsXG4gICAgICBhdDogcHIsXG4gICAgICBib29sZWFuOiBmZSxcbiAgICAgIGNhc2U6IHlyLFxuICAgICAgY29hbGVzY2U6IHVyLFxuICAgICAgY29sbGF0b3I6IHdlLFxuICAgICAgZm9ybWF0OiB5ZSxcbiAgICAgIGltYWdlOiBkZSxcbiAgICAgIGluOiBjcixcbiAgICAgIFwiaW5kZXgtb2ZcIjogaHIsXG4gICAgICBpbnRlcnBvbGF0ZTogb3IsXG4gICAgICBcImludGVycG9sYXRlLWhjbFwiOiBvcixcbiAgICAgIFwiaW50ZXJwb2xhdGUtbGFiXCI6IG9yLFxuICAgICAgbGVuZ3RoOiBJcixcbiAgICAgIGxldDogbHIsXG4gICAgICBsaXRlcmFsOiBwZSxcbiAgICAgIG1hdGNoOiBmcixcbiAgICAgIG51bWJlcjogZmUsXG4gICAgICBcIm51bWJlci1mb3JtYXRcIjoga3IsXG4gICAgICBvYmplY3Q6IGZlLFxuICAgICAgc2xpY2U6IGRyLFxuICAgICAgc3RlcDogS2UsXG4gICAgICBzdHJpbmc6IGZlLFxuICAgICAgXCJ0by1ib29sZWFuXCI6IHZlLFxuICAgICAgXCJ0by1jb2xvclwiOiB2ZSxcbiAgICAgIFwidG8tbnVtYmVyXCI6IHZlLFxuICAgICAgXCJ0by1zdHJpbmdcIjogdmUsXG4gICAgICB2YXI6IGplLFxuICAgICAgd2l0aGluOiBMZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDcih0LCBlKSB7XG4gICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgICAgaSA9IGVbMl0sXG4gICAgICAgICAgYSA9IGVbM107XG4gICAgICByID0gci5ldmFsdWF0ZSh0KSwgbiA9IG4uZXZhbHVhdGUodCksIGkgPSBpLmV2YWx1YXRlKHQpO1xuICAgICAgdmFyIG8gPSBhID8gYS5ldmFsdWF0ZSh0KSA6IDEsXG4gICAgICAgICAgcyA9IG9lKHIsIG4sIGksIG8pO1xuICAgICAgaWYgKHMpIHRocm93IG5ldyBjZShzKTtcbiAgICAgIHJldHVybiBuZXcgZWUociAvIDI1NSAqIG8sIG4gLyAyNTUgKiBvLCBpIC8gMjU1ICogbywgbyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRXIodCwgZSkge1xuICAgICAgcmV0dXJuIHQgaW4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQcih0LCBlKSB7XG4gICAgICB2YXIgciA9IGVbdF07XG4gICAgICByZXR1cm4gdm9pZCAwID09PSByID8gbnVsbCA6IHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTXIodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCcih0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IFwic3VjY2Vzc1wiLFxuICAgICAgICB2YWx1ZTogdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUcih0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IFwiZXJyb3JcIixcbiAgICAgICAgdmFsdWU6IHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVnIodCkge1xuICAgICAgcmV0dXJuIFwiZGF0YS1kcml2ZW5cIiA9PT0gdFtcInByb3BlcnR5LXR5cGVcIl0gfHwgXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiID09PSB0W1wicHJvcGVydHktdHlwZVwiXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGcih0KSB7XG4gICAgICByZXR1cm4gISF0LmV4cHJlc3Npb24gJiYgdC5leHByZXNzaW9uLnBhcmFtZXRlcnMuaW5kZXhPZihcInpvb21cIikgPiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEcih0KSB7XG4gICAgICByZXR1cm4gISF0LmV4cHJlc3Npb24gJiYgdC5leHByZXNzaW9uLmludGVycG9sYXRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMcih0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIE51bWJlciA/IFwibnVtYmVyXCIgOiB0IGluc3RhbmNlb2YgU3RyaW5nID8gXCJzdHJpbmdcIiA6IHQgaW5zdGFuY2VvZiBCb29sZWFuID8gXCJib29sZWFuXCIgOiBBcnJheS5pc0FycmF5KHQpID8gXCJhcnJheVwiIDogbnVsbCA9PT0gdCA/IFwibnVsbFwiIDogdHlwZW9mIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUnIodCkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCAmJiAhQXJyYXkuaXNBcnJheSh0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPcih0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVcih0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSB0ID8gdCA6IHZvaWQgMCAhPT0gZSA/IGUgOiB2b2lkIDAgIT09IHIgPyByIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpyKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHJldHVybiBVcih0eXBlb2YgciA9PT0gaSA/IG5bcl0gOiB2b2lkIDAsIHQuZGVmYXVsdCwgZS5kZWZhdWx0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxcih0LCBlLCByKSB7XG4gICAgICBpZiAoXCJudW1iZXJcIiAhPT0gTHIocikpIHJldHVybiBVcih0LmRlZmF1bHQsIGUuZGVmYXVsdCk7XG4gICAgICB2YXIgbiA9IHQuc3RvcHMubGVuZ3RoO1xuICAgICAgaWYgKDEgPT09IG4pIHJldHVybiB0LnN0b3BzWzBdWzFdO1xuICAgICAgaWYgKHIgPD0gdC5zdG9wc1swXVswXSkgcmV0dXJuIHQuc3RvcHNbMF1bMV07XG4gICAgICBpZiAociA+PSB0LnN0b3BzW24gLSAxXVswXSkgcmV0dXJuIHQuc3RvcHNbbiAtIDFdWzFdO1xuICAgICAgdmFyIGkgPSBOZSh0LnN0b3BzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdFswXTtcbiAgICAgIH0pLCByKTtcbiAgICAgIHJldHVybiB0LnN0b3BzW2ldWzFdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE5yKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdm9pZCAwICE9PSB0LmJhc2UgPyB0LmJhc2UgOiAxO1xuICAgICAgaWYgKFwibnVtYmVyXCIgIT09IExyKHIpKSByZXR1cm4gVXIodC5kZWZhdWx0LCBlLmRlZmF1bHQpO1xuICAgICAgdmFyIGkgPSB0LnN0b3BzLmxlbmd0aDtcbiAgICAgIGlmICgxID09PSBpKSByZXR1cm4gdC5zdG9wc1swXVsxXTtcbiAgICAgIGlmIChyIDw9IHQuc3RvcHNbMF1bMF0pIHJldHVybiB0LnN0b3BzWzBdWzFdO1xuICAgICAgaWYgKHIgPj0gdC5zdG9wc1tpIC0gMV1bMF0pIHJldHVybiB0LnN0b3BzW2kgLSAxXVsxXTtcblxuICAgICAgdmFyIGEgPSBOZSh0LnN0b3BzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdFswXTtcbiAgICAgIH0pLCByKSxcbiAgICAgICAgICBvID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSBuIC0gcixcbiAgICAgICAgICAgIGEgPSB0IC0gcjtcbiAgICAgICAgcmV0dXJuIDAgPT09IGkgPyAwIDogMSA9PT0gZSA/IGEgLyBpIDogKE1hdGgucG93KGUsIGEpIC0gMSkgLyAoTWF0aC5wb3coZSwgaSkgLSAxKTtcbiAgICAgIH0ociwgbiwgdC5zdG9wc1thXVswXSwgdC5zdG9wc1thICsgMV1bMF0pLFxuICAgICAgICAgIHMgPSB0LnN0b3BzW2FdWzFdLFxuICAgICAgICAgIHUgPSB0LnN0b3BzW2EgKyAxXVsxXSxcbiAgICAgICAgICBsID0gWmVbZS50eXBlXSB8fCBPcjtcblxuICAgICAgaWYgKHQuY29sb3JTcGFjZSAmJiBcInJnYlwiICE9PSB0LmNvbG9yU3BhY2UpIHtcbiAgICAgICAgdmFyIHAgPSBhclt0LmNvbG9yU3BhY2VdO1xuXG4gICAgICAgIGwgPSBmdW5jdGlvbiBsKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gcC5yZXZlcnNlKHAuaW50ZXJwb2xhdGUocC5mb3J3YXJkKHQpLCBwLmZvcndhcmQoZSksIG8pKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygcy5ldmFsdWF0ZSA/IHtcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICAgICAgICAgIGZvciAodmFyIHQgPSBbXSwgZSA9IGFyZ3VtZW50cy5sZW5ndGg7IGUtLTspIHtcbiAgICAgICAgICAgIHRbZV0gPSBhcmd1bWVudHNbZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHIgPSBzLmV2YWx1YXRlLmFwcGx5KHZvaWQgMCwgdCksXG4gICAgICAgICAgICAgIG4gPSB1LmV2YWx1YXRlLmFwcGx5KHZvaWQgMCwgdCk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gciAmJiB2b2lkIDAgIT09IG4pIHJldHVybiBsKHIsIG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9IDogbChzLCB1LCBvKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBLcih0LCBlLCByKSB7XG4gICAgICByZXR1cm4gXCJjb2xvclwiID09PSBlLnR5cGUgPyByID0gZWUucGFyc2UocikgOiBcImZvcm1hdHRlZFwiID09PSBlLnR5cGUgPyByID0gaWUuZnJvbVN0cmluZyhyLnRvU3RyaW5nKCkpIDogXCJyZXNvbHZlZEltYWdlXCIgPT09IGUudHlwZSA/IHIgPSBhZS5mcm9tU3RyaW5nKHIudG9TdHJpbmcoKSkgOiBMcihyKSA9PT0gZS50eXBlIHx8IFwiZW51bVwiID09PSBlLnR5cGUgJiYgZS52YWx1ZXNbcl0gfHwgKHIgPSB2b2lkIDApLCBVcihyLCB0LmRlZmF1bHQsIGUuZGVmYXVsdCk7XG4gICAgfVxuXG4gICAgYmUucmVnaXN0ZXIoenIsIHtcbiAgICAgIGVycm9yOiBbe1xuICAgICAgICBraW5kOiBcImVycm9yXCJcbiAgICAgIH0sIFtVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRocm93IG5ldyBjZShlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgdHlwZW9mOiBbVXQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBIdCh1ZShlWzBdLmV2YWx1YXRlKHQpKSk7XG4gICAgICB9XSxcbiAgICAgIFwidG8tcmdiYVwiOiBbSnQoT3QsIDQpLCBbcXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS50b0FycmF5KCk7XG4gICAgICB9XSxcbiAgICAgIHJnYjogW3F0LCBbT3QsIE90LCBPdF0sIENyXSxcbiAgICAgIHJnYmE6IFtxdCwgW090LCBPdCwgT3QsIE90XSwgQ3JdLFxuICAgICAgaGFzOiB7XG4gICAgICAgIHR5cGU6IGp0LFxuICAgICAgICBvdmVybG9hZHM6IFtbW1V0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gRXIoZVswXS5ldmFsdWF0ZSh0KSwgdC5wcm9wZXJ0aWVzKCkpO1xuICAgICAgICB9XSwgW1tVdCwgTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gZVsxXTtcbiAgICAgICAgICByZXR1cm4gRXIoZVswXS5ldmFsdWF0ZSh0KSwgci5ldmFsdWF0ZSh0KSk7XG4gICAgICAgIH1dXVxuICAgICAgfSxcbiAgICAgIGdldDoge1xuICAgICAgICB0eXBlOiBLdCxcbiAgICAgICAgb3ZlcmxvYWRzOiBbW1tVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIFByKGVbMF0uZXZhbHVhdGUodCksIHQucHJvcGVydGllcygpKTtcbiAgICAgICAgfV0sIFtbVXQsIE50XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgICAgcmV0dXJuIFByKGVbMF0uZXZhbHVhdGUodCksIHIuZXZhbHVhdGUodCkpO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBcImZlYXR1cmUtc3RhdGVcIjogW0t0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gUHIoZVswXS5ldmFsdWF0ZSh0KSwgdC5mZWF0dXJlU3RhdGUgfHwge30pO1xuICAgICAgfV0sXG4gICAgICBwcm9wZXJ0aWVzOiBbTnQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5wcm9wZXJ0aWVzKCk7XG4gICAgICB9XSxcbiAgICAgIFwiZ2VvbWV0cnktdHlwZVwiOiBbVXQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5nZW9tZXRyeVR5cGUoKTtcbiAgICAgIH1dLFxuICAgICAgaWQ6IFtLdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkKCk7XG4gICAgICB9XSxcbiAgICAgIHpvb206IFtPdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lmdsb2JhbHMuem9vbTtcbiAgICAgIH1dLFxuICAgICAgXCJoZWF0bWFwLWRlbnNpdHlcIjogW090LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwO1xuICAgICAgfV0sXG4gICAgICBcImxpbmUtcHJvZ3Jlc3NcIjogW090LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMDtcbiAgICAgIH1dLFxuICAgICAgYWNjdW11bGF0ZWQ6IFtLdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IHQuZ2xvYmFscy5hY2N1bXVsYXRlZCA/IG51bGwgOiB0Lmdsb2JhbHMuYWNjdW11bGF0ZWQ7XG4gICAgICB9XSxcbiAgICAgIFwiK1wiOiBbT3QsIE1yKE90KSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICByICs9IGlbbl0uZXZhbHVhdGUodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1dLFxuICAgICAgXCIqXCI6IFtPdCwgTXIoT3QpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gMSwgbiA9IDAsIGkgPSBlOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgIHIgKj0gaVtuXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfV0sXG4gICAgICBcIi1cIjoge1xuICAgICAgICB0eXBlOiBPdCxcbiAgICAgICAgb3ZlcmxvYWRzOiBbW1tPdCwgT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gZVsxXTtcbiAgICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KSAtIHIuZXZhbHVhdGUodCk7XG4gICAgICAgIH1dLCBbW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gLWVbMF0uZXZhbHVhdGUodCk7XG4gICAgICAgIH1dXVxuICAgICAgfSxcbiAgICAgIFwiL1wiOiBbT3QsIFtPdCwgT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpIC8gci5ldmFsdWF0ZSh0KTtcbiAgICAgIH1dLFxuICAgICAgXCIlXCI6IFtPdCwgW090LCBPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVsxXTtcbiAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkgJSByLmV2YWx1YXRlKHQpO1xuICAgICAgfV0sXG4gICAgICBsbjI6IFtPdCwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguTE4yO1xuICAgICAgfV0sXG4gICAgICBwaTogW090LCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1dLFxuICAgICAgZTogW090LCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5FO1xuICAgICAgfV0sXG4gICAgICBcIl5cIjogW090LCBbT3QsIE90XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coZVswXS5ldmFsdWF0ZSh0KSwgci5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIHNxcnQ6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgbG9nMTA6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKGVbMF0uZXZhbHVhdGUodCkpIC8gTWF0aC5MTjEwO1xuICAgICAgfV0sXG4gICAgICBsbjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGxvZzI6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKGVbMF0uZXZhbHVhdGUodCkpIC8gTWF0aC5MTjI7XG4gICAgICB9XSxcbiAgICAgIHNpbjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4oZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGNvczogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5jb3MoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIHRhbjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC50YW4oZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGFzaW46IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXNpbihlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgYWNvczogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBhdGFuOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4oZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIG1pbjogW090LCBNcihPdCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBlLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmV2YWx1YXRlKHQpO1xuICAgICAgICB9KSk7XG4gICAgICB9XSxcbiAgICAgIG1heDogW090LCBNcihPdCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBlLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmV2YWx1YXRlKHQpO1xuICAgICAgICB9KSk7XG4gICAgICB9XSxcbiAgICAgIGFiczogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIHJvdW5kOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIHIgPCAwID8gLU1hdGgucm91bmQoLXIpIDogTWF0aC5yb3VuZChyKTtcbiAgICAgIH1dLFxuICAgICAgZmxvb3I6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGNlaWw6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPT1cIjogW2p0LCBbVXQsIEt0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgICAgbiA9IGVbMV07XG4gICAgICAgIHJldHVybiB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSA9PT0gbi52YWx1ZTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPT1cIjogW2p0LCBbS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF07XG4gICAgICAgIHJldHVybiB0LmlkKCkgPT09IHIudmFsdWU7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLXR5cGUtPT1cIjogW2p0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF07XG4gICAgICAgIHJldHVybiB0Lmdlb21ldHJ5VHlwZSgpID09PSByLnZhbHVlO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci08XCI6IFtqdCwgW1V0LCBLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgICAgaSA9IHQucHJvcGVydGllcygpW3IudmFsdWVdLFxuICAgICAgICAgICAgYSA9IG4udmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaSA9PSB0eXBlb2YgYSAmJiBpIDwgYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPFwiOiBbanQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSB0LmlkKCksXG4gICAgICAgICAgICBpID0gci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBpICYmIG4gPCBpO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci0+XCI6IFtqdCwgW1V0LCBLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgICAgaSA9IHQucHJvcGVydGllcygpW3IudmFsdWVdLFxuICAgICAgICAgICAgYSA9IG4udmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaSA9PSB0eXBlb2YgYSAmJiBpID4gYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPlwiOiBbanQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSB0LmlkKCksXG4gICAgICAgICAgICBpID0gci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBpICYmIG4gPiBpO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci08PVwiOiBbanQsIFtVdCwgS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gZVsxXSxcbiAgICAgICAgICAgIGkgPSB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSxcbiAgICAgICAgICAgIGEgPSBuLnZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGkgPT0gdHlwZW9mIGEgJiYgaSA8PSBhO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1pZC08PVwiOiBbanQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICAgIG4gPSB0LmlkKCksXG4gICAgICAgICAgICBpID0gci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBpICYmIG4gPD0gaTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPj1cIjogW2p0LCBbVXQsIEt0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgICAgICBpID0gdC5wcm9wZXJ0aWVzKClbci52YWx1ZV0sXG4gICAgICAgICAgICBhID0gbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpID09IHR5cGVvZiBhICYmIGkgPj0gYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPj1cIjogW2p0LCBbS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgICBuID0gdC5pZCgpLFxuICAgICAgICAgICAgaSA9IHIudmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgaSAmJiBuID49IGk7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWhhc1wiOiBbanQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlWzBdLnZhbHVlIGluIHQucHJvcGVydGllcygpO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1oYXMtaWRcIjogW2p0LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IHQuaWQoKSAmJiB2b2lkIDAgIT09IHQuaWQoKTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItdHlwZS1pblwiOiBbanQsIFtKdChVdCldLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS52YWx1ZS5pbmRleE9mKHQuZ2VvbWV0cnlUeXBlKCkpID49IDA7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWlkLWluXCI6IFtqdCwgW0p0KEt0KV0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlWzBdLnZhbHVlLmluZGV4T2YodC5pZCgpKSA+PSAwO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1pbi1zbWFsbFwiOiBbanQsIFtVdCwgSnQoS3QpXSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdO1xuICAgICAgICByZXR1cm4gZVsxXS52YWx1ZS5pbmRleE9mKHQucHJvcGVydGllcygpW3IudmFsdWVdKSA+PSAwO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1pbi1sYXJnZVwiOiBbanQsIFtVdCwgSnQoS3QpXSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgICAgbiA9IGVbMV07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIGZvciAoOyByIDw9IG47KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHIgKyBuID4+IDE7XG4gICAgICAgICAgICBpZiAoZVtpXSA9PT0gdCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgZVtpXSA+IHQgPyBuID0gaSAtIDEgOiByID0gaSArIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9KHQucHJvcGVydGllcygpW3IudmFsdWVdLCBuLnZhbHVlLCAwLCBuLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgfV0sXG4gICAgICBhbGw6IHtcbiAgICAgICAgdHlwZToganQsXG4gICAgICAgIG92ZXJsb2FkczogW1tbanQsIGp0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkgJiYgci5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfV0sIFtNcihqdCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSBlOyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFuW3JdLmV2YWx1YXRlKHQpKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBhbnk6IHtcbiAgICAgICAgdHlwZToganQsXG4gICAgICAgIG92ZXJsb2FkczogW1tbanQsIGp0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkgfHwgci5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfV0sIFtNcihqdCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSBlOyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKG5bcl0uZXZhbHVhdGUodCkpIHJldHVybiAhMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1dXVxuICAgICAgfSxcbiAgICAgIFwiIVwiOiBbanQsIFtqdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiAhZVswXS5ldmFsdWF0ZSh0KTtcbiAgICAgIH1dLFxuICAgICAgXCJpcy1zdXBwb3J0ZWQtc2NyaXB0XCI6IFtqdCwgW1V0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0Lmdsb2JhbHMgJiYgdC5nbG9iYWxzLmlzU3VwcG9ydGVkU2NyaXB0O1xuICAgICAgICByZXR1cm4gIXIgfHwgcihlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgdXBjYXNlOiBbVXQsIFtVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XSxcbiAgICAgIGRvd25jYXNlOiBbVXQsIFtVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XSxcbiAgICAgIGNvbmNhdDogW1V0LCBNcihLdCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBsZShlLmV2YWx1YXRlKHQpKTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH1dLFxuICAgICAgXCJyZXNvbHZlZC1sb2NhbGVcIjogW1V0LCBbR3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS5yZXNvbHZlZExvY2FsZSgpO1xuICAgICAgfV1cbiAgICB9KTtcblxuICAgIHZhciBHciA9IGZ1bmN0aW9uIEdyKHQsIGUpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHQsIHRoaXMuX3dhcm5pbmdIaXN0b3J5ID0ge30sIHRoaXMuX2V2YWx1YXRvciA9IG5ldyB4ZSgpLCB0aGlzLl9kZWZhdWx0VmFsdWUgPSBlID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiY29sb3JcIiA9PT0gdC50eXBlICYmIFJyKHQuZGVmYXVsdCkgPyBuZXcgZWUoMCwgMCwgMCwgMCkgOiBcImNvbG9yXCIgPT09IHQudHlwZSA/IGVlLnBhcnNlKHQuZGVmYXVsdCkgfHwgbnVsbCA6IHZvaWQgMCA9PT0gdC5kZWZhdWx0ID8gbnVsbCA6IHQuZGVmYXVsdDtcbiAgICAgIH0oZSkgOiBudWxsLCB0aGlzLl9lbnVtVmFsdWVzID0gZSAmJiBcImVudW1cIiA9PT0gZS50eXBlID8gZS52YWx1ZXMgOiBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBacih0KSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSAmJiB0Lmxlbmd0aCA+IDAgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdFswXSAmJiB0WzBdIGluIHpyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFhyKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IHFlKHpyLCBbXSwgZSA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0ge1xuICAgICAgICAgIGNvbG9yOiBxdCxcbiAgICAgICAgICBzdHJpbmc6IFV0LFxuICAgICAgICAgIG51bWJlcjogT3QsXG4gICAgICAgICAgZW51bTogVXQsXG4gICAgICAgICAgYm9vbGVhbjoganQsXG4gICAgICAgICAgZm9ybWF0dGVkOiBadCxcbiAgICAgICAgICByZXNvbHZlZEltYWdlOiBYdFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiID09PSB0LnR5cGUgPyBKdChlW3QudmFsdWVdIHx8IEt0LCB0Lmxlbmd0aCkgOiBlW3QudHlwZV07XG4gICAgICB9KGUpIDogdm9pZCAwKSxcbiAgICAgICAgICBuID0gci5wYXJzZSh0LCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBlICYmIFwic3RyaW5nXCIgPT09IGUudHlwZSA/IHtcbiAgICAgICAgdHlwZUFubm90YXRpb246IFwiY29lcmNlXCJcbiAgICAgIH0gOiB2b2lkIDApO1xuICAgICAgcmV0dXJuIG4gPyBCcihuZXcgR3IobiwgZSkpIDogVHIoci5lcnJvcnMpO1xuICAgIH1cblxuICAgIEdyLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IHQsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZSwgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IHIsIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBuLCB0aGlzLl9ldmFsdWF0b3IuYXZhaWxhYmxlSW1hZ2VzID0gaSB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGEsIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xuICAgIH0sIEdyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IHQsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZSB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gciB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gbiwgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGkgfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBhIHx8IG51bGw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG4gICAgICAgIGlmIChudWxsID09IG8gfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgbyAmJiBvICE9IG8pIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9lbnVtVmFsdWVzICYmICEobyBpbiB0aGlzLl9lbnVtVmFsdWVzKSkgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mIFwiICsgT2JqZWN0LmtleXModGhpcy5fZW51bVZhbHVlcykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpO1xuICAgICAgICB9KS5qb2luKFwiLCBcIikgKyBcIiwgYnV0IGZvdW5kIFwiICsgSlNPTi5zdHJpbmdpZnkobykgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXJuaW5nSGlzdG9yeVt0Lm1lc3NhZ2VdIHx8ICh0aGlzLl93YXJuaW5nSGlzdG9yeVt0Lm1lc3NhZ2VdID0gITAsIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKHQubWVzc2FnZSkpLCB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBKciA9IGZ1bmN0aW9uIEpyKHQsIGUpIHtcbiAgICAgIHRoaXMua2luZCA9IHQsIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGUsIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IFwiY29uc3RhbnRcIiAhPT0gdCAmJiAhT2UoZS5leHByZXNzaW9uKTtcbiAgICB9O1xuXG4gICAgSnIucHJvdG90eXBlLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKHQsIGUsIHIsIG4sIGksIGEpO1xuICAgIH0sIEpyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKHQsIGUsIHIsIG4sIGksIGEpO1xuICAgIH07XG5cbiAgICB2YXIgSHIgPSBmdW5jdGlvbiBIcih0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmtpbmQgPSB0LCB0aGlzLnpvb21TdG9wcyA9IHIsIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGUsIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IFwiY2FtZXJhXCIgIT09IHQgJiYgIU9lKGUuZXhwcmVzc2lvbiksIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBuO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBZcih0LCBlKSB7XG4gICAgICBpZiAoXCJlcnJvclwiID09PSAodCA9IFhyKHQsIGUpKS5yZXN1bHQpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSB0LnZhbHVlLmV4cHJlc3Npb24sXG4gICAgICAgICAgbiA9IFJlKHIpO1xuICAgICAgaWYgKCFuICYmICFWcihlKSkgcmV0dXJuIFRyKFtuZXcgRHQoXCJcIiwgXCJkYXRhIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWRcIildKTtcbiAgICAgIHZhciBpID0gVWUociwgW1wiem9vbVwiXSk7XG4gICAgICBpZiAoIWkgJiYgIUZyKGUpKSByZXR1cm4gVHIoW25ldyBEdChcIlwiLCBcInpvb20gZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZFwiKV0pO1xuXG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICB2YXIgciA9IG51bGw7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgbHIpIHIgPSB0KGUucmVzdWx0KTtlbHNlIGlmIChlIGluc3RhbmNlb2YgdXIpIGZvciAodmFyIG4gPSAwLCBpID0gZS5hcmdzOyBuIDwgaS5sZW5ndGggJiYgIShyID0gdChpW25dKSk7IG4gKz0gMSkge1xuICAgICAgICAgIDtcbiAgICAgICAgfSBlbHNlIChlIGluc3RhbmNlb2YgS2UgfHwgZSBpbnN0YW5jZW9mIG9yKSAmJiBlLmlucHV0IGluc3RhbmNlb2YgYmUgJiYgXCJ6b29tXCIgPT09IGUuaW5wdXQubmFtZSAmJiAociA9IGUpO1xuICAgICAgICByZXR1cm4gciBpbnN0YW5jZW9mIER0IHx8IGUuZWFjaENoaWxkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIG4gPSB0KGUpO1xuICAgICAgICAgIG4gaW5zdGFuY2VvZiBEdCA/IHIgPSBuIDogIXIgJiYgbiA/IHIgPSBuZXcgRHQoXCJcIiwgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKSA6IHIgJiYgbiAmJiByICE9PSBuICYmIChyID0gbmV3IER0KFwiXCIsICdPbmx5IG9uZSB6b29tLWJhc2VkIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBzdWJleHByZXNzaW9uIG1heSBiZSB1c2VkIGluIGFuIGV4cHJlc3Npb24uJykpO1xuICAgICAgICB9KSwgcjtcbiAgICAgIH0ocik7XG5cbiAgICAgIHJldHVybiBhIHx8IGkgPyBhIGluc3RhbmNlb2YgRHQgPyBUcihbYV0pIDogYSBpbnN0YW5jZW9mIG9yICYmICFEcihlKSA/IFRyKFtuZXcgRHQoXCJcIiwgJ1wiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBjYW5ub3QgYmUgdXNlZCB3aXRoIHRoaXMgcHJvcGVydHknKV0pIDogQnIoYSA/IG5ldyBIcihuID8gXCJjYW1lcmFcIiA6IFwiY29tcG9zaXRlXCIsIHQudmFsdWUsIGEubGFiZWxzLCBhIGluc3RhbmNlb2Ygb3IgPyBhLmludGVycG9sYXRpb24gOiB2b2lkIDApIDogbmV3IEpyKG4gPyBcImNvbnN0YW50XCIgOiBcInNvdXJjZVwiLCB0LnZhbHVlKSkgOiBUcihbbmV3IER0KFwiXCIsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJyldKTtcbiAgICB9XG5cbiAgICBIci5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcodCwgZSwgciwgbiwgaSwgYSk7XG4gICAgfSwgSHIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGUodCwgZSwgciwgbiwgaSwgYSk7XG4gICAgfSwgSHIucHJvdG90eXBlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPyBvci5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvblR5cGUsIHQsIGUsIHIpIDogMDtcbiAgICB9O1xuXG4gICAgdmFyICRyID0gZnVuY3Rpb24gJHIodCwgZSkge1xuICAgICAgdGhpcy5fcGFyYW1ldGVycyA9IHQsIHRoaXMuX3NwZWNpZmljYXRpb24gPSBlLCBUdCh0aGlzLCBmdW5jdGlvbiB0KGUsIHIpIHtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIG8gPSBcImNvbG9yXCIgPT09IHIudHlwZSxcbiAgICAgICAgICAgIHMgPSBlLnN0b3BzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUuc3RvcHNbMF1bMF0sXG4gICAgICAgICAgICB1ID0gcyB8fCAhKHMgfHwgdm9pZCAwICE9PSBlLnByb3BlcnR5KSxcbiAgICAgICAgICAgIGwgPSBlLnR5cGUgfHwgKERyKHIpID8gXCJleHBvbmVudGlhbFwiIDogXCJpbnRlcnZhbFwiKTtcbiAgICAgICAgaWYgKG8gJiYgKChlID0gVHQoe30sIGUpKS5zdG9wcyAmJiAoZS5zdG9wcyA9IGUuc3RvcHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFt0WzBdLCBlZS5wYXJzZSh0WzFdKV07XG4gICAgICAgIH0pKSwgZS5kZWZhdWx0ID0gZWUucGFyc2UoZS5kZWZhdWx0ID8gZS5kZWZhdWx0IDogci5kZWZhdWx0KSksIGUuY29sb3JTcGFjZSAmJiBcInJnYlwiICE9PSBlLmNvbG9yU3BhY2UgJiYgIWFyW2UuY29sb3JTcGFjZV0pIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3Igc3BhY2U6IFwiICsgZS5jb2xvclNwYWNlKTtcbiAgICAgICAgaWYgKFwiZXhwb25lbnRpYWxcIiA9PT0gbCkgbiA9IE5yO2Vsc2UgaWYgKFwiaW50ZXJ2YWxcIiA9PT0gbCkgbiA9IHFyO2Vsc2UgaWYgKFwiY2F0ZWdvcmljYWxcIiA9PT0gbCkge1xuICAgICAgICAgIG4gPSBqciwgaSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBwID0gMCwgYyA9IGUuc3RvcHM7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaCA9IGNbcF07XG4gICAgICAgICAgICBpW2hbMF1dID0gaFsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gdHlwZW9mIGUuc3RvcHNbMF1bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFwiaWRlbnRpdHlcIiAhPT0gbCkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZ1bmN0aW9uIHR5cGUgXCInICsgbCArICdcIicpO1xuICAgICAgICAgIG4gPSBLcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZiA9IHt9LCB5ID0gW10sIGQgPSAwOyBkIDwgZS5zdG9wcy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgdmFyIG0gPSBlLnN0b3BzW2RdLFxuICAgICAgICAgICAgICAgIHYgPSBtWzBdLnpvb207XG4gICAgICAgICAgICB2b2lkIDAgPT09IGZbdl0gJiYgKGZbdl0gPSB7XG4gICAgICAgICAgICAgIHpvb206IHYsXG4gICAgICAgICAgICAgIHR5cGU6IGUudHlwZSxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IGUucHJvcGVydHksXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgc3RvcHM6IFtdXG4gICAgICAgICAgICB9LCB5LnB1c2godikpLCBmW3ZdLnN0b3BzLnB1c2goW21bMF0udmFsdWUsIG1bMV1dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBnID0gW10sIHggPSAwLCBiID0geTsgeCA8IGIubGVuZ3RoOyB4ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB3ID0gYlt4XTtcbiAgICAgICAgICAgIGcucHVzaChbZlt3XS56b29tLCB0KGZbd10sIHIpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF8gPSB7XG4gICAgICAgICAgICBuYW1lOiBcImxpbmVhclwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogXCJjb21wb3NpdGVcIixcbiAgICAgICAgICAgIGludGVycG9sYXRpb25UeXBlOiBfLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3Rvcjogb3IuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHZvaWQgMCwgXyksXG4gICAgICAgICAgICB6b29tU3RvcHM6IGcubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0WzBdO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUodCwgbikge1xuICAgICAgICAgICAgICB2YXIgaSA9IHQuem9vbTtcbiAgICAgICAgICAgICAgcmV0dXJuIE5yKHtcbiAgICAgICAgICAgICAgICBzdG9wczogZyxcbiAgICAgICAgICAgICAgICBiYXNlOiBlLmJhc2VcbiAgICAgICAgICAgICAgfSwgciwgaSkuZXZhbHVhdGUoaSwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgdmFyIEEgPSBcImV4cG9uZW50aWFsXCIgPT09IGwgPyB7XG4gICAgICAgICAgICBuYW1lOiBcImV4cG9uZW50aWFsXCIsXG4gICAgICAgICAgICBiYXNlOiB2b2lkIDAgIT09IGUuYmFzZSA/IGUuYmFzZSA6IDFcbiAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogXCJjYW1lcmFcIixcbiAgICAgICAgICAgIGludGVycG9sYXRpb25UeXBlOiBBLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkZhY3Rvcjogb3IuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHZvaWQgMCwgQSksXG4gICAgICAgICAgICB6b29tU3RvcHM6IGUuc3RvcHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0WzBdO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUodCkge1xuICAgICAgICAgICAgICByZXR1cm4gbihlLCByLCB0Lnpvb20sIGksIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6IFwic291cmNlXCIsXG4gICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKHQsIG8pIHtcbiAgICAgICAgICAgIHZhciBzID0gbyAmJiBvLnByb3BlcnRpZXMgPyBvLnByb3BlcnRpZXNbZS5wcm9wZXJ0eV0gOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBzID8gVXIoZS5kZWZhdWx0LCByLmRlZmF1bHQpIDogbihlLCByLCBzLCBpLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KHRoaXMuX3BhcmFtZXRlcnMsIHRoaXMuX3NwZWNpZmljYXRpb24pKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gV3IodCkge1xuICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgICBuID0gdC52YWx1ZVNwZWMgfHwge30sXG4gICAgICAgICAgaSA9IHQub2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgfHwge30sXG4gICAgICAgICAgYSA9IHQuc3R5bGUsXG4gICAgICAgICAgbyA9IHQuc3R5bGVTcGVjLFxuICAgICAgICAgIHMgPSBbXSxcbiAgICAgICAgICB1ID0gTHIocik7XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdSkgcmV0dXJuIFtuZXcgTXQoZSwgciwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgdSArIFwiIGZvdW5kXCIpXTtcblxuICAgICAgZm9yICh2YXIgbCBpbiByKSB7XG4gICAgICAgIHZhciBwID0gbC5zcGxpdChcIi5cIilbMF0sXG4gICAgICAgICAgICBjID0gbltwXSB8fCBuW1wiKlwiXSxcbiAgICAgICAgICAgIGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChpW3BdKSBoID0gaVtwXTtlbHNlIGlmIChuW3BdKSBoID0gU247ZWxzZSBpZiAoaVtcIipcIl0pIGggPSBpW1wiKlwiXTtlbHNlIHtcbiAgICAgICAgICBpZiAoIW5bXCIqXCJdKSB7XG4gICAgICAgICAgICBzLnB1c2gobmV3IE10KGUsIHJbbF0sICd1bmtub3duIHByb3BlcnR5IFwiJyArIGwgKyAnXCInKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoID0gU247XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuY29uY2F0KGgoe1xuICAgICAgICAgIGtleTogKGUgPyBlICsgXCIuXCIgOiBlKSArIGwsXG4gICAgICAgICAgdmFsdWU6IHJbbF0sXG4gICAgICAgICAgdmFsdWVTcGVjOiBjLFxuICAgICAgICAgIHN0eWxlOiBhLFxuICAgICAgICAgIHN0eWxlU3BlYzogbyxcbiAgICAgICAgICBvYmplY3Q6IHIsXG4gICAgICAgICAgb2JqZWN0S2V5OiBsXG4gICAgICAgIH0sIHIpKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZiBpbiBuKSB7XG4gICAgICAgIGlbZl0gfHwgbltmXS5yZXF1aXJlZCAmJiB2b2lkIDAgPT09IG5bZl0uZGVmYXVsdCAmJiB2b2lkIDAgPT09IHJbZl0gJiYgcy5wdXNoKG5ldyBNdChlLCByLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIicgKyBmICsgJ1wiJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBRcih0KSB7XG4gICAgICB2YXIgZSA9IHQudmFsdWUsXG4gICAgICAgICAgciA9IHQudmFsdWVTcGVjLFxuICAgICAgICAgIG4gPSB0LnN0eWxlLFxuICAgICAgICAgIGkgPSB0LnN0eWxlU3BlYyxcbiAgICAgICAgICBhID0gdC5rZXksXG4gICAgICAgICAgbyA9IHQuYXJyYXlFbGVtZW50VmFsaWRhdG9yIHx8IFNuO1xuICAgICAgaWYgKFwiYXJyYXlcIiAhPT0gTHIoZSkpIHJldHVybiBbbmV3IE10KGEsIGUsIFwiYXJyYXkgZXhwZWN0ZWQsIFwiICsgTHIoZSkgKyBcIiBmb3VuZFwiKV07XG4gICAgICBpZiAoci5sZW5ndGggJiYgZS5sZW5ndGggIT09IHIubGVuZ3RoKSByZXR1cm4gW25ldyBNdChhLCBlLCBcImFycmF5IGxlbmd0aCBcIiArIHIubGVuZ3RoICsgXCIgZXhwZWN0ZWQsIGxlbmd0aCBcIiArIGUubGVuZ3RoICsgXCIgZm91bmRcIildO1xuICAgICAgaWYgKHJbXCJtaW4tbGVuZ3RoXCJdICYmIGUubGVuZ3RoIDwgcltcIm1pbi1sZW5ndGhcIl0pIHJldHVybiBbbmV3IE10KGEsIGUsIFwiYXJyYXkgbGVuZ3RoIGF0IGxlYXN0IFwiICsgcltcIm1pbi1sZW5ndGhcIl0gKyBcIiBleHBlY3RlZCwgbGVuZ3RoIFwiICsgZS5sZW5ndGggKyBcIiBmb3VuZFwiKV07XG4gICAgICB2YXIgcyA9IHtcbiAgICAgICAgdHlwZTogci52YWx1ZSxcbiAgICAgICAgdmFsdWVzOiByLnZhbHVlc1xuICAgICAgfTtcbiAgICAgIGkuJHZlcnNpb24gPCA3ICYmIChzLmZ1bmN0aW9uID0gci5mdW5jdGlvbiksIFwib2JqZWN0XCIgPT09IExyKHIudmFsdWUpICYmIChzID0gci52YWx1ZSk7XG5cbiAgICAgIGZvciAodmFyIHUgPSBbXSwgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHUgPSB1LmNvbmNhdChvKHtcbiAgICAgICAgICBhcnJheTogZSxcbiAgICAgICAgICBhcnJheUluZGV4OiBsLFxuICAgICAgICAgIHZhbHVlOiBlW2xdLFxuICAgICAgICAgIHZhbHVlU3BlYzogcyxcbiAgICAgICAgICBzdHlsZTogbixcbiAgICAgICAgICBzdHlsZVNwZWM6IGksXG4gICAgICAgICAga2V5OiBhICsgXCJbXCIgKyBsICsgXCJdXCJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0bih0KSB7XG4gICAgICB2YXIgZSA9IHQua2V5LFxuICAgICAgICAgIHIgPSB0LnZhbHVlLFxuICAgICAgICAgIG4gPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgICBpID0gTHIocik7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIiA9PT0gaSAmJiByICE9IHIgJiYgKGkgPSBcIk5hTlwiKSwgXCJudW1iZXJcIiAhPT0gaSA/IFtuZXcgTXQoZSwgciwgXCJudW1iZXIgZXhwZWN0ZWQsIFwiICsgaSArIFwiIGZvdW5kXCIpXSA6IFwibWluaW11bVwiIGluIG4gJiYgciA8IG4ubWluaW11bSA/IFtuZXcgTXQoZSwgciwgciArIFwiIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSBcIiArIG4ubWluaW11bSldIDogXCJtYXhpbXVtXCIgaW4gbiAmJiByID4gbi5tYXhpbXVtID8gW25ldyBNdChlLCByLCByICsgXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIFwiICsgbi5tYXhpbXVtKV0gOiBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbih0KSB7XG4gICAgICB2YXIgZSxcbiAgICAgICAgICByLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgaSA9IHQudmFsdWVTcGVjLFxuICAgICAgICAgIGEgPSBWdCh0LnZhbHVlLnR5cGUpLFxuICAgICAgICAgIG8gPSB7fSxcbiAgICAgICAgICBzID0gXCJjYXRlZ29yaWNhbFwiICE9PSBhICYmIHZvaWQgMCA9PT0gdC52YWx1ZS5wcm9wZXJ0eSxcbiAgICAgICAgICB1ID0gIXMsXG4gICAgICAgICAgbCA9IFwiYXJyYXlcIiA9PT0gTHIodC52YWx1ZS5zdG9wcykgJiYgXCJhcnJheVwiID09PSBMcih0LnZhbHVlLnN0b3BzWzBdKSAmJiBcIm9iamVjdFwiID09PSBMcih0LnZhbHVlLnN0b3BzWzBdWzBdKSxcbiAgICAgICAgICBwID0gV3Ioe1xuICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICB2YWx1ZTogdC52YWx1ZSxcbiAgICAgICAgdmFsdWVTcGVjOiB0LnN0eWxlU3BlYy5mdW5jdGlvbixcbiAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgc3RvcHM6IGZ1bmN0aW9uIHN0b3BzKHQpIHtcbiAgICAgICAgICAgIGlmIChcImlkZW50aXR5XCIgPT09IGEpIHJldHVybiBbbmV3IE10KHQua2V5LCB0LnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgXCJzdG9wc1wiIHByb3BlcnR5JyldO1xuICAgICAgICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICAgICAgICByID0gdC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBlID0gZS5jb25jYXQoUXIoe1xuICAgICAgICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgICAgICAgdmFsdWVTcGVjOiB0LnZhbHVlU3BlYyxcbiAgICAgICAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgIGFycmF5RWxlbWVudFZhbGlkYXRvcjogY1xuICAgICAgICAgICAgfSkpLCBcImFycmF5XCIgPT09IExyKHIpICYmIDAgPT09IHIubGVuZ3RoICYmIGUucHVzaChuZXcgTXQodC5rZXksIHIsIFwiYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wXCIpKSwgZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KHQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbih7XG4gICAgICAgICAgICAgIGtleTogdC5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB0LnZhbHVlLFxuICAgICAgICAgICAgICB2YWx1ZVNwZWM6IGksXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFwiaWRlbnRpdHlcIiA9PT0gYSAmJiBzICYmIHAucHVzaChuZXcgTXQodC5rZXksIHQudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwicHJvcGVydHlcIicpKSwgXCJpZGVudGl0eVwiID09PSBhIHx8IHQudmFsdWUuc3RvcHMgfHwgcC5wdXNoKG5ldyBNdCh0LmtleSwgdC52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzdG9wc1wiJykpLCBcImV4cG9uZW50aWFsXCIgPT09IGEgJiYgdC52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhRHIodC52YWx1ZVNwZWMpICYmIHAucHVzaChuZXcgTXQodC5rZXksIHQudmFsdWUsIFwiZXhwb25lbnRpYWwgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIikpLCB0LnN0eWxlU3BlYy4kdmVyc2lvbiA+PSA4ICYmICh1ICYmICFWcih0LnZhbHVlU3BlYykgPyBwLnB1c2gobmV3IE10KHQua2V5LCB0LnZhbHVlLCBcInByb3BlcnR5IGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkXCIpKSA6IHMgJiYgIUZyKHQudmFsdWVTcGVjKSAmJiBwLnB1c2gobmV3IE10KHQua2V5LCB0LnZhbHVlLCBcInpvb20gZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIikpKSwgXCJjYXRlZ29yaWNhbFwiICE9PSBhICYmICFsIHx8IHZvaWQgMCAhPT0gdC52YWx1ZS5wcm9wZXJ0eSB8fCBwLnB1c2gobmV3IE10KHQua2V5LCB0LnZhbHVlLCAnXCJwcm9wZXJ0eVwiIHByb3BlcnR5IGlzIHJlcXVpcmVkJykpLCBwO1xuXG4gICAgICBmdW5jdGlvbiBjKHQpIHtcbiAgICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICAgIGEgPSB0LnZhbHVlLFxuICAgICAgICAgICAgcyA9IHQua2V5O1xuICAgICAgICBpZiAoXCJhcnJheVwiICE9PSBMcihhKSkgcmV0dXJuIFtuZXcgTXQocywgYSwgXCJhcnJheSBleHBlY3RlZCwgXCIgKyBMcihhKSArIFwiIGZvdW5kXCIpXTtcbiAgICAgICAgaWYgKDIgIT09IGEubGVuZ3RoKSByZXR1cm4gW25ldyBNdChzLCBhLCBcImFycmF5IGxlbmd0aCAyIGV4cGVjdGVkLCBsZW5ndGggXCIgKyBhLmxlbmd0aCArIFwiIGZvdW5kXCIpXTtcblxuICAgICAgICBpZiAobCkge1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSBMcihhWzBdKSkgcmV0dXJuIFtuZXcgTXQocywgYSwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgTHIoYVswXSkgKyBcIiBmb3VuZFwiKV07XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYVswXS56b29tKSByZXR1cm4gW25ldyBNdChzLCBhLCBcIm9iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgem9vbVwiKV07XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYVswXS52YWx1ZSkgcmV0dXJuIFtuZXcgTXQocywgYSwgXCJvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHZhbHVlXCIpXTtcbiAgICAgICAgICBpZiAobiAmJiBuID4gVnQoYVswXS56b29tKSkgcmV0dXJuIFtuZXcgTXQocywgYVswXS56b29tLCBcInN0b3Agem9vbSB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyXCIpXTtcbiAgICAgICAgICBWdChhWzBdLnpvb20pICE9PSBuICYmIChuID0gVnQoYVswXS56b29tKSwgciA9IHZvaWQgMCwgbyA9IHt9KSwgZSA9IGUuY29uY2F0KFdyKHtcbiAgICAgICAgICAgIGtleTogcyArIFwiWzBdXCIsXG4gICAgICAgICAgICB2YWx1ZTogYVswXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzoge1xuICAgICAgICAgICAgICB6b29tOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlYyxcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgIHpvb206IHRuLFxuICAgICAgICAgICAgICB2YWx1ZTogaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGUgPSBlLmNvbmNhdChoKHtcbiAgICAgICAgICBrZXk6IHMgKyBcIlswXVwiLFxuICAgICAgICAgIHZhbHVlOiBhWzBdLFxuICAgICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlY1xuICAgICAgICB9LCBhKSk7XG5cbiAgICAgICAgcmV0dXJuIFpyKEZ0KGFbMV0pKSA/IGUuY29uY2F0KFtuZXcgTXQocyArIFwiWzFdXCIsIGFbMV0sIFwiZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGZ1bmN0aW9uIHN0b3BzLlwiKV0pIDogZS5jb25jYXQoU24oe1xuICAgICAgICAgIGtleTogcyArIFwiWzFdXCIsXG4gICAgICAgICAgdmFsdWU6IGFbMV0sXG4gICAgICAgICAgdmFsdWVTcGVjOiBpLFxuICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoKHQsIG4pIHtcbiAgICAgICAgdmFyIHMgPSBMcih0LnZhbHVlKSxcbiAgICAgICAgICAgIHUgPSBWdCh0LnZhbHVlKSxcbiAgICAgICAgICAgIGwgPSBudWxsICE9PSB0LnZhbHVlID8gdC52YWx1ZSA6IG47XG5cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBpZiAocyAhPT0gZSkgcmV0dXJuIFtuZXcgTXQodC5rZXksIGwsIHMgKyBcIiBzdG9wIGRvbWFpbiB0eXBlIG11c3QgbWF0Y2ggcHJldmlvdXMgc3RvcCBkb21haW4gdHlwZSBcIiArIGUpXTtcbiAgICAgICAgfSBlbHNlIGUgPSBzO1xuXG4gICAgICAgIGlmIChcIm51bWJlclwiICE9PSBzICYmIFwic3RyaW5nXCIgIT09IHMgJiYgXCJib29sZWFuXCIgIT09IHMpIHJldHVybiBbbmV3IE10KHQua2V5LCBsLCBcInN0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhblwiKV07XG5cbiAgICAgICAgaWYgKFwibnVtYmVyXCIgIT09IHMgJiYgXCJjYXRlZ29yaWNhbFwiICE9PSBhKSB7XG4gICAgICAgICAgdmFyIHAgPSBcIm51bWJlciBleHBlY3RlZCwgXCIgKyBzICsgXCIgZm91bmRcIjtcbiAgICAgICAgICByZXR1cm4gVnIoaSkgJiYgdm9pZCAwID09PSBhICYmIChwICs9ICdcXG5JZiB5b3UgaW50ZW5kZWQgdG8gdXNlIGEgY2F0ZWdvcmljYWwgZnVuY3Rpb24sIHNwZWNpZnkgYFwidHlwZVwiOiBcImNhdGVnb3JpY2FsXCJgLicpLCBbbmV3IE10KHQua2V5LCBsLCBwKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJjYXRlZ29yaWNhbFwiICE9PSBhIHx8IFwibnVtYmVyXCIgIT09IHMgfHwgaXNGaW5pdGUodSkgJiYgTWF0aC5mbG9vcih1KSA9PT0gdSA/IFwiY2F0ZWdvcmljYWxcIiAhPT0gYSAmJiBcIm51bWJlclwiID09PSBzICYmIHZvaWQgMCAhPT0gciAmJiB1IDwgciA/IFtuZXcgTXQodC5rZXksIGwsIFwic3RvcCBkb21haW4gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlclwiKV0gOiAociA9IHUsIFwiY2F0ZWdvcmljYWxcIiA9PT0gYSAmJiB1IGluIG8gPyBbbmV3IE10KHQua2V5LCBsLCBcInN0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZVwiKV0gOiAob1t1XSA9ICEwLCBbXSkpIDogW25ldyBNdCh0LmtleSwgbCwgXCJpbnRlZ2VyIGV4cGVjdGVkLCBmb3VuZCBcIiArIHUpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBybih0KSB7XG4gICAgICB2YXIgZSA9IChcInByb3BlcnR5XCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgPyBZciA6IFhyKShGdCh0LnZhbHVlKSwgdC52YWx1ZVNwZWMpO1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gZS5yZXN1bHQpIHJldHVybiBlLnZhbHVlLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IE10KFwiXCIgKyB0LmtleSArIGUua2V5LCB0LnZhbHVlLCBlLm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgciA9IGUudmFsdWUuZXhwcmVzc2lvbiB8fCBlLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgICAgIGlmIChcInByb3BlcnR5XCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgXCJ0ZXh0LWZvbnRcIiA9PT0gdC5wcm9wZXJ0eUtleSAmJiAhci5vdXRwdXREZWZpbmVkKCkpIHJldHVybiBbbmV3IE10KHQua2V5LCB0LnZhbHVlLCAnSW52YWxpZCBkYXRhIGV4cHJlc3Npb24gZm9yIFwiJyArIHQucHJvcGVydHlLZXkgKyAnXCIuIE91dHB1dCB2YWx1ZXMgbXVzdCBiZSBjb250YWluZWQgYXMgbGl0ZXJhbHMgd2l0aGluIHRoZSBleHByZXNzaW9uLicpXTtcbiAgICAgIGlmIChcInByb3BlcnR5XCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgXCJsYXlvdXRcIiA9PT0gdC5wcm9wZXJ0eVR5cGUgJiYgIU9lKHIpKSByZXR1cm4gW25ldyBNdCh0LmtleSwgdC52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBsYXlvdXQgcHJvcGVydGllcy4nKV07XG4gICAgICBpZiAoXCJmaWx0ZXJcIiA9PT0gdC5leHByZXNzaW9uQ29udGV4dCAmJiAhT2UocikpIHJldHVybiBbbmV3IE10KHQua2V5LCB0LnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGZpbHRlcnMuJyldO1xuXG4gICAgICBpZiAodC5leHByZXNzaW9uQ29udGV4dCAmJiAwID09PSB0LmV4cHJlc3Npb25Db250ZXh0LmluZGV4T2YoXCJjbHVzdGVyXCIpKSB7XG4gICAgICAgIGlmICghVWUociwgW1wiem9vbVwiLCBcImZlYXR1cmUtc3RhdGVcIl0pKSByZXR1cm4gW25ldyBNdCh0LmtleSwgdC52YWx1ZSwgJ1wiem9vbVwiIGFuZCBcImZlYXR1cmUtc3RhdGVcIiBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGNsdXN0ZXIgcHJvcGVydGllcy4nKV07XG4gICAgICAgIGlmIChcImNsdXN0ZXItaW5pdGlhbFwiID09PSB0LmV4cHJlc3Npb25Db250ZXh0ICYmICFSZShyKSkgcmV0dXJuIFtuZXcgTXQodC5rZXksIHQudmFsdWUsIFwiRmVhdHVyZSBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggaW5pdGlhbCBleHByZXNzaW9uIHBhcnQgb2YgY2x1c3RlciBwcm9wZXJ0aWVzLlwiKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBubih0KSB7XG4gICAgICB2YXIgZSA9IHQua2V5LFxuICAgICAgICAgIHIgPSB0LnZhbHVlLFxuICAgICAgICAgIG4gPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgICBpID0gW107XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuLnZhbHVlcykgPyAtMSA9PT0gbi52YWx1ZXMuaW5kZXhPZihWdChyKSkgJiYgaS5wdXNoKG5ldyBNdChlLCByLCBcImV4cGVjdGVkIG9uZSBvZiBbXCIgKyBuLnZhbHVlcy5qb2luKFwiLCBcIikgKyBcIl0sIFwiICsgSlNPTi5zdHJpbmdpZnkocikgKyBcIiBmb3VuZFwiKSkgOiAtMSA9PT0gT2JqZWN0LmtleXMobi52YWx1ZXMpLmluZGV4T2YoVnQocikpICYmIGkucHVzaChuZXcgTXQoZSwgciwgXCJleHBlY3RlZCBvbmUgb2YgW1wiICsgT2JqZWN0LmtleXMobi52YWx1ZXMpLmpvaW4oXCIsIFwiKSArIFwiXSwgXCIgKyBKU09OLnN0cmluZ2lmeShyKSArIFwiIGZvdW5kXCIpKSwgaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbih0KSB7XG4gICAgICBpZiAoITAgPT09IHQgfHwgITEgPT09IHQpIHJldHVybiAhMDtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0KSB8fCAwID09PSB0Lmxlbmd0aCkgcmV0dXJuICExO1xuXG4gICAgICBzd2l0Y2ggKHRbMF0pIHtcbiAgICAgICAgY2FzZSBcImhhc1wiOlxuICAgICAgICAgIHJldHVybiB0Lmxlbmd0aCA+PSAyICYmIFwiJGlkXCIgIT09IHRbMV0gJiYgXCIkdHlwZVwiICE9PSB0WzFdO1xuXG4gICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgIHJldHVybiB0Lmxlbmd0aCA+PSAzICYmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0WzFdIHx8IEFycmF5LmlzQXJyYXkodFsyXSkpO1xuXG4gICAgICAgIGNhc2UgXCIhaW5cIjpcbiAgICAgICAgY2FzZSBcIiFoYXNcIjpcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICByZXR1cm4gITE7XG5cbiAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgIGNhc2UgXCIhPVwiOlxuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgcmV0dXJuIDMgIT09IHQubGVuZ3RoIHx8IEFycmF5LmlzQXJyYXkodFsxXSkgfHwgQXJyYXkuaXNBcnJheSh0WzJdKTtcblxuICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQuc2xpY2UoMSk7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJbZV07XG4gICAgICAgICAgICBpZiAoIWFuKG4pICYmIFwiYm9vbGVhblwiICE9IHR5cGVvZiBuKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICEwO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cblxuICAgICRyLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgJHIodC5fcGFyYW1ldGVycywgdC5fc3BlY2lmaWNhdGlvbik7XG4gICAgfSwgJHIuc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9wYXJhbWV0ZXJzOiB0Ll9wYXJhbWV0ZXJzLFxuICAgICAgICBfc3BlY2lmaWNhdGlvbjogdC5fc3BlY2lmaWNhdGlvblxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBvbiA9IHtcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogITEsXG4gICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNuKHQpIHtcbiAgICAgIGlmIChudWxsID09IHQpIHJldHVybiB7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgbmVlZEdlb21ldHJ5OiAhMVxuICAgICAgfTtcbiAgICAgIGFuKHQpIHx8ICh0ID0gbG4odCkpO1xuICAgICAgdmFyIGUgPSBYcih0LCBvbik7XG4gICAgICBpZiAoXCJlcnJvclwiID09PSBlLnJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGUudmFsdWUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmtleSArIFwiOiBcIiArIHQubWVzc2FnZTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcih0LCByLCBuKSB7XG4gICAgICAgICAgcmV0dXJuIGUudmFsdWUuZXZhbHVhdGUodCwgciwge30sIG4pO1xuICAgICAgICB9LFxuICAgICAgICBuZWVkR2VvbWV0cnk6IGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuICExO1xuICAgICAgICAgIGlmIChcIndpdGhpblwiID09PSBlWzBdKSByZXR1cm4gITA7XG5cbiAgICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGlmICh0KGVbcl0pKSByZXR1cm4gITA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9KHQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IDwgZSA/IC0xIDogdCA+IGUgPyAxIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsbih0KSB7XG4gICAgICBpZiAoIXQpIHJldHVybiAhMDtcbiAgICAgIHZhciBlLFxuICAgICAgICAgIHIgPSB0WzBdO1xuICAgICAgcmV0dXJuIHQubGVuZ3RoIDw9IDEgPyBcImFueVwiICE9PSByIDogXCI9PVwiID09PSByID8gcG4odFsxXSwgdFsyXSwgXCI9PVwiKSA6IFwiIT1cIiA9PT0gciA/IGZuKHBuKHRbMV0sIHRbMl0sIFwiPT1cIikpIDogXCI8XCIgPT09IHIgfHwgXCI+XCIgPT09IHIgfHwgXCI8PVwiID09PSByIHx8IFwiPj1cIiA9PT0gciA/IHBuKHRbMV0sIHRbMl0sIHIpIDogXCJhbnlcIiA9PT0gciA/IChlID0gdC5zbGljZSgxKSwgW1wiYW55XCJdLmNvbmNhdChlLm1hcChsbikpKSA6IFwiYWxsXCIgPT09IHIgPyBbXCJhbGxcIl0uY29uY2F0KHQuc2xpY2UoMSkubWFwKGxuKSkgOiBcIm5vbmVcIiA9PT0gciA/IFtcImFsbFwiXS5jb25jYXQodC5zbGljZSgxKS5tYXAobG4pLm1hcChmbikpIDogXCJpblwiID09PSByID8gY24odFsxXSwgdC5zbGljZSgyKSkgOiBcIiFpblwiID09PSByID8gZm4oY24odFsxXSwgdC5zbGljZSgyKSkpIDogXCJoYXNcIiA9PT0gciA/IGhuKHRbMV0pIDogXCIhaGFzXCIgPT09IHIgPyBmbihobih0WzFdKSkgOiBcIndpdGhpblwiICE9PSByIHx8IHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG4odCwgZSwgcikge1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCIkdHlwZVwiOlxuICAgICAgICAgIHJldHVybiBbXCJmaWx0ZXItdHlwZS1cIiArIHIsIGVdO1xuXG4gICAgICAgIGNhc2UgXCIkaWRcIjpcbiAgICAgICAgICByZXR1cm4gW1wiZmlsdGVyLWlkLVwiICsgciwgZV07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gW1wiZmlsdGVyLVwiICsgciwgdCwgZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY24odCwgZSkge1xuICAgICAgaWYgKDAgPT09IGUubGVuZ3RoKSByZXR1cm4gITE7XG5cbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwiJHR5cGVcIjpcbiAgICAgICAgICByZXR1cm4gW1wiZmlsdGVyLXR5cGUtaW5cIiwgW1wibGl0ZXJhbFwiLCBlXV07XG5cbiAgICAgICAgY2FzZSBcIiRpZFwiOlxuICAgICAgICAgIHJldHVybiBbXCJmaWx0ZXItaWQtaW5cIiwgW1wibGl0ZXJhbFwiLCBlXV07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZS5sZW5ndGggPiAyMDAgJiYgIWUuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ICE9IHR5cGVvZiBlWzBdO1xuICAgICAgICAgIH0pID8gW1wiZmlsdGVyLWluLWxhcmdlXCIsIHQsIFtcImxpdGVyYWxcIiwgZS5zb3J0KHVuKV1dIDogW1wiZmlsdGVyLWluLXNtYWxsXCIsIHQsIFtcImxpdGVyYWxcIiwgZV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhuKHQpIHtcbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwiJHR5cGVcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG5cbiAgICAgICAgY2FzZSBcIiRpZFwiOlxuICAgICAgICAgIHJldHVybiBbXCJmaWx0ZXItaGFzLWlkXCJdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1oYXNcIiwgdF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm4odCkge1xuICAgICAgcmV0dXJuIFtcIiFcIiwgdF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geW4odCkge1xuICAgICAgcmV0dXJuIGFuKEZ0KHQudmFsdWUpKSA/IHJuKFR0KHt9LCB0LCB7XG4gICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiBcImZpbHRlclwiLFxuICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICB2YWx1ZTogXCJib29sZWFuXCJcbiAgICAgICAgfVxuICAgICAgfSkpIDogZnVuY3Rpb24gdChlKSB7XG4gICAgICAgIHZhciByID0gZS52YWx1ZSxcbiAgICAgICAgICAgIG4gPSBlLmtleTtcbiAgICAgICAgaWYgKFwiYXJyYXlcIiAhPT0gTHIocikpIHJldHVybiBbbmV3IE10KG4sIHIsIFwiYXJyYXkgZXhwZWN0ZWQsIFwiICsgTHIocikgKyBcIiBmb3VuZFwiKV07XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgYSA9IGUuc3R5bGVTcGVjLFxuICAgICAgICAgICAgbyA9IFtdO1xuICAgICAgICBpZiAoci5sZW5ndGggPCAxKSByZXR1cm4gW25ldyBNdChuLCByLCBcImZpbHRlciBhcnJheSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBlbGVtZW50XCIpXTtcblxuICAgICAgICBzd2l0Y2ggKG8gPSBvLmNvbmNhdChubih7XG4gICAgICAgICAga2V5OiBuICsgXCJbMF1cIixcbiAgICAgICAgICB2YWx1ZTogclswXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IGEuZmlsdGVyX29wZXJhdG9yLFxuICAgICAgICAgIHN0eWxlOiBlLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogZS5zdHlsZVNwZWNcbiAgICAgICAgfSkpLCBWdChyWzBdKSkge1xuICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICAgIHIubGVuZ3RoID49IDIgJiYgXCIkdHlwZVwiID09PSBWdChyWzFdKSAmJiBvLnB1c2gobmV3IE10KG4sIHIsICdcIiR0eXBlXCIgY2Fubm90IGJlIHVzZSB3aXRoIG9wZXJhdG9yIFwiJyArIHJbMF0gKyAnXCInKSk7XG5cbiAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgICAgIDMgIT09IHIubGVuZ3RoICYmIG8ucHVzaChuZXcgTXQobiwgciwgJ2ZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCInICsgclswXSArICdcIiBtdXN0IGhhdmUgMyBlbGVtZW50cycpKTtcblxuICAgICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgIGNhc2UgXCIhaW5cIjpcbiAgICAgICAgICAgIHIubGVuZ3RoID49IDIgJiYgXCJzdHJpbmdcIiAhPT0gKGkgPSBMcihyWzFdKSkgJiYgby5wdXNoKG5ldyBNdChuICsgXCJbMV1cIiwgclsxXSwgXCJzdHJpbmcgZXhwZWN0ZWQsIFwiICsgaSArIFwiIGZvdW5kXCIpKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDI7IHMgPCByLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgIGkgPSBMcihyW3NdKSwgXCIkdHlwZVwiID09PSBWdChyWzFdKSA/IG8gPSBvLmNvbmNhdChubih7XG4gICAgICAgICAgICAgICAga2V5OiBuICsgXCJbXCIgKyBzICsgXCJdXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJbc10sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBhLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICAgICAgc3R5bGU6IGUuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBlLnN0eWxlU3BlY1xuICAgICAgICAgICAgICB9KSkgOiBcInN0cmluZ1wiICE9PSBpICYmIFwibnVtYmVyXCIgIT09IGkgJiYgXCJib29sZWFuXCIgIT09IGkgJiYgby5wdXNoKG5ldyBNdChuICsgXCJbXCIgKyBzICsgXCJdXCIsIHJbc10sIFwic3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4gZXhwZWN0ZWQsIFwiICsgaSArIFwiIGZvdW5kXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgICAgY2FzZSBcImFsbFwiOlxuICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gMTsgdSA8IHIubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgbyA9IG8uY29uY2F0KHQoe1xuICAgICAgICAgICAgICAgIGtleTogbiArIFwiW1wiICsgdSArIFwiXVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByW3VdLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBlLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogZS5zdHlsZVNwZWNcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJoYXNcIjpcbiAgICAgICAgICBjYXNlIFwiIWhhc1wiOlxuICAgICAgICAgICAgaSA9IExyKHJbMV0pLCAyICE9PSByLmxlbmd0aCA/IG8ucHVzaChuZXcgTXQobiwgciwgJ2ZpbHRlciBhcnJheSBmb3IgXCInICsgclswXSArICdcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50cycpKSA6IFwic3RyaW5nXCIgIT09IGkgJiYgby5wdXNoKG5ldyBNdChuICsgXCJbMV1cIiwgclsxXSwgXCJzdHJpbmcgZXhwZWN0ZWQsIFwiICsgaSArIFwiIGZvdW5kXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIndpdGhpblwiOlxuICAgICAgICAgICAgaSA9IExyKHJbMV0pLCAyICE9PSByLmxlbmd0aCA/IG8ucHVzaChuZXcgTXQobiwgciwgJ2ZpbHRlciBhcnJheSBmb3IgXCInICsgclswXSArICdcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50cycpKSA6IFwib2JqZWN0XCIgIT09IGkgJiYgby5wdXNoKG5ldyBNdChuICsgXCJbMV1cIiwgclsxXSwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgaSArIFwiIGZvdW5kXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSh0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkbih0LCBlKSB7XG4gICAgICB2YXIgciA9IHQua2V5LFxuICAgICAgICAgIG4gPSB0LnN0eWxlLFxuICAgICAgICAgIGkgPSB0LnN0eWxlU3BlYyxcbiAgICAgICAgICBhID0gdC52YWx1ZSxcbiAgICAgICAgICBvID0gdC5vYmplY3RLZXksXG4gICAgICAgICAgcyA9IGlbZSArIFwiX1wiICsgdC5sYXllclR5cGVdO1xuICAgICAgaWYgKCFzKSByZXR1cm4gW107XG4gICAgICB2YXIgdSA9IG8ubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgICBpZiAoXCJwYWludFwiID09PSBlICYmIHUgJiYgc1t1WzFdXSAmJiBzW3VbMV1dLnRyYW5zaXRpb24pIHJldHVybiBTbih7XG4gICAgICAgIGtleTogcixcbiAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgIHZhbHVlU3BlYzogaS50cmFuc2l0aW9uLFxuICAgICAgICBzdHlsZTogbixcbiAgICAgICAgc3R5bGVTcGVjOiBpXG4gICAgICB9KTtcbiAgICAgIHZhciBsLFxuICAgICAgICAgIHAgPSB0LnZhbHVlU3BlYyB8fCBzW29dO1xuICAgICAgaWYgKCFwKSByZXR1cm4gW25ldyBNdChyLCBhLCAndW5rbm93biBwcm9wZXJ0eSBcIicgKyBvICsgJ1wiJyldO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IExyKGEpICYmIFZyKHApICYmICFwLnRva2VucyAmJiAobCA9IC9eeyhbXn1dKyl9JC8uZXhlYyhhKSkpIHJldHVybiBbbmV3IE10KHIsIGEsICdcIicgKyBvICsgJ1wiIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJwb2xhdGlvbiBzeW50YXhcXG5Vc2UgYW4gaWRlbnRpdHkgcHJvcGVydHkgZnVuY3Rpb24gaW5zdGVhZDogYHsgXCJ0eXBlXCI6IFwiaWRlbnRpdHlcIiwgXCJwcm9wZXJ0eVwiOiAnICsgSlNPTi5zdHJpbmdpZnkobFsxXSkgKyBcIiB9YC5cIildO1xuICAgICAgdmFyIGMgPSBbXTtcbiAgICAgIHJldHVybiBcInN5bWJvbFwiID09PSB0LmxheWVyVHlwZSAmJiAoXCJ0ZXh0LWZpZWxkXCIgPT09IG8gJiYgbiAmJiAhbi5nbHlwaHMgJiYgYy5wdXNoKG5ldyBNdChyLCBhLCAndXNlIG9mIFwidGV4dC1maWVsZFwiIHJlcXVpcmVzIGEgc3R5bGUgXCJnbHlwaHNcIiBwcm9wZXJ0eScpKSwgXCJ0ZXh0LWZvbnRcIiA9PT0gbyAmJiBScihGdChhKSkgJiYgXCJpZGVudGl0eVwiID09PSBWdChhLnR5cGUpICYmIGMucHVzaChuZXcgTXQociwgYSwgJ1widGV4dC1mb250XCIgZG9lcyBub3Qgc3VwcG9ydCBpZGVudGl0eSBmdW5jdGlvbnMnKSkpLCBjLmNvbmNhdChTbih7XG4gICAgICAgIGtleTogdC5rZXksXG4gICAgICAgIHZhbHVlOiBhLFxuICAgICAgICB2YWx1ZVNwZWM6IHAsXG4gICAgICAgIHN0eWxlOiBuLFxuICAgICAgICBzdHlsZVNwZWM6IGksXG4gICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiBcInByb3BlcnR5XCIsXG4gICAgICAgIHByb3BlcnR5VHlwZTogZSxcbiAgICAgICAgcHJvcGVydHlLZXk6IG9cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtbih0KSB7XG4gICAgICByZXR1cm4gZG4odCwgXCJwYWludFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2bih0KSB7XG4gICAgICByZXR1cm4gZG4odCwgXCJsYXlvdXRcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ24odCkge1xuICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgICBuID0gdC5rZXksXG4gICAgICAgICAgaSA9IHQuc3R5bGUsXG4gICAgICAgICAgYSA9IHQuc3R5bGVTcGVjO1xuICAgICAgci50eXBlIHx8IHIucmVmIHx8IGUucHVzaChuZXcgTXQobiwgciwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICAgICAgdmFyIG8sXG4gICAgICAgICAgcyA9IFZ0KHIudHlwZSksXG4gICAgICAgICAgdSA9IFZ0KHIucmVmKTtcbiAgICAgIGlmIChyLmlkKSBmb3IgKHZhciBsID0gVnQoci5pZCksIHAgPSAwOyBwIDwgdC5hcnJheUluZGV4OyBwKyspIHtcbiAgICAgICAgdmFyIGMgPSBpLmxheWVyc1twXTtcbiAgICAgICAgVnQoYy5pZCkgPT09IGwgJiYgZS5wdXNoKG5ldyBNdChuLCByLmlkLCAnZHVwbGljYXRlIGxheWVyIGlkIFwiJyArIHIuaWQgKyAnXCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lICcgKyBjLmlkLl9fbGluZV9fKSk7XG4gICAgICB9XG4gICAgICBpZiAoXCJyZWZcIiBpbiByKSBbXCJ0eXBlXCIsIFwic291cmNlXCIsIFwic291cmNlLWxheWVyXCIsIFwiZmlsdGVyXCIsIFwibGF5b3V0XCJdLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdCBpbiByICYmIGUucHVzaChuZXcgTXQobiwgclt0XSwgJ1wiJyArIHQgKyAnXCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycpKTtcbiAgICAgIH0pLCBpLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIFZ0KHQuaWQpID09PSB1ICYmIChvID0gdCk7XG4gICAgICB9KSwgbyA/IG8ucmVmID8gZS5wdXNoKG5ldyBNdChuLCByLnJlZiwgXCJyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllclwiKSkgOiBzID0gVnQoby50eXBlKSA6IGUucHVzaChuZXcgTXQobiwgci5yZWYsICdyZWYgbGF5ZXIgXCInICsgdSArICdcIiBub3QgZm91bmQnKSk7ZWxzZSBpZiAoXCJiYWNrZ3JvdW5kXCIgIT09IHMpIGlmIChyLnNvdXJjZSkge1xuICAgICAgICB2YXIgaCA9IGkuc291cmNlcyAmJiBpLnNvdXJjZXNbci5zb3VyY2VdLFxuICAgICAgICAgICAgZiA9IGggJiYgVnQoaC50eXBlKTtcbiAgICAgICAgaCA/IFwidmVjdG9yXCIgPT09IGYgJiYgXCJyYXN0ZXJcIiA9PT0gcyA/IGUucHVzaChuZXcgTXQobiwgci5zb3VyY2UsICdsYXllciBcIicgKyByLmlkICsgJ1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScpKSA6IFwicmFzdGVyXCIgPT09IGYgJiYgXCJyYXN0ZXJcIiAhPT0gcyA/IGUucHVzaChuZXcgTXQobiwgci5zb3VyY2UsICdsYXllciBcIicgKyByLmlkICsgJ1wiIHJlcXVpcmVzIGEgdmVjdG9yIHNvdXJjZScpKSA6IFwidmVjdG9yXCIgIT09IGYgfHwgcltcInNvdXJjZS1sYXllclwiXSA/IFwicmFzdGVyLWRlbVwiID09PSBmICYmIFwiaGlsbHNoYWRlXCIgIT09IHMgPyBlLnB1c2gobmV3IE10KG4sIHIuc291cmNlLCBcInJhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlICdoaWxsc2hhZGUnLlwiKSkgOiBcImxpbmVcIiAhPT0gcyB8fCAhci5wYWludCB8fCAhci5wYWludFtcImxpbmUtZ3JhZGllbnRcIl0gfHwgXCJnZW9qc29uXCIgPT09IGYgJiYgaC5saW5lTWV0cmljcyB8fCBlLnB1c2gobmV3IE10KG4sIHIsICdsYXllciBcIicgKyByLmlkICsgJ1wiIHNwZWNpZmllcyBhIGxpbmUtZ3JhZGllbnQsIHdoaWNoIHJlcXVpcmVzIGEgR2VvSlNPTiBzb3VyY2Ugd2l0aCBgbGluZU1ldHJpY3NgIGVuYWJsZWQuJykpIDogZS5wdXNoKG5ldyBNdChuLCByLCAnbGF5ZXIgXCInICsgci5pZCArICdcIiBtdXN0IHNwZWNpZnkgYSBcInNvdXJjZS1sYXllclwiJykpIDogZS5wdXNoKG5ldyBNdChuLCByLnNvdXJjZSwgJ3NvdXJjZSBcIicgKyByLnNvdXJjZSArICdcIiBub3QgZm91bmQnKSk7XG4gICAgICB9IGVsc2UgZS5wdXNoKG5ldyBNdChuLCByLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgICAgcmV0dXJuIGUgPSBlLmNvbmNhdChXcih7XG4gICAgICAgIGtleTogbixcbiAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgIHZhbHVlU3BlYzogYS5sYXllcixcbiAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiBmdW5jdGlvbiB0eXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFNuKHtcbiAgICAgICAgICAgICAga2V5OiBuICsgXCIudHlwZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogci50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZVNwZWM6IGEubGF5ZXIudHlwZSxcbiAgICAgICAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgIG9iamVjdDogcixcbiAgICAgICAgICAgICAgb2JqZWN0S2V5OiBcInR5cGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaWx0ZXI6IHluLFxuICAgICAgICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KHQpIHtcbiAgICAgICAgICAgIHJldHVybiBXcih7XG4gICAgICAgICAgICAgIGxheWVyOiByLFxuICAgICAgICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdC52YWx1ZSxcbiAgICAgICAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uIF8odCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZuKFR0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJUeXBlOiBzXG4gICAgICAgICAgICAgICAgICB9LCB0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhaW50OiBmdW5jdGlvbiBwYWludCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gV3Ioe1xuICAgICAgICAgICAgICBsYXllcjogcixcbiAgICAgICAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHQudmFsdWUsXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgIFwiKlwiOiBmdW5jdGlvbiBfKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtbihUdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyVHlwZTogc1xuICAgICAgICAgICAgICAgICAgfSwgdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geG4odCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgIHIgPSB0LmtleSxcbiAgICAgICAgICBuID0gTHIoZSk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPT0gbiA/IFtuZXcgTXQociwgZSwgXCJzdHJpbmcgZXhwZWN0ZWQsIFwiICsgbiArIFwiIGZvdW5kXCIpXSA6IFtdO1xuICAgIH1cblxuICAgIHZhciBibiA9IHtcbiAgICAgIHByb21vdGVJZDogZnVuY3Rpb24gcHJvbW90ZUlkKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgICAgIHIgPSB0LnZhbHVlO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gTHIocikpIHJldHVybiB4bih7XG4gICAgICAgICAga2V5OiBlLFxuICAgICAgICAgIHZhbHVlOiByXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbiA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gcikge1xuICAgICAgICAgIG4ucHVzaC5hcHBseShuLCB4bih7XG4gICAgICAgICAgICBrZXk6IGUgKyBcIi5cIiArIGksXG4gICAgICAgICAgICB2YWx1ZTogcltpXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3bih0KSB7XG4gICAgICB2YXIgZSA9IHQudmFsdWUsXG4gICAgICAgICAgciA9IHQua2V5LFxuICAgICAgICAgIG4gPSB0LnN0eWxlU3BlYyxcbiAgICAgICAgICBpID0gdC5zdHlsZTtcbiAgICAgIGlmICghZS50eXBlKSByZXR1cm4gW25ldyBNdChyLCBlLCAnXCJ0eXBlXCIgaXMgcmVxdWlyZWQnKV07XG4gICAgICB2YXIgYSxcbiAgICAgICAgICBvID0gVnQoZS50eXBlKTtcblxuICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgIGNhc2UgXCJ2ZWN0b3JcIjpcbiAgICAgICAgY2FzZSBcInJhc3RlclwiOlxuICAgICAgICBjYXNlIFwicmFzdGVyLWRlbVwiOlxuICAgICAgICAgIHJldHVybiBXcih7XG4gICAgICAgICAgICBrZXk6IHIsXG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogbltcInNvdXJjZV9cIiArIG8ucmVwbGFjZShcIi1cIiwgXCJfXCIpXSxcbiAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBuLFxuICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IGJuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSBcImdlb2pzb25cIjpcbiAgICAgICAgICBpZiAoYSA9IFdyKHtcbiAgICAgICAgICAgIGtleTogcixcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBuLnNvdXJjZV9nZW9qc29uLFxuICAgICAgICAgICAgc3R5bGU6IGksXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG4sXG4gICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogYm5cbiAgICAgICAgICB9KSwgZS5jbHVzdGVyKSBmb3IgKHZhciBzIGluIGUuY2x1c3RlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciB1ID0gZS5jbHVzdGVyUHJvcGVydGllc1tzXSxcbiAgICAgICAgICAgICAgICBsID0gdVswXSxcbiAgICAgICAgICAgICAgICBwID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgbCA/IFtsLCBbXCJhY2N1bXVsYXRlZFwiXSwgW1wiZ2V0XCIsIHNdXSA6IGw7XG4gICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgcm4oe1xuICAgICAgICAgICAgICBrZXk6IHIgKyBcIi5cIiArIHMgKyBcIi5tYXBcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHVbMV0sXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiBcImNsdXN0ZXItbWFwXCJcbiAgICAgICAgICAgIH0pKSwgYS5wdXNoLmFwcGx5KGEsIHJuKHtcbiAgICAgICAgICAgICAga2V5OiByICsgXCIuXCIgKyBzICsgXCIucmVkdWNlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwLFxuICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogXCJjbHVzdGVyLXJlZHVjZVwiXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhO1xuXG4gICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgICAgIHJldHVybiBXcih7XG4gICAgICAgICAgICBrZXk6IHIsXG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogbi5zb3VyY2VfdmlkZW8sXG4gICAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIHJldHVybiBXcih7XG4gICAgICAgICAgICBrZXk6IHIsXG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogbi5zb3VyY2VfaW1hZ2UsXG4gICAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgXCJjYW52YXNcIjpcbiAgICAgICAgICByZXR1cm4gW25ldyBNdChyLCBudWxsLCBcIlBsZWFzZSB1c2UgcnVudGltZSBBUElzIHRvIGFkZCBjYW52YXMgc291cmNlcywgcmF0aGVyIHRoYW4gaW5jbHVkaW5nIHRoZW0gaW4gc3R5bGVzaGVldHMuXCIsIFwic291cmNlLmNhbnZhc1wiKV07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbm4oe1xuICAgICAgICAgICAga2V5OiByICsgXCIudHlwZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGUudHlwZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzoge1xuICAgICAgICAgICAgICB2YWx1ZXM6IFtcInZlY3RvclwiLCBcInJhc3RlclwiLCBcInJhc3Rlci1kZW1cIiwgXCJnZW9qc29uXCIsIFwidmlkZW9cIiwgXCJpbWFnZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiBpLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBuXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX24odCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgIHIgPSB0LnN0eWxlU3BlYyxcbiAgICAgICAgICBuID0gci5saWdodCxcbiAgICAgICAgICBpID0gdC5zdHlsZSxcbiAgICAgICAgICBhID0gW10sXG4gICAgICAgICAgbyA9IExyKGUpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgcmV0dXJuIGE7XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gbykgcmV0dXJuIGEuY29uY2F0KFtuZXcgTXQoXCJsaWdodFwiLCBlLCBcIm9iamVjdCBleHBlY3RlZCwgXCIgKyBvICsgXCIgZm91bmRcIildKTtcblxuICAgICAgZm9yICh2YXIgcyBpbiBlKSB7XG4gICAgICAgIHZhciB1ID0gcy5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcbiAgICAgICAgYSA9IGEuY29uY2F0KHUgJiYgblt1WzFdXSAmJiBuW3VbMV1dLnRyYW5zaXRpb24gPyBTbih7XG4gICAgICAgICAga2V5OiBzLFxuICAgICAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgICAgIHZhbHVlU3BlYzogci50cmFuc2l0aW9uLFxuICAgICAgICAgIHN0eWxlOiBpLFxuICAgICAgICAgIHN0eWxlU3BlYzogclxuICAgICAgICB9KSA6IG5bc10gPyBTbih7XG4gICAgICAgICAga2V5OiBzLFxuICAgICAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgICAgIHZhbHVlU3BlYzogbltzXSxcbiAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHJcbiAgICAgICAgfSkgOiBbbmV3IE10KHMsIGVbc10sICd1bmtub3duIHByb3BlcnR5IFwiJyArIHMgKyAnXCInKV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgQW4gPSB7XG4gICAgICBcIipcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSxcbiAgICAgIGFycmF5OiBRcixcbiAgICAgIGJvb2xlYW46IGZ1bmN0aW9uIGJvb2xlYW4odCkge1xuICAgICAgICB2YXIgZSA9IHQudmFsdWUsXG4gICAgICAgICAgICByID0gdC5rZXksXG4gICAgICAgICAgICBuID0gTHIoZSk7XG4gICAgICAgIHJldHVybiBcImJvb2xlYW5cIiAhPT0gbiA/IFtuZXcgTXQociwgZSwgXCJib29sZWFuIGV4cGVjdGVkLCBcIiArIG4gKyBcIiBmb3VuZFwiKV0gOiBbXTtcbiAgICAgIH0sXG4gICAgICBudW1iZXI6IHRuLFxuICAgICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgICAgIHIgPSB0LnZhbHVlLFxuICAgICAgICAgICAgbiA9IExyKHIpO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPT0gbiA/IFtuZXcgTXQoZSwgciwgXCJjb2xvciBleHBlY3RlZCwgXCIgKyBuICsgXCIgZm91bmRcIildIDogbnVsbCA9PT0gdGUocikgPyBbbmV3IE10KGUsIHIsICdjb2xvciBleHBlY3RlZCwgXCInICsgciArICdcIiBmb3VuZCcpXSA6IFtdO1xuICAgICAgfSxcbiAgICAgIGNvbnN0YW50czogQnQsXG4gICAgICBlbnVtOiBubixcbiAgICAgIGZpbHRlcjogeW4sXG4gICAgICBmdW5jdGlvbjogZW4sXG4gICAgICBsYXllcjogZ24sXG4gICAgICBvYmplY3Q6IFdyLFxuICAgICAgc291cmNlOiB3bixcbiAgICAgIGxpZ2h0OiBfbixcbiAgICAgIHN0cmluZzogeG4sXG4gICAgICBmb3JtYXR0ZWQ6IGZ1bmN0aW9uIGZvcm1hdHRlZCh0KSB7XG4gICAgICAgIHJldHVybiAwID09PSB4bih0KS5sZW5ndGggPyBbXSA6IHJuKHQpO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVkSW1hZ2U6IGZ1bmN0aW9uIHJlc29sdmVkSW1hZ2UodCkge1xuICAgICAgICByZXR1cm4gMCA9PT0geG4odCkubGVuZ3RoID8gW10gOiBybih0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU24odCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgIHIgPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgICBuID0gdC5zdHlsZVNwZWM7XG4gICAgICByZXR1cm4gci5leHByZXNzaW9uICYmIFJyKFZ0KGUpKSA/IGVuKHQpIDogci5leHByZXNzaW9uICYmIFpyKEZ0KGUpKSA/IHJuKHQpIDogci50eXBlICYmIEFuW3IudHlwZV0gPyBBbltyLnR5cGVdKHQpIDogV3IoVHQoe30sIHQsIHtcbiAgICAgICAgdmFsdWVTcGVjOiByLnR5cGUgPyBuW3IudHlwZV0gOiByXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga24odCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICAgIHIgPSB0LmtleSxcbiAgICAgICAgICBuID0geG4odCk7XG4gICAgICByZXR1cm4gbi5sZW5ndGggfHwgKC0xID09PSBlLmluZGV4T2YoXCJ7Zm9udHN0YWNrfVwiKSAmJiBuLnB1c2gobmV3IE10KHIsIGUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntmb250c3RhY2t9XCIgdG9rZW4nKSksIC0xID09PSBlLmluZGV4T2YoXCJ7cmFuZ2V9XCIpICYmIG4ucHVzaChuZXcgTXQociwgZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpKSwgbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbih0LCBlKSB7XG4gICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSBQdCk7XG4gICAgICB2YXIgciA9IFtdO1xuICAgICAgcmV0dXJuIHIgPSByLmNvbmNhdChTbih7XG4gICAgICAgIGtleTogXCJcIixcbiAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgIHZhbHVlU3BlYzogZS4kcm9vdCxcbiAgICAgICAgc3R5bGVTcGVjOiBlLFxuICAgICAgICBzdHlsZTogdCxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICBnbHlwaHM6IGtuLFxuICAgICAgICAgIFwiKlwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpLCB0LmNvbnN0YW50cyAmJiAociA9IHIuY29uY2F0KEJ0KHtcbiAgICAgICAga2V5OiBcImNvbnN0YW50c1wiLFxuICAgICAgICB2YWx1ZTogdC5jb25zdGFudHMsXG4gICAgICAgIHN0eWxlOiB0LFxuICAgICAgICBzdHlsZVNwZWM6IGVcbiAgICAgIH0pKSksIHpuKHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHpuKHQpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQodCkuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5saW5lIC0gZS5saW5lO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ24odCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IFtdLCByID0gYXJndW1lbnRzLmxlbmd0aDsgci0tOykge1xuICAgICAgICAgIGVbcl0gPSBhcmd1bWVudHNbcl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gem4odC5hcHBseSh0aGlzLCBlKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEluLnNvdXJjZSA9IENuKHduKSwgSW4ubGlnaHQgPSBDbihfbiksIEluLmxheWVyID0gQ24oZ24pLCBJbi5maWx0ZXIgPSBDbih5biksIEluLnBhaW50UHJvcGVydHkgPSBDbihtbiksIEluLmxheW91dFByb3BlcnR5ID0gQ24odm4pO1xuICAgIHZhciBFbiA9IEluLFxuICAgICAgICBQbiA9IEVuLmxpZ2h0LFxuICAgICAgICBNbiA9IEVuLnBhaW50UHJvcGVydHksXG4gICAgICAgIEJuID0gRW4ubGF5b3V0UHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBUbih0LCBlKSB7XG4gICAgICB2YXIgciA9ICExO1xuICAgICAgaWYgKGUgJiYgZS5sZW5ndGgpIGZvciAodmFyIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdC5maXJlKG5ldyBDdChuZXcgRXJyb3IoaVtuXS5tZXNzYWdlKSkpLCByID0gITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICB2YXIgVm4gPSBGbjtcblxuICAgIGZ1bmN0aW9uIEZuKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jZWxscyA9IFtdO1xuXG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSB0O1xuICAgICAgICB2YXIgaSA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgICB0ID0gaVswXSwgdGhpcy5kID0gKGUgPSBpWzFdKSArIDIgKiAociA9IGlbMl0pO1xuXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhpcy5kICogdGhpcy5kOyBhKyspIHtcbiAgICAgICAgICB2YXIgbyA9IGlbMyArIGFdLFxuICAgICAgICAgICAgICBzID0gaVszICsgYSArIDFdO1xuICAgICAgICAgIG4ucHVzaChvID09PSBzID8gbnVsbCA6IGkuc3ViYXJyYXkobywgcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHUgPSBpWzMgKyBuLmxlbmd0aCArIDFdO1xuICAgICAgICB0aGlzLmtleXMgPSBpLnN1YmFycmF5KGlbMyArIG4ubGVuZ3RoXSwgdSksIHRoaXMuYmJveGVzID0gaS5zdWJhcnJheSh1KSwgdGhpcy5pbnNlcnQgPSB0aGlzLl9pbnNlcnRSZWFkb25seTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZCA9IGUgKyAyICogcjtcblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoaXMuZCAqIHRoaXMuZDsgbCsrKSB7XG4gICAgICAgICAgbi5wdXNoKFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMua2V5cyA9IFtdLCB0aGlzLmJib3hlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm4gPSBlLCB0aGlzLmV4dGVudCA9IHQsIHRoaXMucGFkZGluZyA9IHIsIHRoaXMuc2NhbGUgPSBlIC8gdCwgdGhpcy51aWQgPSAwO1xuICAgICAgdmFyIHAgPSByIC8gZSAqIHQ7XG4gICAgICB0aGlzLm1pbiA9IC1wLCB0aGlzLm1heCA9IHQgKyBwO1xuICAgIH1cblxuICAgIEZuLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy5fZm9yRWFjaENlbGwoZSwgciwgbiwgaSwgdGhpcy5faW5zZXJ0Q2VsbCwgdGhpcy51aWQrKyksIHRoaXMua2V5cy5wdXNoKHQpLCB0aGlzLmJib3hlcy5wdXNoKGUpLCB0aGlzLmJib3hlcy5wdXNoKHIpLCB0aGlzLmJib3hlcy5wdXNoKG4pLCB0aGlzLmJib3hlcy5wdXNoKGkpO1xuICAgIH0sIEZuLnByb3RvdHlwZS5faW5zZXJ0UmVhZG9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBpbnNlcnQgaW50byBhIEdyaWRJbmRleCBjcmVhdGVkIGZyb20gYW4gQXJyYXlCdWZmZXIuXCI7XG4gICAgfSwgRm4ucHJvdG90eXBlLl9pbnNlcnRDZWxsID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHRoaXMuY2VsbHNbaV0ucHVzaChhKTtcbiAgICB9LCBGbi5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdmFyIGEgPSB0aGlzLm1pbixcbiAgICAgICAgICBvID0gdGhpcy5tYXg7XG4gICAgICBpZiAodCA8PSBhICYmIGUgPD0gYSAmJiBvIDw9IHIgJiYgbyA8PSBuICYmICFpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5rZXlzKTtcbiAgICAgIHZhciBzID0gW107XG4gICAgICByZXR1cm4gdGhpcy5fZm9yRWFjaENlbGwodCwgZSwgciwgbiwgdGhpcy5fcXVlcnlDZWxsLCBzLCB7fSwgaSksIHM7XG4gICAgfSwgRm4ucHJvdG90eXBlLl9xdWVyeUNlbGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcykge1xuICAgICAgdmFyIHUgPSB0aGlzLmNlbGxzW2ldO1xuICAgICAgaWYgKG51bGwgIT09IHUpIGZvciAodmFyIGwgPSB0aGlzLmtleXMsIHAgPSB0aGlzLmJib3hlcywgYyA9IDA7IGMgPCB1Lmxlbmd0aDsgYysrKSB7XG4gICAgICAgIHZhciBoID0gdVtjXTtcblxuICAgICAgICBpZiAodm9pZCAwID09PSBvW2hdKSB7XG4gICAgICAgICAgdmFyIGYgPSA0ICogaDtcbiAgICAgICAgICAocyA/IHMocFtmICsgMF0sIHBbZiArIDFdLCBwW2YgKyAyXSwgcFtmICsgM10pIDogdCA8PSBwW2YgKyAyXSAmJiBlIDw9IHBbZiArIDNdICYmIHIgPj0gcFtmICsgMF0gJiYgbiA+PSBwW2YgKyAxXSkgPyAob1toXSA9ICEwLCBhLnB1c2gobFtoXSkpIDogb1toXSA9ICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgRm4ucHJvdG90eXBlLl9mb3JFYWNoQ2VsbCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICBmb3IgKHZhciB1ID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKHQpLCBsID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKGUpLCBwID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKHIpLCBjID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKG4pLCBoID0gdTsgaCA8PSBwOyBoKyspIHtcbiAgICAgICAgZm9yICh2YXIgZiA9IGw7IGYgPD0gYzsgZisrKSB7XG4gICAgICAgICAgdmFyIHkgPSB0aGlzLmQgKiBmICsgaDtcbiAgICAgICAgICBpZiAoKCFzIHx8IHModGhpcy5fY29udmVydEZyb21DZWxsQ29vcmQoaCksIHRoaXMuX2NvbnZlcnRGcm9tQ2VsbENvb3JkKGYpLCB0aGlzLl9jb252ZXJ0RnJvbUNlbGxDb29yZChoICsgMSksIHRoaXMuX2NvbnZlcnRGcm9tQ2VsbENvb3JkKGYgKyAxKSkpICYmIGkuY2FsbCh0aGlzLCB0LCBlLCByLCBuLCB5LCBhLCBvLCBzKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgRm4ucHJvdG90eXBlLl9jb252ZXJ0RnJvbUNlbGxDb29yZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gKHQgLSB0aGlzLnBhZGRpbmcpIC8gdGhpcy5zY2FsZTtcbiAgICB9LCBGbi5wcm90b3R5cGUuX2NvbnZlcnRUb0NlbGxDb29yZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5kIC0gMSwgTWF0aC5mbG9vcih0ICogdGhpcy5zY2FsZSkgKyB0aGlzLnBhZGRpbmcpKTtcbiAgICB9LCBGbi5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmFycmF5QnVmZmVyKSByZXR1cm4gdGhpcy5hcnJheUJ1ZmZlcjtcblxuICAgICAgZm9yICh2YXIgdCA9IHRoaXMuY2VsbHMsIGUgPSAzICsgdGhpcy5jZWxscy5sZW5ndGggKyAxICsgMSwgciA9IDAsIG4gPSAwOyBuIDwgdGhpcy5jZWxscy5sZW5ndGg7IG4rKykge1xuICAgICAgICByICs9IHRoaXMuY2VsbHNbbl0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IG5ldyBJbnQzMkFycmF5KGUgKyByICsgdGhpcy5rZXlzLmxlbmd0aCArIHRoaXMuYmJveGVzLmxlbmd0aCk7XG4gICAgICBpWzBdID0gdGhpcy5leHRlbnQsIGlbMV0gPSB0aGlzLm4sIGlbMl0gPSB0aGlzLnBhZGRpbmc7XG5cbiAgICAgIGZvciAodmFyIGEgPSBlLCBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgdmFyIHMgPSB0W29dO1xuICAgICAgICBpWzMgKyBvXSA9IGEsIGkuc2V0KHMsIGEpLCBhICs9IHMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaVszICsgdC5sZW5ndGhdID0gYSwgaS5zZXQodGhpcy5rZXlzLCBhKSwgaVszICsgdC5sZW5ndGggKyAxXSA9IGEgKz0gdGhpcy5rZXlzLmxlbmd0aCwgaS5zZXQodGhpcy5iYm94ZXMsIGEpLCBhICs9IHRoaXMuYmJveGVzLmxlbmd0aCwgaS5idWZmZXI7XG4gICAgfTtcbiAgICB2YXIgRG4gPSBvLkltYWdlRGF0YSxcbiAgICAgICAgTG4gPSBvLkltYWdlQml0bWFwLFxuICAgICAgICBSbiA9IHt9O1xuXG4gICAgZnVuY3Rpb24gT24odCwgZSwgcikge1xuICAgICAgdm9pZCAwID09PSByICYmIChyID0ge30pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfY2xhc3NSZWdpc3RyeUtleVwiLCB7XG4gICAgICAgIHZhbHVlOiB0LFxuICAgICAgICB3cml0ZWFibGU6ICExXG4gICAgICB9KSwgUm5bdF0gPSB7XG4gICAgICAgIGtsYXNzOiBlLFxuICAgICAgICBvbWl0OiByLm9taXQgfHwgW10sXG4gICAgICAgIHNoYWxsb3c6IHIuc2hhbGxvdyB8fCBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBVbiBpbiBPbihcIk9iamVjdFwiLCBPYmplY3QpLCBWbi5zZXJpYWxpemUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0LnRvQXJyYXlCdWZmZXIoKTtcbiAgICAgIHJldHVybiBlICYmIGUucHVzaChyKSwge1xuICAgICAgICBidWZmZXI6IHJcbiAgICAgIH07XG4gICAgfSwgVm4uZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5ldyBWbih0LmJ1ZmZlcik7XG4gICAgfSwgT24oXCJHcmlkXCIsIFZuKSwgT24oXCJDb2xvclwiLCBlZSksIE9uKFwiRXJyb3JcIiwgRXJyb3IpLCBPbihcIlJlc29sdmVkSW1hZ2VcIiwgYWUpLCBPbihcIlN0eWxlUHJvcGVydHlGdW5jdGlvblwiLCAkciksIE9uKFwiU3R5bGVFeHByZXNzaW9uXCIsIEdyLCB7XG4gICAgICBvbWl0OiBbXCJfZXZhbHVhdG9yXCJdXG4gICAgfSksIE9uKFwiWm9vbURlcGVuZGVudEV4cHJlc3Npb25cIiwgSHIpLCBPbihcIlpvb21Db25zdGFudEV4cHJlc3Npb25cIiwgSnIpLCBPbihcIkNvbXBvdW5kRXhwcmVzc2lvblwiLCBiZSwge1xuICAgICAgb21pdDogW1wiX2V2YWx1YXRlXCJdXG4gICAgfSksIHpyKSB7XG4gICAgICB6cltVbl0uX2NsYXNzUmVnaXN0cnlLZXkgfHwgT24oXCJFeHByZXNzaW9uX1wiICsgVW4sIHpyW1VuXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam4odCkge1xuICAgICAgcmV0dXJuIHQgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYgKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCB0LmNvbnN0cnVjdG9yICYmIFwiQXJyYXlCdWZmZXJcIiA9PT0gdC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxbih0KSB7XG4gICAgICByZXR1cm4gTG4gJiYgdCBpbnN0YW5jZW9mIExuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE5uKHQsIGUpIHtcbiAgICAgIGlmIChudWxsID09IHQgfHwgXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgdCB8fCBcInN0cmluZ1wiID09IHR5cGVvZiB0IHx8IHQgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHQgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0IGluc3RhbmNlb2YgRGF0ZSB8fCB0IGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gdDtcbiAgICAgIGlmIChqbih0KSB8fCBxbih0KSkgcmV0dXJuIGUgJiYgZS5wdXNoKHQpLCB0O1xuXG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHQpKSB7XG4gICAgICAgIHZhciByID0gdDtcbiAgICAgICAgcmV0dXJuIGUgJiYgZS5wdXNoKHIuYnVmZmVyKSwgcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBEbikgcmV0dXJuIGUgJiYgZS5wdXNoKHQuZGF0YS5idWZmZXIpLCB0O1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwLCBhID0gdDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBuLnB1c2goTm4oYVtpXSwgZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG5cbiAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgIHZhciBvID0gdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIHMgPSBvLl9jbGFzc1JlZ2lzdHJ5S2V5O1xuICAgICAgICBpZiAoIXMpIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBvYmplY3Qgb2YgdW5yZWdpc3RlcmVkIGNsYXNzXCIpO1xuICAgICAgICB2YXIgdSA9IG8uc2VyaWFsaXplID8gby5zZXJpYWxpemUodCwgZSkgOiB7fTtcblxuICAgICAgICBpZiAoIW8uc2VyaWFsaXplKSB7XG4gICAgICAgICAgZm9yICh2YXIgbCBpbiB0KSB7XG4gICAgICAgICAgICBpZiAodC5oYXNPd25Qcm9wZXJ0eShsKSAmJiAhKFJuW3NdLm9taXQuaW5kZXhPZihsKSA+PSAwKSkge1xuICAgICAgICAgICAgICB2YXIgcCA9IHRbbF07XG4gICAgICAgICAgICAgIHVbbF0gPSBSbltzXS5zaGFsbG93LmluZGV4T2YobCkgPj0gMCA/IHAgOiBObihwLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0IGluc3RhbmNlb2YgRXJyb3IgJiYgKHUubWVzc2FnZSA9IHQubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodS4kbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiJG5hbWUgcHJvcGVydHkgaXMgcmVzZXJ2ZWQgZm9yIHdvcmtlciBzZXJpYWxpemF0aW9uIGxvZ2ljLlwiKTtcbiAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgIT09IHMgJiYgKHUuJG5hbWUgPSBzKSwgdTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIG9iamVjdCBvZiB0eXBlIFwiICsgdHlwZW9mIHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEtuKHQpIHtcbiAgICAgIGlmIChudWxsID09IHQgfHwgXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgdCB8fCBcInN0cmluZ1wiID09IHR5cGVvZiB0IHx8IHQgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHQgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0IGluc3RhbmNlb2YgRGF0ZSB8fCB0IGluc3RhbmNlb2YgUmVnRXhwIHx8IGpuKHQpIHx8IHFuKHQpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh0KSB8fCB0IGluc3RhbmNlb2YgRG4pIHJldHVybiB0O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHJldHVybiB0Lm1hcChLbik7XG5cbiAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgIHZhciBlID0gdC4kbmFtZSB8fCBcIk9iamVjdFwiLFxuICAgICAgICAgICAgciA9IFJuW2VdLmtsYXNzO1xuICAgICAgICBpZiAoIXIpIHRocm93IG5ldyBFcnJvcihcImNhbid0IGRlc2VyaWFsaXplIHVucmVnaXN0ZXJlZCBjbGFzcyBcIiArIGUpO1xuICAgICAgICBpZiAoci5kZXNlcmlhbGl6ZSkgcmV0dXJuIHIuZGVzZXJpYWxpemUodCk7XG5cbiAgICAgICAgZm9yICh2YXIgbiA9IE9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpLCBpID0gMCwgYSA9IE9iamVjdC5rZXlzKHQpOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBvID0gYVtpXTtcblxuICAgICAgICAgIGlmIChcIiRuYW1lXCIgIT09IG8pIHtcbiAgICAgICAgICAgIHZhciBzID0gdFtvXTtcbiAgICAgICAgICAgIG5bb10gPSBSbltlXS5zaGFsbG93LmluZGV4T2YobykgPj0gMCA/IHMgOiBLbihzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgZGVzZXJpYWxpemUgb2JqZWN0IG9mIHR5cGUgXCIgKyB0eXBlb2YgdCk7XG4gICAgfVxuXG4gICAgdmFyIEduID0gZnVuY3Rpb24gR24oKSB7XG4gICAgICB0aGlzLmZpcnN0ID0gITA7XG4gICAgfTtcblxuICAgIEduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKHQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmlyc3QgPyAodGhpcy5maXJzdCA9ICExLCB0aGlzLmxhc3RJbnRlZ2VyWm9vbSA9IHIsIHRoaXMubGFzdEludGVnZXJab29tVGltZSA9IDAsIHRoaXMubGFzdFpvb20gPSB0LCB0aGlzLmxhc3RGbG9vclpvb20gPSByLCAhMCkgOiAodGhpcy5sYXN0Rmxvb3Jab29tID4gciA/ICh0aGlzLmxhc3RJbnRlZ2VyWm9vbSA9IHIgKyAxLCB0aGlzLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBlKSA6IHRoaXMubGFzdEZsb29yWm9vbSA8IHIgJiYgKHRoaXMubGFzdEludGVnZXJab29tID0gciwgdGhpcy5sYXN0SW50ZWdlclpvb21UaW1lID0gZSksIHQgIT09IHRoaXMubGFzdFpvb20gJiYgKHRoaXMubGFzdFpvb20gPSB0LCB0aGlzLmxhc3RGbG9vclpvb20gPSByLCAhMCkpO1xuICAgIH07XG5cbiAgICB2YXIgWm4gPSB7XG4gICAgICBcIkxhdGluLTEgU3VwcGxlbWVudFwiOiBmdW5jdGlvbiBMYXRpbjFTdXBwbGVtZW50KHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI4ICYmIHQgPD0gMjU1O1xuICAgICAgfSxcbiAgICAgIEFyYWJpYzogZnVuY3Rpb24gQXJhYmljKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTUzNiAmJiB0IDw9IDE3OTE7XG4gICAgICB9LFxuICAgICAgXCJBcmFiaWMgU3VwcGxlbWVudFwiOiBmdW5jdGlvbiBBcmFiaWNTdXBwbGVtZW50KHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTg3MiAmJiB0IDw9IDE5MTk7XG4gICAgICB9LFxuICAgICAgXCJBcmFiaWMgRXh0ZW5kZWQtQVwiOiBmdW5jdGlvbiBBcmFiaWNFeHRlbmRlZEEodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAyMjA4ICYmIHQgPD0gMjMwMztcbiAgICAgIH0sXG4gICAgICBcIkhhbmd1bCBKYW1vXCI6IGZ1bmN0aW9uIEhhbmd1bEphbW8odCkge1xuICAgICAgICByZXR1cm4gdCA+PSA0MzUyICYmIHQgPD0gNDYwNztcbiAgICAgIH0sXG4gICAgICBcIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcIjogZnVuY3Rpb24gVW5pZmllZENhbmFkaWFuQWJvcmlnaW5hbFN5bGxhYmljcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDUxMjAgJiYgdCA8PSA1NzU5O1xuICAgICAgfSxcbiAgICAgIEtobWVyOiBmdW5jdGlvbiBLaG1lcih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDYwMTYgJiYgdCA8PSA2MTQzO1xuICAgICAgfSxcbiAgICAgIFwiVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljcyBFeHRlbmRlZFwiOiBmdW5jdGlvbiBVbmlmaWVkQ2FuYWRpYW5BYm9yaWdpbmFsU3lsbGFiaWNzRXh0ZW5kZWQodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2MzIwICYmIHQgPD0gNjM5OTtcbiAgICAgIH0sXG4gICAgICBcIkdlbmVyYWwgUHVuY3R1YXRpb25cIjogZnVuY3Rpb24gR2VuZXJhbFB1bmN0dWF0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gODE5MiAmJiB0IDw9IDgzMDM7XG4gICAgICB9LFxuICAgICAgXCJMZXR0ZXJsaWtlIFN5bWJvbHNcIjogZnVuY3Rpb24gTGV0dGVybGlrZVN5bWJvbHModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA4NDQ4ICYmIHQgPD0gODUyNztcbiAgICAgIH0sXG4gICAgICBcIk51bWJlciBGb3Jtc1wiOiBmdW5jdGlvbiBOdW1iZXJGb3Jtcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDg1MjggJiYgdCA8PSA4NTkxO1xuICAgICAgfSxcbiAgICAgIFwiTWlzY2VsbGFuZW91cyBUZWNobmljYWxcIjogZnVuY3Rpb24gTWlzY2VsbGFuZW91c1RlY2huaWNhbCh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDg5NjAgJiYgdCA8PSA5MjE1O1xuICAgICAgfSxcbiAgICAgIFwiQ29udHJvbCBQaWN0dXJlc1wiOiBmdW5jdGlvbiBDb250cm9sUGljdHVyZXModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA5MjE2ICYmIHQgPD0gOTI3OTtcbiAgICAgIH0sXG4gICAgICBcIk9wdGljYWwgQ2hhcmFjdGVyIFJlY29nbml0aW9uXCI6IGZ1bmN0aW9uIE9wdGljYWxDaGFyYWN0ZXJSZWNvZ25pdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDkyODAgJiYgdCA8PSA5MzExO1xuICAgICAgfSxcbiAgICAgIFwiRW5jbG9zZWQgQWxwaGFudW1lcmljc1wiOiBmdW5jdGlvbiBFbmNsb3NlZEFscGhhbnVtZXJpY3ModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA5MzEyICYmIHQgPD0gOTQ3MTtcbiAgICAgIH0sXG4gICAgICBcIkdlb21ldHJpYyBTaGFwZXNcIjogZnVuY3Rpb24gR2VvbWV0cmljU2hhcGVzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gOTYzMiAmJiB0IDw9IDk3Mjc7XG4gICAgICB9LFxuICAgICAgXCJNaXNjZWxsYW5lb3VzIFN5bWJvbHNcIjogZnVuY3Rpb24gTWlzY2VsbGFuZW91c1N5bWJvbHModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA5NzI4ICYmIHQgPD0gOTk4MztcbiAgICAgIH0sXG4gICAgICBcIk1pc2NlbGxhbmVvdXMgU3ltYm9scyBhbmQgQXJyb3dzXCI6IGZ1bmN0aW9uIE1pc2NlbGxhbmVvdXNTeW1ib2xzQW5kQXJyb3dzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTEwMDggJiYgdCA8PSAxMTI2MztcbiAgICAgIH0sXG4gICAgICBcIkNKSyBSYWRpY2FscyBTdXBwbGVtZW50XCI6IGZ1bmN0aW9uIENKS1JhZGljYWxzU3VwcGxlbWVudCh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDExOTA0ICYmIHQgPD0gMTIwMzE7XG4gICAgICB9LFxuICAgICAgXCJLYW5neGkgUmFkaWNhbHNcIjogZnVuY3Rpb24gS2FuZ3hpUmFkaWNhbHModCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjAzMiAmJiB0IDw9IDEyMjU1O1xuICAgICAgfSxcbiAgICAgIFwiSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1wiOiBmdW5jdGlvbiBJZGVvZ3JhcGhpY0Rlc2NyaXB0aW9uQ2hhcmFjdGVycyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyMjcyICYmIHQgPD0gMTIyODc7XG4gICAgICB9LFxuICAgICAgXCJDSksgU3ltYm9scyBhbmQgUHVuY3R1YXRpb25cIjogZnVuY3Rpb24gQ0pLU3ltYm9sc0FuZFB1bmN0dWF0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTIyODggJiYgdCA8PSAxMjM1MTtcbiAgICAgIH0sXG4gICAgICBIaXJhZ2FuYTogZnVuY3Rpb24gSGlyYWdhbmEodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjM1MiAmJiB0IDw9IDEyNDQ3O1xuICAgICAgfSxcbiAgICAgIEthdGFrYW5hOiBmdW5jdGlvbiBLYXRha2FuYSh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyNDQ4ICYmIHQgPD0gMTI1NDM7XG4gICAgICB9LFxuICAgICAgQm9wb21vZm86IGZ1bmN0aW9uIEJvcG9tb2ZvKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI1NDQgJiYgdCA8PSAxMjU5MTtcbiAgICAgIH0sXG4gICAgICBcIkhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cIjogZnVuY3Rpb24gSGFuZ3VsQ29tcGF0aWJpbGl0eUphbW8odCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjU5MiAmJiB0IDw9IDEyNjg3O1xuICAgICAgfSxcbiAgICAgIEthbmJ1bjogZnVuY3Rpb24gS2FuYnVuKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI2ODggJiYgdCA8PSAxMjcwMztcbiAgICAgIH0sXG4gICAgICBcIkJvcG9tb2ZvIEV4dGVuZGVkXCI6IGZ1bmN0aW9uIEJvcG9tb2ZvRXh0ZW5kZWQodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjcwNCAmJiB0IDw9IDEyNzM1O1xuICAgICAgfSxcbiAgICAgIFwiQ0pLIFN0cm9rZXNcIjogZnVuY3Rpb24gQ0pLU3Ryb2tlcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyNzM2ICYmIHQgPD0gMTI3ODM7XG4gICAgICB9LFxuICAgICAgXCJLYXRha2FuYSBQaG9uZXRpYyBFeHRlbnNpb25zXCI6IGZ1bmN0aW9uIEthdGFrYW5hUGhvbmV0aWNFeHRlbnNpb25zKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI3ODQgJiYgdCA8PSAxMjc5OTtcbiAgICAgIH0sXG4gICAgICBcIkVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHNcIjogZnVuY3Rpb24gRW5jbG9zZWRDSktMZXR0ZXJzQW5kTW9udGhzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI4MDAgJiYgdCA8PSAxMzA1NTtcbiAgICAgIH0sXG4gICAgICBcIkNKSyBDb21wYXRpYmlsaXR5XCI6IGZ1bmN0aW9uIENKS0NvbXBhdGliaWxpdHkodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMzA1NiAmJiB0IDw9IDEzMzExO1xuICAgICAgfSxcbiAgICAgIFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQVwiOiBmdW5jdGlvbiBDSktVbmlmaWVkSWRlb2dyYXBoc0V4dGVuc2lvbkEodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMzMxMiAmJiB0IDw9IDE5OTAzO1xuICAgICAgfSxcbiAgICAgIFwiWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcIjogZnVuY3Rpb24gWWlqaW5nSGV4YWdyYW1TeW1ib2xzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTk5MDQgJiYgdCA8PSAxOTk2NztcbiAgICAgIH0sXG4gICAgICBcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHNcIjogZnVuY3Rpb24gQ0pLVW5pZmllZElkZW9ncmFwaHModCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxOTk2OCAmJiB0IDw9IDQwOTU5O1xuICAgICAgfSxcbiAgICAgIFwiWWkgU3lsbGFibGVzXCI6IGZ1bmN0aW9uIFlpU3lsbGFibGVzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNDA5NjAgJiYgdCA8PSA0MjEyNztcbiAgICAgIH0sXG4gICAgICBcIllpIFJhZGljYWxzXCI6IGZ1bmN0aW9uIFlpUmFkaWNhbHModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA0MjEyOCAmJiB0IDw9IDQyMTkxO1xuICAgICAgfSxcbiAgICAgIFwiSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQVwiOiBmdW5jdGlvbiBIYW5ndWxKYW1vRXh0ZW5kZWRBKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNDMzNjAgJiYgdCA8PSA0MzM5MTtcbiAgICAgIH0sXG4gICAgICBcIkhhbmd1bCBTeWxsYWJsZXNcIjogZnVuY3Rpb24gSGFuZ3VsU3lsbGFibGVzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNDQwMzIgJiYgdCA8PSA1NTIxNTtcbiAgICAgIH0sXG4gICAgICBcIkhhbmd1bCBKYW1vIEV4dGVuZGVkLUJcIjogZnVuY3Rpb24gSGFuZ3VsSmFtb0V4dGVuZGVkQih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDU1MjE2ICYmIHQgPD0gNTUyOTU7XG4gICAgICB9LFxuICAgICAgXCJQcml2YXRlIFVzZSBBcmVhXCI6IGZ1bmN0aW9uIFByaXZhdGVVc2VBcmVhKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNTczNDQgJiYgdCA8PSA2Mzc0MztcbiAgICAgIH0sXG4gICAgICBcIkNKSyBDb21wYXRpYmlsaXR5IElkZW9ncmFwaHNcIjogZnVuY3Rpb24gQ0pLQ29tcGF0aWJpbGl0eUlkZW9ncmFwaHModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2Mzc0NCAmJiB0IDw9IDY0MjU1O1xuICAgICAgfSxcbiAgICAgIFwiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXCI6IGZ1bmN0aW9uIEFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zQSh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDY0MzM2ICYmIHQgPD0gNjUwMjM7XG4gICAgICB9LFxuICAgICAgXCJWZXJ0aWNhbCBGb3Jtc1wiOiBmdW5jdGlvbiBWZXJ0aWNhbEZvcm1zKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjUwNDAgJiYgdCA8PSA2NTA1NTtcbiAgICAgIH0sXG4gICAgICBcIkNKSyBDb21wYXRpYmlsaXR5IEZvcm1zXCI6IGZ1bmN0aW9uIENKS0NvbXBhdGliaWxpdHlGb3Jtcyh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDY1MDcyICYmIHQgPD0gNjUxMDM7XG4gICAgICB9LFxuICAgICAgXCJTbWFsbCBGb3JtIFZhcmlhbnRzXCI6IGZ1bmN0aW9uIFNtYWxsRm9ybVZhcmlhbnRzKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjUxMDQgJiYgdCA8PSA2NTEzNTtcbiAgICAgIH0sXG4gICAgICBcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlwiOiBmdW5jdGlvbiBBcmFiaWNQcmVzZW50YXRpb25Gb3Jtc0IodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NTEzNiAmJiB0IDw9IDY1Mjc5O1xuICAgICAgfSxcbiAgICAgIFwiSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcIjogZnVuY3Rpb24gSGFsZndpZHRoQW5kRnVsbHdpZHRoRm9ybXModCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NTI4MCAmJiB0IDw9IDY1NTE5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBYbih0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIGlmIChKbihyW2VdLmNoYXJDb2RlQXQoMCkpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBKbih0KSB7XG4gICAgICByZXR1cm4gISg3NDYgIT09IHQgJiYgNzQ3ICE9PSB0ICYmICh0IDwgNDM1MiB8fCAhKFpuW1wiQm9wb21vZm8gRXh0ZW5kZWRcIl0odCkgfHwgWm4uQm9wb21vZm8odCkgfHwgWm5bXCJDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1wiXSh0KSAmJiAhKHQgPj0gNjUwOTcgJiYgdCA8PSA2NTEwMykgfHwgWm5bXCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXCJdKHQpIHx8IFpuW1wiQ0pLIENvbXBhdGliaWxpdHlcIl0odCkgfHwgWm5bXCJDSksgUmFkaWNhbHMgU3VwcGxlbWVudFwiXSh0KSB8fCBabltcIkNKSyBTdHJva2VzXCJdKHQpIHx8ICEoIVpuW1wiQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXCJdKHQpIHx8IHQgPj0gMTIyOTYgJiYgdCA8PSAxMjMwNSB8fCB0ID49IDEyMzA4ICYmIHQgPD0gMTIzMTkgfHwgMTIzMzYgPT09IHQpIHx8IFpuW1wiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQVwiXSh0KSB8fCBabltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHNcIl0odCkgfHwgWm5bXCJFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXCJdKHQpIHx8IFpuW1wiSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1wiXSh0KSB8fCBabltcIkhhbmd1bCBKYW1vIEV4dGVuZGVkLUFcIl0odCkgfHwgWm5bXCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1CXCJdKHQpIHx8IFpuW1wiSGFuZ3VsIEphbW9cIl0odCkgfHwgWm5bXCJIYW5ndWwgU3lsbGFibGVzXCJdKHQpIHx8IFpuLkhpcmFnYW5hKHQpIHx8IFpuW1wiSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1wiXSh0KSB8fCBabi5LYW5idW4odCkgfHwgWm5bXCJLYW5neGkgUmFkaWNhbHNcIl0odCkgfHwgWm5bXCJLYXRha2FuYSBQaG9uZXRpYyBFeHRlbnNpb25zXCJdKHQpIHx8IFpuLkthdGFrYW5hKHQpICYmIDEyNTQwICE9PSB0IHx8ICEoIVpuW1wiSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcIl0odCkgfHwgNjUyODggPT09IHQgfHwgNjUyODkgPT09IHQgfHwgNjUyOTMgPT09IHQgfHwgdCA+PSA2NTMwNiAmJiB0IDw9IDY1MzEwIHx8IDY1MzM5ID09PSB0IHx8IDY1MzQxID09PSB0IHx8IDY1MzQzID09PSB0IHx8IHQgPj0gNjUzNzEgJiYgdCA8PSA2NTUwMyB8fCA2NTUwNyA9PT0gdCB8fCB0ID49IDY1NTEyICYmIHQgPD0gNjU1MTkpIHx8ICEoIVpuW1wiU21hbGwgRm9ybSBWYXJpYW50c1wiXSh0KSB8fCB0ID49IDY1MTEyICYmIHQgPD0gNjUxMTggfHwgdCA+PSA2NTEyMyAmJiB0IDw9IDY1MTI2KSB8fCBabltcIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcIl0odCkgfHwgWm5bXCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzIEV4dGVuZGVkXCJdKHQpIHx8IFpuW1wiVmVydGljYWwgRm9ybXNcIl0odCkgfHwgWm5bXCJZaWppbmcgSGV4YWdyYW0gU3ltYm9sc1wiXSh0KSB8fCBabltcIllpIFN5bGxhYmxlc1wiXSh0KSB8fCBabltcIllpIFJhZGljYWxzXCJdKHQpKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhuKHQpIHtcbiAgICAgIHJldHVybiAhKEpuKHQpIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAhIShabltcIkxhdGluLTEgU3VwcGxlbWVudFwiXSh0KSAmJiAoMTY3ID09PSB0IHx8IDE2OSA9PT0gdCB8fCAxNzQgPT09IHQgfHwgMTc3ID09PSB0IHx8IDE4OCA9PT0gdCB8fCAxODkgPT09IHQgfHwgMTkwID09PSB0IHx8IDIxNSA9PT0gdCB8fCAyNDcgPT09IHQpIHx8IFpuW1wiR2VuZXJhbCBQdW5jdHVhdGlvblwiXSh0KSAmJiAoODIxNCA9PT0gdCB8fCA4MjI0ID09PSB0IHx8IDgyMjUgPT09IHQgfHwgODI0MCA9PT0gdCB8fCA4MjQxID09PSB0IHx8IDgyNTEgPT09IHQgfHwgODI1MiA9PT0gdCB8fCA4MjU4ID09PSB0IHx8IDgyNjMgPT09IHQgfHwgODI2NCA9PT0gdCB8fCA4MjY1ID09PSB0IHx8IDgyNzMgPT09IHQpIHx8IFpuW1wiTGV0dGVybGlrZSBTeW1ib2xzXCJdKHQpIHx8IFpuW1wiTnVtYmVyIEZvcm1zXCJdKHQpIHx8IFpuW1wiTWlzY2VsbGFuZW91cyBUZWNobmljYWxcIl0odCkgJiYgKHQgPj0gODk2MCAmJiB0IDw9IDg5NjcgfHwgdCA+PSA4OTcyICYmIHQgPD0gODk5MSB8fCB0ID49IDg5OTYgJiYgdCA8PSA5ZTMgfHwgOTAwMyA9PT0gdCB8fCB0ID49IDkwODUgJiYgdCA8PSA5MTE0IHx8IHQgPj0gOTE1MCAmJiB0IDw9IDkxNjUgfHwgOTE2NyA9PT0gdCB8fCB0ID49IDkxNjkgJiYgdCA8PSA5MTc5IHx8IHQgPj0gOTE4NiAmJiB0IDw9IDkyMTUpIHx8IFpuW1wiQ29udHJvbCBQaWN0dXJlc1wiXSh0KSAmJiA5MjUxICE9PSB0IHx8IFpuW1wiT3B0aWNhbCBDaGFyYWN0ZXIgUmVjb2duaXRpb25cIl0odCkgfHwgWm5bXCJFbmNsb3NlZCBBbHBoYW51bWVyaWNzXCJdKHQpIHx8IFpuW1wiR2VvbWV0cmljIFNoYXBlc1wiXSh0KSB8fCBabltcIk1pc2NlbGxhbmVvdXMgU3ltYm9sc1wiXSh0KSAmJiAhKHQgPj0gOTc1NCAmJiB0IDw9IDk3NTkpIHx8IFpuW1wiTWlzY2VsbGFuZW91cyBTeW1ib2xzIGFuZCBBcnJvd3NcIl0odCkgJiYgKHQgPj0gMTEwMjYgJiYgdCA8PSAxMTA1NSB8fCB0ID49IDExMDg4ICYmIHQgPD0gMTEwOTcgfHwgdCA+PSAxMTE5MiAmJiB0IDw9IDExMjQzKSB8fCBabltcIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiXSh0KSB8fCBabi5LYXRha2FuYSh0KSB8fCBabltcIlByaXZhdGUgVXNlIEFyZWFcIl0odCkgfHwgWm5bXCJDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1wiXSh0KSB8fCBabltcIlNtYWxsIEZvcm0gVmFyaWFudHNcIl0odCkgfHwgWm5bXCJIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1wiXSh0KSB8fCA4NzM0ID09PSB0IHx8IDg3NTYgPT09IHQgfHwgODc1NyA9PT0gdCB8fCB0ID49IDk5ODQgJiYgdCA8PSAxMDA4NyB8fCB0ID49IDEwMTAyICYmIHQgPD0gMTAxMzEgfHwgNjU1MzIgPT09IHQgfHwgNjU1MzMgPT09IHQpO1xuICAgICAgfSh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWW4odCkge1xuICAgICAgcmV0dXJuIHQgPj0gMTQyNCAmJiB0IDw9IDIzMDMgfHwgWm5bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcIl0odCkgfHwgWm5bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcIl0odCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJG4odCwgZSkge1xuICAgICAgcmV0dXJuICEoIWUgJiYgWW4odCkgfHwgdCA+PSAyMzA0ICYmIHQgPD0gMzU4MyB8fCB0ID49IDM4NDAgJiYgdCA8PSA0MjU1IHx8IFpuLktobWVyKHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXbih0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIGlmIChZbihyW2VdLmNoYXJDb2RlQXQoMCkpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICB2YXIgUW4gPSBudWxsLFxuICAgICAgICB0aSA9IFwidW5hdmFpbGFibGVcIixcbiAgICAgICAgZWkgPSBudWxsLFxuICAgICAgICByaSA9IGZ1bmN0aW9uIHJpKHQpIHtcbiAgICAgIHQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB0LmluZGV4T2YoXCJOZXR3b3JrRXJyb3JcIikgPiAtMSAmJiAodGkgPSBcImVycm9yXCIpLCBRbiAmJiBRbih0KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbmkoKSB7XG4gICAgICBpaS5maXJlKG5ldyB6dChcInBsdWdpblN0YXRlQ2hhbmdlXCIsIHtcbiAgICAgICAgcGx1Z2luU3RhdHVzOiB0aSxcbiAgICAgICAgcGx1Z2luVVJMOiBlaVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciBpaSA9IG5ldyBFdCgpLFxuICAgICAgICBhaSA9IGZ1bmN0aW9uIGFpKCkge1xuICAgICAgcmV0dXJuIHRpO1xuICAgIH0sXG4gICAgICAgIG9pID0gZnVuY3Rpb24gb2koKSB7XG4gICAgICBpZiAoXCJkZWZlcnJlZFwiICE9PSB0aSB8fCAhZWkpIHRocm93IG5ldyBFcnJvcihcInJ0bC10ZXh0LXBsdWdpbiBjYW5ub3QgYmUgZG93bmxvYWRlZCB1bmxlc3MgYSBwbHVnaW5VUkwgaXMgc3BlY2lmaWVkXCIpO1xuICAgICAgdGkgPSBcImxvYWRpbmdcIiwgbmkoKSwgZWkgJiYgd3Qoe1xuICAgICAgICB1cmw6IGVpXG4gICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICB0ID8gcmkodCkgOiAodGkgPSBcImxvYWRlZFwiLCBuaSgpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIHNpID0ge1xuICAgICAgYXBwbHlBcmFiaWNTaGFwaW5nOiBudWxsLFxuICAgICAgcHJvY2Vzc0JpZGlyZWN0aW9uYWxUZXh0OiBudWxsLFxuICAgICAgcHJvY2Vzc1N0eWxlZEJpZGlyZWN0aW9uYWxUZXh0OiBudWxsLFxuICAgICAgaXNMb2FkZWQ6IGZ1bmN0aW9uIGlzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gXCJsb2FkZWRcIiA9PT0gdGkgfHwgbnVsbCAhPSBzaS5hcHBseUFyYWJpY1NoYXBpbmc7XG4gICAgICB9LFxuICAgICAgaXNMb2FkaW5nOiBmdW5jdGlvbiBpc0xvYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiBcImxvYWRpbmdcIiA9PT0gdGk7XG4gICAgICB9LFxuICAgICAgc2V0U3RhdGU6IGZ1bmN0aW9uIHNldFN0YXRlKHQpIHtcbiAgICAgICAgdGkgPSB0LnBsdWdpblN0YXR1cywgZWkgPSB0LnBsdWdpblVSTDtcbiAgICAgIH0sXG4gICAgICBpc1BhcnNlZDogZnVuY3Rpb24gaXNQYXJzZWQoKSB7XG4gICAgICAgIHJldHVybiBudWxsICE9IHNpLmFwcGx5QXJhYmljU2hhcGluZyAmJiBudWxsICE9IHNpLnByb2Nlc3NCaWRpcmVjdGlvbmFsVGV4dCAmJiBudWxsICE9IHNpLnByb2Nlc3NTdHlsZWRCaWRpcmVjdGlvbmFsVGV4dDtcbiAgICAgIH0sXG4gICAgICBnZXRQbHVnaW5VUkw6IGZ1bmN0aW9uIGdldFBsdWdpblVSTCgpIHtcbiAgICAgICAgcmV0dXJuIGVpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIHVpID0gZnVuY3Rpb24gdWkodCwgZSkge1xuICAgICAgdGhpcy56b29tID0gdCwgZSA/ICh0aGlzLm5vdyA9IGUubm93LCB0aGlzLmZhZGVEdXJhdGlvbiA9IGUuZmFkZUR1cmF0aW9uLCB0aGlzLnpvb21IaXN0b3J5ID0gZS56b29tSGlzdG9yeSwgdGhpcy50cmFuc2l0aW9uID0gZS50cmFuc2l0aW9uKSA6ICh0aGlzLm5vdyA9IDAsIHRoaXMuZmFkZUR1cmF0aW9uID0gMCwgdGhpcy56b29tSGlzdG9yeSA9IG5ldyBHbigpLCB0aGlzLnRyYW5zaXRpb24gPSB7fSk7XG4gICAgfTtcblxuICAgIHVpLnByb3RvdHlwZS5pc1N1cHBvcnRlZFNjcmlwdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSB0OyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIGlmICghJG4obltyXS5jaGFyQ29kZUF0KDApLCBlKSkgcmV0dXJuICExO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSh0LCBzaS5pc0xvYWRlZCgpKTtcbiAgICB9LCB1aS5wcm90b3R5cGUuY3Jvc3NGYWRpbmdGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5mYWRlRHVyYXRpb24gPyAxIDogTWF0aC5taW4oKHRoaXMubm93IC0gdGhpcy56b29tSGlzdG9yeS5sYXN0SW50ZWdlclpvb21UaW1lKSAvIHRoaXMuZmFkZUR1cmF0aW9uLCAxKTtcbiAgICB9LCB1aS5wcm90b3R5cGUuZ2V0Q3Jvc3NmYWRlUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy56b29tLFxuICAgICAgICAgIGUgPSB0IC0gTWF0aC5mbG9vcih0KSxcbiAgICAgICAgICByID0gdGhpcy5jcm9zc0ZhZGluZ0ZhY3RvcigpO1xuICAgICAgcmV0dXJuIHQgPiB0aGlzLnpvb21IaXN0b3J5Lmxhc3RJbnRlZ2VyWm9vbSA/IHtcbiAgICAgICAgZnJvbVNjYWxlOiAyLFxuICAgICAgICB0b1NjYWxlOiAxLFxuICAgICAgICB0OiBlICsgKDEgLSBlKSAqIHJcbiAgICAgIH0gOiB7XG4gICAgICAgIGZyb21TY2FsZTogLjUsXG4gICAgICAgIHRvU2NhbGU6IDEsXG4gICAgICAgIHQ6IDEgLSAoMSAtIHIpICogZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGxpID0gZnVuY3Rpb24gbGkodCwgZSkge1xuICAgICAgdGhpcy5wcm9wZXJ0eSA9IHQsIHRoaXMudmFsdWUgPSBlLCB0aGlzLmV4cHJlc3Npb24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpZiAoUnIodCkpIHJldHVybiBuZXcgJHIodCwgZSk7XG5cbiAgICAgICAgaWYgKFpyKHQpKSB7XG4gICAgICAgICAgdmFyIHIgPSBZcih0LCBlKTtcbiAgICAgICAgICBpZiAoXCJlcnJvclwiID09PSByLnJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKHIudmFsdWUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5rZXkgKyBcIjogXCIgKyB0Lm1lc3NhZ2U7XG4gICAgICAgICAgfSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICByZXR1cm4gci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gdDtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgXCJjb2xvclwiID09PSBlLnR5cGUgJiYgKG4gPSBlZS5wYXJzZSh0KSksIHtcbiAgICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSh2b2lkIDAgPT09IGUgPyB0LnNwZWNpZmljYXRpb24uZGVmYXVsdCA6IGUsIHQuc3BlY2lmaWNhdGlvbik7XG4gICAgfTtcblxuICAgIGxpLnByb3RvdHlwZS5pc0RhdGFEcml2ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJzb3VyY2VcIiA9PT0gdGhpcy5leHByZXNzaW9uLmtpbmQgfHwgXCJjb21wb3NpdGVcIiA9PT0gdGhpcy5leHByZXNzaW9uLmtpbmQ7XG4gICAgfSwgbGkucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkucG9zc2libHlFdmFsdWF0ZSh0aGlzLCB0LCBlLCByKTtcbiAgICB9O1xuXG4gICAgdmFyIHBpID0gZnVuY3Rpb24gcGkodCkge1xuICAgICAgdGhpcy5wcm9wZXJ0eSA9IHQsIHRoaXMudmFsdWUgPSBuZXcgbGkodCwgdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgcGkucHJvdG90eXBlLnRyYW5zaXRpb25lZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gbmV3IGhpKHRoaXMucHJvcGVydHksIHRoaXMudmFsdWUsIGUsIGgoe30sIHQudHJhbnNpdGlvbiwgdGhpcy50cmFuc2l0aW9uKSwgdC5ub3cpO1xuICAgIH0sIHBpLnByb3RvdHlwZS51bnRyYW5zaXRpb25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgaGkodGhpcy5wcm9wZXJ0eSwgdGhpcy52YWx1ZSwgbnVsbCwge30sIDApO1xuICAgIH07XG5cbiAgICB2YXIgY2kgPSBmdW5jdGlvbiBjaSh0KSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdCwgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0LmRlZmF1bHRUcmFuc2l0aW9uYWJsZVByb3BlcnR5VmFsdWVzKTtcbiAgICB9O1xuXG4gICAgY2kucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB3KHRoaXMuX3ZhbHVlc1t0XS52YWx1ZS52YWx1ZSk7XG4gICAgfSwgY2kucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh0KSB8fCAodGhpcy5fdmFsdWVzW3RdID0gbmV3IHBpKHRoaXMuX3ZhbHVlc1t0XS5wcm9wZXJ0eSkpLCB0aGlzLl92YWx1ZXNbdF0udmFsdWUgPSBuZXcgbGkodGhpcy5fdmFsdWVzW3RdLnByb3BlcnR5LCBudWxsID09PSBlID8gdm9pZCAwIDogdyhlKSk7XG4gICAgfSwgY2kucHJvdG90eXBlLmdldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHcodGhpcy5fdmFsdWVzW3RdLnRyYW5zaXRpb24pO1xuICAgIH0sIGNpLnByb3RvdHlwZS5zZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh0KSB8fCAodGhpcy5fdmFsdWVzW3RdID0gbmV3IHBpKHRoaXMuX3ZhbHVlc1t0XS5wcm9wZXJ0eSkpLCB0aGlzLl92YWx1ZXNbdF0udHJhbnNpdGlvbiA9IHcoZSkgfHwgdm9pZCAwO1xuICAgIH0sIGNpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0ge30sIGUgPSAwLCByID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdLFxuICAgICAgICAgICAgaSA9IHRoaXMuZ2V0VmFsdWUobik7XG4gICAgICAgIHZvaWQgMCAhPT0gaSAmJiAodFtuXSA9IGkpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0VHJhbnNpdGlvbihuKTtcbiAgICAgICAgdm9pZCAwICE9PSBhICYmICh0W24gKyBcIi10cmFuc2l0aW9uXCJdID0gYSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH0sIGNpLnByb3RvdHlwZS50cmFuc2l0aW9uZWQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IG5ldyBmaSh0aGlzLl9wcm9wZXJ0aWVzKSwgbiA9IDAsIGkgPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZXMpOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG4gICAgICAgIHIuX3ZhbHVlc1thXSA9IHRoaXMuX3ZhbHVlc1thXS50cmFuc2l0aW9uZWQodCwgZS5fdmFsdWVzW2FdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgY2kucHJvdG90eXBlLnVudHJhbnNpdGlvbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IG5ldyBmaSh0aGlzLl9wcm9wZXJ0aWVzKSwgZSA9IDAsIHIgPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZXMpOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV07XG4gICAgICAgIHQuX3ZhbHVlc1tuXSA9IHRoaXMuX3ZhbHVlc1tuXS51bnRyYW5zaXRpb25lZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgdmFyIGhpID0gZnVuY3Rpb24gaGkodCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy5wcm9wZXJ0eSA9IHQsIHRoaXMudmFsdWUgPSBlLCB0aGlzLmJlZ2luID0gaSArIG4uZGVsYXkgfHwgMCwgdGhpcy5lbmQgPSB0aGlzLmJlZ2luICsgbi5kdXJhdGlvbiB8fCAwLCB0LnNwZWNpZmljYXRpb24udHJhbnNpdGlvbiAmJiAobi5kZWxheSB8fCBuLmR1cmF0aW9uKSAmJiAodGhpcy5wcmlvciA9IHIpO1xuICAgIH07XG5cbiAgICBoaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHQubm93IHx8IDAsXG4gICAgICAgICAgaSA9IHRoaXMudmFsdWUucG9zc2libHlFdmFsdWF0ZSh0LCBlLCByKSxcbiAgICAgICAgICBhID0gdGhpcy5wcmlvcjtcblxuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKG4gPiB0aGlzLmVuZCkgcmV0dXJuIHRoaXMucHJpb3IgPSBudWxsLCBpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5pc0RhdGFEcml2ZW4oKSkgcmV0dXJuIHRoaXMucHJpb3IgPSBudWxsLCBpO1xuICAgICAgICBpZiAobiA8IHRoaXMuYmVnaW4pIHJldHVybiBhLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgcik7XG4gICAgICAgIHZhciBvID0gKG4gLSB0aGlzLmJlZ2luKSAvICh0aGlzLmVuZCAtIHRoaXMuYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5pbnRlcnBvbGF0ZShhLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgciksIGksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgICAgICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgICAgICAgdmFyIGUgPSB0ICogdCxcbiAgICAgICAgICAgICAgciA9IGUgKiB0O1xuICAgICAgICAgIHJldHVybiA0ICogKHQgPCAuNSA/IHIgOiAzICogKHQgLSBlKSArIHIgLSAuNzUpO1xuICAgICAgICB9KG8pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIHZhciBmaSA9IGZ1bmN0aW9uIGZpKHQpIHtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0LCB0aGlzLl92YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHQuZGVmYXVsdFRyYW5zaXRpb25pbmdQcm9wZXJ0eVZhbHVlcyk7XG4gICAgfTtcblxuICAgIGZpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSBuZXcgbWkodGhpcy5fcHJvcGVydGllcyksIGkgPSAwLCBhID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICBuLl92YWx1ZXNbb10gPSB0aGlzLl92YWx1ZXNbb10ucG9zc2libHlFdmFsdWF0ZSh0LCBlLCByKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgZmkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMCwgZSA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXNbZVt0XV0ucHJpb3IpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH07XG5cbiAgICB2YXIgeWkgPSBmdW5jdGlvbiB5aSh0KSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdCwgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0LmRlZmF1bHRQcm9wZXJ0eVZhbHVlcyk7XG4gICAgfTtcblxuICAgIHlpLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdyh0aGlzLl92YWx1ZXNbdF0udmFsdWUpO1xuICAgIH0sIHlpLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLl92YWx1ZXNbdF0gPSBuZXcgbGkodGhpcy5fdmFsdWVzW3RdLnByb3BlcnR5LCBudWxsID09PSBlID8gdm9pZCAwIDogdyhlKSk7XG4gICAgfSwgeWkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSB7fSwgZSA9IDAsIHIgPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZXMpOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV0sXG4gICAgICAgICAgICBpID0gdGhpcy5nZXRWYWx1ZShuKTtcbiAgICAgICAgdm9pZCAwICE9PSBpICYmICh0W25dID0gaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH0sIHlpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSBuZXcgbWkodGhpcy5fcHJvcGVydGllcyksIGkgPSAwLCBhID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICBuLl92YWx1ZXNbb10gPSB0aGlzLl92YWx1ZXNbb10ucG9zc2libHlFdmFsdWF0ZSh0LCBlLCByKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG47XG4gICAgfTtcblxuICAgIHZhciBkaSA9IGZ1bmN0aW9uIGRpKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSB0LCB0aGlzLnZhbHVlID0gZSwgdGhpcy5wYXJhbWV0ZXJzID0gcjtcbiAgICB9O1xuXG4gICAgZGkucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJjb25zdGFudFwiID09PSB0aGlzLnZhbHVlLmtpbmQ7XG4gICAgfSwgZGkucHJvdG90eXBlLmNvbnN0YW50T3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIFwiY29uc3RhbnRcIiA9PT0gdGhpcy52YWx1ZS5raW5kID8gdGhpcy52YWx1ZS52YWx1ZSA6IHQ7XG4gICAgfSwgZGkucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmV2YWx1YXRlKHRoaXMudmFsdWUsIHRoaXMucGFyYW1ldGVycywgdCwgZSwgciwgbik7XG4gICAgfTtcblxuICAgIHZhciBtaSA9IGZ1bmN0aW9uIG1pKHQpIHtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0LCB0aGlzLl92YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHQuZGVmYXVsdFBvc3NpYmx5RXZhbHVhdGVkVmFsdWVzKTtcbiAgICB9O1xuXG4gICAgbWkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW3RdO1xuICAgIH07XG5cbiAgICB2YXIgdmkgPSBmdW5jdGlvbiB2aSh0KSB7XG4gICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSB0O1xuICAgIH07XG5cbiAgICB2aS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdC5leHByZXNzaW9uLmV2YWx1YXRlKGUpO1xuICAgIH0sIHZpLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IFplW3RoaXMuc3BlY2lmaWNhdGlvbi50eXBlXTtcbiAgICAgIHJldHVybiBuID8gbih0LCBlLCByKSA6IHQ7XG4gICAgfTtcblxuICAgIHZhciBnaSA9IGZ1bmN0aW9uIGdpKHQsIGUpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQsIHRoaXMub3ZlcnJpZGVzID0gZTtcbiAgICB9O1xuXG4gICAgZ2kucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG5ldyBkaSh0aGlzLCBcImNvbnN0YW50XCIgPT09IHQuZXhwcmVzc2lvbi5raW5kIHx8IFwiY2FtZXJhXCIgPT09IHQuZXhwcmVzc2lvbi5raW5kID8ge1xuICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgIHZhbHVlOiB0LmV4cHJlc3Npb24uZXZhbHVhdGUoZSwgbnVsbCwge30sIHIsIG4pXG4gICAgICB9IDogdC5leHByZXNzaW9uLCBlKTtcbiAgICB9LCBnaS5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKFwiY29uc3RhbnRcIiAhPT0gdC52YWx1ZS5raW5kIHx8IFwiY29uc3RhbnRcIiAhPT0gZS52YWx1ZS5raW5kKSByZXR1cm4gdDtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQudmFsdWUudmFsdWUgfHwgdm9pZCAwID09PSBlLnZhbHVlLnZhbHVlKSByZXR1cm4gbmV3IGRpKHRoaXMsIHtcbiAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9LCB0LnBhcmFtZXRlcnMpO1xuICAgICAgdmFyIG4gPSBaZVt0aGlzLnNwZWNpZmljYXRpb24udHlwZV07XG4gICAgICByZXR1cm4gbiA/IG5ldyBkaSh0aGlzLCB7XG4gICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgdmFsdWU6IG4odC52YWx1ZS52YWx1ZSwgZS52YWx1ZS52YWx1ZSwgcilcbiAgICAgIH0sIHQucGFyYW1ldGVycykgOiB0O1xuICAgIH0sIGdpLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gXCJjb25zdGFudFwiID09PSB0LmtpbmQgPyB0LnZhbHVlIDogdC5ldmFsdWF0ZShlLCByLCBuLCBpLCBhKTtcbiAgICB9O1xuXG4gICAgdmFyIHhpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IHQudmFsdWUpIHJldHVybiBuZXcgZGkodGhpcywge1xuICAgICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0sIGUpO1xuXG4gICAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHQuZXhwcmVzc2lvbi5raW5kKSB7XG4gICAgICAgICAgdmFyIGkgPSB0LmV4cHJlc3Npb24uZXZhbHVhdGUoZSwgbnVsbCwge30sIHIsIG4pLFxuICAgICAgICAgICAgICBhID0gXCJyZXNvbHZlZEltYWdlXCIgPT09IHQucHJvcGVydHkuc3BlY2lmaWNhdGlvbi50eXBlICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGkgPyBpLm5hbWUgOiBpLFxuICAgICAgICAgICAgICBvID0gdGhpcy5fY2FsY3VsYXRlKGEsIGEsIGEsIGUpO1xuXG4gICAgICAgICAgcmV0dXJuIG5ldyBkaSh0aGlzLCB7XG4gICAgICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogb1xuICAgICAgICAgIH0sIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiY2FtZXJhXCIgPT09IHQuZXhwcmVzc2lvbi5raW5kKSB7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLl9jYWxjdWxhdGUodC5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IGUuem9vbSAtIDFcbiAgICAgICAgICB9KSwgdC5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IGUuem9vbVxuICAgICAgICAgIH0pLCB0LmV4cHJlc3Npb24uZXZhbHVhdGUoe1xuICAgICAgICAgICAgem9vbTogZS56b29tICsgMVxuICAgICAgICAgIH0pLCBlKTtcblxuICAgICAgICAgIHJldHVybiBuZXcgZGkodGhpcywge1xuICAgICAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICAgICAgdmFsdWU6IHNcbiAgICAgICAgICB9LCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgZGkodGhpcywgdC5leHByZXNzaW9uLCBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgaWYgKFwic291cmNlXCIgPT09IHQua2luZCkge1xuICAgICAgICAgIHZhciBvID0gdC5ldmFsdWF0ZShlLCByLCBuLCBpLCBhKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlKG8sIG8sIG8sIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiY29tcG9zaXRlXCIgPT09IHQua2luZCA/IHRoaXMuX2NhbGN1bGF0ZSh0LmV2YWx1YXRlKHtcbiAgICAgICAgICB6b29tOiBNYXRoLmZsb29yKGUuem9vbSkgLSAxXG4gICAgICAgIH0sIHIsIG4pLCB0LmV2YWx1YXRlKHtcbiAgICAgICAgICB6b29tOiBNYXRoLmZsb29yKGUuem9vbSlcbiAgICAgICAgfSwgciwgbiksIHQuZXZhbHVhdGUoe1xuICAgICAgICAgIHpvb206IE1hdGguZmxvb3IoZS56b29tKSArIDFcbiAgICAgICAgfSwgciwgbiksIGUpIDogdC52YWx1ZTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9jYWxjdWxhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICByZXR1cm4gbi56b29tID4gbi56b29tSGlzdG9yeS5sYXN0SW50ZWdlclpvb20gPyB7XG4gICAgICAgICAgZnJvbTogdCxcbiAgICAgICAgICB0bzogZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGZyb206IHIsXG4gICAgICAgICAgdG86IGVcbiAgICAgICAgfTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oZ2kpLFxuICAgICAgICBiaSA9IGZ1bmN0aW9uIGJpKHQpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQ7XG4gICAgfTtcblxuICAgIGJpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIGlmICh2b2lkIDAgIT09IHQudmFsdWUpIHtcbiAgICAgICAgaWYgKFwiY29uc3RhbnRcIiA9PT0gdC5leHByZXNzaW9uLmtpbmQpIHtcbiAgICAgICAgICB2YXIgaSA9IHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlLCBudWxsLCB7fSwgciwgbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZShpLCBpLCBpLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGUodC5leHByZXNzaW9uLmV2YWx1YXRlKG5ldyB1aShNYXRoLmZsb29yKGUuem9vbSAtIDEpLCBlKSksIHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgdWkoTWF0aC5mbG9vcihlLnpvb20pLCBlKSksIHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgdWkoTWF0aC5mbG9vcihlLnpvb20gKyAxKSwgZSkpLCBlKTtcbiAgICAgIH1cbiAgICB9LCBiaS5wcm90b3R5cGUuX2NhbGN1bGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gbi56b29tID4gbi56b29tSGlzdG9yeS5sYXN0SW50ZWdlclpvb20gPyB7XG4gICAgICAgIGZyb206IHQsXG4gICAgICAgIHRvOiBlXG4gICAgICB9IDoge1xuICAgICAgICBmcm9tOiByLFxuICAgICAgICB0bzogZVxuICAgICAgfTtcbiAgICB9LCBiaS5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHZhciB3aSA9IGZ1bmN0aW9uIHdpKHQpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQ7XG4gICAgfTtcblxuICAgIHdpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiAhIXQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlLCBudWxsLCB7fSwgciwgbik7XG4gICAgfSwgd2kucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH07XG5cbiAgICB2YXIgX2kgPSBmdW5jdGlvbiBfaSh0KSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMucHJvcGVydGllcyA9IHQsIHRoaXMuZGVmYXVsdFByb3BlcnR5VmFsdWVzID0ge30sIHRoaXMuZGVmYXVsdFRyYW5zaXRpb25hYmxlUHJvcGVydHlWYWx1ZXMgPSB7fSwgdGhpcy5kZWZhdWx0VHJhbnNpdGlvbmluZ1Byb3BlcnR5VmFsdWVzID0ge30sIHRoaXMuZGVmYXVsdFBvc3NpYmx5RXZhbHVhdGVkVmFsdWVzID0ge30sIHRoaXMub3ZlcnJpZGFibGVQcm9wZXJ0aWVzID0gW10sIHQpIHtcbiAgICAgICAgdmFyIHIgPSB0W2VdO1xuICAgICAgICByLnNwZWNpZmljYXRpb24ub3ZlcnJpZGFibGUgJiYgdGhpcy5vdmVycmlkYWJsZVByb3BlcnRpZXMucHVzaChlKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmRlZmF1bHRQcm9wZXJ0eVZhbHVlc1tlXSA9IG5ldyBsaShyLCB2b2lkIDApLFxuICAgICAgICAgICAgaSA9IHRoaXMuZGVmYXVsdFRyYW5zaXRpb25hYmxlUHJvcGVydHlWYWx1ZXNbZV0gPSBuZXcgcGkocik7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRyYW5zaXRpb25pbmdQcm9wZXJ0eVZhbHVlc1tlXSA9IGkudW50cmFuc2l0aW9uZWQoKSwgdGhpcy5kZWZhdWx0UG9zc2libHlFdmFsdWF0ZWRWYWx1ZXNbZV0gPSBuLnBvc3NpYmx5RXZhbHVhdGUoe30pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBPbihcIkRhdGFEcml2ZW5Qcm9wZXJ0eVwiLCBnaSksIE9uKFwiRGF0YUNvbnN0YW50UHJvcGVydHlcIiwgdmkpLCBPbihcIkNyb3NzRmFkZWREYXRhRHJpdmVuUHJvcGVydHlcIiwgeGkpLCBPbihcIkNyb3NzRmFkZWRQcm9wZXJ0eVwiLCBiaSksIE9uKFwiQ29sb3JSYW1wUHJvcGVydHlcIiwgd2kpO1xuXG4gICAgdmFyIEFpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICBpZiAodC5jYWxsKHRoaXMpLCB0aGlzLmlkID0gZS5pZCwgdGhpcy50eXBlID0gZS50eXBlLCB0aGlzLl9mZWF0dXJlRmlsdGVyID0ge1xuICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmVlZEdlb21ldHJ5OiAhMVxuICAgICAgICB9LCBcImN1c3RvbVwiICE9PSBlLnR5cGUgJiYgKHRoaXMubWV0YWRhdGEgPSAoZSA9IGUpLm1ldGFkYXRhLCB0aGlzLm1pbnpvb20gPSBlLm1pbnpvb20sIHRoaXMubWF4em9vbSA9IGUubWF4em9vbSwgXCJiYWNrZ3JvdW5kXCIgIT09IGUudHlwZSAmJiAodGhpcy5zb3VyY2UgPSBlLnNvdXJjZSwgdGhpcy5zb3VyY2VMYXllciA9IGVbXCJzb3VyY2UtbGF5ZXJcIl0sIHRoaXMuZmlsdGVyID0gZS5maWx0ZXIpLCByLmxheW91dCAmJiAodGhpcy5fdW5ldmFsdWF0ZWRMYXlvdXQgPSBuZXcgeWkoci5sYXlvdXQpKSwgci5wYWludCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBuIGluIHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQgPSBuZXcgY2koci5wYWludCksIGUucGFpbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFpbnRQcm9wZXJ0eShuLCBlLnBhaW50W25dLCB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBlLmxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5zZXRMYXlvdXRQcm9wZXJ0eShpLCBlLmxheW91dFtpXSwge1xuICAgICAgICAgICAgICB2YWxpZGF0ZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25pbmdQYWludCA9IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQudW50cmFuc2l0aW9uZWQoKSwgdGhpcy5wYWludCA9IG5ldyBtaShyLnBhaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3Jvc3NmYWRlUGFyYW1ldGVycztcbiAgICAgIH0sIGUucHJvdG90eXBlLmdldExheW91dFByb3BlcnR5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwidmlzaWJpbGl0eVwiID09PSB0ID8gdGhpcy52aXNpYmlsaXR5IDogdGhpcy5fdW5ldmFsdWF0ZWRMYXlvdXQuZ2V0VmFsdWUodCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgbnVsbCAhPSBlICYmIHRoaXMuX3ZhbGlkYXRlKEJuLCBcImxheWVycy5cIiArIHRoaXMuaWQgKyBcIi5sYXlvdXQuXCIgKyB0LCB0LCBlLCByKSB8fCAoXCJ2aXNpYmlsaXR5XCIgIT09IHQgPyB0aGlzLl91bmV2YWx1YXRlZExheW91dC5zZXRWYWx1ZSh0LCBlKSA6IHRoaXMudmlzaWJpbGl0eSA9IGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZ2V0UGFpbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBnKHQsIFwiLXRyYW5zaXRpb25cIikgPyB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50LmdldFRyYW5zaXRpb24odC5zbGljZSgwLCAtXCItdHJhbnNpdGlvblwiLmxlbmd0aCkpIDogdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5nZXRWYWx1ZSh0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICBpZiAodm9pZCAwID09PSByICYmIChyID0ge30pLCBudWxsICE9IGUgJiYgdGhpcy5fdmFsaWRhdGUoTW4sIFwibGF5ZXJzLlwiICsgdGhpcy5pZCArIFwiLnBhaW50LlwiICsgdCwgdCwgZSwgcikpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKGcodCwgXCItdHJhbnNpdGlvblwiKSkgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuc2V0VHJhbnNpdGlvbih0LnNsaWNlKDAsIC1cIi10cmFuc2l0aW9uXCIubGVuZ3RoKSwgZSB8fCB2b2lkIDApLCAhMTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50Ll92YWx1ZXNbdF0sXG4gICAgICAgICAgICBpID0gXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiID09PSBuLnByb3BlcnR5LnNwZWNpZmljYXRpb25bXCJwcm9wZXJ0eS10eXBlXCJdLFxuICAgICAgICAgICAgYSA9IG4udmFsdWUuaXNEYXRhRHJpdmVuKCksXG4gICAgICAgICAgICBvID0gbi52YWx1ZTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5zZXRWYWx1ZSh0LCBlKSwgdGhpcy5faGFuZGxlU3BlY2lhbFBhaW50UHJvcGVydHlVcGRhdGUodCk7XG4gICAgICAgIHZhciBzID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW3RdLnZhbHVlO1xuICAgICAgICByZXR1cm4gcy5pc0RhdGFEcml2ZW4oKSB8fCBhIHx8IGkgfHwgdGhpcy5faGFuZGxlT3ZlcnJpZGFibGVQYWludFByb3BlcnR5VXBkYXRlKHQsIG8sIHMpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX2hhbmRsZVNwZWNpYWxQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQpIHt9LCBlLnByb3RvdHlwZS5faGFuZGxlT3ZlcnJpZGFibGVQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5taW56b29tICYmIHQgPCB0aGlzLm1pbnpvb20pIHx8ICEhKHRoaXMubWF4em9vbSAmJiB0ID49IHRoaXMubWF4em9vbSkgfHwgXCJub25lXCIgPT09IHRoaXMudmlzaWJpbGl0eTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50ID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC50cmFuc2l0aW9uZWQodCwgdGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uaW5nUGFpbnQuaGFzVHJhbnNpdGlvbigpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0LmdldENyb3NzZmFkZVBhcmFtZXRlcnMgJiYgKHRoaXMuX2Nyb3NzZmFkZVBhcmFtZXRlcnMgPSB0LmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSksIHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0ICYmICh0aGlzLmxheW91dCA9IHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0LnBvc3NpYmx5RXZhbHVhdGUodCwgdm9pZCAwLCBlKSksIHRoaXMucGFpbnQgPSB0aGlzLl90cmFuc2l0aW9uaW5nUGFpbnQucG9zc2libHlFdmFsdWF0ZSh0LCB2b2lkIDAsIGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHtcbiAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICBcInNvdXJjZS1sYXllclwiOiB0aGlzLnNvdXJjZUxheWVyLFxuICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgIG1pbnpvb206IHRoaXMubWluem9vbSxcbiAgICAgICAgICBtYXh6b29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgICAgICBsYXlvdXQ6IHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0ICYmIHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgIHBhaW50OiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50ICYmIHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuc2VyaWFsaXplKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJpbGl0eSAmJiAodC5sYXlvdXQgPSB0LmxheW91dCB8fCB7fSwgdC5sYXlvdXQudmlzaWJpbGl0eSA9IHRoaXMudmlzaWJpbGl0eSksIGIodCwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gISh2b2lkIDAgPT09IHQgfHwgXCJsYXlvdXRcIiA9PT0gZSAmJiAhT2JqZWN0LmtleXModCkubGVuZ3RoIHx8IFwicGFpbnRcIiA9PT0gZSAmJiAhT2JqZWN0LmtleXModCkubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBpICYmIChpID0ge30pLCAoIWkgfHwgITEgIT09IGkudmFsaWRhdGUpICYmIFRuKHRoaXMsIHQuY2FsbChFbiwge1xuICAgICAgICAgIGtleTogZSxcbiAgICAgICAgICBsYXllclR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICBvYmplY3RLZXk6IHIsXG4gICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgc3R5bGVTcGVjOiBQdCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZ2x5cGhzOiAhMCxcbiAgICAgICAgICAgIHNwcml0ZTogITBcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzVGlsZUNsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmhhc09mZnNjcmVlblBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHt9LCBlLnByb3RvdHlwZS5pc1N0YXRlRGVwZW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMucGFpbnQuX3ZhbHVlcykge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5wYWludC5nZXQodCk7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBkaSAmJiBWcihlLnByb3BlcnR5LnNwZWNpZmljYXRpb24pICYmIChcInNvdXJjZVwiID09PSBlLnZhbHVlLmtpbmQgfHwgXCJjb21wb3NpdGVcIiA9PT0gZS52YWx1ZS5raW5kKSAmJiBlLnZhbHVlLmlzU3RhdGVEZXBlbmRlbnQpIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGU7XG4gICAgfShFdCksXG4gICAgICAgIFNpID0ge1xuICAgICAgSW50ODogSW50OEFycmF5LFxuICAgICAgVWludDg6IFVpbnQ4QXJyYXksXG4gICAgICBJbnQxNjogSW50MTZBcnJheSxcbiAgICAgIFVpbnQxNjogVWludDE2QXJyYXksXG4gICAgICBJbnQzMjogSW50MzJBcnJheSxcbiAgICAgIFVpbnQzMjogVWludDMyQXJyYXksXG4gICAgICBGbG9hdDMyOiBGbG9hdDMyQXJyYXlcbiAgICB9LFxuICAgICAgICBraSA9IGZ1bmN0aW9uIGtpKHQsIGUpIHtcbiAgICAgIHRoaXMuX3N0cnVjdEFycmF5ID0gdCwgdGhpcy5fcG9zMSA9IGUgKiB0aGlzLnNpemUsIHRoaXMuX3BvczIgPSB0aGlzLl9wb3MxIC8gMiwgdGhpcy5fcG9zNCA9IHRoaXMuX3BvczEgLyA0LCB0aGlzLl9wb3M4ID0gdGhpcy5fcG9zMSAvIDg7XG4gICAgfSxcbiAgICAgICAgSWkgPSBmdW5jdGlvbiBJaSgpIHtcbiAgICAgIHRoaXMuaXNUcmFuc2ZlcnJlZCA9ICExLCB0aGlzLmNhcGFjaXR5ID0gLTEsIHRoaXMucmVzaXplKDApO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB6aSh0LCBlKSB7XG4gICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAxKTtcbiAgICAgIHZhciByID0gMCxcbiAgICAgICAgICBuID0gMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lbWJlcnM6IHQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGkgPSBTaVt0LnR5cGVdLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAgICAgICBhID0gciA9IENpKHIsIE1hdGgubWF4KGUsIGkpKSxcbiAgICAgICAgICAgICAgbyA9IHQuY29tcG9uZW50cyB8fCAxO1xuICAgICAgICAgIHJldHVybiBuID0gTWF0aC5tYXgobiwgaSksIHIgKz0gaSAqIG8sIHtcbiAgICAgICAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHQudHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IG8sXG4gICAgICAgICAgICBvZmZzZXQ6IGFcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgc2l6ZTogQ2kociwgTWF0aC5tYXgobiwgZSkpLFxuICAgICAgICBhbGlnbm1lbnQ6IGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ2kodCwgZSkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0IC8gZSkgKiBlO1xuICAgIH1cblxuICAgIElpLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdC5fdHJpbSgpLCBlICYmICh0LmlzVHJhbnNmZXJyZWQgPSAhMCwgZS5wdXNoKHQuYXJyYXlCdWZmZXIpKSwge1xuICAgICAgICBsZW5ndGg6IHQubGVuZ3RoLFxuICAgICAgICBhcnJheUJ1ZmZlcjogdC5hcnJheUJ1ZmZlclxuICAgICAgfTtcbiAgICB9LCBJaS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGUuYXJyYXlCdWZmZXIgPSB0LmFycmF5QnVmZmVyLCBlLmxlbmd0aCA9IHQubGVuZ3RoLCBlLmNhcGFjaXR5ID0gdC5hcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC8gZS5ieXRlc1BlckVsZW1lbnQsIGUuX3JlZnJlc2hWaWV3cygpLCBlO1xuICAgIH0sIElpLnByb3RvdHlwZS5fdHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGVuZ3RoICE9PSB0aGlzLmNhcGFjaXR5ICYmICh0aGlzLmNhcGFjaXR5ID0gdGhpcy5sZW5ndGgsIHRoaXMuYXJyYXlCdWZmZXIgPSB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKDAsIHRoaXMubGVuZ3RoICogdGhpcy5ieXRlc1BlckVsZW1lbnQpLCB0aGlzLl9yZWZyZXNoVmlld3MoKSk7XG4gICAgfSwgSWkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH0sIElpLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5yZXNlcnZlKHQpLCB0aGlzLmxlbmd0aCA9IHQ7XG4gICAgfSwgSWkucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQgPiB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heCh0LCBNYXRoLmZsb29yKDUgKiB0aGlzLmNhcGFjaXR5KSwgMTI4KSwgdGhpcy5hcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmNhcGFjaXR5ICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICB2YXIgZSA9IHRoaXMudWludDg7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpLCBlICYmIHRoaXMudWludDguc2V0KGUpO1xuICAgICAgfVxuICAgIH0sIElpLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3JlZnJlc2hWaWV3cygpIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBjb25jcmV0ZSBTdHJ1Y3RBcnJheSBsYXlvdXRcIik7XG4gICAgfTtcblxuICAgIHZhciBFaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUociArIDEpLCB0aGlzLmVtcGxhY2UociwgdCwgZSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSAyICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbbiArIDBdID0gZSwgdGhpcy5pbnQxNltuICsgMV0gPSByLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIEVpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA0LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0Mmk0XCIsIEVpKTtcblxuICAgIHZhciBQaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoaSArIDEpLCB0aGlzLmVtcGxhY2UoaSwgdCwgZSwgciwgbik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdmFyIGEgPSA0ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbYSArIDBdID0gZSwgdGhpcy5pbnQxNlthICsgMV0gPSByLCB0aGlzLmludDE2W2EgKyAyXSA9IG4sIHRoaXMuaW50MTZbYSArIDNdID0gaSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBQaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gOCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDRpOFwiLCBQaSk7XG5cbiAgICB2YXIgTWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKG8gKyAxKSwgdGhpcy5lbXBsYWNlKG8sIHQsIGUsIHIsIG4sIGksIGEpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICAgIHZhciBzID0gNiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W3MgKyAwXSA9IGUsIHRoaXMuaW50MTZbcyArIDFdID0gciwgdGhpcy5pbnQxNltzICsgMl0gPSBuLCB0aGlzLmludDE2W3MgKyAzXSA9IGksIHRoaXMuaW50MTZbcyArIDRdID0gYSwgdGhpcy5pbnQxNltzICsgNV0gPSBvLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIE1pLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAxMiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJpNGkxMlwiLCBNaSk7XG5cbiAgICB2YXIgQmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKG8gKyAxKSwgdGhpcy5lbXBsYWNlKG8sIHQsIGUsIHIsIG4sIGksIGEpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICAgIHZhciBzID0gNCAqIHQsXG4gICAgICAgICAgICB1ID0gOCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W3MgKyAwXSA9IGUsIHRoaXMuaW50MTZbcyArIDFdID0gciwgdGhpcy51aW50OFt1ICsgNF0gPSBuLCB0aGlzLnVpbnQ4W3UgKyA1XSA9IGksIHRoaXMudWludDhbdSArIDZdID0gYSwgdGhpcy51aW50OFt1ICsgN10gPSBvLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIEJpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA4LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0Mmk0dWI4XCIsIEJpKTtcblxuICAgIHZhciBUaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHIgKyAxKSwgdGhpcy5lbXBsYWNlKHIsIHQsIGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gMiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbbiArIDBdID0gZSwgdGhpcy5mbG9hdDMyW24gKyAxXSA9IHIsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuXG4gICAgVGkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDgsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQyZjhcIiwgVGkpO1xuXG4gICAgdmFyIFZpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHAgKyAxKSwgdGhpcy5lbXBsYWNlKHAsIHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwKSB7XG4gICAgICAgIHZhciBjID0gMTAgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MTZbYyArIDBdID0gZSwgdGhpcy51aW50MTZbYyArIDFdID0gciwgdGhpcy51aW50MTZbYyArIDJdID0gbiwgdGhpcy51aW50MTZbYyArIDNdID0gaSwgdGhpcy51aW50MTZbYyArIDRdID0gYSwgdGhpcy51aW50MTZbYyArIDVdID0gbywgdGhpcy51aW50MTZbYyArIDZdID0gcywgdGhpcy51aW50MTZbYyArIDddID0gdSwgdGhpcy51aW50MTZbYyArIDhdID0gbCwgdGhpcy51aW50MTZbYyArIDldID0gcCwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBWaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMjAsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQxMHVpMjBcIiwgVmkpO1xuXG4gICAgdmFyIEZpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYykge1xuICAgICAgICB2YXIgaCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoaCArIDEpLCB0aGlzLmVtcGxhY2UoaCwgdCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYyk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgpIHtcbiAgICAgICAgdmFyIGYgPSAxMiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W2YgKyAwXSA9IGUsIHRoaXMuaW50MTZbZiArIDFdID0gciwgdGhpcy5pbnQxNltmICsgMl0gPSBuLCB0aGlzLmludDE2W2YgKyAzXSA9IGksIHRoaXMudWludDE2W2YgKyA0XSA9IGEsIHRoaXMudWludDE2W2YgKyA1XSA9IG8sIHRoaXMudWludDE2W2YgKyA2XSA9IHMsIHRoaXMudWludDE2W2YgKyA3XSA9IHUsIHRoaXMuaW50MTZbZiArIDhdID0gbCwgdGhpcy5pbnQxNltmICsgOV0gPSBwLCB0aGlzLmludDE2W2YgKyAxMF0gPSBjLCB0aGlzLmludDE2W2YgKyAxMV0gPSBoLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIEZpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAyNCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDRpNHVpNGkyNFwiLCBGaSk7XG5cbiAgICB2YXIgRGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShuICsgMSksIHRoaXMuZW1wbGFjZShuLCB0LCBlLCByKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdDMyW2kgKyAwXSA9IGUsIHRoaXMuZmxvYXQzMltpICsgMV0gPSByLCB0aGlzLmZsb2F0MzJbaSArIDJdID0gbiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBEaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMTIsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQzZjEyXCIsIERpKTtcblxuICAgIHZhciBMaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShlICsgMSksIHRoaXMuZW1wbGFjZShlLCB0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzJbMSAqIHQgKyAwXSA9IGUsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuXG4gICAgTGkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDQsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQxdWw0XCIsIExpKTtcblxuICAgIHZhciBSaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1KSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShsICsgMSksIHRoaXMuZW1wbGFjZShsLCB0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCkge1xuICAgICAgICB2YXIgcCA9IDEwICogdCxcbiAgICAgICAgICAgIGMgPSA1ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbcCArIDBdID0gZSwgdGhpcy5pbnQxNltwICsgMV0gPSByLCB0aGlzLmludDE2W3AgKyAyXSA9IG4sIHRoaXMuaW50MTZbcCArIDNdID0gaSwgdGhpcy5pbnQxNltwICsgNF0gPSBhLCB0aGlzLmludDE2W3AgKyA1XSA9IG8sIHRoaXMudWludDMyW2MgKyAzXSA9IHMsIHRoaXMudWludDE2W3AgKyA4XSA9IHUsIHRoaXMudWludDE2W3AgKyA5XSA9IGwsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuXG4gICAgUmkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDIwLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0NmkxdWwydWkyMFwiLCBSaSk7XG5cbiAgICB2YXIgT2kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKG8gKyAxKSwgdGhpcy5lbXBsYWNlKG8sIHQsIGUsIHIsIG4sIGksIGEpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICAgIHZhciBzID0gNiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W3MgKyAwXSA9IGUsIHRoaXMuaW50MTZbcyArIDFdID0gciwgdGhpcy5pbnQxNltzICsgMl0gPSBuLCB0aGlzLmludDE2W3MgKyAzXSA9IGksIHRoaXMuaW50MTZbcyArIDRdID0gYSwgdGhpcy5pbnQxNltzICsgNV0gPSBvLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIE9pLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAxMiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJpMmkyaTEyXCIsIE9pKTtcblxuICAgIHZhciBVaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB2YXIgYSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoYSArIDEpLCB0aGlzLmVtcGxhY2UoYSwgdCwgZSwgciwgbiwgaSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgdmFyIG8gPSA0ICogdCxcbiAgICAgICAgICAgIHMgPSA4ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXQzMltvICsgMF0gPSBlLCB0aGlzLmZsb2F0MzJbbyArIDFdID0gciwgdGhpcy5mbG9hdDMyW28gKyAyXSA9IG4sIHRoaXMuaW50MTZbcyArIDZdID0gaSwgdGhpcy5pbnQxNltzICsgN10gPSBhLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIFVpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAxNiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJmMWYyaTE2XCIsIFVpKTtcblxuICAgIHZhciBqaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGkgKyAxKSwgdGhpcy5lbXBsYWNlKGksIHQsIGUsIHIsIG4pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICAgIHZhciBhID0gMTIgKiB0LFxuICAgICAgICAgICAgbyA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy51aW50OFthICsgMF0gPSBlLCB0aGlzLnVpbnQ4W2EgKyAxXSA9IHIsIHRoaXMuZmxvYXQzMltvICsgMV0gPSBuLCB0aGlzLmZsb2F0MzJbbyArIDJdID0gaSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBqaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMTIsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQydWIyZjEyXCIsIGppKTtcblxuICAgIHZhciBxaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShuICsgMSksIHRoaXMuZW1wbGFjZShuLCB0LCBlLCByKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MTZbaSArIDBdID0gZSwgdGhpcy51aW50MTZbaSArIDFdID0gciwgdGhpcy51aW50MTZbaSArIDJdID0gbiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBxaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDN1aTZcIiwgcWkpO1xuXG4gICAgdmFyIE5pID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHYgKyAxKSwgdGhpcy5lbXBsYWNlKHYsIHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtLCB2KSB7XG4gICAgICAgIHZhciBnID0gMjQgKiB0LFxuICAgICAgICAgICAgeCA9IDEyICogdCxcbiAgICAgICAgICAgIGIgPSA0OCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W2cgKyAwXSA9IGUsIHRoaXMuaW50MTZbZyArIDFdID0gciwgdGhpcy51aW50MTZbZyArIDJdID0gbiwgdGhpcy51aW50MTZbZyArIDNdID0gaSwgdGhpcy51aW50MzJbeCArIDJdID0gYSwgdGhpcy51aW50MzJbeCArIDNdID0gbywgdGhpcy51aW50MzJbeCArIDRdID0gcywgdGhpcy51aW50MTZbZyArIDEwXSA9IHUsIHRoaXMudWludDE2W2cgKyAxMV0gPSBsLCB0aGlzLnVpbnQxNltnICsgMTJdID0gcCwgdGhpcy5mbG9hdDMyW3ggKyA3XSA9IGMsIHRoaXMuZmxvYXQzMlt4ICsgOF0gPSBoLCB0aGlzLnVpbnQ4W2IgKyAzNl0gPSBmLCB0aGlzLnVpbnQ4W2IgKyAzN10gPSB5LCB0aGlzLnVpbnQ4W2IgKyAzOF0gPSBkLCB0aGlzLnVpbnQzMlt4ICsgMTBdID0gbSwgdGhpcy5pbnQxNltnICsgMjJdID0gdiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBOaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNDgsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQyaTJ1aTN1bDN1aTJmM3ViMXVsMWk0OFwiLCBOaSk7XG5cbiAgICB2YXIgS2kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCwgbSwgdiwgZywgeCwgYiwgdywgXywgQSwgUywgaywgSSwgeikge1xuICAgICAgICB2YXIgQyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoQyArIDEpLCB0aGlzLmVtcGxhY2UoQywgdCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCwgbSwgdiwgZywgeCwgYiwgdywgXywgQSwgUywgaywgSSwgeik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0sIHYsIGcsIHgsIGIsIHcsIF8sIEEsIFMsIGssIEksIHosIEMpIHtcbiAgICAgICAgdmFyIEUgPSAzNCAqIHQsXG4gICAgICAgICAgICBQID0gMTcgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltFICsgMF0gPSBlLCB0aGlzLmludDE2W0UgKyAxXSA9IHIsIHRoaXMuaW50MTZbRSArIDJdID0gbiwgdGhpcy5pbnQxNltFICsgM10gPSBpLCB0aGlzLmludDE2W0UgKyA0XSA9IGEsIHRoaXMuaW50MTZbRSArIDVdID0gbywgdGhpcy5pbnQxNltFICsgNl0gPSBzLCB0aGlzLmludDE2W0UgKyA3XSA9IHUsIHRoaXMudWludDE2W0UgKyA4XSA9IGwsIHRoaXMudWludDE2W0UgKyA5XSA9IHAsIHRoaXMudWludDE2W0UgKyAxMF0gPSBjLCB0aGlzLnVpbnQxNltFICsgMTFdID0gaCwgdGhpcy51aW50MTZbRSArIDEyXSA9IGYsIHRoaXMudWludDE2W0UgKyAxM10gPSB5LCB0aGlzLnVpbnQxNltFICsgMTRdID0gZCwgdGhpcy51aW50MTZbRSArIDE1XSA9IG0sIHRoaXMudWludDE2W0UgKyAxNl0gPSB2LCB0aGlzLnVpbnQxNltFICsgMTddID0gZywgdGhpcy51aW50MTZbRSArIDE4XSA9IHgsIHRoaXMudWludDE2W0UgKyAxOV0gPSBiLCB0aGlzLnVpbnQxNltFICsgMjBdID0gdywgdGhpcy51aW50MTZbRSArIDIxXSA9IF8sIHRoaXMudWludDE2W0UgKyAyMl0gPSBBLCB0aGlzLnVpbnQzMltQICsgMTJdID0gUywgdGhpcy5mbG9hdDMyW1AgKyAxM10gPSBrLCB0aGlzLmZsb2F0MzJbUCArIDE0XSA9IEksIHRoaXMuZmxvYXQzMltQICsgMTVdID0geiwgdGhpcy5mbG9hdDMyW1AgKyAxNl0gPSBDLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIEtpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA2OCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDhpMTV1aTF1bDRmNjhcIiwgS2kpO1xuXG4gICAgdmFyIEdpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoZSArIDEpLCB0aGlzLmVtcGxhY2UoZSwgdCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXQzMlsxICogdCArIDBdID0gZSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBHaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDFmNFwiLCBHaSk7XG5cbiAgICB2YXIgWmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKG4gKyAxKSwgdGhpcy5lbXBsYWNlKG4sIHQsIGUsIHIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gMyAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W2kgKyAwXSA9IGUsIHRoaXMuaW50MTZbaSArIDFdID0gciwgdGhpcy5pbnQxNltpICsgMl0gPSBuLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIFppLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA2LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0M2k2XCIsIFppKTtcblxuICAgIHZhciBYaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobiArIDEpLCB0aGlzLmVtcGxhY2UobiwgdCwgZSwgcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSA0ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyWzIgKiB0ICsgMF0gPSBlLCB0aGlzLnVpbnQxNltpICsgMl0gPSByLCB0aGlzLnVpbnQxNltpICsgM10gPSBuLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcblxuICAgIFhpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA4LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MXVsMnVpOFwiLCBYaSk7XG5cbiAgICB2YXIgSmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUociArIDEpLCB0aGlzLmVtcGxhY2UociwgdCwgZSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSAyICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDE2W24gKyAwXSA9IGUsIHRoaXMudWludDE2W24gKyAxXSA9IHIsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuXG4gICAgSmkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDQsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQydWk0XCIsIEppKTtcblxuICAgIHZhciBIaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShlICsgMSksIHRoaXMuZW1wbGFjZShlLCB0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MTZbMSAqIHQgKyAwXSA9IGUsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuXG4gICAgSGkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDIsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQxdWkyXCIsIEhpKTtcblxuICAgIHZhciBZaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGkgKyAxKSwgdGhpcy5lbXBsYWNlKGksIHQsIGUsIHIsIG4pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICAgIHZhciBhID0gNCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbYSArIDBdID0gZSwgdGhpcy5mbG9hdDMyW2EgKyAxXSA9IHIsIHRoaXMuZmxvYXQzMlthICsgMl0gPSBuLCB0aGlzLmZsb2F0MzJbYSArIDNdID0gaSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG5cbiAgICBZaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMTYsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ0ZjE2XCIsIFlpKTtcblxuICAgIHZhciAkaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZTtcbiAgICAgIHZhciByID0ge1xuICAgICAgICBhbmNob3JQb2ludFg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclBvaW50WToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgeDE6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHkxOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB4Mjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgeTI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGZlYXR1cmVJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlTGF5ZXJJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYnVja2V0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclBvaW50OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHIuYW5jaG9yUG9pbnRYLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAwXTtcbiAgICAgIH0sIHIuYW5jaG9yUG9pbnRZLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAxXTtcbiAgICAgIH0sIHIueDEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDJdO1xuICAgICAgfSwgci55MS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgM107XG4gICAgICB9LCByLngyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA0XTtcbiAgICAgIH0sIHIueTIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDVdO1xuICAgICAgfSwgci5mZWF0dXJlSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAzXTtcbiAgICAgIH0sIHIuc291cmNlTGF5ZXJJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDhdO1xuICAgICAgfSwgci5idWNrZXRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDldO1xuICAgICAgfSwgci5hbmNob3JQb2ludC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgaSh0aGlzLmFuY2hvclBvaW50WCwgdGhpcy5hbmNob3JQb2ludFkpO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBlO1xuICAgIH0oa2kpO1xuXG4gICAgJGkucHJvdG90eXBlLnNpemUgPSAyMDtcblxuICAgIHZhciBXaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgJGkodGhpcywgdCk7XG4gICAgICB9LCBlO1xuICAgIH0oUmkpO1xuXG4gICAgT24oXCJDb2xsaXNpb25Cb3hBcnJheVwiLCBXaSk7XG5cbiAgICB2YXIgUWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGU7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgYW5jaG9yWDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYW5jaG9yWToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgZ2x5cGhTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBudW1HbHlwaHM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRleFN0YXJ0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsaW5lTGVuZ3RoOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBzZWdtZW50OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsb3dlclNpemU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyU2l6ZToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbGluZU9mZnNldFg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVPZmZzZXRZOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB3cml0aW5nTW9kZToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VkT3JpZW50YXRpb246IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGRlbjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvc3NUaWxlSUQ6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFzc29jaWF0ZWRJY29uSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5hbmNob3JYLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAwXTtcbiAgICAgIH0sIHIuYW5jaG9yWS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMV07XG4gICAgICB9LCByLmdseXBoU3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDJdO1xuICAgICAgfSwgci5udW1HbHlwaHMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAzXTtcbiAgICAgIH0sIHIudmVydGV4U3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDJdO1xuICAgICAgfSwgci5saW5lU3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDNdO1xuICAgICAgfSwgci5saW5lTGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQzMlt0aGlzLl9wb3M0ICsgNF07XG4gICAgICB9LCByLnNlZ21lbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxMF07XG4gICAgICB9LCByLmxvd2VyU2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDExXTtcbiAgICAgIH0sIHIudXBwZXJTaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTJdO1xuICAgICAgfSwgci5saW5lT2Zmc2V0WC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyA3XTtcbiAgICAgIH0sIHIubGluZU9mZnNldFkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgOF07XG4gICAgICB9LCByLndyaXRpbmdNb2RlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzNl07XG4gICAgICB9LCByLnBsYWNlZE9yaWVudGF0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzN107XG4gICAgICB9LCByLnBsYWNlZE9yaWVudGF0aW9uLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzN10gPSB0O1xuICAgICAgfSwgci5oaWRkZW4uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDhbdGhpcy5fcG9zMSArIDM4XTtcbiAgICAgIH0sIHIuaGlkZGVuLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzOF0gPSB0O1xuICAgICAgfSwgci5jcm9zc1RpbGVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDEwXTtcbiAgICAgIH0sIHIuY3Jvc3NUaWxlSUQuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAxMF0gPSB0O1xuICAgICAgfSwgci5hc3NvY2lhdGVkSWNvbkluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAyMl07XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIGU7XG4gICAgfShraSk7XG5cbiAgICBRaS5wcm90b3R5cGUuc2l6ZSA9IDQ4O1xuXG4gICAgdmFyIHRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRaSh0aGlzLCB0KTtcbiAgICAgIH0sIGU7XG4gICAgfShOaSk7XG5cbiAgICBPbihcIlBsYWNlZFN5bWJvbEFycmF5XCIsIHRhKTtcblxuICAgIHZhciBlYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZTtcbiAgICAgIHZhciByID0ge1xuICAgICAgICBhbmNob3JYOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JZOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICByaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VkSWNvblN5bWJvbEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFBsYWNlZEljb25TeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Qm94U3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dEJveEVuZEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFRleHRCb3hTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFRleHRCb3hFbmRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgaWNvbkJveFN0YXJ0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGljb25Cb3hFbmRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxJY29uQm94U3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxJY29uQm94RW5kSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGZlYXR1cmVJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIG51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbnVtSWNvblZlcnRpY2VzOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBudW1WZXJ0aWNhbEljb25WZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzVGlsZUlEOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Qm94U2NhbGU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRPZmZzZXQwOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0T2Zmc2V0MToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGlzaW9uQ2lyY2xlRGlhbWV0ZXI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5hbmNob3JYLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAwXTtcbiAgICAgIH0sIHIuYW5jaG9yWS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMV07XG4gICAgICB9LCByLnJpZ2h0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAyXTtcbiAgICAgIH0sIHIuY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAzXTtcbiAgICAgIH0sIHIubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgNF07XG4gICAgICB9LCByLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA1XTtcbiAgICAgIH0sIHIucGxhY2VkSWNvblN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA2XTtcbiAgICAgIH0sIHIudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDddO1xuICAgICAgfSwgci5rZXkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyA4XTtcbiAgICAgIH0sIHIudGV4dEJveFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyA5XTtcbiAgICAgIH0sIHIudGV4dEJveEVuZEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTBdO1xuICAgICAgfSwgci52ZXJ0aWNhbFRleHRCb3hTdGFydEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTFdO1xuICAgICAgfSwgci52ZXJ0aWNhbFRleHRCb3hFbmRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDEyXTtcbiAgICAgIH0sIHIuaWNvbkJveFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxM107XG4gICAgICB9LCByLmljb25Cb3hFbmRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE0XTtcbiAgICAgIH0sIHIudmVydGljYWxJY29uQm94U3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE1XTtcbiAgICAgIH0sIHIudmVydGljYWxJY29uQm94RW5kSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxNl07XG4gICAgICB9LCByLmZlYXR1cmVJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE3XTtcbiAgICAgIH0sIHIubnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxOF07XG4gICAgICB9LCByLm51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE5XTtcbiAgICAgIH0sIHIubnVtSWNvblZlcnRpY2VzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMjBdO1xuICAgICAgfSwgci5udW1WZXJ0aWNhbEljb25WZXJ0aWNlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDIxXTtcbiAgICAgIH0sIHIudXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAyMl07XG4gICAgICB9LCByLmNyb3NzVGlsZUlELmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQzMlt0aGlzLl9wb3M0ICsgMTJdO1xuICAgICAgfSwgci5jcm9zc1RpbGVJRC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDEyXSA9IHQ7XG4gICAgICB9LCByLnRleHRCb3hTY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyAxM107XG4gICAgICB9LCByLnRleHRPZmZzZXQwLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmZsb2F0MzJbdGhpcy5fcG9zNCArIDE0XTtcbiAgICAgIH0sIHIudGV4dE9mZnNldDEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgMTVdO1xuICAgICAgfSwgci5jb2xsaXNpb25DaXJjbGVEaWFtZXRlci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyAxNl07XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIGU7XG4gICAgfShraSk7XG5cbiAgICBlYS5wcm90b3R5cGUuc2l6ZSA9IDY4O1xuXG4gICAgdmFyIHJhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlYSh0aGlzLCB0KTtcbiAgICAgIH0sIGU7XG4gICAgfShLaSk7XG5cbiAgICBPbihcIlN5bWJvbEluc3RhbmNlQXJyYXlcIiwgcmEpO1xuXG4gICAgdmFyIG5hID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0b2Zmc2V0WCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbMSAqIHQgKyAwXTtcbiAgICAgIH0sIGU7XG4gICAgfShHaSk7XG5cbiAgICBPbihcIkdseXBoT2Zmc2V0QXJyYXlcIiwgbmEpO1xuXG4gICAgdmFyIGlhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0eCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2WzMgKiB0ICsgMF07XG4gICAgICB9LCBlLnByb3RvdHlwZS5nZXR5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbMyAqIHQgKyAxXTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmdldHRpbGVVbml0RGlzdGFuY2VGcm9tQW5jaG9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbMyAqIHQgKyAyXTtcbiAgICAgIH0sIGU7XG4gICAgfShaaSk7XG5cbiAgICBPbihcIlN5bWJvbExpbmVWZXJ0ZXhBcnJheVwiLCBpYSk7XG5cbiAgICB2YXIgYWEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGU7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgZmVhdHVyZUluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VMYXllckluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBidWNrZXRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLmZlYXR1cmVJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDBdO1xuICAgICAgfSwgci5zb3VyY2VMYXllckluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMl07XG4gICAgICB9LCByLmJ1Y2tldEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgM107XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIGU7XG4gICAgfShraSk7XG5cbiAgICBhYS5wcm90b3R5cGUuc2l6ZSA9IDg7XG5cbiAgICB2YXIgb2EgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IGFhKHRoaXMsIHQpO1xuICAgICAgfSwgZTtcbiAgICB9KFhpKTtcblxuICAgIE9uKFwiRmVhdHVyZUluZGV4QXJyYXlcIiwgb2EpO1xuXG4gICAgdmFyIHNhID0gemkoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9XSwgNCkubWVtYmVycyxcbiAgICAgICAgdWEgPSBmdW5jdGlvbiB1YSh0KSB7XG4gICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSBbXSksIHRoaXMuc2VnbWVudHMgPSB0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsYSh0LCBlKSB7XG4gICAgICByZXR1cm4gMjU2ICogKHQgPSBwKE1hdGguZmxvb3IodCksIDAsIDI1NSkpICsgcChNYXRoLmZsb29yKGUpLCAwLCAyNTUpO1xuICAgIH1cblxuICAgIHVhLnByb3RvdHlwZS5wcmVwYXJlU2VnbWVudCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiB0ID4gdWEuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgQShcIk1heCB2ZXJ0aWNlcyBwZXIgc2VnbWVudCBpcyBcIiArIHVhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIICsgXCI6IGJ1Y2tldCByZXF1ZXN0ZWQgXCIgKyB0KSwgKCFpIHx8IGkudmVydGV4TGVuZ3RoICsgdCA+IHVhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIIHx8IGkuc29ydEtleSAhPT0gbikgJiYgKGkgPSB7XG4gICAgICAgIHZlcnRleE9mZnNldDogZS5sZW5ndGgsXG4gICAgICAgIHByaW1pdGl2ZU9mZnNldDogci5sZW5ndGgsXG4gICAgICAgIHZlcnRleExlbmd0aDogMCxcbiAgICAgICAgcHJpbWl0aXZlTGVuZ3RoOiAwXG4gICAgICB9LCB2b2lkIDAgIT09IG4gJiYgKGkuc29ydEtleSA9IG4pLCB0aGlzLnNlZ21lbnRzLnB1c2goaSkpLCBpO1xuICAgIH0sIHVhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWdtZW50cztcbiAgICB9LCB1YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gdGhpcy5zZWdtZW50czsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIHtcbiAgICAgICAgdmFyIHIgPSBlW3RdO1xuXG4gICAgICAgIGZvciAodmFyIG4gaW4gci52YW9zKSB7XG4gICAgICAgICAgci52YW9zW25dLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHVhLnNpbXBsZVNlZ21lbnQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG5ldyB1YShbe1xuICAgICAgICB2ZXJ0ZXhPZmZzZXQ6IHQsXG4gICAgICAgIHByaW1pdGl2ZU9mZnNldDogZSxcbiAgICAgICAgdmVydGV4TGVuZ3RoOiByLFxuICAgICAgICBwcmltaXRpdmVMZW5ndGg6IG4sXG4gICAgICAgIHZhb3M6IHt9LFxuICAgICAgICBzb3J0S2V5OiAwXG4gICAgICB9XSk7XG4gICAgfSwgdWEuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggPSBNYXRoLnBvdygyLCAxNikgLSAxLCBPbihcIlNlZ21lbnRWZWN0b3JcIiwgdWEpO1xuICAgIHZhciBwYSA9IHppKFt7XG4gICAgICBuYW1lOiBcImFfcGF0dGVybl9mcm9tXCIsXG4gICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgdHlwZTogXCJVaW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9wYXR0ZXJuX3RvXCIsXG4gICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgdHlwZTogXCJVaW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9waXhlbF9yYXRpb19mcm9tXCIsXG4gICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgdHlwZTogXCJVaW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9waXhlbF9yYXRpb190b1wiLFxuICAgICAgY29tcG9uZW50czogMSxcbiAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICB9XSksXG4gICAgICAgIGNhID0gZShmdW5jdGlvbiAodCkge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIsIG4sIGksIGEsIG8sIHMsIHUsIGw7XG5cbiAgICAgICAgZm9yIChuID0gdC5sZW5ndGggLSAociA9IDMgJiB0Lmxlbmd0aCksIGkgPSBlLCBvID0gMzQzMjkxODM1MywgcyA9IDQ2MTg0NTkwNywgbCA9IDA7IGwgPCBuOykge1xuICAgICAgICAgIHUgPSAyNTUgJiB0LmNoYXJDb2RlQXQobCkgfCAoMjU1ICYgdC5jaGFyQ29kZUF0KCsrbCkpIDw8IDggfCAoMjU1ICYgdC5jaGFyQ29kZUF0KCsrbCkpIDw8IDE2IHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2wpKSA8PCAyNCwgKytsLCBpID0gMjc0OTIgKyAoNjU1MzUgJiAoYSA9IDUgKiAoNjU1MzUgJiAoaSA9IChpIF49IHUgPSAoNjU1MzUgJiAodSA9ICh1ID0gKDY1NTM1ICYgdSkgKiBvICsgKCgodSA+Pj4gMTYpICogbyAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1KSA8PCAxNSB8IHUgPj4+IDE3KSkgKiBzICsgKCgodSA+Pj4gMTYpICogcyAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1KSA8PCAxMyB8IGkgPj4+IDE5KSkgKyAoKDUgKiAoaSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTUpKSArICgoNTg5NjQgKyAoYSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodSA9IDAsIHIpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB1IF49ICgyNTUgJiB0LmNoYXJDb2RlQXQobCArIDIpKSA8PCAxNjtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHUgXj0gKDI1NSAmIHQuY2hhckNvZGVBdChsICsgMSkpIDw8IDg7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpIF49IHUgPSAoNjU1MzUgJiAodSA9ICh1ID0gKDY1NTM1ICYgKHUgXj0gMjU1ICYgdC5jaGFyQ29kZUF0KGwpKSkgKiBvICsgKCgodSA+Pj4gMTYpICogbyAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1KSA8PCAxNSB8IHUgPj4+IDE3KSkgKiBzICsgKCgodSA+Pj4gMTYpICogcyAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGkgXj0gdC5sZW5ndGgsIGkgPSAyMjQ2ODIyNTA3ICogKDY1NTM1ICYgKGkgXj0gaSA+Pj4gMTYpKSArICgoMjI0NjgyMjUwNyAqIChpID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSwgaSA9IDMyNjY0ODk5MDkgKiAoNjU1MzUgJiAoaSBePSBpID4+PiAxMykpICsgKCgzMjY2NDg5OTA5ICogKGkgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1LCAoaSBePSBpID4+PiAxNikgPj4+IDA7XG4gICAgICB9O1xuICAgIH0pLFxuICAgICAgICBoYSA9IGUoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIsIG4gPSB0Lmxlbmd0aCwgaSA9IGUgXiBuLCBhID0gMDsgbiA+PSA0Oykge1xuICAgICAgICAgIHIgPSAxNTQwNDgzNDc3ICogKDY1NTM1ICYgKHIgPSAyNTUgJiB0LmNoYXJDb2RlQXQoYSkgfCAoMjU1ICYgdC5jaGFyQ29kZUF0KCsrYSkpIDw8IDggfCAoMjU1ICYgdC5jaGFyQ29kZUF0KCsrYSkpIDw8IDE2IHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2EpKSA8PCAyNCkpICsgKCgxNTQwNDgzNDc3ICogKHIgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNiksIGkgPSAxNTQwNDgzNDc3ICogKDY1NTM1ICYgaSkgKyAoKDE1NDA0ODM0NzcgKiAoaSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSBeIChyID0gMTU0MDQ4MzQ3NyAqICg2NTUzNSAmIChyIF49IHIgPj4+IDI0KSkgKyAoKDE1NDA0ODM0NzcgKiAociA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSksIG4gLT0gNCwgKythO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaSBePSAoMjU1ICYgdC5jaGFyQ29kZUF0KGEgKyAyKSkgPDwgMTY7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpIF49ICgyNTUgJiB0LmNoYXJDb2RlQXQoYSArIDEpKSA8PCA4O1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaSA9IDE1NDA0ODM0NzcgKiAoNjU1MzUgJiAoaSBePSAyNTUgJiB0LmNoYXJDb2RlQXQoYSkpKSArICgoMTU0MDQ4MzQ3NyAqIChpID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGkgPSAxNTQwNDgzNDc3ICogKDY1NTM1ICYgKGkgXj0gaSA+Pj4gMTMpKSArICgoMTU0MDQ4MzQ3NyAqIChpID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpLCAoaSBePSBpID4+PiAxNSkgPj4+IDA7XG4gICAgICB9O1xuICAgIH0pLFxuICAgICAgICBmYSA9IGNhLFxuICAgICAgICB5YSA9IGhhO1xuICAgIGZhLm11cm11cjMgPSBjYSwgZmEubXVybXVyMiA9IHlhO1xuXG4gICAgdmFyIGRhID0gZnVuY3Rpb24gZGEoKSB7XG4gICAgICB0aGlzLmlkcyA9IFtdLCB0aGlzLnBvc2l0aW9ucyA9IFtdLCB0aGlzLmluZGV4ZWQgPSAhMTtcbiAgICB9O1xuXG4gICAgZGEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmlkcy5wdXNoKHZhKHQpKSwgdGhpcy5wb3NpdGlvbnMucHVzaChlLCByLCBuKTtcbiAgICB9LCBkYS5wcm90b3R5cGUuZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSB2YSh0KSwgciA9IDAsIG4gPSB0aGlzLmlkcy5sZW5ndGggLSAxOyByIDwgbjspIHtcbiAgICAgICAgdmFyIGkgPSByICsgbiA+PiAxO1xuICAgICAgICB0aGlzLmlkc1tpXSA+PSBlID8gbiA9IGkgOiByID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGEgPSBbXTsgdGhpcy5pZHNbcl0gPT09IGU7KSB7XG4gICAgICAgIGEucHVzaCh7XG4gICAgICAgICAgaW5kZXg6IHRoaXMucG9zaXRpb25zWzMgKiByXSxcbiAgICAgICAgICBzdGFydDogdGhpcy5wb3NpdGlvbnNbMyAqIHIgKyAxXSxcbiAgICAgICAgICBlbmQ6IHRoaXMucG9zaXRpb25zWzMgKiByICsgMl1cbiAgICAgICAgfSksIHIrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgZGEuc2VyaWFsaXplID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IEZsb2F0NjRBcnJheSh0LmlkcyksXG4gICAgICAgICAgbiA9IG5ldyBVaW50MzJBcnJheSh0LnBvc2l0aW9ucyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdChlLCByLCBuLCBpKSB7XG4gICAgICAgIGZvciAoOyBuIDwgaTspIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gZVtuICsgaSA+PiAxXSwgbyA9IG4gLSAxLCBzID0gaSArIDE7Oykge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBvKys7XG4gICAgICAgICAgICB9IHdoaWxlIChlW29dIDwgYSk7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgfSB3aGlsZSAoZVtzXSA+IGEpO1xuXG4gICAgICAgICAgICBpZiAobyA+PSBzKSBicmVhaztcbiAgICAgICAgICAgIGdhKGUsIG8sIHMpLCBnYShyLCAzICogbywgMyAqIHMpLCBnYShyLCAzICogbyArIDEsIDMgKiBzICsgMSksIGdhKHIsIDMgKiBvICsgMiwgMyAqIHMgKyAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzIC0gbiA8IGkgLSBzID8gKHQoZSwgciwgbiwgcyksIG4gPSBzICsgMSkgOiAodChlLCByLCBzICsgMSwgaSksIGkgPSBzKTtcbiAgICAgICAgfVxuICAgICAgfShyLCBuLCAwLCByLmxlbmd0aCAtIDEpLCBlICYmIGUucHVzaChyLmJ1ZmZlciwgbi5idWZmZXIpLCB7XG4gICAgICAgIGlkczogcixcbiAgICAgICAgcG9zaXRpb25zOiBuXG4gICAgICB9O1xuICAgIH0sIGRhLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gbmV3IGRhKCk7XG4gICAgICByZXR1cm4gZS5pZHMgPSB0LmlkcywgZS5wb3NpdGlvbnMgPSB0LnBvc2l0aW9ucywgZS5pbmRleGVkID0gITAsIGU7XG4gICAgfTtcbiAgICB2YXIgbWEgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gICAgZnVuY3Rpb24gdmEodCkge1xuICAgICAgdmFyIGUgPSArdDtcbiAgICAgIHJldHVybiAhaXNOYU4oZSkgJiYgZSA8PSBtYSA/IGUgOiBmYShTdHJpbmcodCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdFtlXTtcbiAgICAgIHRbZV0gPSB0W3JdLCB0W3JdID0gbjtcbiAgICB9XG5cbiAgICBPbihcIkZlYXR1cmVQb3NpdGlvbk1hcFwiLCBkYSk7XG5cbiAgICB2YXIgeGEgPSBmdW5jdGlvbiB4YSh0LCBlKSB7XG4gICAgICB0aGlzLmdsID0gdC5nbCwgdGhpcy5sb2NhdGlvbiA9IGU7XG4gICAgfSxcbiAgICAgICAgYmEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCByKSwgdGhpcy5jdXJyZW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ICE9PSB0ICYmICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm0xaSh0aGlzLmxvY2F0aW9uLCB0KSk7XG4gICAgICB9LCBlO1xuICAgIH0oeGEpLFxuICAgICAgICB3YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUsIHIpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgIT09IHQgJiYgKHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybTFmKHRoaXMubG9jYXRpb24sIHQpKTtcbiAgICAgIH0sIGU7XG4gICAgfSh4YSksXG4gICAgICAgIF9hID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IFswLCAwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdFswXSA9PT0gdGhpcy5jdXJyZW50WzBdICYmIHRbMV0gPT09IHRoaXMuY3VycmVudFsxXSB8fCAodGhpcy5jdXJyZW50ID0gdCwgdGhpcy5nbC51bmlmb3JtMmYodGhpcy5sb2NhdGlvbiwgdFswXSwgdFsxXSkpO1xuICAgICAgfSwgZTtcbiAgICB9KHhhKSxcbiAgICAgICAgQWEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCByKSwgdGhpcy5jdXJyZW50ID0gWzAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0WzBdID09PSB0aGlzLmN1cnJlbnRbMF0gJiYgdFsxXSA9PT0gdGhpcy5jdXJyZW50WzFdICYmIHRbMl0gPT09IHRoaXMuY3VycmVudFsyXSB8fCAodGhpcy5jdXJyZW50ID0gdCwgdGhpcy5nbC51bmlmb3JtM2YodGhpcy5sb2NhdGlvbiwgdFswXSwgdFsxXSwgdFsyXSkpO1xuICAgICAgfSwgZTtcbiAgICB9KHhhKSxcbiAgICAgICAgU2EgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCByKSwgdGhpcy5jdXJyZW50ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0WzBdID09PSB0aGlzLmN1cnJlbnRbMF0gJiYgdFsxXSA9PT0gdGhpcy5jdXJyZW50WzFdICYmIHRbMl0gPT09IHRoaXMuY3VycmVudFsyXSAmJiB0WzNdID09PSB0aGlzLmN1cnJlbnRbM10gfHwgKHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybTRmKHRoaXMubG9jYXRpb24sIHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pKTtcbiAgICAgIH0sIGU7XG4gICAgfSh4YSksXG4gICAgICAgIGthID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IGVlLnRyYW5zcGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnIgPT09IHRoaXMuY3VycmVudC5yICYmIHQuZyA9PT0gdGhpcy5jdXJyZW50LmcgJiYgdC5iID09PSB0aGlzLmN1cnJlbnQuYiAmJiB0LmEgPT09IHRoaXMuY3VycmVudC5hIHx8ICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm00Zih0aGlzLmxvY2F0aW9uLCB0LnIsIHQuZywgdC5iLCB0LmEpKTtcbiAgICAgIH0sIGU7XG4gICAgfSh4YSksXG4gICAgICAgIElhID0gbmV3IEZsb2F0MzJBcnJheSgxNiksXG4gICAgICAgIHphID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IElhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodFsxMl0gIT09IHRoaXMuY3VycmVudFsxMl0gfHwgdFswXSAhPT0gdGhpcy5jdXJyZW50WzBdKSByZXR1cm4gdGhpcy5jdXJyZW50ID0gdCwgdm9pZCB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5sb2NhdGlvbiwgITEsIHQpO1xuXG4gICAgICAgIGZvciAodmFyIGUgPSAxOyBlIDwgMTY7IGUrKykge1xuICAgICAgICAgIGlmICh0W2VdICE9PSB0aGlzLmN1cnJlbnRbZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmxvY2F0aW9uLCAhMSwgdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfSh4YSk7XG5cbiAgICBmdW5jdGlvbiBDYSh0KSB7XG4gICAgICByZXR1cm4gW2xhKDI1NSAqIHQuciwgMjU1ICogdC5nKSwgbGEoMjU1ICogdC5iLCAyNTUgKiB0LmEpXTtcbiAgICB9XG5cbiAgICB2YXIgRWEgPSBmdW5jdGlvbiBFYSh0LCBlLCByKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdCwgdGhpcy51bmlmb3JtTmFtZXMgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gXCJ1X1wiICsgdDtcbiAgICAgIH0pLCB0aGlzLnR5cGUgPSByO1xuICAgIH07XG5cbiAgICBFYS5wcm90b3R5cGUuc2V0VW5pZm9ybSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0LnNldChyLmNvbnN0YW50T3IodGhpcy52YWx1ZSkpO1xuICAgIH0sIEVhLnByb3RvdHlwZS5nZXRCaW5kaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBcImNvbG9yXCIgPT09IHRoaXMudHlwZSA/IG5ldyBrYSh0LCBlKSA6IG5ldyB3YSh0LCBlKTtcbiAgICB9O1xuXG4gICAgdmFyIFBhID0gZnVuY3Rpb24gUGEodCwgZSkge1xuICAgICAgdGhpcy51bmlmb3JtTmFtZXMgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gXCJ1X1wiICsgdDtcbiAgICAgIH0pLCB0aGlzLnBhdHRlcm5Gcm9tID0gbnVsbCwgdGhpcy5wYXR0ZXJuVG8gPSBudWxsLCB0aGlzLnBpeGVsUmF0aW9Gcm9tID0gMSwgdGhpcy5waXhlbFJhdGlvVG8gPSAxO1xuICAgIH07XG5cbiAgICBQYS5wcm90b3R5cGUuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpb0Zyb20gPSBlLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpb1RvID0gdC5waXhlbFJhdGlvLCB0aGlzLnBhdHRlcm5Gcm9tID0gZS50bGJyLCB0aGlzLnBhdHRlcm5UbyA9IHQudGxicjtcbiAgICB9LCBQYS5wcm90b3R5cGUuc2V0VW5pZm9ybSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IFwidV9wYXR0ZXJuX3RvXCIgPT09IG4gPyB0aGlzLnBhdHRlcm5UbyA6IFwidV9wYXR0ZXJuX2Zyb21cIiA9PT0gbiA/IHRoaXMucGF0dGVybkZyb20gOiBcInVfcGl4ZWxfcmF0aW9fdG9cIiA9PT0gbiA/IHRoaXMucGl4ZWxSYXRpb1RvIDogXCJ1X3BpeGVsX3JhdGlvX2Zyb21cIiA9PT0gbiA/IHRoaXMucGl4ZWxSYXRpb0Zyb20gOiBudWxsO1xuICAgICAgaSAmJiB0LnNldChpKTtcbiAgICB9LCBQYS5wcm90b3R5cGUuZ2V0QmluZGluZyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gXCJ1X3BhdHRlcm5cIiA9PT0gci5zdWJzdHIoMCwgOSkgPyBuZXcgU2EodCwgZSkgOiBuZXcgd2EodCwgZSk7XG4gICAgfTtcblxuICAgIHZhciBNYSA9IGZ1bmN0aW9uIE1hKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHQsIHRoaXMudHlwZSA9IHIsIHRoaXMubWF4VmFsdWUgPSAwLCB0aGlzLnBhaW50VmVydGV4QXR0cmlidXRlcyA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJhX1wiICsgdCxcbiAgICAgICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgICAgICBjb21wb25lbnRzOiBcImNvbG9yXCIgPT09IHIgPyAyIDogMSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH0pLCB0aGlzLnBhaW50VmVydGV4QXJyYXkgPSBuZXcgbigpO1xuICAgIH07XG5cbiAgICBNYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5wYWludFZlcnRleEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKG5ldyB1aSgwKSwgZSwge30sIG4sIFtdLCBpKTtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5yZXNpemUodCksIHRoaXMuX3NldFBhaW50VmFsdWUoYSwgdCwgbyk7XG4gICAgfSwgTWEucHJvdG90eXBlLnVwZGF0ZVBhaW50QXJyYXkgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoe1xuICAgICAgICB6b29tOiAwXG4gICAgICB9LCByLCBuKTtcblxuICAgICAgdGhpcy5fc2V0UGFpbnRWYWx1ZSh0LCBlLCBpKTtcbiAgICB9LCBNYS5wcm90b3R5cGUuX3NldFBhaW50VmFsdWUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKFwiY29sb3JcIiA9PT0gdGhpcy50eXBlKSBmb3IgKHZhciBuID0gQ2EociksIGkgPSB0OyBpIDwgZTsgaSsrKSB7XG4gICAgICAgIHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5lbXBsYWNlKGksIG5bMF0sIG5bMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IHQ7IGEgPCBlOyBhKyspIHtcbiAgICAgICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShhLCByKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLm1heFZhbHVlLCBNYXRoLmFicyhyKSk7XG4gICAgICB9XG4gICAgfSwgTWEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy5wYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmICh0aGlzLnBhaW50VmVydGV4QnVmZmVyICYmIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIuYnVmZmVyID8gdGhpcy5wYWludFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHRoaXMucGFpbnRWZXJ0ZXhBcnJheSkgOiB0aGlzLnBhaW50VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5wYWludFZlcnRleEFycmF5LCB0aGlzLnBhaW50VmVydGV4QXR0cmlidXRlcywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpKTtcbiAgICB9LCBNYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy5wYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIHZhciBCYSA9IGZ1bmN0aW9uIEJhKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHQsIHRoaXMudW5pZm9ybU5hbWVzID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwidV9cIiArIHQgKyBcIl90XCI7XG4gICAgICB9KSwgdGhpcy50eXBlID0gciwgdGhpcy51c2VJbnRlZ2VyWm9vbSA9IG4sIHRoaXMuem9vbSA9IGksIHRoaXMubWF4VmFsdWUgPSAwLCB0aGlzLnBhaW50VmVydGV4QXR0cmlidXRlcyA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJhX1wiICsgdCxcbiAgICAgICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgICAgICBjb21wb25lbnRzOiBcImNvbG9yXCIgPT09IHIgPyA0IDogMixcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH0pLCB0aGlzLnBhaW50VmVydGV4QXJyYXkgPSBuZXcgYSgpO1xuICAgIH07XG5cbiAgICBCYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKG5ldyB1aSh0aGlzLnpvb20pLCBlLCB7fSwgbiwgW10sIGkpLFxuICAgICAgICAgIG8gPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUobmV3IHVpKHRoaXMuem9vbSArIDEpLCBlLCB7fSwgbiwgW10sIGkpLFxuICAgICAgICAgIHMgPSB0aGlzLnBhaW50VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgICAgdGhpcy5wYWludFZlcnRleEFycmF5LnJlc2l6ZSh0KSwgdGhpcy5fc2V0UGFpbnRWYWx1ZShzLCB0LCBhLCBvKTtcbiAgICB9LCBCYS5wcm90b3R5cGUudXBkYXRlUGFpbnRBcnJheSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh7XG4gICAgICAgIHpvb206IHRoaXMuem9vbVxuICAgICAgfSwgciwgbiksXG4gICAgICAgICAgYSA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh7XG4gICAgICAgIHpvb206IHRoaXMuem9vbSArIDFcbiAgICAgIH0sIHIsIG4pO1xuXG4gICAgICB0aGlzLl9zZXRQYWludFZhbHVlKHQsIGUsIGksIGEpO1xuICAgIH0sIEJhLnByb3RvdHlwZS5fc2V0UGFpbnRWYWx1ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBpZiAoXCJjb2xvclwiID09PSB0aGlzLnR5cGUpIGZvciAodmFyIGkgPSBDYShyKSwgYSA9IENhKG4pLCBvID0gdDsgbyA8IGU7IG8rKykge1xuICAgICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShvLCBpWzBdLCBpWzFdLCBhWzBdLCBhWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHMgPSB0OyBzIDwgZTsgcysrKSB7XG4gICAgICAgICAgdGhpcy5wYWludFZlcnRleEFycmF5LmVtcGxhY2Uocywgciwgbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5tYXhWYWx1ZSwgTWF0aC5hYnMociksIE1hdGguYWJzKG4pKTtcbiAgICAgIH1cbiAgICB9LCBCYS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhBcnJheSAmJiB0aGlzLnBhaW50VmVydGV4QXJyYXkuYXJyYXlCdWZmZXIgJiYgKHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy5wYWludFZlcnRleEJ1ZmZlci5idWZmZXIgPyB0aGlzLnBhaW50VmVydGV4QnVmZmVyLnVwZGF0ZURhdGEodGhpcy5wYWludFZlcnRleEFycmF5KSA6IHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLnBhaW50VmVydGV4QXJyYXksIHRoaXMucGFpbnRWZXJ0ZXhBdHRyaWJ1dGVzLCB0aGlzLmV4cHJlc3Npb24uaXNTdGF0ZURlcGVuZGVudCkpO1xuICAgIH0sIEJhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLnBhaW50VmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9LCBCYS5wcm90b3R5cGUuc2V0VW5pZm9ybSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRoaXMudXNlSW50ZWdlclpvb20gPyBNYXRoLmZsb29yKGUuem9vbSkgOiBlLnpvb20sXG4gICAgICAgICAgbiA9IHAodGhpcy5leHByZXNzaW9uLmludGVycG9sYXRpb25GYWN0b3IociwgdGhpcy56b29tLCB0aGlzLnpvb20gKyAxKSwgMCwgMSk7XG4gICAgICB0LnNldChuKTtcbiAgICB9LCBCYS5wcm90b3R5cGUuZ2V0QmluZGluZyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gbmV3IHdhKHQsIGUpO1xuICAgIH07XG5cbiAgICB2YXIgVGEgPSBmdW5jdGlvbiBUYSh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSB0LCB0aGlzLnR5cGUgPSBlLCB0aGlzLnVzZUludGVnZXJab29tID0gciwgdGhpcy56b29tID0gbiwgdGhpcy5sYXllcklkID0gYSwgdGhpcy56b29tSW5QYWludFZlcnRleEFycmF5ID0gbmV3IGkoKSwgdGhpcy56b29tT3V0UGFpbnRWZXJ0ZXhBcnJheSA9IG5ldyBpKCk7XG4gICAgfTtcblxuICAgIFRhLnByb3RvdHlwZS5wb3B1bGF0ZVBhaW50QXJyYXkgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgICAgdGhpcy56b29tSW5QYWludFZlcnRleEFycmF5LnJlc2l6ZSh0KSwgdGhpcy56b29tT3V0UGFpbnRWZXJ0ZXhBcnJheS5yZXNpemUodCksIHRoaXMuX3NldFBhaW50VmFsdWVzKG4sIHQsIGUucGF0dGVybnMgJiYgZS5wYXR0ZXJuc1t0aGlzLmxheWVySWRdLCByKTtcbiAgICB9LCBUYS5wcm90b3R5cGUudXBkYXRlUGFpbnRBcnJheSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLl9zZXRQYWludFZhbHVlcyh0LCBlLCByLnBhdHRlcm5zICYmIHIucGF0dGVybnNbdGhpcy5sYXllcklkXSwgaSk7XG4gICAgfSwgVGEucHJvdG90eXBlLl9zZXRQYWludFZhbHVlcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBpZiAobiAmJiByKSB7XG4gICAgICAgIHZhciBpID0gbltyLm1pbl0sXG4gICAgICAgICAgICBhID0gbltyLm1pZF0sXG4gICAgICAgICAgICBvID0gbltyLm1heF07XG4gICAgICAgIGlmIChpICYmIGEgJiYgbykgZm9yICh2YXIgcyA9IHQ7IHMgPCBlOyBzKyspIHtcbiAgICAgICAgICB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShzLCBhLnRsWzBdLCBhLnRsWzFdLCBhLmJyWzBdLCBhLmJyWzFdLCBpLnRsWzBdLCBpLnRsWzFdLCBpLmJyWzBdLCBpLmJyWzFdLCBhLnBpeGVsUmF0aW8sIGkucGl4ZWxSYXRpbyksIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShzLCBhLnRsWzBdLCBhLnRsWzFdLCBhLmJyWzBdLCBhLmJyWzFdLCBvLnRsWzBdLCBvLnRsWzFdLCBvLmJyWzBdLCBvLmJyWzFdLCBhLnBpeGVsUmF0aW8sIG8ucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBUYS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheSAmJiB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkuYXJyYXlCdWZmZXIgJiYgdGhpcy56b29tT3V0UGFpbnRWZXJ0ZXhBcnJheSAmJiB0aGlzLnpvb21PdXRQYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmICh0aGlzLnpvb21JblBhaW50VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy56b29tSW5QYWludFZlcnRleEFycmF5LCBwYS5tZW1iZXJzLCB0aGlzLmV4cHJlc3Npb24uaXNTdGF0ZURlcGVuZGVudCksIHRoaXMuem9vbU91dFBhaW50VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy56b29tT3V0UGFpbnRWZXJ0ZXhBcnJheSwgcGEubWVtYmVycywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpKTtcbiAgICB9LCBUYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuem9vbU91dFBhaW50VmVydGV4QnVmZmVyICYmIHRoaXMuem9vbU91dFBhaW50VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy56b29tSW5QYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLnpvb21JblBhaW50VmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgdmFyIFZhID0gZnVuY3Rpb24gVmEodCwgZSwgcikge1xuICAgICAgdGhpcy5iaW5kZXJzID0ge30sIHRoaXMuX2J1ZmZlcnMgPSBbXTtcbiAgICAgIHZhciBuID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdC5wYWludC5fdmFsdWVzKSB7XG4gICAgICAgIGlmIChyKGkpKSB7XG4gICAgICAgICAgdmFyIGEgPSB0LnBhaW50LmdldChpKTtcblxuICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgZGkgJiYgVnIoYS5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uKSkge1xuICAgICAgICAgICAgdmFyIG8gPSBEYShpLCB0LnR5cGUpLFxuICAgICAgICAgICAgICAgIHMgPSBhLnZhbHVlLFxuICAgICAgICAgICAgICAgIHUgPSBhLnByb3BlcnR5LnNwZWNpZmljYXRpb24udHlwZSxcbiAgICAgICAgICAgICAgICBsID0gYS5wcm9wZXJ0eS51c2VJbnRlZ2VyWm9vbSxcbiAgICAgICAgICAgICAgICBwID0gYS5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uW1wicHJvcGVydHktdHlwZVwiXSxcbiAgICAgICAgICAgICAgICBjID0gXCJjcm9zcy1mYWRlZFwiID09PSBwIHx8IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIiA9PT0gcDtcbiAgICAgICAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHMua2luZCkgdGhpcy5iaW5kZXJzW2ldID0gYyA/IG5ldyBQYShzLnZhbHVlLCBvKSA6IG5ldyBFYShzLnZhbHVlLCBvLCB1KSwgbi5wdXNoKFwiL3VfXCIgKyBpKTtlbHNlIGlmIChcInNvdXJjZVwiID09PSBzLmtpbmQgfHwgYykge1xuICAgICAgICAgICAgICB2YXIgaCA9IExhKGksIHUsIFwic291cmNlXCIpO1xuICAgICAgICAgICAgICB0aGlzLmJpbmRlcnNbaV0gPSBjID8gbmV3IFRhKHMsIHUsIGwsIGUsIGgsIHQuaWQpIDogbmV3IE1hKHMsIG8sIHUsIGgpLCBuLnB1c2goXCIvYV9cIiArIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSBMYShpLCB1LCBcImNvbXBvc2l0ZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5iaW5kZXJzW2ldID0gbmV3IEJhKHMsIG8sIHUsIGwsIGUsIGYpLCBuLnB1c2goXCIvel9cIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlS2V5ID0gbi5zb3J0KCkuam9pbihcIlwiKTtcbiAgICB9O1xuXG4gICAgVmEucHJvdG90eXBlLmdldE1heFZhbHVlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5iaW5kZXJzW3RdO1xuICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBNYSB8fCBlIGluc3RhbmNlb2YgQmEgPyBlLm1heFZhbHVlIDogMDtcbiAgICB9LCBWYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5cyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICBmb3IgKHZhciBhIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgbyA9IHRoaXMuYmluZGVyc1thXTtcbiAgICAgICAgKG8gaW5zdGFuY2VvZiBNYSB8fCBvIGluc3RhbmNlb2YgQmEgfHwgbyBpbnN0YW5jZW9mIFRhKSAmJiBvLnBvcHVsYXRlUGFpbnRBcnJheSh0LCBlLCByLCBuLCBpKTtcbiAgICAgIH1cbiAgICB9LCBWYS5wcm90b3R5cGUuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5iaW5kZXJzW3JdO1xuICAgICAgICBuIGluc3RhbmNlb2YgUGEgJiYgbi5zZXRDb25zdGFudFBhdHRlcm5Qb3NpdGlvbnModCwgZSk7XG4gICAgICB9XG4gICAgfSwgVmEucHJvdG90eXBlLnVwZGF0ZVBhaW50QXJyYXlzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gITE7XG5cbiAgICAgIGZvciAodmFyIG8gaW4gdCkge1xuICAgICAgICBmb3IgKHZhciBzID0gMCwgdSA9IGUuZ2V0UG9zaXRpb25zKG8pOyBzIDwgdS5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICAgIHZhciBsID0gdVtzXSxcbiAgICAgICAgICAgICAgcCA9IHIuZmVhdHVyZShsLmluZGV4KTtcblxuICAgICAgICAgIGZvciAodmFyIGMgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuYmluZGVyc1tjXTtcblxuICAgICAgICAgICAgaWYgKChoIGluc3RhbmNlb2YgTWEgfHwgaCBpbnN0YW5jZW9mIEJhIHx8IGggaW5zdGFuY2VvZiBUYSkgJiYgITAgPT09IGguZXhwcmVzc2lvbi5pc1N0YXRlRGVwZW5kZW50KSB7XG4gICAgICAgICAgICAgIHZhciBmID0gbi5wYWludC5nZXQoYyk7XG4gICAgICAgICAgICAgIGguZXhwcmVzc2lvbiA9IGYudmFsdWUsIGgudXBkYXRlUGFpbnRBcnJheShsLnN0YXJ0LCBsLmVuZCwgcCwgdFtvXSwgaSksIGEgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgVmEucHJvdG90eXBlLmRlZmluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcbiAgICAgICAgKHIgaW5zdGFuY2VvZiBFYSB8fCByIGluc3RhbmNlb2YgUGEpICYmIHQucHVzaC5hcHBseSh0LCByLnVuaWZvcm1OYW1lcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCIjZGVmaW5lIEhBU19VTklGT1JNX1wiICsgdDtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBWYS5wcm90b3R5cGUuZ2V0QmluZGVyQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5iaW5kZXJzW2VdO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIE1hIHx8IHIgaW5zdGFuY2VvZiBCYSkgZm9yICh2YXIgbiA9IDA7IG4gPCByLnBhaW50VmVydGV4QXR0cmlidXRlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgIHQucHVzaChyLnBhaW50VmVydGV4QXR0cmlidXRlc1tuXS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgVGEpIGZvciAodmFyIGkgPSAwOyBpIDwgcGEubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHQucHVzaChwYS5tZW1iZXJzW2ldLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH0sIFZhLnByb3RvdHlwZS5nZXRCaW5kZXJVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5iaW5kZXJzW2VdO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIEVhIHx8IHIgaW5zdGFuY2VvZiBQYSB8fCByIGluc3RhbmNlb2YgQmEpIGZvciAodmFyIG4gPSAwLCBpID0gci51bmlmb3JtTmFtZXM7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgdC5wdXNoKGlbbl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH0sIFZhLnByb3RvdHlwZS5nZXRQYWludFZlcnRleEJ1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVycztcbiAgICB9LCBWYS5wcm90b3R5cGUuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmJpbmRlcnMpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmJpbmRlcnNbbl07XG4gICAgICAgIGlmIChpIGluc3RhbmNlb2YgRWEgfHwgaSBpbnN0YW5jZW9mIFBhIHx8IGkgaW5zdGFuY2VvZiBCYSkgZm9yICh2YXIgYSA9IDAsIG8gPSBpLnVuaWZvcm1OYW1lczsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICB2YXIgcyA9IG9bYV07XG5cbiAgICAgICAgICBpZiAoZVtzXSkge1xuICAgICAgICAgICAgdmFyIHUgPSBpLmdldEJpbmRpbmcodCwgZVtzXSwgcyk7XG4gICAgICAgICAgICByLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBzLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogbixcbiAgICAgICAgICAgICAgYmluZGluZzogdVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIFZhLnByb3RvdHlwZS5zZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYSA9IGU7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXSxcbiAgICAgICAgICAgIHMgPSBvLm5hbWUsXG4gICAgICAgICAgICB1ID0gby5wcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5iaW5kZXJzW3VdLnNldFVuaWZvcm0oby5iaW5kaW5nLCBuLCByLmdldCh1KSwgcyk7XG4gICAgICB9XG4gICAgfSwgVmEucHJvdG90eXBlLnVwZGF0ZVBhaW50QnVmZmVycyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuX2J1ZmZlcnMgPSBbXSwgdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5iaW5kZXJzW2VdO1xuXG4gICAgICAgIGlmICh0ICYmIHIgaW5zdGFuY2VvZiBUYSkge1xuICAgICAgICAgIHZhciBuID0gMiA9PT0gdC5mcm9tU2NhbGUgPyByLnpvb21JblBhaW50VmVydGV4QnVmZmVyIDogci56b29tT3V0UGFpbnRWZXJ0ZXhCdWZmZXI7XG4gICAgICAgICAgbiAmJiB0aGlzLl9idWZmZXJzLnB1c2gobik7XG4gICAgICAgIH0gZWxzZSAociBpbnN0YW5jZW9mIE1hIHx8IHIgaW5zdGFuY2VvZiBCYSkgJiYgci5wYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLl9idWZmZXJzLnB1c2goci5wYWludFZlcnRleEJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSwgVmEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcbiAgICAgICAgKHIgaW5zdGFuY2VvZiBNYSB8fCByIGluc3RhbmNlb2YgQmEgfHwgciBpbnN0YW5jZW9mIFRhKSAmJiByLnVwbG9hZCh0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVQYWludEJ1ZmZlcnMoKTtcbiAgICB9LCBWYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5iaW5kZXJzW3RdO1xuICAgICAgICAoZSBpbnN0YW5jZW9mIE1hIHx8IGUgaW5zdGFuY2VvZiBCYSB8fCBlIGluc3RhbmNlb2YgVGEpICYmIGUuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgRmEgPSBmdW5jdGlvbiBGYSh0LCBlLCByKSB7XG4gICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSBmdW5jdGlvbiByKCkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9KSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSB0OyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG4gICAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW2EuaWRdID0gbmV3IFZhKGEsIGUsIHIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZWRzVXBsb2FkID0gITEsIHRoaXMuX2ZlYXR1cmVNYXAgPSBuZXcgZGEoKSwgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRGEodCwgZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJ0ZXh0LW9wYWNpdHlcIjogW1wib3BhY2l0eVwiXSxcbiAgICAgICAgXCJpY29uLW9wYWNpdHlcIjogW1wib3BhY2l0eVwiXSxcbiAgICAgICAgXCJ0ZXh0LWNvbG9yXCI6IFtcImZpbGxfY29sb3JcIl0sXG4gICAgICAgIFwiaWNvbi1jb2xvclwiOiBbXCJmaWxsX2NvbG9yXCJdLFxuICAgICAgICBcInRleHQtaGFsby1jb2xvclwiOiBbXCJoYWxvX2NvbG9yXCJdLFxuICAgICAgICBcImljb24taGFsby1jb2xvclwiOiBbXCJoYWxvX2NvbG9yXCJdLFxuICAgICAgICBcInRleHQtaGFsby1ibHVyXCI6IFtcImhhbG9fYmx1clwiXSxcbiAgICAgICAgXCJpY29uLWhhbG8tYmx1clwiOiBbXCJoYWxvX2JsdXJcIl0sXG4gICAgICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IFtcImhhbG9fd2lkdGhcIl0sXG4gICAgICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IFtcImhhbG9fd2lkdGhcIl0sXG4gICAgICAgIFwibGluZS1nYXAtd2lkdGhcIjogW1wiZ2Fwd2lkdGhcIl0sXG4gICAgICAgIFwibGluZS1wYXR0ZXJuXCI6IFtcInBhdHRlcm5fdG9cIiwgXCJwYXR0ZXJuX2Zyb21cIiwgXCJwaXhlbF9yYXRpb190b1wiLCBcInBpeGVsX3JhdGlvX2Zyb21cIl0sXG4gICAgICAgIFwiZmlsbC1wYXR0ZXJuXCI6IFtcInBhdHRlcm5fdG9cIiwgXCJwYXR0ZXJuX2Zyb21cIiwgXCJwaXhlbF9yYXRpb190b1wiLCBcInBpeGVsX3JhdGlvX2Zyb21cIl0sXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiOiBbXCJwYXR0ZXJuX3RvXCIsIFwicGF0dGVybl9mcm9tXCIsIFwicGl4ZWxfcmF0aW9fdG9cIiwgXCJwaXhlbF9yYXRpb19mcm9tXCJdXG4gICAgICB9W3RdIHx8IFt0LnJlcGxhY2UoZSArIFwiLVwiLCBcIlwiKS5yZXBsYWNlKC8tL2csIFwiX1wiKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTGEodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc291cmNlOiBUaSxcbiAgICAgICAgICBjb21wb3NpdGU6IFlpXG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgIHNvdXJjZTogR2ksXG4gICAgICAgICAgY29tcG9zaXRlOiBUaVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgICAgIGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwibGluZS1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgIHNvdXJjZTogVmksXG4gICAgICAgICAgICBjb21wb3NpdGU6IFZpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZpbGwtcGF0dGVyblwiOiB7XG4gICAgICAgICAgICBzb3VyY2U6IFZpLFxuICAgICAgICAgICAgY29tcG9zaXRlOiBWaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgIHNvdXJjZTogVmksXG4gICAgICAgICAgICBjb21wb3NpdGU6IFZpXG4gICAgICAgICAgfVxuICAgICAgICB9W3RdO1xuICAgICAgfSh0KTtcblxuICAgICAgcmV0dXJuIGkgJiYgaVtyXSB8fCBuW2VdW3JdO1xuICAgIH1cblxuICAgIEZhLnByb3RvdHlwZS5wb3B1bGF0ZVBhaW50QXJyYXlzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnNbb10ucG9wdWxhdGVQYWludEFycmF5cyh0LCBlLCBuLCBpLCBhKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCAwICE9PSBlLmlkICYmIHRoaXMuX2ZlYXR1cmVNYXAuYWRkKGUuaWQsIHIsIHRoaXMuX2J1ZmZlck9mZnNldCwgdCksIHRoaXMuX2J1ZmZlck9mZnNldCA9IHQsIHRoaXMubmVlZHNVcGxvYWQgPSAhMDtcbiAgICB9LCBGYS5wcm90b3R5cGUudXBkYXRlUGFpbnRBcnJheXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGEgPSByOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IGFbaV07XG4gICAgICAgIHRoaXMubmVlZHNVcGxvYWQgPSB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9uc1tvLmlkXS51cGRhdGVQYWludEFycmF5cyh0LCB0aGlzLl9mZWF0dXJlTWFwLCBlLCBvLCBuKSB8fCB0aGlzLm5lZWRzVXBsb2FkO1xuICAgICAgfVxuICAgIH0sIEZhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW3RdO1xuICAgIH0sIEZhLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMubmVlZHNVcGxvYWQpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucykge1xuICAgICAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW2VdLnVwbG9hZCh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmVlZHNVcGxvYWQgPSAhMTtcbiAgICAgIH1cbiAgICB9LCBGYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnNbdF0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0sIE9uKFwiQ29uc3RhbnRCaW5kZXJcIiwgRWEpLCBPbihcIkNyb3NzRmFkZWRDb25zdGFudEJpbmRlclwiLCBQYSksIE9uKFwiU291cmNlRXhwcmVzc2lvbkJpbmRlclwiLCBNYSksIE9uKFwiQ3Jvc3NGYWRlZENvbXBvc2l0ZUJpbmRlclwiLCBUYSksIE9uKFwiQ29tcG9zaXRlRXhwcmVzc2lvbkJpbmRlclwiLCBCYSksIE9uKFwiUHJvZ3JhbUNvbmZpZ3VyYXRpb25cIiwgVmEsIHtcbiAgICAgIG9taXQ6IFtcIl9idWZmZXJzXCJdXG4gICAgfSksIE9uKFwiUHJvZ3JhbUNvbmZpZ3VyYXRpb25TZXRcIiwgRmEpO1xuICAgIHZhciBSYSA9IE1hdGgucG93KDIsIDE0KSAtIDEsXG4gICAgICAgIE9hID0gLVJhIC0gMTtcblxuICAgIGZ1bmN0aW9uIFVhKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSA4MTkyIC8gdC5leHRlbnQsIHIgPSB0LmxvYWRHZW9tZXRyeSgpLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJbbl0sIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykge1xuICAgICAgICAgIHZhciBvID0gaVthXSxcbiAgICAgICAgICAgICAgcyA9IE1hdGgucm91bmQoby54ICogZSksXG4gICAgICAgICAgICAgIHUgPSBNYXRoLnJvdW5kKG8ueSAqIGUpO1xuICAgICAgICAgIG8ueCA9IHAocywgT2EsIFJhKSwgby55ID0gcCh1LCBPYSwgUmEpLCAocyA8IG8ueCB8fCBzID4gby54ICsgMSB8fCB1IDwgby55IHx8IHUgPiBvLnkgKyAxKSAmJiBBKFwiR2VvbWV0cnkgZXhjZWVkcyBhbGxvd2VkIGV4dGVudCwgcmVkdWNlIHlvdXIgdmVjdG9yIHRpbGUgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gamEodCwgZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdC50eXBlLFxuICAgICAgICBpZDogdC5pZCxcbiAgICAgICAgcHJvcGVydGllczogdC5wcm9wZXJ0aWVzLFxuICAgICAgICBnZW9tZXRyeTogZSA/IFVhKHQpIDogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcWEodCwgZSwgciwgbiwgaSkge1xuICAgICAgdC5lbXBsYWNlQmFjaygyICogZSArIChuICsgMSkgLyAyLCAyICogciArIChpICsgMSkgLyAyKTtcbiAgICB9XG5cbiAgICB2YXIgTmEgPSBmdW5jdGlvbiBOYSh0KSB7XG4gICAgICB0aGlzLnpvb20gPSB0Lnpvb20sIHRoaXMub3ZlcnNjYWxpbmcgPSB0Lm92ZXJzY2FsaW5nLCB0aGlzLmxheWVycyA9IHQubGF5ZXJzLCB0aGlzLmxheWVySWRzID0gdGhpcy5sYXllcnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSksIHRoaXMuaW5kZXggPSB0LmluZGV4LCB0aGlzLmhhc1BhdHRlcm4gPSAhMSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSA9IG5ldyBFaSgpLCB0aGlzLmluZGV4QXJyYXkgPSBuZXcgcWkoKSwgdGhpcy5zZWdtZW50cyA9IG5ldyB1YSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IG5ldyBGYSh0LmxheWVycywgdC56b29tKSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzU3RhdGVEZXBlbmRlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBLYSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgaWYgKFFhKGUsIHRbcl0pKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICBpZiAoUWEodCwgZVtuXSkpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEhSmEodCwgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR2EodCwgZSwgcikge1xuICAgICAgcmV0dXJuICEhUWEodCwgZSkgfHwgISFZYShlLCB0LCByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBaYSh0LCBlKSB7XG4gICAgICBpZiAoMSA9PT0gdC5sZW5ndGgpIHJldHVybiBXYShlLCB0WzBdKTtcblxuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSBlW3JdLCBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoUWEodCwgbltpXSkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgaWYgKFdhKGUsIHRbYV0pKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgICAgICBpZiAoSmEodCwgZVtvXSkpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFhhKHQsIGUsIHIpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKEphKHQsIGUpKSByZXR1cm4gITA7XG5cbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgaWYgKFlhKGVbbl0sIHQsIHIpKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChZYSh0W2ldLCBlLCByKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSmEodCwgZSkge1xuICAgICAgaWYgKDAgPT09IHQubGVuZ3RoIHx8IDAgPT09IGUubGVuZ3RoKSByZXR1cm4gITE7XG5cbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGggLSAxOyByKyspIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IHRbcl0sIGkgPSB0W3IgKyAxXSwgYSA9IDA7IGEgPCBlLmxlbmd0aCAtIDE7IGErKykge1xuICAgICAgICAgIGlmIChIYShuLCBpLCBlW2FdLCBlW2EgKyAxXSkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSGEodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIFModCwgciwgbikgIT09IFMoZSwgciwgbikgJiYgUyh0LCBlLCByKSAhPT0gUyh0LCBlLCBuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBZYSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHIgKiByO1xuICAgICAgaWYgKDEgPT09IGUubGVuZ3RoKSByZXR1cm4gdC5kaXN0U3FyKGVbMF0pIDwgbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgkYSh0LCBlW2kgLSAxXSwgZVtpXSkgPCBuKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUuZGlzdFNxcihyKTtcbiAgICAgIGlmICgwID09PSBuKSByZXR1cm4gdC5kaXN0U3FyKGUpO1xuICAgICAgdmFyIGkgPSAoKHQueCAtIGUueCkgKiAoci54IC0gZS54KSArICh0LnkgLSBlLnkpICogKHIueSAtIGUueSkpIC8gbjtcbiAgICAgIHJldHVybiB0LmRpc3RTcXIoaSA8IDAgPyBlIDogaSA+IDEgPyByIDogci5zdWIoZSkuX211bHQoaSkuX2FkZChlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2EodCwgZSkge1xuICAgICAgZm9yICh2YXIgciwgbiwgaSwgYSA9ICExLCBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIHUgPSAociA9IHRbb10pLmxlbmd0aCAtIDE7IHMgPCByLmxlbmd0aDsgdSA9IHMrKykge1xuICAgICAgICAgIChuID0gcltzXSkueSA+IGUueSAhPSAoaSA9IHJbdV0pLnkgPiBlLnkgJiYgZS54IDwgKGkueCAtIG4ueCkgKiAoZS55IC0gbi55KSAvIChpLnkgLSBuLnkpICsgbi54ICYmIChhID0gIWEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFFhKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAhMSwgbiA9IDAsIGkgPSB0Lmxlbmd0aCAtIDE7IG4gPCB0Lmxlbmd0aDsgaSA9IG4rKykge1xuICAgICAgICB2YXIgYSA9IHRbbl0sXG4gICAgICAgICAgICBvID0gdFtpXTtcbiAgICAgICAgYS55ID4gZS55ICE9IG8ueSA+IGUueSAmJiBlLnggPCAoby54IC0gYS54KSAqIChlLnkgLSBhLnkpIC8gKG8ueSAtIGEueSkgKyBhLnggJiYgKHIgPSAhcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gclswXSxcbiAgICAgICAgICBpID0gclsyXTtcbiAgICAgIGlmICh0LnggPCBuLnggJiYgZS54IDwgbi54IHx8IHQueCA+IGkueCAmJiBlLnggPiBpLnggfHwgdC55IDwgbi55ICYmIGUueSA8IG4ueSB8fCB0LnkgPiBpLnkgJiYgZS55ID4gaS55KSByZXR1cm4gITE7XG4gICAgICB2YXIgYSA9IFModCwgZSwgclswXSk7XG4gICAgICByZXR1cm4gYSAhPT0gUyh0LCBlLCByWzFdKSB8fCBhICE9PSBTKHQsIGUsIHJbMl0pIHx8IGEgIT09IFModCwgZSwgclszXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW8odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlLnBhaW50LmdldCh0KS52YWx1ZTtcbiAgICAgIHJldHVybiBcImNvbnN0YW50XCIgPT09IG4ua2luZCA/IG4udmFsdWUgOiByLnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoZS5pZCkuZ2V0TWF4VmFsdWUodCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm8odCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0WzBdICogdFswXSArIHRbMV0gKiB0WzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBubyh0LCBlLCByLCBuLCBhKSB7XG4gICAgICBpZiAoIWVbMF0gJiYgIWVbMV0pIHJldHVybiB0O1xuXG4gICAgICB2YXIgbyA9IGkuY29udmVydChlKS5fbXVsdChhKTtcblxuICAgICAgXCJ2aWV3cG9ydFwiID09PSByICYmIG8uX3JvdGF0ZSgtbik7XG5cbiAgICAgIGZvciAodmFyIHMgPSBbXSwgdSA9IDA7IHUgPCB0Lmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIHMucHVzaCh0W3VdLnN1YihvKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIE5hLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRoaXMubGF5ZXJzWzBdLFxuICAgICAgICAgIGkgPSBbXSxcbiAgICAgICAgICBhID0gbnVsbCxcbiAgICAgICAgICBvID0gITE7XG4gICAgICBcImNpcmNsZVwiID09PSBuLnR5cGUgJiYgKG8gPSAhKGEgPSBuLmxheW91dC5nZXQoXCJjaXJjbGUtc29ydC1rZXlcIikpLmlzQ29uc3RhbnQoKSk7XG5cbiAgICAgIGZvciAodmFyIHMgPSAwLCB1ID0gdDsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgdmFyIGwgPSB1W3NdLFxuICAgICAgICAgICAgcCA9IGwuZmVhdHVyZSxcbiAgICAgICAgICAgIGMgPSBsLmlkLFxuICAgICAgICAgICAgaCA9IGwuaW5kZXgsXG4gICAgICAgICAgICBmID0gbC5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgICAgeSA9IHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLm5lZWRHZW9tZXRyeSxcbiAgICAgICAgICAgIGQgPSBqYShwLCB5KTtcblxuICAgICAgICBpZiAodGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIuZmlsdGVyKG5ldyB1aSh0aGlzLnpvb20pLCBkLCByKSkge1xuICAgICAgICAgIHZhciBtID0gbyA/IGEuZXZhbHVhdGUoZCwge30sIHIpIDogdm9pZCAwLFxuICAgICAgICAgICAgICB2ID0ge1xuICAgICAgICAgICAgaWQ6IGMsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwLnByb3BlcnRpZXMsXG4gICAgICAgICAgICB0eXBlOiBwLnR5cGUsXG4gICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiBmLFxuICAgICAgICAgICAgaW5kZXg6IGgsXG4gICAgICAgICAgICBnZW9tZXRyeTogeSA/IGQuZ2VvbWV0cnkgOiBVYShwKSxcbiAgICAgICAgICAgIHBhdHRlcm5zOiB7fSxcbiAgICAgICAgICAgIHNvcnRLZXk6IG1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGkucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvICYmIGkuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5zb3J0S2V5IC0gZS5zb3J0S2V5O1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGcgPSAwLCB4ID0gaTsgZyA8IHgubGVuZ3RoOyBnICs9IDEpIHtcbiAgICAgICAgdmFyIGIgPSB4W2ddLFxuICAgICAgICAgICAgdyA9IGIuZ2VvbWV0cnksXG4gICAgICAgICAgICBfID0gYi5pbmRleCxcbiAgICAgICAgICAgIEEgPSBiLnNvdXJjZUxheWVySW5kZXgsXG4gICAgICAgICAgICBTID0gdFtfXS5mZWF0dXJlO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoYiwgdywgXywgciksIGUuZmVhdHVyZUluZGV4Lmluc2VydChTLCB3LCBfLCBBLCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9LCBOYS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMubGVuZ3RoICYmIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwZGF0ZVBhaW50QXJyYXlzKHQsIGUsIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMsIHIpO1xuICAgIH0sIE5hLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgIH0sIE5hLnByb3RvdHlwZS51cGxvYWRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnVwbG9hZGVkIHx8IHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkO1xuICAgIH0sIE5hLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy51cGxvYWRlZCB8fCAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmxheW91dFZlcnRleEFycmF5LCBzYSksIHRoaXMuaW5kZXhCdWZmZXIgPSB0LmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhBcnJheSkpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGxvYWQodCksIHRoaXMudXBsb2FkZWQgPSAhMDtcbiAgICB9LCBOYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5kZXN0cm95KCksIHRoaXMuc2VnbWVudHMuZGVzdHJveSgpKTtcbiAgICB9LCBOYS5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYSA9IGU7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSAwLCBzID0gYVtpXTsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgdSA9IHNbb10sXG4gICAgICAgICAgICAgIGwgPSB1LngsXG4gICAgICAgICAgICAgIHAgPSB1Lnk7XG5cbiAgICAgICAgICBpZiAoIShsIDwgMCB8fCBsID49IDgxOTIgfHwgcCA8IDAgfHwgcCA+PSA4MTkyKSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSwgdC5zb3J0S2V5KSxcbiAgICAgICAgICAgICAgICBoID0gYy52ZXJ0ZXhMZW5ndGg7XG4gICAgICAgICAgICBxYSh0aGlzLmxheW91dFZlcnRleEFycmF5LCBsLCBwLCAtMSwgLTEpLCBxYSh0aGlzLmxheW91dFZlcnRleEFycmF5LCBsLCBwLCAxLCAtMSksIHFhKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGwsIHAsIDEsIDEpLCBxYSh0aGlzLmxheW91dFZlcnRleEFycmF5LCBsLCBwLCAtMSwgMSksIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhoLCBoICsgMSwgaCArIDIpLCB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaCwgaCArIDMsIGggKyAyKSwgYy52ZXJ0ZXhMZW5ndGggKz0gNCwgYy5wcmltaXRpdmVMZW5ndGggKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMucG9wdWxhdGVQYWludEFycmF5cyh0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCwgdCwgciwge30sIG4pO1xuICAgIH0sIE9uKFwiQ2lyY2xlQnVja2V0XCIsIE5hLCB7XG4gICAgICBvbWl0OiBbXCJsYXllcnNcIl1cbiAgICB9KTtcbiAgICB2YXIgaW8gPSBuZXcgX2koe1xuICAgICAgXCJjaXJjbGUtc29ydC1rZXlcIjogbmV3IGdpKFB0LmxheW91dF9jaXJjbGVbXCJjaXJjbGUtc29ydC1rZXlcIl0pXG4gICAgfSksXG4gICAgICAgIGFvID0ge1xuICAgICAgcGFpbnQ6IG5ldyBfaSh7XG4gICAgICAgIFwiY2lyY2xlLXJhZGl1c1wiOiBuZXcgZ2koUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXJhZGl1c1wiXSksXG4gICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtY29sb3JcIl0pLFxuICAgICAgICBcImNpcmNsZS1ibHVyXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtYmx1clwiXSksXG4gICAgICAgIFwiY2lyY2xlLW9wYWNpdHlcIjogbmV3IGdpKFB0LnBhaW50X2NpcmNsZVtcImNpcmNsZS1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IG5ldyB2aShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtdHJhbnNsYXRlXCJdKSxcbiAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIl0pLFxuICAgICAgICBcImNpcmNsZS1waXRjaC1zY2FsZVwiOiBuZXcgdmkoUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXBpdGNoLXNjYWxlXCJdKSxcbiAgICAgICAgXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IG5ldyB2aShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCJdKSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCJdKSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCJdKSxcbiAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjogbmV3IGdpKFB0LnBhaW50X2NpcmNsZVtcImNpcmNsZS1zdHJva2Utb3BhY2l0eVwiXSlcbiAgICAgIH0pLFxuICAgICAgbGF5b3V0OiBpb1xuICAgIH0sXG4gICAgICAgIG9vID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgRmxvYXQzMkFycmF5ID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5cbiAgICBmdW5jdGlvbiBzbyh0KSB7XG4gICAgICByZXR1cm4gdFswXSA9IDEsIHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDAsIHRbNF0gPSAwLCB0WzVdID0gMSwgdFs2XSA9IDAsIHRbN10gPSAwLCB0WzhdID0gMCwgdFs5XSA9IDAsIHRbMTBdID0gMSwgdFsxMV0gPSAwLCB0WzEyXSA9IDAsIHRbMTNdID0gMCwgdFsxNF0gPSAwLCB0WzE1XSA9IDEsIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW8odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICAgIGkgPSBlWzFdLFxuICAgICAgICAgIGEgPSBlWzJdLFxuICAgICAgICAgIG8gPSBlWzNdLFxuICAgICAgICAgIHMgPSBlWzRdLFxuICAgICAgICAgIHUgPSBlWzVdLFxuICAgICAgICAgIGwgPSBlWzZdLFxuICAgICAgICAgIHAgPSBlWzddLFxuICAgICAgICAgIGMgPSBlWzhdLFxuICAgICAgICAgIGggPSBlWzldLFxuICAgICAgICAgIGYgPSBlWzEwXSxcbiAgICAgICAgICB5ID0gZVsxMV0sXG4gICAgICAgICAgZCA9IGVbMTJdLFxuICAgICAgICAgIG0gPSBlWzEzXSxcbiAgICAgICAgICB2ID0gZVsxNF0sXG4gICAgICAgICAgZyA9IGVbMTVdLFxuICAgICAgICAgIHggPSByWzBdLFxuICAgICAgICAgIGIgPSByWzFdLFxuICAgICAgICAgIHcgPSByWzJdLFxuICAgICAgICAgIF8gPSByWzNdO1xuICAgICAgcmV0dXJuIHRbMF0gPSB4ICogbiArIGIgKiBzICsgdyAqIGMgKyBfICogZCwgdFsxXSA9IHggKiBpICsgYiAqIHUgKyB3ICogaCArIF8gKiBtLCB0WzJdID0geCAqIGEgKyBiICogbCArIHcgKiBmICsgXyAqIHYsIHRbM10gPSB4ICogbyArIGIgKiBwICsgdyAqIHkgKyBfICogZywgdFs0XSA9ICh4ID0gcls0XSkgKiBuICsgKGIgPSByWzVdKSAqIHMgKyAodyA9IHJbNl0pICogYyArIChfID0gcls3XSkgKiBkLCB0WzVdID0geCAqIGkgKyBiICogdSArIHcgKiBoICsgXyAqIG0sIHRbNl0gPSB4ICogYSArIGIgKiBsICsgdyAqIGYgKyBfICogdiwgdFs3XSA9IHggKiBvICsgYiAqIHAgKyB3ICogeSArIF8gKiBnLCB0WzhdID0gKHggPSByWzhdKSAqIG4gKyAoYiA9IHJbOV0pICogcyArICh3ID0gclsxMF0pICogYyArIChfID0gclsxMV0pICogZCwgdFs5XSA9IHggKiBpICsgYiAqIHUgKyB3ICogaCArIF8gKiBtLCB0WzEwXSA9IHggKiBhICsgYiAqIGwgKyB3ICogZiArIF8gKiB2LCB0WzExXSA9IHggKiBvICsgYiAqIHAgKyB3ICogeSArIF8gKiBnLCB0WzEyXSA9ICh4ID0gclsxMl0pICogbiArIChiID0gclsxM10pICogcyArICh3ID0gclsxNF0pICogYyArIChfID0gclsxNV0pICogZCwgdFsxM10gPSB4ICogaSArIGIgKiB1ICsgdyAqIGggKyBfICogbSwgdFsxNF0gPSB4ICogYSArIGIgKiBsICsgdyAqIGYgKyBfICogdiwgdFsxNV0gPSB4ICogbyArIGIgKiBwICsgdyAqIHkgKyBfICogZywgdDtcbiAgICB9XG5cbiAgICBNYXRoLmh5cG90IHx8IChNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cywgZSA9IDAsIHIgPSBhcmd1bWVudHMubGVuZ3RoOyByLS07KSB7XG4gICAgICAgIGUgKz0gdFtyXSAqIHRbcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZSk7XG4gICAgfSk7XG4gICAgdmFyIGxvLFxuICAgICAgICBwbyA9IHVvO1xuXG4gICAgZnVuY3Rpb24gY28odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICAgIGkgPSBlWzFdLFxuICAgICAgICAgIGEgPSBlWzJdLFxuICAgICAgICAgIG8gPSBlWzNdO1xuICAgICAgcmV0dXJuIHRbMF0gPSByWzBdICogbiArIHJbNF0gKiBpICsgcls4XSAqIGEgKyByWzEyXSAqIG8sIHRbMV0gPSByWzFdICogbiArIHJbNV0gKiBpICsgcls5XSAqIGEgKyByWzEzXSAqIG8sIHRbMl0gPSByWzJdICogbiArIHJbNl0gKiBpICsgclsxMF0gKiBhICsgclsxNF0gKiBvLCB0WzNdID0gclszXSAqIG4gKyByWzddICogaSArIHJbMTFdICogYSArIHJbMTVdICogbywgdDtcbiAgICB9XG5cbiAgICBsbyA9IG5ldyBvbygzKSwgb28gIT0gRmxvYXQzMkFycmF5ICYmIChsb1swXSA9IDAsIGxvWzFdID0gMCwgbG9bMl0gPSAwKSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgb28oNCk7XG4gICAgICBvbyAhPSBGbG9hdDMyQXJyYXkgJiYgKHRbMF0gPSAwLCB0WzFdID0gMCwgdFsyXSA9IDAsIHRbM10gPSAwKTtcbiAgICB9KCk7XG4gICAgdmFyIGhvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gbmV3IG9vKDIpO1xuICAgICAgb28gIT0gRmxvYXQzMkFycmF5ICYmICh0WzBdID0gMCwgdFsxXSA9IDApO1xuICAgIH0oKSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgYW8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQ7XG4gICAgICAgIHJldHVybiBlbyhcImNpcmNsZS1yYWRpdXNcIiwgdGhpcywgZSkgKyBlbyhcImNpcmNsZS1zdHJva2Utd2lkdGhcIiwgdGhpcywgZSkgKyBybyh0aGlzLnBhaW50LmdldChcImNpcmNsZS10cmFuc2xhdGVcIikpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSBubyh0LCB0aGlzLnBhaW50LmdldChcImNpcmNsZS10cmFuc2xhdGVcIiksIHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIiksIGEuYW5nbGUsIG8pLCBsID0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcmFkaXVzXCIpLmV2YWx1YXRlKGUsIHIpICsgdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCIpLmV2YWx1YXRlKGUsIHIpLCBwID0gXCJtYXBcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCIpLCBjID0gcCA/IHUgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvKHQsIGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KHUsIHMpLCBoID0gcCA/IGwgKiBvIDogbCwgZiA9IDAsIHkgPSBuOyBmIDwgeS5sZW5ndGg7IGYgKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIGQgPSAwLCBtID0geVtmXTsgZCA8IG0ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB2ID0gbVtkXSxcbiAgICAgICAgICAgICAgICBnID0gcCA/IHYgOiBmbyh2LCBzKSxcbiAgICAgICAgICAgICAgICB4ID0gaCxcbiAgICAgICAgICAgICAgICBiID0gY28oW10sIFt2LngsIHYueSwgMCwgMV0sIHMpO1xuICAgICAgICAgICAgaWYgKFwidmlld3BvcnRcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikgJiYgXCJtYXBcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCIpID8geCAqPSBiWzNdIC8gYS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIDogXCJtYXBcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikgJiYgXCJ2aWV3cG9ydFwiID09PSB0aGlzLnBhaW50LmdldChcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIikgJiYgKHggKj0gYS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIC8gYlszXSksIEdhKGMsIGcsIHgpKSByZXR1cm4gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZTtcbiAgICB9KEFpKSk7XG5cbiAgICBmdW5jdGlvbiBmbyh0LCBlKSB7XG4gICAgICB2YXIgciA9IGNvKFtdLCBbdC54LCB0LnksIDAsIDFdLCBlKTtcbiAgICAgIHJldHVybiBuZXcgaShyWzBdIC8gclszXSwgclsxXSAvIHJbM10pO1xuICAgIH1cblxuICAgIHZhciB5byA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgfShOYSk7XG5cbiAgICBmdW5jdGlvbiBtbyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IGUud2lkdGgsXG4gICAgICAgICAgYSA9IGUuaGVpZ2h0O1xuXG4gICAgICBpZiAobikge1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSBuID0gbmV3IFVpbnQ4QXJyYXkobi5idWZmZXIpO2Vsc2UgaWYgKG4ubGVuZ3RoICE9PSBpICogYSAqIHIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWlzbWF0Y2hlZCBpbWFnZSBzaXplXCIpO1xuICAgICAgfSBlbHNlIG4gPSBuZXcgVWludDhBcnJheShpICogYSAqIHIpO1xuXG4gICAgICByZXR1cm4gdC53aWR0aCA9IGksIHQuaGVpZ2h0ID0gYSwgdC5kYXRhID0gbiwgdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2byh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUud2lkdGgsXG4gICAgICAgICAgaSA9IGUuaGVpZ2h0O1xuXG4gICAgICBpZiAobiAhPT0gdC53aWR0aCB8fCBpICE9PSB0LmhlaWdodCkge1xuICAgICAgICB2YXIgYSA9IG1vKHt9LCB7XG4gICAgICAgICAgd2lkdGg6IG4sXG4gICAgICAgICAgaGVpZ2h0OiBpXG4gICAgICAgIH0sIHIpO1xuICAgICAgICBnbyh0LCBhLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbih0LndpZHRoLCBuKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKHQuaGVpZ2h0LCBpKVxuICAgICAgICB9LCByKSwgdC53aWR0aCA9IG4sIHQuaGVpZ2h0ID0gaSwgdC5kYXRhID0gYS5kYXRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIGlmICgwID09PSBpLndpZHRoIHx8IDAgPT09IGkuaGVpZ2h0KSByZXR1cm4gZTtcbiAgICAgIGlmIChpLndpZHRoID4gdC53aWR0aCB8fCBpLmhlaWdodCA+IHQuaGVpZ2h0IHx8IHIueCA+IHQud2lkdGggLSBpLndpZHRoIHx8IHIueSA+IHQuaGVpZ2h0IC0gaS5oZWlnaHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIHNvdXJjZSBjb29yZGluYXRlcyBmb3IgaW1hZ2UgY29weVwiKTtcbiAgICAgIGlmIChpLndpZHRoID4gZS53aWR0aCB8fCBpLmhlaWdodCA+IGUuaGVpZ2h0IHx8IG4ueCA+IGUud2lkdGggLSBpLndpZHRoIHx8IG4ueSA+IGUuaGVpZ2h0IC0gaS5oZWlnaHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGRlc3RpbmF0aW9uIGNvb3JkaW5hdGVzIGZvciBpbWFnZSBjb3B5XCIpO1xuXG4gICAgICBmb3IgKHZhciBvID0gdC5kYXRhLCBzID0gZS5kYXRhLCB1ID0gMDsgdSA8IGkuaGVpZ2h0OyB1KyspIHtcbiAgICAgICAgZm9yICh2YXIgbCA9ICgoci55ICsgdSkgKiB0LndpZHRoICsgci54KSAqIGEsIHAgPSAoKG4ueSArIHUpICogZS53aWR0aCArIG4ueCkgKiBhLCBjID0gMDsgYyA8IGkud2lkdGggKiBhOyBjKyspIHtcbiAgICAgICAgICBzW3AgKyBjXSA9IG9bbCArIGNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIE9uKFwiSGVhdG1hcEJ1Y2tldFwiLCB5bywge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCJdXG4gICAgfSk7XG5cbiAgICB2YXIgeG8gPSBmdW5jdGlvbiB4byh0LCBlKSB7XG4gICAgICBtbyh0aGlzLCB0LCAxLCBlKTtcbiAgICB9O1xuXG4gICAgeG8ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2byh0aGlzLCB0LCAxKTtcbiAgICB9LCB4by5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IHhvKHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH0sIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSkpO1xuICAgIH0sIHhvLmNvcHkgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZ28odCwgZSwgciwgbiwgaSwgMSk7XG4gICAgfTtcblxuICAgIHZhciBibyA9IGZ1bmN0aW9uIGJvKHQsIGUpIHtcbiAgICAgIG1vKHRoaXMsIHQsIDQsIGUpO1xuICAgIH07XG5cbiAgICBiby5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvKHRoaXMsIHQsIDQpO1xuICAgIH0sIGJvLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGUgPyB0aGlzLmRhdGEuc2V0KHQpIDogdGhpcy5kYXRhID0gdCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID8gbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpIDogdDtcbiAgICB9LCBiby5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGJvKHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH0sIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSkpO1xuICAgIH0sIGJvLmNvcHkgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZ28odCwgZSwgciwgbiwgaSwgNCk7XG4gICAgfSwgT24oXCJBbHBoYUltYWdlXCIsIHhvKSwgT24oXCJSR0JBSW1hZ2VcIiwgYm8pO1xuICAgIHZhciB3byA9IHtcbiAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICBcImhlYXRtYXAtcmFkaXVzXCI6IG5ldyBnaShQdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC1yYWRpdXNcIl0pLFxuICAgICAgICBcImhlYXRtYXAtd2VpZ2h0XCI6IG5ldyBnaShQdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC13ZWlnaHRcIl0pLFxuICAgICAgICBcImhlYXRtYXAtaW50ZW5zaXR5XCI6IG5ldyB2aShQdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC1pbnRlbnNpdHlcIl0pLFxuICAgICAgICBcImhlYXRtYXAtY29sb3JcIjogbmV3IHdpKFB0LnBhaW50X2hlYXRtYXBbXCJoZWF0bWFwLWNvbG9yXCJdKSxcbiAgICAgICAgXCJoZWF0bWFwLW9wYWNpdHlcIjogbmV3IHZpKFB0LnBhaW50X2hlYXRtYXBbXCJoZWF0bWFwLW9wYWNpdHlcIl0pXG4gICAgICB9KVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfbyh0KSB7XG4gICAgICB2YXIgZSA9IHt9LFxuICAgICAgICAgIHIgPSB0LnJlc29sdXRpb24gfHwgMjU2LFxuICAgICAgICAgIG4gPSB0LmNsaXBzID8gdC5jbGlwcy5sZW5ndGggOiAxLFxuICAgICAgICAgIGkgPSB0LmltYWdlIHx8IG5ldyBibyh7XG4gICAgICAgIHdpZHRoOiByLFxuICAgICAgICBoZWlnaHQ6IG5cbiAgICAgIH0pLFxuICAgICAgICAgIGEgPSBmdW5jdGlvbiBhKHIsIG4sIF9hMikge1xuICAgICAgICBlW3QuZXZhbHVhdGlvbktleV0gPSBfYTI7XG4gICAgICAgIHZhciBvID0gdC5leHByZXNzaW9uLmV2YWx1YXRlKGUpO1xuICAgICAgICBpLmRhdGFbciArIG4gKyAwXSA9IE1hdGguZmxvb3IoMjU1ICogby5yIC8gby5hKSwgaS5kYXRhW3IgKyBuICsgMV0gPSBNYXRoLmZsb29yKDI1NSAqIG8uZyAvIG8uYSksIGkuZGF0YVtyICsgbiArIDJdID0gTWF0aC5mbG9vcigyNTUgKiBvLmIgLyBvLmEpLCBpLmRhdGFbciArIG4gKyAzXSA9IE1hdGguZmxvb3IoMjU1ICogby5hKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0LmNsaXBzKSBmb3IgKHZhciBvID0gMCwgcyA9IDA7IG8gPCBuOyArK28sIHMgKz0gNCAqIHIpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IDAsIGwgPSAwOyB1IDwgcjsgdSsrLCBsICs9IDQpIHtcbiAgICAgICAgICB2YXIgcCA9IHUgLyAociAtIDEpLFxuICAgICAgICAgICAgICBjID0gdC5jbGlwc1tvXTtcbiAgICAgICAgICBhKHMsIGwsIGMuc3RhcnQgKiAoMSAtIHApICsgYy5lbmQgKiBwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAodmFyIGggPSAwLCBmID0gMDsgaCA8IHI7IGgrKywgZiArPSA0KSB7XG4gICAgICAgIGEoMCwgZiwgaCAvIChyIC0gMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIEFvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgd28pLCB0aGlzLl91cGRhdGVDb2xvclJhbXAoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuY3JlYXRlQnVja2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB5byh0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9oYW5kbGVTcGVjaWFsUGFpbnRQcm9wZXJ0eVVwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIFwiaGVhdG1hcC1jb2xvclwiID09PSB0ICYmIHRoaXMuX3VwZGF0ZUNvbG9yUmFtcCgpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yUmFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb2xvclJhbXAgPSBfbyh7XG4gICAgICAgICAgZXhwcmVzc2lvbjogdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW1wiaGVhdG1hcC1jb2xvclwiXS52YWx1ZS5leHByZXNzaW9uLFxuICAgICAgICAgIGV2YWx1YXRpb25LZXk6IFwiaGVhdG1hcERlbnNpdHlcIixcbiAgICAgICAgICBpbWFnZTogdGhpcy5jb2xvclJhbXBcbiAgICAgICAgfSksIHRoaXMuY29sb3JSYW1wVGV4dHVyZSA9IG51bGw7XG4gICAgICB9LCBlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGVhdG1hcEZibyAmJiAodGhpcy5oZWF0bWFwRmJvLmRlc3Ryb3koKSwgdGhpcy5oZWF0bWFwRmJvID0gbnVsbCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeUludGVyc2VjdHNGZWF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5oYXNPZmZzY3JlZW5QYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAhPT0gdGhpcy5wYWludC5nZXQoXCJoZWF0bWFwLW9wYWNpdHlcIikgJiYgXCJub25lXCIgIT09IHRoaXMudmlzaWJpbGl0eTtcbiAgICAgIH0sIGU7XG4gICAgfShBaSksXG4gICAgICAgIFNvID0ge1xuICAgICAgcGFpbnQ6IG5ldyBfaSh7XG4gICAgICAgIFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1kaXJlY3Rpb25cIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCJdKSxcbiAgICAgICAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfaGlsbHNoYWRlW1wiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbmNob3JcIl0pLFxuICAgICAgICBcImhpbGxzaGFkZS1leGFnZ2VyYXRpb25cIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1leGFnZ2VyYXRpb25cIl0pLFxuICAgICAgICBcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIl0pLFxuICAgICAgICBcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIl0pLFxuICAgICAgICBcImhpbGxzaGFkZS1hY2NlbnQtY29sb3JcIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1hY2NlbnQtY29sb3JcIl0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgICAgIGtvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgU28pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5oYXNPZmZzY3JlZW5QYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAhPT0gdGhpcy5wYWludC5nZXQoXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCIpICYmIFwibm9uZVwiICE9PSB0aGlzLnZpc2liaWxpdHk7XG4gICAgICB9LCBlO1xuICAgIH0oQWkpLFxuICAgICAgICBJbyA9IHppKFt7XG4gICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfV0sIDQpLm1lbWJlcnMsXG4gICAgICAgIHpvID0gRW8sXG4gICAgICAgIENvID0gRW87XG5cbiAgICBmdW5jdGlvbiBFbyh0LCBlLCByKSB7XG4gICAgICByID0gciB8fCAyO1xuICAgICAgdmFyIG4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgcyxcbiAgICAgICAgICB1LFxuICAgICAgICAgIGwsXG4gICAgICAgICAgcCA9IGUgJiYgZS5sZW5ndGgsXG4gICAgICAgICAgYyA9IHAgPyBlWzBdICogciA6IHQubGVuZ3RoLFxuICAgICAgICAgIGggPSBQbyh0LCAwLCBjLCByLCAhMCksXG4gICAgICAgICAgZiA9IFtdO1xuICAgICAgaWYgKCFoIHx8IGgubmV4dCA9PT0gaC5wcmV2KSByZXR1cm4gZjtcblxuICAgICAgaWYgKHAgJiYgKGggPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBvLFxuICAgICAgICAgICAgcyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGEgPSBlLmxlbmd0aDsgaSA8IGE7IGkrKykge1xuICAgICAgICAgIChvID0gUG8odCwgZVtpXSAqIG4sIGkgPCBhIC0gMSA/IGVbaSArIDFdICogbiA6IHQubGVuZ3RoLCBuLCAhMSkpID09PSBvLm5leHQgJiYgKG8uc3RlaW5lciA9ICEwKSwgcy5wdXNoKGpvKG8pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocy5zb3J0KExvKSwgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgUm8oc1tpXSwgciksIHIgPSBNbyhyLCByLm5leHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9KHQsIGUsIGgsIHIpKSwgdC5sZW5ndGggPiA4MCAqIHIpIHtcbiAgICAgICAgbiA9IGEgPSB0WzBdLCBpID0gbyA9IHRbMV07XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IHI7IHkgPCBjOyB5ICs9IHIpIHtcbiAgICAgICAgICAocyA9IHRbeV0pIDwgbiAmJiAobiA9IHMpLCAodSA9IHRbeSArIDFdKSA8IGkgJiYgKGkgPSB1KSwgcyA+IGEgJiYgKGEgPSBzKSwgdSA+IG8gJiYgKG8gPSB1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGwgPSAwICE9PSAobCA9IE1hdGgubWF4KGEgLSBuLCBvIC0gaSkpID8gMSAvIGwgOiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQm8oaCwgZiwgciwgbiwgaSwgbCksIGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUG8odCwgZSwgciwgbiwgaSkge1xuICAgICAgdmFyIGEsIG87XG4gICAgICBpZiAoaSA9PT0gdHModCwgZSwgciwgbikgPiAwKSBmb3IgKGEgPSBlOyBhIDwgcjsgYSArPSBuKSB7XG4gICAgICAgIG8gPSAkbyhhLCB0W2FdLCB0W2EgKyAxXSwgbyk7XG4gICAgICB9IGVsc2UgZm9yIChhID0gciAtIG47IGEgPj0gZTsgYSAtPSBuKSB7XG4gICAgICAgIG8gPSAkbyhhLCB0W2FdLCB0W2EgKyAxXSwgbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbyAmJiBHbyhvLCBvLm5leHQpICYmIChXbyhvKSwgbyA9IG8ubmV4dCksIG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTW8odCwgZSkge1xuICAgICAgaWYgKCF0KSByZXR1cm4gdDtcbiAgICAgIGUgfHwgKGUgPSB0KTtcbiAgICAgIHZhciByLFxuICAgICAgICAgIG4gPSB0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChyID0gITEsIG4uc3RlaW5lciB8fCAhR28obiwgbi5uZXh0KSAmJiAwICE9PSBLbyhuLnByZXYsIG4sIG4ubmV4dCkpIG4gPSBuLm5leHQ7ZWxzZSB7XG4gICAgICAgICAgaWYgKFdvKG4pLCAobiA9IGUgPSBuLnByZXYpID09PSBuLm5leHQpIGJyZWFrO1xuICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAociB8fCBuICE9PSBlKTtcblxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQm8odCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgIW8gJiYgYSAmJiBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIHZhciBpID0gdDtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG51bGwgPT09IGkueiAmJiAoaS56ID0gVW8oaS54LCBpLnksIGUsIHIsIG4pKSwgaS5wcmV2WiA9IGkucHJldiwgaS5uZXh0WiA9IGkubmV4dCwgaSA9IGkubmV4dDtcbiAgICAgICAgICB9IHdoaWxlIChpICE9PSB0KTtcblxuICAgICAgICAgIGkucHJldloubmV4dFogPSBudWxsLCBpLnByZXZaID0gbnVsbCwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBlLFxuICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgIHUsXG4gICAgICAgICAgICAgICAgbCA9IDE7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgZm9yIChyID0gdCwgdCA9IG51bGwsIGEgPSBudWxsLCBvID0gMDsgcjspIHtcbiAgICAgICAgICAgICAgICBmb3IgKG8rKywgbiA9IHIsIHMgPSAwLCBlID0gMDsgZSA8IGwgJiYgKHMrKywgbiA9IG4ubmV4dFopOyBlKyspIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHUgPSBsOyBzID4gMCB8fCB1ID4gMCAmJiBuOykge1xuICAgICAgICAgICAgICAgICAgMCAhPT0gcyAmJiAoMCA9PT0gdSB8fCAhbiB8fCByLnogPD0gbi56KSA/IChpID0gciwgciA9IHIubmV4dFosIHMtLSkgOiAoaSA9IG4sIG4gPSBuLm5leHRaLCB1LS0pLCBhID8gYS5uZXh0WiA9IGkgOiB0ID0gaSwgaS5wcmV2WiA9IGEsIGEgPSBpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHIgPSBuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYS5uZXh0WiA9IG51bGwsIGwgKj0gMjtcbiAgICAgICAgICAgIH0gd2hpbGUgKG8gPiAxKTtcbiAgICAgICAgICB9KGkpO1xuICAgICAgICB9KHQsIG4sIGksIGEpO1xuXG4gICAgICAgIGZvciAodmFyIHMsIHUsIGwgPSB0OyB0LnByZXYgIT09IHQubmV4dDspIHtcbiAgICAgICAgICBpZiAocyA9IHQucHJldiwgdSA9IHQubmV4dCwgYSA/IFZvKHQsIG4sIGksIGEpIDogVG8odCkpIGUucHVzaChzLmkgLyByKSwgZS5wdXNoKHQuaSAvIHIpLCBlLnB1c2godS5pIC8gciksIFdvKHQpLCB0ID0gdS5uZXh0LCBsID0gdS5uZXh0O2Vsc2UgaWYgKCh0ID0gdSkgPT09IGwpIHtcbiAgICAgICAgICAgIG8gPyAxID09PSBvID8gQm8odCA9IEZvKE1vKHQpLCBlLCByKSwgZSwgciwgbiwgaSwgYSwgMikgOiAyID09PSBvICYmIERvKHQsIGUsIHIsIG4sIGksIGEpIDogQm8oTW8odCksIGUsIHIsIG4sIGksIGEsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVG8odCkge1xuICAgICAgdmFyIGUgPSB0LnByZXYsXG4gICAgICAgICAgciA9IHQsXG4gICAgICAgICAgbiA9IHQubmV4dDtcbiAgICAgIGlmIChLbyhlLCByLCBuKSA+PSAwKSByZXR1cm4gITE7XG5cbiAgICAgIGZvciAodmFyIGkgPSB0Lm5leHQubmV4dDsgaSAhPT0gdC5wcmV2Oykge1xuICAgICAgICBpZiAocW8oZS54LCBlLnksIHIueCwgci55LCBuLngsIG4ueSwgaS54LCBpLnkpICYmIEtvKGkucHJldiwgaSwgaS5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGkgPSBpLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBWbyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHQucHJldixcbiAgICAgICAgICBhID0gdCxcbiAgICAgICAgICBvID0gdC5uZXh0O1xuICAgICAgaWYgKEtvKGksIGEsIG8pID49IDApIHJldHVybiAhMTtcblxuICAgICAgZm9yICh2YXIgcyA9IGkueCA+IGEueCA/IGkueCA+IG8ueCA/IGkueCA6IG8ueCA6IGEueCA+IG8ueCA/IGEueCA6IG8ueCwgdSA9IGkueSA+IGEueSA/IGkueSA+IG8ueSA/IGkueSA6IG8ueSA6IGEueSA+IG8ueSA/IGEueSA6IG8ueSwgbCA9IFVvKGkueCA8IGEueCA/IGkueCA8IG8ueCA/IGkueCA6IG8ueCA6IGEueCA8IG8ueCA/IGEueCA6IG8ueCwgaS55IDwgYS55ID8gaS55IDwgby55ID8gaS55IDogby55IDogYS55IDwgby55ID8gYS55IDogby55LCBlLCByLCBuKSwgcCA9IFVvKHMsIHUsIGUsIHIsIG4pLCBjID0gdC5wcmV2WiwgaCA9IHQubmV4dFo7IGMgJiYgYy56ID49IGwgJiYgaCAmJiBoLnogPD0gcDspIHtcbiAgICAgICAgaWYgKGMgIT09IHQucHJldiAmJiBjICE9PSB0Lm5leHQgJiYgcW8oaS54LCBpLnksIGEueCwgYS55LCBvLngsIG8ueSwgYy54LCBjLnkpICYmIEtvKGMucHJldiwgYywgYy5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChjID0gYy5wcmV2WiwgaCAhPT0gdC5wcmV2ICYmIGggIT09IHQubmV4dCAmJiBxbyhpLngsIGkueSwgYS54LCBhLnksIG8ueCwgby55LCBoLngsIGgueSkgJiYgS28oaC5wcmV2LCBoLCBoLm5leHQpID49IDApIHJldHVybiAhMTtcbiAgICAgICAgaCA9IGgubmV4dFo7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBjICYmIGMueiA+PSBsOykge1xuICAgICAgICBpZiAoYyAhPT0gdC5wcmV2ICYmIGMgIT09IHQubmV4dCAmJiBxbyhpLngsIGkueSwgYS54LCBhLnksIG8ueCwgby55LCBjLngsIGMueSkgJiYgS28oYy5wcmV2LCBjLCBjLm5leHQpID49IDApIHJldHVybiAhMTtcbiAgICAgICAgYyA9IGMucHJldlo7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBoICYmIGgueiA8PSBwOykge1xuICAgICAgICBpZiAoaCAhPT0gdC5wcmV2ICYmIGggIT09IHQubmV4dCAmJiBxbyhpLngsIGkueSwgYS54LCBhLnksIG8ueCwgby55LCBoLngsIGgueSkgJiYgS28oaC5wcmV2LCBoLCBoLm5leHQpID49IDApIHJldHVybiAhMTtcbiAgICAgICAgaCA9IGgubmV4dFo7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGbyh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGkgPSBuLnByZXYsXG4gICAgICAgICAgICBhID0gbi5uZXh0Lm5leHQ7XG4gICAgICAgICFHbyhpLCBhKSAmJiBabyhpLCBuLCBuLm5leHQsIGEpICYmIEhvKGksIGEpICYmIEhvKGEsIGkpICYmIChlLnB1c2goaS5pIC8gciksIGUucHVzaChuLmkgLyByKSwgZS5wdXNoKGEuaSAvIHIpLCBXbyhuKSwgV28obi5uZXh0KSwgbiA9IHQgPSBhKSwgbiA9IG4ubmV4dDtcbiAgICAgIH0gd2hpbGUgKG4gIT09IHQpO1xuXG4gICAgICByZXR1cm4gTW8obik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRG8odCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdmFyIG8gPSB0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGZvciAodmFyIHMgPSBvLm5leHQubmV4dDsgcyAhPT0gby5wcmV2Oykge1xuICAgICAgICAgIGlmIChvLmkgIT09IHMuaSAmJiBObyhvLCBzKSkge1xuICAgICAgICAgICAgdmFyIHUgPSBZbyhvLCBzKTtcbiAgICAgICAgICAgIHJldHVybiBvID0gTW8obywgby5uZXh0KSwgdSA9IE1vKHUsIHUubmV4dCksIEJvKG8sIGUsIHIsIG4sIGksIGEpLCB2b2lkIEJvKHUsIGUsIHIsIG4sIGksIGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHMgPSBzLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBvID0gby5uZXh0O1xuICAgICAgfSB3aGlsZSAobyAhPT0gdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG8odCwgZSkge1xuICAgICAgcmV0dXJuIHQueCAtIGUueDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSbyh0LCBlKSB7XG4gICAgICBpZiAoZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByLFxuICAgICAgICAgICAgbiA9IGUsXG4gICAgICAgICAgICBpID0gdC54LFxuICAgICAgICAgICAgYSA9IHQueSxcbiAgICAgICAgICAgIG8gPSAtMSAvIDA7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChhIDw9IG4ueSAmJiBhID49IG4ubmV4dC55ICYmIG4ubmV4dC55ICE9PSBuLnkpIHtcbiAgICAgICAgICAgIHZhciBzID0gbi54ICsgKGEgLSBuLnkpICogKG4ubmV4dC54IC0gbi54KSAvIChuLm5leHQueSAtIG4ueSk7XG5cbiAgICAgICAgICAgIGlmIChzIDw9IGkgJiYgcyA+IG8pIHtcbiAgICAgICAgICAgICAgaWYgKG8gPSBzLCBzID09PSBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IG4ueSkgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IG4ubmV4dC55KSByZXR1cm4gbi5uZXh0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgciA9IG4ueCA8IG4ubmV4dC54ID8gbiA6IG4ubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuID0gbi5uZXh0O1xuICAgICAgICB9IHdoaWxlIChuICE9PSBlKTtcblxuICAgICAgICBpZiAoIXIpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoaSA9PT0gbykgcmV0dXJuIHI7XG4gICAgICAgIHZhciB1LFxuICAgICAgICAgICAgbCA9IHIsXG4gICAgICAgICAgICBwID0gci54LFxuICAgICAgICAgICAgYyA9IHIueSxcbiAgICAgICAgICAgIGggPSAxIC8gMDtcbiAgICAgICAgbiA9IHI7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGkgPj0gbi54ICYmIG4ueCA+PSBwICYmIGkgIT09IG4ueCAmJiBxbyhhIDwgYyA/IGkgOiBvLCBhLCBwLCBjLCBhIDwgYyA/IG8gOiBpLCBhLCBuLngsIG4ueSkgJiYgKHUgPSBNYXRoLmFicyhhIC0gbi55KSAvIChpIC0gbi54KSwgSG8obiwgdCkgJiYgKHUgPCBoIHx8IHUgPT09IGggJiYgKG4ueCA+IHIueCB8fCBuLnggPT09IHIueCAmJiBPbyhyLCBuKSkpICYmIChyID0gbiwgaCA9IHUpKSwgbiA9IG4ubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobiAhPT0gbCk7XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9KHQsIGUpKSB7XG4gICAgICAgIHZhciByID0gWW8oZSwgdCk7XG4gICAgICAgIE1vKGUsIGUubmV4dCksIE1vKHIsIHIubmV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gT28odCwgZSkge1xuICAgICAgcmV0dXJuIEtvKHQucHJldiwgdCwgZS5wcmV2KSA8IDAgJiYgS28oZS5uZXh0LCB0LCB0Lm5leHQpIDwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVbyh0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4gKHQgPSAxNDMxNjU1NzY1ICYgKCh0ID0gODU4OTkzNDU5ICYgKCh0ID0gMjUyNjQ1MTM1ICYgKCh0ID0gMTY3MTE5MzUgJiAoKHQgPSAzMjc2NyAqICh0IC0gcikgKiBpKSB8IHQgPDwgOCkpIHwgdCA8PCA0KSkgfCB0IDw8IDIpKSB8IHQgPDwgMSkpIHwgKGUgPSAxNDMxNjU1NzY1ICYgKChlID0gODU4OTkzNDU5ICYgKChlID0gMjUyNjQ1MTM1ICYgKChlID0gMTY3MTE5MzUgJiAoKGUgPSAzMjc2NyAqIChlIC0gbikgKiBpKSB8IGUgPDwgOCkpIHwgZSA8PCA0KSkgfCBlIDw8IDIpKSB8IGUgPDwgMSkpIDw8IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam8odCkge1xuICAgICAgdmFyIGUgPSB0LFxuICAgICAgICAgIHIgPSB0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIChlLnggPCByLnggfHwgZS54ID09PSByLnggJiYgZS55IDwgci55KSAmJiAociA9IGUpLCBlID0gZS5uZXh0O1xuICAgICAgfSB3aGlsZSAoZSAhPT0gdCk7XG5cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHFvKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMpIHtcbiAgICAgIHJldHVybiAoaSAtIG8pICogKGUgLSBzKSAtICh0IC0gbykgKiAoYSAtIHMpID49IDAgJiYgKHQgLSBvKSAqIChuIC0gcykgLSAociAtIG8pICogKGUgLSBzKSA+PSAwICYmIChyIC0gbykgKiAoYSAtIHMpIC0gKGkgLSBvKSAqIChuIC0gcykgPj0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBObyh0LCBlKSB7XG4gICAgICByZXR1cm4gdC5uZXh0LmkgIT09IGUuaSAmJiB0LnByZXYuaSAhPT0gZS5pICYmICFmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHQ7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChyLmkgIT09IHQuaSAmJiByLm5leHQuaSAhPT0gdC5pICYmIHIuaSAhPT0gZS5pICYmIHIubmV4dC5pICE9PSBlLmkgJiYgWm8ociwgci5uZXh0LCB0LCBlKSkgcmV0dXJuICEwO1xuICAgICAgICAgIHIgPSByLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHIgIT09IHQpO1xuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0odCwgZSkgJiYgKEhvKHQsIGUpICYmIEhvKGUsIHQpICYmIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gdCxcbiAgICAgICAgICAgIG4gPSAhMSxcbiAgICAgICAgICAgIGkgPSAodC54ICsgZS54KSAvIDIsXG4gICAgICAgICAgICBhID0gKHQueSArIGUueSkgLyAyO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICByLnkgPiBhICE9IHIubmV4dC55ID4gYSAmJiByLm5leHQueSAhPT0gci55ICYmIGkgPCAoci5uZXh0LnggLSByLngpICogKGEgLSByLnkpIC8gKHIubmV4dC55IC0gci55KSArIHIueCAmJiAobiA9ICFuKSwgciA9IHIubmV4dDtcbiAgICAgICAgfSB3aGlsZSAociAhPT0gdCk7XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9KHQsIGUpICYmIChLbyh0LnByZXYsIHQsIGUucHJldikgfHwgS28odCwgZS5wcmV2LCBlKSkgfHwgR28odCwgZSkgJiYgS28odC5wcmV2LCB0LCB0Lm5leHQpID4gMCAmJiBLbyhlLnByZXYsIGUsIGUubmV4dCkgPiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBLbyh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gKGUueSAtIHQueSkgKiAoci54IC0gZS54KSAtIChlLnggLSB0LngpICogKHIueSAtIGUueSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR28odCwgZSkge1xuICAgICAgcmV0dXJuIHQueCA9PT0gZS54ICYmIHQueSA9PT0gZS55O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFpvKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gSm8oS28odCwgZSwgcikpLFxuICAgICAgICAgIGEgPSBKbyhLbyh0LCBlLCBuKSksXG4gICAgICAgICAgbyA9IEpvKEtvKHIsIG4sIHQpKSxcbiAgICAgICAgICBzID0gSm8oS28ociwgbiwgZSkpO1xuICAgICAgcmV0dXJuIGkgIT09IGEgJiYgbyAhPT0gcyB8fCAhKDAgIT09IGkgfHwgIVhvKHQsIHIsIGUpKSB8fCAhKDAgIT09IGEgfHwgIVhvKHQsIG4sIGUpKSB8fCAhKDAgIT09IG8gfHwgIVhvKHIsIHQsIG4pKSB8fCAhKDAgIT09IHMgfHwgIVhvKHIsIGUsIG4pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBYbyh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gZS54IDw9IE1hdGgubWF4KHQueCwgci54KSAmJiBlLnggPj0gTWF0aC5taW4odC54LCByLngpICYmIGUueSA8PSBNYXRoLm1heCh0LnksIHIueSkgJiYgZS55ID49IE1hdGgubWluKHQueSwgci55KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBKbyh0KSB7XG4gICAgICByZXR1cm4gdCA+IDAgPyAxIDogdCA8IDAgPyAtMSA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSG8odCwgZSkge1xuICAgICAgcmV0dXJuIEtvKHQucHJldiwgdCwgdC5uZXh0KSA8IDAgPyBLbyh0LCBlLCB0Lm5leHQpID49IDAgJiYgS28odCwgdC5wcmV2LCBlKSA+PSAwIDogS28odCwgZSwgdC5wcmV2KSA8IDAgfHwgS28odCwgdC5uZXh0LCBlKSA8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWW8odCwgZSkge1xuICAgICAgdmFyIHIgPSBuZXcgUW8odC5pLCB0LngsIHQueSksXG4gICAgICAgICAgbiA9IG5ldyBRbyhlLmksIGUueCwgZS55KSxcbiAgICAgICAgICBpID0gdC5uZXh0LFxuICAgICAgICAgIGEgPSBlLnByZXY7XG4gICAgICByZXR1cm4gdC5uZXh0ID0gZSwgZS5wcmV2ID0gdCwgci5uZXh0ID0gaSwgaS5wcmV2ID0gciwgbi5uZXh0ID0gciwgci5wcmV2ID0gbiwgYS5uZXh0ID0gbiwgbi5wcmV2ID0gYSwgbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkbyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IG5ldyBRbyh0LCBlLCByKTtcbiAgICAgIHJldHVybiBuID8gKGkubmV4dCA9IG4ubmV4dCwgaS5wcmV2ID0gbiwgbi5uZXh0LnByZXYgPSBpLCBuLm5leHQgPSBpKSA6IChpLnByZXYgPSBpLCBpLm5leHQgPSBpKSwgaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXbyh0KSB7XG4gICAgICB0Lm5leHQucHJldiA9IHQucHJldiwgdC5wcmV2Lm5leHQgPSB0Lm5leHQsIHQucHJldlogJiYgKHQucHJldloubmV4dFogPSB0Lm5leHRaKSwgdC5uZXh0WiAmJiAodC5uZXh0Wi5wcmV2WiA9IHQucHJldlopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFFvKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuaSA9IHQsIHRoaXMueCA9IGUsIHRoaXMueSA9IHIsIHRoaXMucHJldiA9IG51bGwsIHRoaXMubmV4dCA9IG51bGwsIHRoaXMueiA9IG51bGwsIHRoaXMucHJldlogPSBudWxsLCB0aGlzLm5leHRaID0gbnVsbCwgdGhpcy5zdGVpbmVyID0gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHModCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGEgPSBlLCBvID0gciAtIG47IGEgPCByOyBhICs9IG4pIHtcbiAgICAgICAgaSArPSAodFtvXSAtIHRbYV0pICogKHRbYSArIDFdICsgdFtvICsgMV0pLCBvID0gYTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXModCwgZSwgciwgbiwgaSkge1xuICAgICAgIWZ1bmN0aW9uIHQoZSwgciwgbiwgaSwgYSkge1xuICAgICAgICBmb3IgKDsgaSA+IG47KSB7XG4gICAgICAgICAgaWYgKGkgLSBuID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGkgLSBuICsgMSxcbiAgICAgICAgICAgICAgICBzID0gciAtIG4gKyAxLFxuICAgICAgICAgICAgICAgIHUgPSBNYXRoLmxvZyhvKSxcbiAgICAgICAgICAgICAgICBsID0gLjUgKiBNYXRoLmV4cCgyICogdSAvIDMpLFxuICAgICAgICAgICAgICAgIHAgPSAuNSAqIE1hdGguc3FydCh1ICogbCAqIChvIC0gbCkgLyBvKSAqIChzIC0gbyAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHQoZSwgciwgTWF0aC5tYXgobiwgTWF0aC5mbG9vcihyIC0gcyAqIGwgLyBvICsgcCkpLCBNYXRoLm1pbihpLCBNYXRoLmZsb29yKHIgKyAobyAtIHMpICogbCAvIG8gKyBwKSksIGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjID0gZVtyXSxcbiAgICAgICAgICAgICAgaCA9IG4sXG4gICAgICAgICAgICAgIGYgPSBpO1xuXG4gICAgICAgICAgZm9yIChycyhlLCBuLCByKSwgYShlW2ldLCBjKSA+IDAgJiYgcnMoZSwgbiwgaSk7IGggPCBmOykge1xuICAgICAgICAgICAgZm9yIChycyhlLCBoLCBmKSwgaCsrLCBmLS07IGEoZVtoXSwgYykgPCAwOykge1xuICAgICAgICAgICAgICBoKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoOyBhKGVbZl0sIGMpID4gMDspIHtcbiAgICAgICAgICAgICAgZi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIDAgPT09IGEoZVtuXSwgYykgPyBycyhlLCBuLCBmKSA6IHJzKGUsICsrZiwgaSksIGYgPD0gciAmJiAobiA9IGYgKyAxKSwgciA8PSBmICYmIChpID0gZiAtIDEpO1xuICAgICAgICB9XG4gICAgICB9KHQsIGUsIHIgfHwgMCwgbiB8fCB0Lmxlbmd0aCAtIDEsIGkgfHwgbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJzKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdFtlXTtcbiAgICAgIHRbZV0gPSB0W3JdLCB0W3JdID0gbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBucyh0LCBlKSB7XG4gICAgICByZXR1cm4gdCA8IGUgPyAtMSA6IHQgPiBlID8gMSA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXModCwgZSkge1xuICAgICAgdmFyIHIgPSB0Lmxlbmd0aDtcbiAgICAgIGlmIChyIDw9IDEpIHJldHVybiBbdF07XG5cbiAgICAgIGZvciAodmFyIG4sIGksIGEgPSBbXSwgbyA9IDA7IG8gPCByOyBvKyspIHtcbiAgICAgICAgdmFyIHMgPSBrKHRbb10pO1xuICAgICAgICAwICE9PSBzICYmICh0W29dLmFyZWEgPSBNYXRoLmFicyhzKSwgdm9pZCAwID09PSBpICYmIChpID0gcyA8IDApLCBpID09PSBzIDwgMCA/IChuICYmIGEucHVzaChuKSwgbiA9IFt0W29dXSkgOiBuLnB1c2godFtvXSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobiAmJiBhLnB1c2gobiksIGUgPiAxKSBmb3IgKHZhciB1ID0gMDsgdSA8IGEubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgYVt1XS5sZW5ndGggPD0gZSB8fCAoZXMoYVt1XSwgZSwgMSwgYVt1XS5sZW5ndGggLSAxLCBhcyksIGFbdV0gPSBhW3VdLnNsaWNlKDAsIGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHQsIGUpIHtcbiAgICAgIHJldHVybiBlLmFyZWEgLSB0LmFyZWE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3ModCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IHIucGF0dGVybkRlcGVuZGVuY2llcywgaSA9ICExLCBhID0gMCwgbyA9IGU7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gb1thXS5wYWludC5nZXQodCArIFwiLXBhdHRlcm5cIik7XG4gICAgICAgIHMuaXNDb25zdGFudCgpIHx8IChpID0gITApO1xuICAgICAgICB2YXIgdSA9IHMuY29uc3RhbnRPcihudWxsKTtcbiAgICAgICAgdSAmJiAoaSA9ICEwLCBuW3UudG9dID0gITAsIG5bdS5mcm9tXSA9ICEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3ModCwgZSwgciwgbiwgaSkge1xuICAgICAgZm9yICh2YXIgYSA9IGkucGF0dGVybkRlcGVuZGVuY2llcywgbyA9IDAsIHMgPSBlOyBvIDwgcy5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICB2YXIgdSA9IHNbb10sXG4gICAgICAgICAgICBsID0gdS5wYWludC5nZXQodCArIFwiLXBhdHRlcm5cIikudmFsdWU7XG5cbiAgICAgICAgaWYgKFwiY29uc3RhbnRcIiAhPT0gbC5raW5kKSB7XG4gICAgICAgICAgdmFyIHAgPSBsLmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IG4gLSAxXG4gICAgICAgICAgfSwgciwge30sIGkuYXZhaWxhYmxlSW1hZ2VzKSxcbiAgICAgICAgICAgICAgYyA9IGwuZXZhbHVhdGUoe1xuICAgICAgICAgICAgem9vbTogblxuICAgICAgICAgIH0sIHIsIHt9LCBpLmF2YWlsYWJsZUltYWdlcyksXG4gICAgICAgICAgICAgIGggPSBsLmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IG4gKyAxXG4gICAgICAgICAgfSwgciwge30sIGkuYXZhaWxhYmxlSW1hZ2VzKTtcbiAgICAgICAgICBjID0gYyAmJiBjLm5hbWUgPyBjLm5hbWUgOiBjLCBoID0gaCAmJiBoLm5hbWUgPyBoLm5hbWUgOiBoLCBhW3AgPSBwICYmIHAubmFtZSA/IHAubmFtZSA6IHBdID0gITAsIGFbY10gPSAhMCwgYVtoXSA9ICEwLCByLnBhdHRlcm5zW3UuaWRdID0ge1xuICAgICAgICAgICAgbWluOiBwLFxuICAgICAgICAgICAgbWlkOiBjLFxuICAgICAgICAgICAgbWF4OiBoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBFby5kZXZpYXRpb24gPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBlICYmIGUubGVuZ3RoLFxuICAgICAgICAgIGEgPSBNYXRoLmFicyh0cyh0LCAwLCBpID8gZVswXSAqIHIgOiB0Lmxlbmd0aCwgcikpO1xuICAgICAgaWYgKGkpIGZvciAodmFyIG8gPSAwLCBzID0gZS5sZW5ndGg7IG8gPCBzOyBvKyspIHtcbiAgICAgICAgYSAtPSBNYXRoLmFicyh0cyh0LCBlW29dICogciwgbyA8IHMgLSAxID8gZVtvICsgMV0gKiByIDogdC5sZW5ndGgsIHIpKTtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gMDtcblxuICAgICAgZm9yIChvID0gMDsgbyA8IG4ubGVuZ3RoOyBvICs9IDMpIHtcbiAgICAgICAgdmFyIGwgPSBuW29dICogcixcbiAgICAgICAgICAgIHAgPSBuW28gKyAxXSAqIHIsXG4gICAgICAgICAgICBjID0gbltvICsgMl0gKiByO1xuICAgICAgICB1ICs9IE1hdGguYWJzKCh0W2xdIC0gdFtjXSkgKiAodFtwICsgMV0gLSB0W2wgKyAxXSkgLSAodFtsXSAtIHRbcF0pICogKHRbYyArIDFdIC0gdFtsICsgMV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDAgPT09IGEgJiYgMCA9PT0gdSA/IDAgOiBNYXRoLmFicygodSAtIGEpIC8gYSk7XG4gICAgfSwgRW8uZmxhdHRlbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdFswXVswXS5sZW5ndGgsIHIgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgaG9sZXM6IFtdLFxuICAgICAgICBkaW1lbnNpb25zOiBlXG4gICAgICB9LCBuID0gMCwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdFtpXS5sZW5ndGg7IGErKykge1xuICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZTsgbysrKSB7XG4gICAgICAgICAgICByLnZlcnRpY2VzLnB1c2godFtpXVthXVtvXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaSA+IDAgJiYgci5ob2xlcy5wdXNoKG4gKz0gdFtpIC0gMV0ubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgem8uZGVmYXVsdCA9IENvO1xuXG4gICAgdmFyIHVzID0gZnVuY3Rpb24gdXModCkge1xuICAgICAgdGhpcy56b29tID0gdC56b29tLCB0aGlzLm92ZXJzY2FsaW5nID0gdC5vdmVyc2NhbGluZywgdGhpcy5sYXllcnMgPSB0LmxheWVycywgdGhpcy5sYXllcklkcyA9IHRoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pLCB0aGlzLmluZGV4ID0gdC5pbmRleCwgdGhpcy5oYXNQYXR0ZXJuID0gITEsIHRoaXMucGF0dGVybkZlYXR1cmVzID0gW10sIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgRWkoKSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IHFpKCksIHRoaXMuaW5kZXhBcnJheTIgPSBuZXcgSmkoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgRmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5zZWdtZW50czIgPSBuZXcgdWEoKSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzU3RhdGVEZXBlbmRlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB1cy5wcm90b3R5cGUucG9wdWxhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5oYXNQYXR0ZXJuID0gb3MoXCJmaWxsXCIsIHRoaXMubGF5ZXJzLCBlKTtcblxuICAgICAgZm9yICh2YXIgbiA9IHRoaXMubGF5ZXJzWzBdLmxheW91dC5nZXQoXCJmaWxsLXNvcnQta2V5XCIpLCBpID0gIW4uaXNDb25zdGFudCgpLCBhID0gW10sIG8gPSAwLCBzID0gdDsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgICAgbCA9IHUuZmVhdHVyZSxcbiAgICAgICAgICAgIHAgPSB1LmlkLFxuICAgICAgICAgICAgYyA9IHUuaW5kZXgsXG4gICAgICAgICAgICBoID0gdS5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgICAgZiA9IHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLm5lZWRHZW9tZXRyeSxcbiAgICAgICAgICAgIHkgPSBqYShsLCBmKTtcblxuICAgICAgICBpZiAodGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIuZmlsdGVyKG5ldyB1aSh0aGlzLnpvb20pLCB5LCByKSkge1xuICAgICAgICAgIHZhciBkID0gaSA/IG4uZXZhbHVhdGUoeSwge30sIHIsIGUuYXZhaWxhYmxlSW1hZ2VzKSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgIGlkOiBwLFxuICAgICAgICAgICAgcHJvcGVydGllczogbC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdHlwZTogbC50eXBlLFxuICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogaCxcbiAgICAgICAgICAgIGluZGV4OiBjLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IGYgPyB5Lmdlb21ldHJ5IDogVWEobCksXG4gICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgICAgICBzb3J0S2V5OiBkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSAmJiBhLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHQuc29ydEtleSAtIGUuc29ydEtleTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciB2ID0gMCwgZyA9IGE7IHYgPCBnLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgIHZhciB4ID0gZ1t2XSxcbiAgICAgICAgICAgIGIgPSB4Lmdlb21ldHJ5LFxuICAgICAgICAgICAgdyA9IHguaW5kZXgsXG4gICAgICAgICAgICBfID0geC5zb3VyY2VMYXllckluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1BhdHRlcm4pIHtcbiAgICAgICAgICB2YXIgQSA9IHNzKFwiZmlsbFwiLCB0aGlzLmxheWVycywgeCwgdGhpcy56b29tLCBlKTtcbiAgICAgICAgICB0aGlzLnBhdHRlcm5GZWF0dXJlcy5wdXNoKEEpO1xuICAgICAgICB9IGVsc2UgdGhpcy5hZGRGZWF0dXJlKHgsIGIsIHcsIHIsIHt9KTtcblxuICAgICAgICBlLmZlYXR1cmVJbmRleC5pbnNlcnQodFt3XS5mZWF0dXJlLCBiLCB3LCBfLCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB1cy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMubGVuZ3RoICYmIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwZGF0ZVBhaW50QXJyYXlzKHQsIGUsIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcnMsIHIpO1xuICAgIH0sIHVzLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMucGF0dGVybkZlYXR1cmVzOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZShhLCBhLmdlb21ldHJ5LCBhLmluZGV4LCBlLCByKTtcbiAgICAgIH1cbiAgICB9LCB1cy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICB9LCB1cy5wcm90b3R5cGUudXBsb2FkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy51cGxvYWRlZCB8fCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZDtcbiAgICB9LCB1cy5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudXBsb2FkZWQgfHwgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgSW8pLCB0aGlzLmluZGV4QnVmZmVyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXkpLCB0aGlzLmluZGV4QnVmZmVyMiA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5MikpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGxvYWQodCksIHRoaXMudXBsb2FkZWQgPSAhMDtcbiAgICB9LCB1cy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLmluZGV4QnVmZmVyMi5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCksIHRoaXMuc2VnbWVudHMyLmRlc3Ryb3koKSk7XG4gICAgfSwgdXMucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZm9yICh2YXIgYSA9IDAsIG8gPSBpcyhlLCA1MDApOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBzID0gb1thXSwgdSA9IDAsIGwgPSAwLCBwID0gczsgbCA8IHAubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgICB1ICs9IHBbbF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQodSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgdGhpcy5pbmRleEFycmF5KSwgaCA9IGMudmVydGV4TGVuZ3RoLCBmID0gW10sIHkgPSBbXSwgZCA9IDAsIG0gPSBzOyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgIHZhciB2ID0gbVtkXTtcblxuICAgICAgICAgIGlmICgwICE9PSB2Lmxlbmd0aCkge1xuICAgICAgICAgICAgdiAhPT0gc1swXSAmJiB5LnB1c2goZi5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5zZWdtZW50czIucHJlcGFyZVNlZ21lbnQodi5sZW5ndGgsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheTIpLFxuICAgICAgICAgICAgICAgIHggPSBnLnZlcnRleExlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkuZW1wbGFjZUJhY2sodlswXS54LCB2WzBdLnkpLCB0aGlzLmluZGV4QXJyYXkyLmVtcGxhY2VCYWNrKHggKyB2Lmxlbmd0aCAtIDEsIHgpLCBmLnB1c2godlswXS54KSwgZi5wdXNoKHZbMF0ueSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAxOyBiIDwgdi5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5LmVtcGxhY2VCYWNrKHZbYl0ueCwgdltiXS55KSwgdGhpcy5pbmRleEFycmF5Mi5lbXBsYWNlQmFjayh4ICsgYiAtIDEsIHggKyBiKSwgZi5wdXNoKHZbYl0ueCksIGYucHVzaCh2W2JdLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnLnZlcnRleExlbmd0aCArPSB2Lmxlbmd0aCwgZy5wcmltaXRpdmVMZW5ndGggKz0gdi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IHpvKGYsIHkpLCBfID0gMDsgXyA8IHcubGVuZ3RoOyBfICs9IDMpIHtcbiAgICAgICAgICB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaCArIHdbX10sIGggKyB3W18gKyAxXSwgaCArIHdbXyArIDJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMudmVydGV4TGVuZ3RoICs9IHUsIGMucHJpbWl0aXZlTGVuZ3RoICs9IHcubGVuZ3RoIC8gMztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMucG9wdWxhdGVQYWludEFycmF5cyh0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCwgdCwgciwgaSwgbik7XG4gICAgfSwgT24oXCJGaWxsQnVja2V0XCIsIHVzLCB7XG4gICAgICBvbWl0OiBbXCJsYXllcnNcIiwgXCJwYXR0ZXJuRmVhdHVyZXNcIl1cbiAgICB9KTtcblxuICAgIHZhciBscyA9IG5ldyBfaSh7XG4gICAgICBcImZpbGwtc29ydC1rZXlcIjogbmV3IGdpKFB0LmxheW91dF9maWxsW1wiZmlsbC1zb3J0LWtleVwiXSlcbiAgICB9KSxcbiAgICAgICAgcHMgPSB7XG4gICAgICBwYWludDogbmV3IF9pKHtcbiAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiBuZXcgdmkoUHQucGFpbnRfZmlsbFtcImZpbGwtYW50aWFsaWFzXCJdKSxcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogbmV3IGdpKFB0LnBhaW50X2ZpbGxbXCJmaWxsLW9wYWNpdHlcIl0pLFxuICAgICAgICBcImZpbGwtY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X2ZpbGxbXCJmaWxsLWNvbG9yXCJdKSxcbiAgICAgICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X2ZpbGxbXCJmaWxsLW91dGxpbmUtY29sb3JcIl0pLFxuICAgICAgICBcImZpbGwtdHJhbnNsYXRlXCI6IG5ldyB2aShQdC5wYWludF9maWxsW1wiZmlsbC10cmFuc2xhdGVcIl0pLFxuICAgICAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfZmlsbFtcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiXSksXG4gICAgICAgIFwiZmlsbC1wYXR0ZXJuXCI6IG5ldyB4aShQdC5wYWludF9maWxsW1wiZmlsbC1wYXR0ZXJuXCJdKVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IGxzXG4gICAgfSxcbiAgICAgICAgY3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBwcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgdC5wcm90b3R5cGUucmVjYWxjdWxhdGUuY2FsbCh0aGlzLCBlLCByKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnBhaW50Ll92YWx1ZXNbXCJmaWxsLW91dGxpbmUtY29sb3JcIl07XG4gICAgICAgIFwiY29uc3RhbnRcIiA9PT0gbi52YWx1ZS5raW5kICYmIHZvaWQgMCA9PT0gbi52YWx1ZS52YWx1ZSAmJiAodGhpcy5wYWludC5fdmFsdWVzW1wiZmlsbC1vdXRsaW5lLWNvbG9yXCJdID0gdGhpcy5wYWludC5fdmFsdWVzW1wiZmlsbC1jb2xvclwiXSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IHVzKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBybyh0aGlzLnBhaW50LmdldChcImZpbGwtdHJhbnNsYXRlXCIpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgICByZXR1cm4gWmEobm8odCwgdGhpcy5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZVwiKSwgdGhpcy5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIiksIGEuYW5nbGUsIG8pLCBuKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzVGlsZUNsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGU7XG4gICAgfShBaSksXG4gICAgICAgIGhzID0gemkoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfbm9ybWFsX2VkXCIsXG4gICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfV0sIDQpLm1lbWJlcnMsXG4gICAgICAgIGZzID0geXM7XG5cbiAgICBmdW5jdGlvbiB5cyh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fSwgdGhpcy5leHRlbnQgPSByLCB0aGlzLnR5cGUgPSAwLCB0aGlzLl9wYmYgPSB0LCB0aGlzLl9nZW9tZXRyeSA9IC0xLCB0aGlzLl9rZXlzID0gbiwgdGhpcy5fdmFsdWVzID0gaSwgdC5yZWFkRmllbGRzKGRzLCB0aGlzLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcyh0LCBlLCByKSB7XG4gICAgICAxID09IHQgPyBlLmlkID0gci5yZWFkVmFyaW50KCkgOiAyID09IHQgPyBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gdC5yZWFkVmFyaW50KCkgKyB0LnBvczsgdC5wb3MgPCByOykge1xuICAgICAgICAgIHZhciBuID0gZS5fa2V5c1t0LnJlYWRWYXJpbnQoKV0sXG4gICAgICAgICAgICAgIGkgPSBlLl92YWx1ZXNbdC5yZWFkVmFyaW50KCldO1xuXG4gICAgICAgICAgZS5wcm9wZXJ0aWVzW25dID0gaTtcbiAgICAgICAgfVxuICAgICAgfShyLCBlKSA6IDMgPT0gdCA/IGUudHlwZSA9IHIucmVhZFZhcmludCgpIDogNCA9PSB0ICYmIChlLl9nZW9tZXRyeSA9IHIucG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtcyh0KSB7XG4gICAgICBmb3IgKHZhciBlLCByLCBuID0gMCwgaSA9IDAsIGEgPSB0Lmxlbmd0aCwgbyA9IGEgLSAxOyBpIDwgYTsgbyA9IGkrKykge1xuICAgICAgICBuICs9ICgociA9IHRbb10pLnggLSAoZSA9IHRbaV0pLngpICogKGUueSArIHIueSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIHlzLnR5cGVzID0gW1wiVW5rbm93blwiLCBcIlBvaW50XCIsIFwiTGluZVN0cmluZ1wiLCBcIlBvbHlnb25cIl0sIHlzLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3BiZjtcbiAgICAgIHQucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICAgIGZvciAodmFyIGUsIHIgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zLCBuID0gMSwgYSA9IDAsIG8gPSAwLCBzID0gMCwgdSA9IFtdOyB0LnBvcyA8IHI7KSB7XG4gICAgICAgIGlmIChhIDw9IDApIHtcbiAgICAgICAgICB2YXIgbCA9IHQucmVhZFZhcmludCgpO1xuICAgICAgICAgIG4gPSA3ICYgbCwgYSA9IGwgPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLS0sIDEgPT09IG4gfHwgMiA9PT0gbikgbyArPSB0LnJlYWRTVmFyaW50KCksIHMgKz0gdC5yZWFkU1ZhcmludCgpLCAxID09PSBuICYmIChlICYmIHUucHVzaChlKSwgZSA9IFtdKSwgZS5wdXNoKG5ldyBpKG8sIHMpKTtlbHNlIHtcbiAgICAgICAgICBpZiAoNyAhPT0gbikgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjb21tYW5kIFwiICsgbik7XG4gICAgICAgICAgZSAmJiBlLnB1c2goZVswXS5jbG9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiB1LnB1c2goZSksIHU7XG4gICAgfSwgeXMucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3BiZjtcbiAgICAgIHQucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICAgIGZvciAodmFyIGUgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zLCByID0gMSwgbiA9IDAsIGkgPSAwLCBhID0gMCwgbyA9IDEgLyAwLCBzID0gLTEgLyAwLCB1ID0gMSAvIDAsIGwgPSAtMSAvIDA7IHQucG9zIDwgZTspIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHZhciBwID0gdC5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgciA9IDcgJiBwLCBuID0gcCA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4tLSwgMSA9PT0gciB8fCAyID09PSByKSAoaSArPSB0LnJlYWRTVmFyaW50KCkpIDwgbyAmJiAobyA9IGkpLCBpID4gcyAmJiAocyA9IGkpLCAoYSArPSB0LnJlYWRTVmFyaW50KCkpIDwgdSAmJiAodSA9IGEpLCBhID4gbCAmJiAobCA9IGEpO2Vsc2UgaWYgKDcgIT09IHIpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gY29tbWFuZCBcIiArIHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW28sIHUsIHMsIGxdO1xuICAgIH0sIHlzLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBhID0gdGhpcy5leHRlbnQgKiBNYXRoLnBvdygyLCByKSxcbiAgICAgICAgICBvID0gdGhpcy5leHRlbnQgKiB0LFxuICAgICAgICAgIHMgPSB0aGlzLmV4dGVudCAqIGUsXG4gICAgICAgICAgdSA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgICAgbCA9IHlzLnR5cGVzW3RoaXMudHlwZV07XG5cbiAgICAgIGZ1bmN0aW9uIHAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgciA9IHRbZV07XG4gICAgICAgICAgdFtlXSA9IFszNjAgKiAoci54ICsgbykgLyBhIC0gMTgwLCAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKCgxODAgLSAzNjAgKiAoci55ICsgcykgLyBhKSAqIE1hdGguUEkgLyAxODApKSAtIDkwXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdmFyIGMgPSBbXTtcblxuICAgICAgICAgIGZvciAobiA9IDA7IG4gPCB1Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjW25dID0gdVtuXVswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwKHUgPSBjKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZm9yIChuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHAodVtuXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZvciAodSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGUgPD0gMSkgcmV0dXJuIFt0XTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciwgbiwgaSA9IFtdLCBhID0gMDsgYSA8IGU7IGErKykge1xuICAgICAgICAgICAgICB2YXIgbyA9IG1zKHRbYV0pO1xuICAgICAgICAgICAgICAwICE9PSBvICYmICh2b2lkIDAgPT09IG4gJiYgKG4gPSBvIDwgMCksIG4gPT09IG8gPCAwID8gKHIgJiYgaS5wdXNoKHIpLCByID0gW3RbYV1dKSA6IHIucHVzaCh0W2FdKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByICYmIGkucHVzaChyKSwgaTtcbiAgICAgICAgICB9KHUpLCBuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB1W25dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHAodVtuXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIDEgPT09IHUubGVuZ3RoID8gdSA9IHVbMF0gOiBsID0gXCJNdWx0aVwiICsgbDtcbiAgICAgIHZhciBoID0ge1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiBsLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB1XG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBcImlkXCIgaW4gdGhpcyAmJiAoaC5pZCA9IHRoaXMuaWQpLCBoO1xuICAgIH07XG4gICAgdmFyIHZzID0gZ3M7XG5cbiAgICBmdW5jdGlvbiBncyh0LCBlKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSAxLCB0aGlzLm5hbWUgPSBudWxsLCB0aGlzLmV4dGVudCA9IDQwOTYsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5fcGJmID0gdCwgdGhpcy5fa2V5cyA9IFtdLCB0aGlzLl92YWx1ZXMgPSBbXSwgdGhpcy5fZmVhdHVyZXMgPSBbXSwgdC5yZWFkRmllbGRzKHhzLCB0aGlzLCBlKSwgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geHModCwgZSwgcikge1xuICAgICAgMTUgPT09IHQgPyBlLnZlcnNpb24gPSByLnJlYWRWYXJpbnQoKSA6IDEgPT09IHQgPyBlLm5hbWUgPSByLnJlYWRTdHJpbmcoKSA6IDUgPT09IHQgPyBlLmV4dGVudCA9IHIucmVhZFZhcmludCgpIDogMiA9PT0gdCA/IGUuX2ZlYXR1cmVzLnB1c2goci5wb3MpIDogMyA9PT0gdCA/IGUuX2tleXMucHVzaChyLnJlYWRTdHJpbmcoKSkgOiA0ID09PSB0ICYmIGUuX3ZhbHVlcy5wdXNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBudWxsLCByID0gdC5yZWFkVmFyaW50KCkgKyB0LnBvczsgdC5wb3MgPCByOykge1xuICAgICAgICAgIHZhciBuID0gdC5yZWFkVmFyaW50KCkgPj4gMztcbiAgICAgICAgICBlID0gMSA9PT0gbiA/IHQucmVhZFN0cmluZygpIDogMiA9PT0gbiA/IHQucmVhZEZsb2F0KCkgOiAzID09PSBuID8gdC5yZWFkRG91YmxlKCkgOiA0ID09PSBuID8gdC5yZWFkVmFyaW50NjQoKSA6IDUgPT09IG4gPyB0LnJlYWRWYXJpbnQoKSA6IDYgPT09IG4gPyB0LnJlYWRTVmFyaW50KCkgOiA3ID09PSBuID8gdC5yZWFkQm9vbGVhbigpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnModCwgZSwgcikge1xuICAgICAgaWYgKDMgPT09IHQpIHtcbiAgICAgICAgdmFyIG4gPSBuZXcgdnMociwgci5yZWFkVmFyaW50KCkgKyByLnBvcyk7XG4gICAgICAgIG4ubGVuZ3RoICYmIChlW24ubmFtZV0gPSBuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncy5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodCA8IDAgfHwgdCA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcImZlYXR1cmUgaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIHRoaXMuX3BiZi5wb3MgPSB0aGlzLl9mZWF0dXJlc1t0XTtcblxuICAgICAgdmFyIGUgPSB0aGlzLl9wYmYucmVhZFZhcmludCgpICsgdGhpcy5fcGJmLnBvcztcblxuICAgICAgcmV0dXJuIG5ldyBmcyh0aGlzLl9wYmYsIGUsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xuICAgIH07XG5cbiAgICB2YXIgd3MgPSB7XG4gICAgICBWZWN0b3JUaWxlOiBmdW5jdGlvbiBWZWN0b3JUaWxlKHQsIGUpIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSB0LnJlYWRGaWVsZHMoYnMsIHt9LCBlKTtcbiAgICAgIH0sXG4gICAgICBWZWN0b3JUaWxlRmVhdHVyZTogZnMsXG4gICAgICBWZWN0b3JUaWxlTGF5ZXI6IHZzXG4gICAgfSxcbiAgICAgICAgX3MgPSB3cy5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyxcbiAgICAgICAgQXMgPSBNYXRoLnBvdygyLCAxMyk7XG5cbiAgICBmdW5jdGlvbiBTcyh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICB0LmVtcGxhY2VCYWNrKGUsIHIsIDIgKiBNYXRoLmZsb29yKG4gKiBBcykgKyBvLCBpICogQXMgKiAyLCBhICogQXMgKiAyLCBNYXRoLnJvdW5kKHMpKTtcbiAgICB9XG5cbiAgICB2YXIga3MgPSBmdW5jdGlvbiBrcyh0KSB7XG4gICAgICB0aGlzLnpvb20gPSB0Lnpvb20sIHRoaXMub3ZlcnNjYWxpbmcgPSB0Lm92ZXJzY2FsaW5nLCB0aGlzLmxheWVycyA9IHQubGF5ZXJzLCB0aGlzLmxheWVySWRzID0gdGhpcy5sYXllcnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSksIHRoaXMuaW5kZXggPSB0LmluZGV4LCB0aGlzLmhhc1BhdHRlcm4gPSAhMSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSA9IG5ldyBNaSgpLCB0aGlzLmluZGV4QXJyYXkgPSBuZXcgcWkoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgRmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzU3RhdGVEZXBlbmRlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJcyh0LCBlKSB7XG4gICAgICByZXR1cm4gdC54ID09PSBlLnggJiYgKHQueCA8IDAgfHwgdC54ID4gODE5MikgfHwgdC55ID09PSBlLnkgJiYgKHQueSA8IDAgfHwgdC55ID4gODE5Mik7XG4gICAgfVxuXG4gICAga3MucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuZmVhdHVyZXMgPSBbXSwgdGhpcy5oYXNQYXR0ZXJuID0gb3MoXCJmaWxsLWV4dHJ1c2lvblwiLCB0aGlzLmxheWVycywgZSk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gdDsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dLFxuICAgICAgICAgICAgbyA9IGEuZmVhdHVyZSxcbiAgICAgICAgICAgIHMgPSBhLmlkLFxuICAgICAgICAgICAgdSA9IGEuaW5kZXgsXG4gICAgICAgICAgICBsID0gYS5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgICAgcCA9IHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLm5lZWRHZW9tZXRyeSxcbiAgICAgICAgICAgIGMgPSBqYShvLCBwKTtcblxuICAgICAgICBpZiAodGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIuZmlsdGVyKG5ldyB1aSh0aGlzLnpvb20pLCBjLCByKSkge1xuICAgICAgICAgIHZhciBoID0ge1xuICAgICAgICAgICAgaWQ6IHMsXG4gICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiBsLFxuICAgICAgICAgICAgaW5kZXg6IHUsXG4gICAgICAgICAgICBnZW9tZXRyeTogcCA/IGMuZ2VvbWV0cnkgOiBVYShvKSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG8ucHJvcGVydGllcyxcbiAgICAgICAgICAgIHR5cGU6IG8udHlwZSxcbiAgICAgICAgICAgIHBhdHRlcm5zOiB7fVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5oYXNQYXR0ZXJuID8gdGhpcy5mZWF0dXJlcy5wdXNoKHNzKFwiZmlsbC1leHRydXNpb25cIiwgdGhpcy5sYXllcnMsIGgsIHRoaXMuem9vbSwgZSkpIDogdGhpcy5hZGRGZWF0dXJlKGgsIGguZ2VvbWV0cnksIHUsIHIsIHt9KSwgZS5mZWF0dXJlSW5kZXguaW5zZXJ0KG8sIGguZ2VvbWV0cnksIHUsIGwsIHRoaXMuaW5kZXgsICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGtzLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMuZmVhdHVyZXM7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGEsIGEuZ2VvbWV0cnksIGEuaW5kZXgsIGUsIHIpO1xuICAgICAgfVxuICAgIH0sIGtzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycywgcik7XG4gICAgfSwga3MucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgfSwga3MucHJvdG90eXBlLnVwbG9hZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudXBsb2FkZWQgfHwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwga3MucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnVwbG9hZGVkIHx8ICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGhzKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5KSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSwgdGhpcy51cGxvYWRlZCA9ICEwO1xuICAgIH0sIGtzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCkpO1xuICAgIH0sIGtzLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBvID0gaXMoZSwgNTAwKTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IG9bYV0sIHUgPSAwLCBsID0gMCwgcCA9IHM7IGwgPCBwLmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgICAgdSArPSBwW2xdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSksIGggPSAwLCBmID0gczsgaCA8IGYubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICB2YXIgeSA9IGZbaF07XG4gICAgICAgICAgaWYgKDAgIT09IHkubGVuZ3RoICYmICEoKEIgPSB5KS5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueCA8IDA7XG4gICAgICAgICAgfSkgfHwgQi5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueCA+IDgxOTI7XG4gICAgICAgICAgfSkgfHwgQi5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueSA8IDA7XG4gICAgICAgICAgfSkgfHwgQi5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQueSA+IDgxOTI7XG4gICAgICAgICAgfSkpKSBmb3IgKHZhciBkID0gMCwgbSA9IDA7IG0gPCB5Lmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHlbbV07XG5cbiAgICAgICAgICAgIGlmIChtID49IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGcgPSB5W20gLSAxXTtcblxuICAgICAgICAgICAgICBpZiAoIUlzKHYsIGcpKSB7XG4gICAgICAgICAgICAgICAgYy52ZXJ0ZXhMZW5ndGggKyA0ID4gdWEuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgKGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSB2LnN1YihnKS5fcGVycCgpLl91bml0KCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBnLmRpc3Qodik7XG5cbiAgICAgICAgICAgICAgICBkICsgYiA+IDMyNzY4ICYmIChkID0gMCksIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHYueCwgdi55LCB4LngsIHgueSwgMCwgMCwgZCksIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHYueCwgdi55LCB4LngsIHgueSwgMCwgMSwgZCksIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGcueCwgZy55LCB4LngsIHgueSwgMCwgMCwgZCArPSBiKSwgU3ModGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgZy54LCBnLnksIHgueCwgeC55LCAwLCAxLCBkKTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGMudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayh3LCB3ICsgMiwgdyArIDEpLCB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2sodyArIDEsIHcgKyAyLCB3ICsgMyksIGMudmVydGV4TGVuZ3RoICs9IDQsIGMucHJpbWl0aXZlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYy52ZXJ0ZXhMZW5ndGggKyB1ID4gdWEuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgKGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KHUsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSkpLCBcIlBvbHlnb25cIiA9PT0gX3NbdC50eXBlXSkge1xuICAgICAgICAgIGZvciAodmFyIF8gPSBbXSwgQSA9IFtdLCBTID0gYy52ZXJ0ZXhMZW5ndGgsIGsgPSAwLCBJID0gczsgayA8IEkubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB6ID0gSVtrXTtcblxuICAgICAgICAgICAgaWYgKDAgIT09IHoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHogIT09IHNbMF0gJiYgQS5wdXNoKF8ubGVuZ3RoIC8gMik7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgQyA9IDA7IEMgPCB6Lmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIEUgPSB6W0NdO1xuICAgICAgICAgICAgICAgIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIEUueCwgRS55LCAwLCAwLCAxLCAxLCAwKSwgXy5wdXNoKEUueCksIF8ucHVzaChFLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgUCA9IHpvKF8sIEEpLCBNID0gMDsgTSA8IFAubGVuZ3RoOyBNICs9IDMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhTICsgUFtNXSwgUyArIFBbTSArIDJdLCBTICsgUFtNICsgMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMucHJpbWl0aXZlTGVuZ3RoICs9IFAubGVuZ3RoIC8gMywgYy52ZXJ0ZXhMZW5ndGggKz0gdTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgQjtcbiAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnBvcHVsYXRlUGFpbnRBcnJheXModGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGgsIHQsIHIsIGksIG4pO1xuICAgIH0sIE9uKFwiRmlsbEV4dHJ1c2lvbkJ1Y2tldFwiLCBrcywge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCIsIFwiZmVhdHVyZXNcIl1cbiAgICB9KTtcblxuICAgIHZhciB6cyA9IHtcbiAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIjogbmV3IHZpKFB0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiBuZXcgZ2koUHRbXCJwYWludF9maWxsLWV4dHJ1c2lvblwiXVtcImZpbGwtZXh0cnVzaW9uLWNvbG9yXCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIjogbmV3IHZpKFB0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIl0pLFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IHZpKFB0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yXCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IG5ldyB4aShQdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tcGF0dGVyblwiXSksXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCI6IG5ldyBnaShQdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24taGVpZ2h0XCJdKSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IG5ldyBnaShQdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tYmFzZVwiXSksXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnRcIjogbmV3IHZpKFB0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiXSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAgICAgQ3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCB6cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcga3ModCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJvKHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCIpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmlzM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcywgdSkge1xuICAgICAgICB2YXIgbCA9IG5vKHQsIHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCIpLCB0aGlzLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIiksIG8uYW5nbGUsIHMpLFxuICAgICAgICAgICAgcCA9IHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCIpLmV2YWx1YXRlKGUsIHIpLFxuICAgICAgICAgICAgYyA9IHRoaXMucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tYmFzZVwiKS5ldmFsdWF0ZShlLCByKSxcbiAgICAgICAgICAgIGggPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbyA9IDAsIHMgPSB0OyBvIDwgcy5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgICAgICAgIGwgPSBbdS54LCB1LnksIDAsIDFdO1xuICAgICAgICAgICAgY28obCwgbCwgZSksIGEucHVzaChuZXcgaShsWzBdIC8gbFszXSwgbFsxXSAvIGxbM10pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfShsLCB1KSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIGZvciAodmFyIGEgPSBbXSwgbyA9IFtdLCBzID0gbls4XSAqIGUsIHUgPSBuWzldICogZSwgbCA9IG5bMTBdICogZSwgcCA9IG5bMTFdICogZSwgYyA9IG5bOF0gKiByLCBoID0gbls5XSAqIHIsIGYgPSBuWzEwXSAqIHIsIHkgPSBuWzExXSAqIHIsIGQgPSAwLCBtID0gdDsgZCA8IG0ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBbXSwgZyA9IFtdLCB4ID0gMCwgYiA9IG1bZF07IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gYlt4XSxcbiAgICAgICAgICAgICAgICAgIF8gPSB3LngsXG4gICAgICAgICAgICAgICAgICBBID0gdy55LFxuICAgICAgICAgICAgICAgICAgUyA9IG5bMF0gKiBfICsgbls0XSAqIEEgKyBuWzEyXSxcbiAgICAgICAgICAgICAgICAgIGsgPSBuWzFdICogXyArIG5bNV0gKiBBICsgblsxM10sXG4gICAgICAgICAgICAgICAgICBJID0gblsyXSAqIF8gKyBuWzZdICogQSArIG5bMTRdLFxuICAgICAgICAgICAgICAgICAgeiA9IG5bM10gKiBfICsgbls3XSAqIEEgKyBuWzE1XSxcbiAgICAgICAgICAgICAgICAgIEMgPSBJICsgbCxcbiAgICAgICAgICAgICAgICAgIEUgPSB6ICsgcCxcbiAgICAgICAgICAgICAgICAgIFAgPSBTICsgYyxcbiAgICAgICAgICAgICAgICAgIE0gPSBrICsgaCxcbiAgICAgICAgICAgICAgICAgIEIgPSBJICsgZixcbiAgICAgICAgICAgICAgICAgIFQgPSB6ICsgeSxcbiAgICAgICAgICAgICAgICAgIFYgPSBuZXcgaSgoUyArIHMpIC8gRSwgKGsgKyB1KSAvIEUpO1xuICAgICAgICAgICAgICBWLnogPSBDIC8gRSwgdi5wdXNoKFYpO1xuICAgICAgICAgICAgICB2YXIgRiA9IG5ldyBpKFAgLyBULCBNIC8gVCk7XG4gICAgICAgICAgICAgIEYueiA9IEIgLyBULCBnLnB1c2goRik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGEucHVzaCh2KSwgby5wdXNoKGcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbYSwgb107XG4gICAgICAgIH0obiwgYywgcCwgdSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgdmFyIG4gPSAxIC8gMDtcbiAgICAgICAgICBaYShyLCBlKSAmJiAobiA9IFBzKHIsIGVbMF0pKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGVbaV0sIG8gPSB0W2ldLCBzID0gMDsgcyA8IGEubGVuZ3RoIC0gMTsgcysrKSB7XG4gICAgICAgICAgICAgIHZhciB1ID0gYVtzXSxcbiAgICAgICAgICAgICAgICAgIGwgPSBbdSwgYVtzICsgMV0sIG9bcyArIDFdLCBvW3NdLCB1XTtcbiAgICAgICAgICAgICAgS2EociwgbCkgJiYgKG4gPSBNYXRoLm1pbihuLCBQcyhyLCBsKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuICE9PSAxIC8gMCAmJiBuO1xuICAgICAgICB9KGZbMF0sIGZbMV0sIGgpO1xuICAgICAgfSwgZTtcbiAgICB9KEFpKTtcblxuICAgIGZ1bmN0aW9uIEVzKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnggKiBlLnggKyB0LnkgKiBlLnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUHModCwgZSkge1xuICAgICAgaWYgKDEgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIHIsIG4gPSAwLCBpID0gZVtuKytdOyAhciB8fCBpLmVxdWFscyhyKTspIHtcbiAgICAgICAgICBpZiAoIShyID0gZVtuKytdKSkgcmV0dXJuIDEgLyAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgdmFyIGEgPSBlW25dLFxuICAgICAgICAgICAgICBvID0gdFswXSxcbiAgICAgICAgICAgICAgcyA9IHIuc3ViKGkpLFxuICAgICAgICAgICAgICB1ID0gYS5zdWIoaSksXG4gICAgICAgICAgICAgIGwgPSBvLnN1YihpKSxcbiAgICAgICAgICAgICAgcCA9IEVzKHMsIHMpLFxuICAgICAgICAgICAgICBjID0gRXMocywgdSksXG4gICAgICAgICAgICAgIGggPSBFcyh1LCB1KSxcbiAgICAgICAgICAgICAgZiA9IEVzKGwsIHMpLFxuICAgICAgICAgICAgICB5ID0gRXMobCwgdSksXG4gICAgICAgICAgICAgIGQgPSBwICogaCAtIGMgKiBjLFxuICAgICAgICAgICAgICBtID0gKGggKiBmIC0gYyAqIHkpIC8gZCxcbiAgICAgICAgICAgICAgdiA9IChwICogeSAtIGMgKiBmKSAvIGQsXG4gICAgICAgICAgICAgIGcgPSBpLnogKiAoMSAtIG0gLSB2KSArIHIueiAqIG0gKyBhLnogKiB2O1xuICAgICAgICAgIGlmIChpc0Zpbml0ZShnKSkgcmV0dXJuIGc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMSAvIDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHggPSAxIC8gMCwgYiA9IDAsIHcgPSBlOyBiIDwgdy5sZW5ndGg7IGIgKz0gMSkge1xuICAgICAgICB4ID0gTWF0aC5taW4oeCwgd1tiXS56KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgdmFyIE1zID0gemkoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3Nfbm9ybWFsXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJhX2RhdGFcIixcbiAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICB0eXBlOiBcIlVpbnQ4XCJcbiAgICB9XSwgNCkubWVtYmVycyxcbiAgICAgICAgQnMgPSB6aShbe1xuICAgICAgbmFtZTogXCJhX3V2X3hcIixcbiAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9zcGxpdF9pbmRleFwiLFxuICAgICAgY29tcG9uZW50czogMSxcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiXG4gICAgfV0pLm1lbWJlcnMsXG4gICAgICAgIFRzID0gd3MuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMsXG4gICAgICAgIFZzID0gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIDM3LjUpLFxuICAgICAgICBGcyA9IE1hdGgucG93KDIsIDE0KSAvIC41LFxuICAgICAgICBEcyA9IGZ1bmN0aW9uIERzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcbiAgICAgIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5vdmVyc2NhbGluZyA9IHQub3ZlcnNjYWxpbmcsIHRoaXMubGF5ZXJzID0gdC5sYXllcnMsIHRoaXMubGF5ZXJJZHMgPSB0aGlzLmxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMuaGFzUGF0dGVybiA9ICExLCB0aGlzLnBhdHRlcm5GZWF0dXJlcyA9IFtdLCB0aGlzLmxpbmVDbGlwc0FycmF5ID0gW10sIHRoaXMuZ3JhZGllbnRzID0ge30sIHRoaXMubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZS5ncmFkaWVudHNbdC5pZF0gPSB7fTtcbiAgICAgIH0pLCB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IEJpKCksIHRoaXMubGF5b3V0VmVydGV4QXJyYXkyID0gbmV3IFRpKCksIHRoaXMuaW5kZXhBcnJheSA9IG5ldyBxaSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IG5ldyBGYSh0LmxheWVycywgdC56b29tKSwgdGhpcy5zZWdtZW50cyA9IG5ldyB1YSgpLCB0aGlzLm1heExpbmVMZW5ndGggPSAwLCB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJJZHMgPSB0aGlzLmxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaXNTdGF0ZURlcGVuZGVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIERzLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLmhhc1BhdHRlcm4gPSBvcyhcImxpbmVcIiwgdGhpcy5sYXllcnMsIGUpO1xuXG4gICAgICBmb3IgKHZhciBuID0gdGhpcy5sYXllcnNbMF0ubGF5b3V0LmdldChcImxpbmUtc29ydC1rZXlcIiksIGkgPSAhbi5pc0NvbnN0YW50KCksIGEgPSBbXSwgbyA9IDAsIHMgPSB0OyBvIDwgcy5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICB2YXIgdSA9IHNbb10sXG4gICAgICAgICAgICBsID0gdS5mZWF0dXJlLFxuICAgICAgICAgICAgcCA9IHUuaWQsXG4gICAgICAgICAgICBjID0gdS5pbmRleCxcbiAgICAgICAgICAgIGggPSB1LnNvdXJjZUxheWVySW5kZXgsXG4gICAgICAgICAgICBmID0gdGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIubmVlZEdlb21ldHJ5LFxuICAgICAgICAgICAgeSA9IGphKGwsIGYpO1xuXG4gICAgICAgIGlmICh0aGlzLmxheWVyc1swXS5fZmVhdHVyZUZpbHRlci5maWx0ZXIobmV3IHVpKHRoaXMuem9vbSksIHksIHIpKSB7XG4gICAgICAgICAgdmFyIGQgPSBpID8gbi5ldmFsdWF0ZSh5LCB7fSwgcikgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICBpZDogcCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGwucHJvcGVydGllcyxcbiAgICAgICAgICAgIHR5cGU6IGwudHlwZSxcbiAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IGgsXG4gICAgICAgICAgICBpbmRleDogYyxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBmID8geS5nZW9tZXRyeSA6IFVhKGwpLFxuICAgICAgICAgICAgcGF0dGVybnM6IHt9LFxuICAgICAgICAgICAgc29ydEtleTogZFxuICAgICAgICAgIH07XG4gICAgICAgICAgYS5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgJiYgYS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgdiA9IDAsIGcgPSBhOyB2IDwgZy5sZW5ndGg7IHYgKz0gMSkge1xuICAgICAgICB2YXIgeCA9IGdbdl0sXG4gICAgICAgICAgICBiID0geC5nZW9tZXRyeSxcbiAgICAgICAgICAgIHcgPSB4LmluZGV4LFxuICAgICAgICAgICAgXyA9IHguc291cmNlTGF5ZXJJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5oYXNQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIEEgPSBzcyhcImxpbmVcIiwgdGhpcy5sYXllcnMsIHgsIHRoaXMuem9vbSwgZSk7XG4gICAgICAgICAgdGhpcy5wYXR0ZXJuRmVhdHVyZXMucHVzaChBKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuYWRkRmVhdHVyZSh4LCBiLCB3LCByLCB7fSk7XG5cbiAgICAgICAgZS5mZWF0dXJlSW5kZXguaW5zZXJ0KHRbd10uZmVhdHVyZSwgYiwgdywgXywgdGhpcy5pbmRleCk7XG4gICAgICB9XG4gICAgfSwgRHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJzLmxlbmd0aCAmJiB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGRhdGVQYWludEFycmF5cyh0LCBlLCB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJzLCByKTtcbiAgICB9LCBEcy5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSB0aGlzLnBhdHRlcm5GZWF0dXJlczsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoYSwgYS5nZW9tZXRyeSwgYS5pbmRleCwgZSwgcik7XG4gICAgICB9XG4gICAgfSwgRHMucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgfSwgRHMucHJvdG90eXBlLnVwbG9hZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudXBsb2FkZWQgfHwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwgRHMucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnVwbG9hZGVkIHx8ICgwICE9PSB0aGlzLmxheW91dFZlcnRleEFycmF5Mi5sZW5ndGggJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyMiA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXkyLCBCcykpLCB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIE1zKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5KSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSwgdGhpcy51cGxvYWRlZCA9ICEwO1xuICAgIH0sIERzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCkpO1xuICAgIH0sIERzLnByb3RvdHlwZS5saW5lRmVhdHVyZUNsaXBzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0LnByb3BlcnRpZXMgJiYgdC5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFwibWFwYm94X2NsaXBfc3RhcnRcIikgJiYgdC5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFwibWFwYm94X2NsaXBfZW5kXCIpKSByZXR1cm4ge1xuICAgICAgICBzdGFydDogK3QucHJvcGVydGllcy5tYXBib3hfY2xpcF9zdGFydCxcbiAgICAgICAgZW5kOiArdC5wcm9wZXJ0aWVzLm1hcGJveF9jbGlwX2VuZFxuICAgICAgfTtcbiAgICB9LCBEcy5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9IHRoaXMubGF5ZXJzWzBdLmxheW91dCxcbiAgICAgICAgICBvID0gYS5nZXQoXCJsaW5lLWpvaW5cIikuZXZhbHVhdGUodCwge30pLFxuICAgICAgICAgIHMgPSBhLmdldChcImxpbmUtY2FwXCIpLFxuICAgICAgICAgIHUgPSBhLmdldChcImxpbmUtbWl0ZXItbGltaXRcIiksXG4gICAgICAgICAgbCA9IGEuZ2V0KFwibGluZS1yb3VuZC1saW1pdFwiKTtcbiAgICAgIHRoaXMubGluZUNsaXBzID0gdGhpcy5saW5lRmVhdHVyZUNsaXBzKHQpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMCwgYyA9IGU7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgIHRoaXMuYWRkTGluZShjW3BdLCB0LCBvLCBzLCB1LCBsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMucG9wdWxhdGVQYWludEFycmF5cyh0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCwgdCwgciwgaSwgbik7XG4gICAgfSwgRHMucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgaWYgKHRoaXMuZGlzdGFuY2UgPSAwLCB0aGlzLnNjYWxlZERpc3RhbmNlID0gMCwgdGhpcy50b3RhbERpc3RhbmNlID0gMCwgdGhpcy5saW5lQ2xpcHMpIHtcbiAgICAgICAgdGhpcy5saW5lQ2xpcHNBcnJheS5wdXNoKHRoaXMubGluZUNsaXBzKTtcblxuICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHQubGVuZ3RoIC0gMTsgbysrKSB7XG4gICAgICAgICAgdGhpcy50b3RhbERpc3RhbmNlICs9IHRbb10uZGlzdCh0W28gKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVNjYWxlZERpc3RhbmNlKCksIHRoaXMubWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KHRoaXMubWF4TGluZUxlbmd0aCwgdGhpcy50b3RhbERpc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcyA9IFwiUG9seWdvblwiID09PSBUc1tlLnR5cGVdLCB1ID0gdC5sZW5ndGg7IHUgPj0gMiAmJiB0W3UgLSAxXS5lcXVhbHModFt1IC0gMl0pOykge1xuICAgICAgICB1LS07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdSAtIDEgJiYgdFtsXS5lcXVhbHModFtsICsgMV0pOykge1xuICAgICAgICBsKys7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHUgPCAocyA/IDMgOiAyKSkpIHtcbiAgICAgICAgXCJiZXZlbFwiID09PSByICYmIChpID0gMS4wNSk7XG4gICAgICAgIHZhciBwLFxuICAgICAgICAgICAgYyA9IHRoaXMub3ZlcnNjYWxpbmcgPD0gMTYgPyAxMjI4ODAgLyAoNTEyICogdGhpcy5vdmVyc2NhbGluZykgOiAwLFxuICAgICAgICAgICAgaCA9IHRoaXMuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQoMTAgKiB1LCB0aGlzLmxheW91dFZlcnRleEFycmF5LCB0aGlzLmluZGV4QXJyYXkpLFxuICAgICAgICAgICAgZiA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBkID0gdm9pZCAwLFxuICAgICAgICAgICAgbSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTIgPSAtMSwgcyAmJiAobSA9IHRbbF0uc3ViKHAgPSB0W3UgLSAyXSkuX3VuaXQoKS5fcGVycCgpKTtcblxuICAgICAgICBmb3IgKHZhciB2ID0gbDsgdiA8IHU7IHYrKykge1xuICAgICAgICAgIGlmICghKHkgPSB2ID09PSB1IC0gMSA/IHMgPyB0W2wgKyAxXSA6IHZvaWQgMCA6IHRbdiArIDFdKSB8fCAhdFt2XS5lcXVhbHMoeSkpIHtcbiAgICAgICAgICAgIG0gJiYgKGQgPSBtKSwgcCAmJiAoZiA9IHApLCBwID0gdFt2XSwgbSA9IHkgPyB5LnN1YihwKS5fdW5pdCgpLl9wZXJwKCkgOiBkO1xuICAgICAgICAgICAgdmFyIGcgPSAoZCA9IGQgfHwgbSkuYWRkKG0pO1xuICAgICAgICAgICAgMCA9PT0gZy54ICYmIDAgPT09IGcueSB8fCBnLl91bml0KCk7XG5cbiAgICAgICAgICAgIHZhciB4ID0gZC54ICogbS54ICsgZC55ICogbS55LFxuICAgICAgICAgICAgICAgIGIgPSBnLnggKiBtLnggKyBnLnkgKiBtLnksXG4gICAgICAgICAgICAgICAgdyA9IDAgIT09IGIgPyAxIC8gYiA6IDEgLyAwLFxuICAgICAgICAgICAgICAgIF8gPSAyICogTWF0aC5zcXJ0KDIgLSAyICogYiksXG4gICAgICAgICAgICAgICAgQSA9IGIgPCBWcyAmJiBmICYmIHksXG4gICAgICAgICAgICAgICAgUyA9IGQueCAqIG0ueSAtIGQueSAqIG0ueCA+IDA7XG5cbiAgICAgICAgICAgIGlmIChBICYmIHYgPiBsKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gcC5kaXN0KGYpO1xuXG4gICAgICAgICAgICAgIGlmIChrID4gMiAqIGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgSSA9IHAuc3ViKHAuc3ViKGYpLl9tdWx0KGMgLyBrKS5fcm91bmQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXN0YW5jZShmLCBJKSwgdGhpcy5hZGRDdXJyZW50VmVydGV4KEksIGQsIDAsIDAsIGgpLCBmID0gSTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeiA9IGYgJiYgeSxcbiAgICAgICAgICAgICAgICBDID0geiA/IHIgOiBzID8gXCJidXR0XCIgOiBuO1xuICAgICAgICAgICAgaWYgKHogJiYgXCJyb3VuZFwiID09PSBDICYmICh3IDwgYSA/IEMgPSBcIm1pdGVyXCIgOiB3IDw9IDIgJiYgKEMgPSBcImZha2Vyb3VuZFwiKSksIFwibWl0ZXJcIiA9PT0gQyAmJiB3ID4gaSAmJiAoQyA9IFwiYmV2ZWxcIiksIFwiYmV2ZWxcIiA9PT0gQyAmJiAodyA+IDIgJiYgKEMgPSBcImZsaXBiZXZlbFwiKSwgdyA8IGkgJiYgKEMgPSBcIm1pdGVyXCIpKSwgZiAmJiB0aGlzLnVwZGF0ZURpc3RhbmNlKGYsIHApLCBcIm1pdGVyXCIgPT09IEMpIGcuX211bHQodyksIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBnLCAwLCAwLCBoKTtlbHNlIGlmIChcImZsaXBiZXZlbFwiID09PSBDKSB7XG4gICAgICAgICAgICAgIGlmICh3ID4gMTAwKSBnID0gbS5tdWx0KC0xKTtlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgRSA9IHcgKiBkLmFkZChtKS5tYWcoKSAvIGQuc3ViKG0pLm1hZygpO1xuXG4gICAgICAgICAgICAgICAgZy5fcGVycCgpLl9tdWx0KEUgKiAoUyA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBnLCAwLCAwLCBoKSwgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGcubXVsdCgtMSksIDAsIDAsIGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcImJldmVsXCIgPT09IEMgfHwgXCJmYWtlcm91bmRcIiA9PT0gQykge1xuICAgICAgICAgICAgICB2YXIgUCA9IC1NYXRoLnNxcnQodyAqIHcgLSAxKSxcbiAgICAgICAgICAgICAgICAgIE0gPSBTID8gUCA6IDAsXG4gICAgICAgICAgICAgICAgICBCID0gUyA/IDAgOiBQO1xuICAgICAgICAgICAgICBpZiAoZiAmJiB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZCwgTSwgQiwgaCksIFwiZmFrZXJvdW5kXCIgPT09IEMpIGZvciAodmFyIFQgPSBNYXRoLnJvdW5kKDE4MCAqIF8gLyBNYXRoLlBJIC8gMjApLCBWID0gMTsgViA8IFQ7IFYrKykge1xuICAgICAgICAgICAgICAgIHZhciBGID0gViAvIFQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoLjUgIT09IEYpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBEID0gRiAtIC41O1xuICAgICAgICAgICAgICAgICAgRiArPSBGICogRCAqIChGIC0gMSkgKiAoKDEuMDkwNCArIHggKiAoeCAqICgzLjU1NjQ1IC0gMS40MzUxOSAqIHgpIC0gMy4yNDUyKSkgKiBEICogRCArICguODQ4MDEzICsgeCAqICguMjE1NjM4ICogeCAtIDEuMDYwMjEpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIEwgPSBtLnN1YihkKS5fbXVsdChGKS5fYWRkKGQpLl91bml0KCkuX211bHQoUyA/IC0xIDogMSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhbGZWZXJ0ZXgocCwgTC54LCBMLnksICExLCBTLCAwLCBoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB5ICYmIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBtLCAtTSwgLUIsIGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcImJ1dHRcIiA9PT0gQykgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGcsIDAsIDAsIGgpO2Vsc2UgaWYgKFwic3F1YXJlXCIgPT09IEMpIHtcbiAgICAgICAgICAgICAgdmFyIFIgPSBmID8gMSA6IC0xO1xuICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZywgUiwgUiwgaCk7XG4gICAgICAgICAgICB9IGVsc2UgXCJyb3VuZFwiID09PSBDICYmIChmICYmICh0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZCwgMCwgMCwgaCksIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBkLCAxLCAxLCBoLCAhMCkpLCB5ICYmICh0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgbSwgLTEsIC0xLCBoLCAhMCksIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBtLCAwLCAwLCBoKSkpO1xuXG4gICAgICAgICAgICBpZiAoQSAmJiB2IDwgdSAtIDEpIHtcbiAgICAgICAgICAgICAgdmFyIE8gPSBwLmRpc3QoeSk7XG5cbiAgICAgICAgICAgICAgaWYgKE8gPiAyICogYykge1xuICAgICAgICAgICAgICAgIHZhciBVID0gcC5hZGQoeS5zdWIocCkuX211bHQoYyAvIE8pLl9yb3VuZCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3RhbmNlKHAsIFUpLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoVSwgbSwgMCwgMCwgaCksIHAgPSBVO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgRHMucHJvdG90eXBlLmFkZEN1cnJlbnRWZXJ0ZXggPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdm9pZCAwID09PSBhICYmIChhID0gITEpO1xuICAgICAgdmFyIG8gPSBlLnkgKiBuIC0gZS54LFxuICAgICAgICAgIHMgPSAtZS55IC0gZS54ICogbjtcbiAgICAgIHRoaXMuYWRkSGFsZlZlcnRleCh0LCBlLnggKyBlLnkgKiByLCBlLnkgLSBlLnggKiByLCBhLCAhMSwgciwgaSksIHRoaXMuYWRkSGFsZlZlcnRleCh0LCBvLCBzLCBhLCAhMCwgLW4sIGkpLCB0aGlzLmRpc3RhbmNlID4gRnMgLyAyICYmIDAgPT09IHRoaXMudG90YWxEaXN0YW5jZSAmJiAodGhpcy5kaXN0YW5jZSA9IDAsIHRoaXMuYWRkQ3VycmVudFZlcnRleCh0LCBlLCByLCBuLCBpLCBhKSk7XG4gICAgfSwgRHMucHJvdG90eXBlLmFkZEhhbGZWZXJ0ZXggPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgdmFyIHMgPSAuNSAqICh0aGlzLmxpbmVDbGlwcyA/IHRoaXMuc2NhbGVkRGlzdGFuY2UgKiAoRnMgLSAxKSA6IHRoaXMuc2NhbGVkRGlzdGFuY2UpO1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjaygodC54IDw8IDEpICsgKG4gPyAxIDogMCksICh0LnkgPDwgMSkgKyAoaSA/IDEgOiAwKSwgTWF0aC5yb3VuZCg2MyAqIGUpICsgMTI4LCBNYXRoLnJvdW5kKDYzICogcikgKyAxMjgsIDEgKyAoMCA9PT0gYSA/IDAgOiBhIDwgMCA/IC0xIDogMSkgfCAoNjMgJiBzKSA8PCAyLCBzID4+IDYpLCB0aGlzLmxpbmVDbGlwcyAmJiB0aGlzLmxheW91dFZlcnRleEFycmF5Mi5lbXBsYWNlQmFjaygodGhpcy5zY2FsZWREaXN0YW5jZSAtIHRoaXMubGluZUNsaXBzLnN0YXJ0KSAvICh0aGlzLmxpbmVDbGlwcy5lbmQgLSB0aGlzLmxpbmVDbGlwcy5zdGFydCksIHRoaXMubGluZUNsaXBzQXJyYXkubGVuZ3RoKTtcbiAgICAgIHZhciB1ID0gby52ZXJ0ZXhMZW5ndGgrKztcbiAgICAgIHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDAgJiYgKHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayh0aGlzLmUxLCB0aGlzLmUyLCB1KSwgby5wcmltaXRpdmVMZW5ndGgrKyksIGkgPyB0aGlzLmUyID0gdSA6IHRoaXMuZTEgPSB1O1xuICAgIH0sIERzLnByb3RvdHlwZS51cGRhdGVTY2FsZWREaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2NhbGVkRGlzdGFuY2UgPSB0aGlzLmxpbmVDbGlwcyA/IHRoaXMubGluZUNsaXBzLnN0YXJ0ICsgKHRoaXMubGluZUNsaXBzLmVuZCAtIHRoaXMubGluZUNsaXBzLnN0YXJ0KSAqIHRoaXMuZGlzdGFuY2UgLyB0aGlzLnRvdGFsRGlzdGFuY2UgOiB0aGlzLmRpc3RhbmNlO1xuICAgIH0sIERzLnByb3RvdHlwZS51cGRhdGVEaXN0YW5jZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLmRpc3RhbmNlICs9IHQuZGlzdChlKSwgdGhpcy51cGRhdGVTY2FsZWREaXN0YW5jZSgpO1xuICAgIH0sIE9uKFwiTGluZUJ1Y2tldFwiLCBEcywge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCIsIFwicGF0dGVybkZlYXR1cmVzXCJdXG4gICAgfSk7XG4gICAgdmFyIExzID0gbmV3IF9pKHtcbiAgICAgIFwibGluZS1jYXBcIjogbmV3IHZpKFB0LmxheW91dF9saW5lW1wibGluZS1jYXBcIl0pLFxuICAgICAgXCJsaW5lLWpvaW5cIjogbmV3IGdpKFB0LmxheW91dF9saW5lW1wibGluZS1qb2luXCJdKSxcbiAgICAgIFwibGluZS1taXRlci1saW1pdFwiOiBuZXcgdmkoUHQubGF5b3V0X2xpbmVbXCJsaW5lLW1pdGVyLWxpbWl0XCJdKSxcbiAgICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiBuZXcgdmkoUHQubGF5b3V0X2xpbmVbXCJsaW5lLXJvdW5kLWxpbWl0XCJdKSxcbiAgICAgIFwibGluZS1zb3J0LWtleVwiOiBuZXcgZ2koUHQubGF5b3V0X2xpbmVbXCJsaW5lLXNvcnQta2V5XCJdKVxuICAgIH0pLFxuICAgICAgICBScyA9IHtcbiAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICBcImxpbmUtb3BhY2l0eVwiOiBuZXcgZ2koUHQucGFpbnRfbGluZVtcImxpbmUtb3BhY2l0eVwiXSksXG4gICAgICAgIFwibGluZS1jb2xvclwiOiBuZXcgZ2koUHQucGFpbnRfbGluZVtcImxpbmUtY29sb3JcIl0pLFxuICAgICAgICBcImxpbmUtdHJhbnNsYXRlXCI6IG5ldyB2aShQdC5wYWludF9saW5lW1wibGluZS10cmFuc2xhdGVcIl0pLFxuICAgICAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfbGluZVtcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiXSksXG4gICAgICAgIFwibGluZS13aWR0aFwiOiBuZXcgZ2koUHQucGFpbnRfbGluZVtcImxpbmUtd2lkdGhcIl0pLFxuICAgICAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IG5ldyBnaShQdC5wYWludF9saW5lW1wibGluZS1nYXAtd2lkdGhcIl0pLFxuICAgICAgICBcImxpbmUtb2Zmc2V0XCI6IG5ldyBnaShQdC5wYWludF9saW5lW1wibGluZS1vZmZzZXRcIl0pLFxuICAgICAgICBcImxpbmUtYmx1clwiOiBuZXcgZ2koUHQucGFpbnRfbGluZVtcImxpbmUtYmx1clwiXSksXG4gICAgICAgIFwibGluZS1kYXNoYXJyYXlcIjogbmV3IGJpKFB0LnBhaW50X2xpbmVbXCJsaW5lLWRhc2hhcnJheVwiXSksXG4gICAgICAgIFwibGluZS1wYXR0ZXJuXCI6IG5ldyB4aShQdC5wYWludF9saW5lW1wibGluZS1wYXR0ZXJuXCJdKSxcbiAgICAgICAgXCJsaW5lLWdyYWRpZW50XCI6IG5ldyB3aShQdC5wYWludF9saW5lW1wibGluZS1ncmFkaWVudFwiXSlcbiAgICAgIH0pLFxuICAgICAgbGF5b3V0OiBMc1xuICAgIH0sXG4gICAgICAgIE9zID0gbmV3IChmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIHIgPSBuZXcgdWkoTWF0aC5mbG9vcihyLnpvb20pLCB7XG4gICAgICAgICAgbm93OiByLm5vdyxcbiAgICAgICAgICBmYWRlRHVyYXRpb246IHIuZmFkZUR1cmF0aW9uLFxuICAgICAgICAgIHpvb21IaXN0b3J5OiByLnpvb21IaXN0b3J5LFxuICAgICAgICAgIHRyYW5zaXRpb246IHIudHJhbnNpdGlvblxuICAgICAgICB9KSwgdC5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZS5jYWxsKHRoaXMsIGUsIHIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoZSwgciwgbiwgaSkge1xuICAgICAgICByZXR1cm4gciA9IGgoe30sIHIsIHtcbiAgICAgICAgICB6b29tOiBNYXRoLmZsb29yKHIuem9vbSlcbiAgICAgICAgfSksIHQucHJvdG90eXBlLmV2YWx1YXRlLmNhbGwodGhpcywgZSwgciwgbiwgaSk7XG4gICAgICB9LCBlO1xuICAgIH0oZ2kpKShScy5wYWludC5wcm9wZXJ0aWVzW1wibGluZS13aWR0aFwiXS5zcGVjaWZpY2F0aW9uKTtcbiAgICBPcy51c2VJbnRlZ2VyWm9vbSA9ICEwO1xuXG4gICAgdmFyIFVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgUnMpLCB0aGlzLmdyYWRpZW50VmVyc2lvbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9oYW5kbGVTcGVjaWFsUGFpbnRQcm9wZXJ0eVVwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIFwibGluZS1ncmFkaWVudFwiID09PSB0ICYmICh0aGlzLnN0ZXBJbnRlcnBvbGFudCA9IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuX3ZhbHVlc1tcImxpbmUtZ3JhZGllbnRcIl0udmFsdWUuZXhwcmVzc2lvbi5fc3R5bGVFeHByZXNzaW9uLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBLZSwgdGhpcy5ncmFkaWVudFZlcnNpb24gPSAodGhpcy5ncmFkaWVudFZlcnNpb24gKyAxKSAlIHMpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZ3JhZGllbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW1wibGluZS1ncmFkaWVudFwiXS52YWx1ZS5leHByZXNzaW9uO1xuICAgICAgfSwgZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICB0LnByb3RvdHlwZS5yZWNhbGN1bGF0ZS5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLnBhaW50Ll92YWx1ZXNbXCJsaW5lLWZsb29yd2lkdGhcIl0gPSBPcy5wb3NzaWJseUV2YWx1YXRlKHRoaXMuX3RyYW5zaXRpb25pbmdQYWludC5fdmFsdWVzW1wibGluZS13aWR0aFwiXS52YWx1ZSwgZSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IERzKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQsXG4gICAgICAgICAgICByID0ganMoZW8oXCJsaW5lLXdpZHRoXCIsIHRoaXMsIGUpLCBlbyhcImxpbmUtZ2FwLXdpZHRoXCIsIHRoaXMsIGUpKSxcbiAgICAgICAgICAgIG4gPSBlbyhcImxpbmUtb2Zmc2V0XCIsIHRoaXMsIGUpO1xuICAgICAgICByZXR1cm4gciAvIDIgKyBNYXRoLmFicyhuKSArIHJvKHRoaXMucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGVcIikpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBhLCBvLCBzKSB7XG4gICAgICAgIHZhciB1ID0gbm8odCwgdGhpcy5wYWludC5nZXQoXCJsaW5lLXRyYW5zbGF0ZVwiKSwgdGhpcy5wYWludC5nZXQoXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIiksIG8uYW5nbGUsIHMpLFxuICAgICAgICAgICAgbCA9IHMgLyAyICoganModGhpcy5wYWludC5nZXQoXCJsaW5lLXdpZHRoXCIpLmV2YWx1YXRlKGUsIHIpLCB0aGlzLnBhaW50LmdldChcImxpbmUtZ2FwLXdpZHRoXCIpLmV2YWx1YXRlKGUsIHIpKSxcbiAgICAgICAgICAgIHAgPSB0aGlzLnBhaW50LmdldChcImxpbmUtb2Zmc2V0XCIpLmV2YWx1YXRlKGUsIHIpO1xuICAgICAgICByZXR1cm4gcCAmJiAobiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBuID0gbmV3IGkoMCwgMCksIGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgZm9yICh2YXIgbyA9IHRbYV0sIHMgPSBbXSwgdSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gb1t1XSxcbiAgICAgICAgICAgICAgICAgIHAgPSBvW3UgKyAxXSxcbiAgICAgICAgICAgICAgICAgIGMgPSAwID09PSB1ID8gbiA6IGwuc3ViKG9bdSAtIDFdKS5fdW5pdCgpLl9wZXJwKCksXG4gICAgICAgICAgICAgICAgICBoID0gdSA9PT0gby5sZW5ndGggLSAxID8gbiA6IHAuc3ViKGwpLl91bml0KCkuX3BlcnAoKSxcbiAgICAgICAgICAgICAgICAgIGYgPSBjLl9hZGQoaCkuX3VuaXQoKTtcblxuICAgICAgICAgICAgICBmLl9tdWx0KDEgLyAoZi54ICogaC54ICsgZi55ICogaC55KSksIHMucHVzaChmLl9tdWx0KGUpLl9hZGQobCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnB1c2gocyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0obiwgcCAqIHMpKSwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBpID0gZVtuXTtcbiAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+PSAzKSBmb3IgKHZhciBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgaWYgKFFhKHQsIGlbYV0pKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoWGEodCwgaSwgcikpIHJldHVybiAhMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0odSwgbiwgbCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5pc1RpbGVDbGlwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LCBlO1xuICAgIH0oQWkpO1xuXG4gICAgZnVuY3Rpb24ganModCwgZSkge1xuICAgICAgcmV0dXJuIGUgPiAwID8gZSArIDIgKiB0IDogdDtcbiAgICB9XG5cbiAgICB2YXIgcXMgPSB6aShbe1xuICAgICAgbmFtZTogXCJhX3Bvc19vZmZzZXRcIixcbiAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfZGF0YVwiLFxuICAgICAgY29tcG9uZW50czogNCxcbiAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfcGl4ZWxvZmZzZXRcIixcbiAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9XSwgNCksXG4gICAgICAgIE5zID0gemkoW3tcbiAgICAgIG5hbWU6IFwiYV9wcm9qZWN0ZWRfcG9zXCIsXG4gICAgICBjb21wb25lbnRzOiAzLFxuICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICB9XSwgNCksXG4gICAgICAgIEtzID0gKHppKFt7XG4gICAgICBuYW1lOiBcImFfZmFkZV9vcGFjaXR5XCIsXG4gICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgdHlwZTogXCJVaW50MzJcIlxuICAgIH1dLCA0KSwgemkoW3tcbiAgICAgIG5hbWU6IFwiYV9wbGFjZWRcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIlVpbnQ4XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfc2hpZnRcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIlxuICAgIH1dKSksXG4gICAgICAgIEdzID0gKHppKFt7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFuY2hvclBvaW50WFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJhbmNob3JQb2ludFlcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwieDFcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwieTFcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwieDJcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwieTJcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICBuYW1lOiBcImZlYXR1cmVJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwic291cmNlTGF5ZXJJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwiYnVja2V0SW5kZXhcIlxuICAgIH1dKSwgemkoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICB0eXBlOiBcIkludDE2XCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfYW5jaG9yX3Bvc1wiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiYV9leHRydWRlXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfV0sIDQpKSxcbiAgICAgICAgWnMgPSB6aShbe1xuICAgICAgbmFtZTogXCJhX3Bvc1wiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJhX3JhZGl1c1wiLFxuICAgICAgY29tcG9uZW50czogMSxcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJhX2ZsYWdzXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgfV0sIDQpO1xuXG4gICAgZnVuY3Rpb24gWHModCwgZSwgcikge1xuICAgICAgcmV0dXJuIHQuc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnRleHQgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHZhciBuID0gZS5sYXlvdXQuZ2V0KFwidGV4dC10cmFuc2Zvcm1cIikuZXZhbHVhdGUociwge30pO1xuICAgICAgICAgIHJldHVybiBcInVwcGVyY2FzZVwiID09PSBuID8gdCA9IHQudG9Mb2NhbGVVcHBlckNhc2UoKSA6IFwibG93ZXJjYXNlXCIgPT09IG4gJiYgKHQgPSB0LnRvTG9jYWxlTG93ZXJDYXNlKCkpLCBzaS5hcHBseUFyYWJpY1NoYXBpbmcgJiYgKHQgPSBzaS5hcHBseUFyYWJpY1NoYXBpbmcodCkpLCB0O1xuICAgICAgICB9KHQudGV4dCwgZSwgcik7XG4gICAgICB9KSwgdDtcbiAgICB9XG5cbiAgICB6aShbe1xuICAgICAgbmFtZTogXCJ0cmlhbmdsZVwiLFxuICAgICAgY29tcG9uZW50czogMyxcbiAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICB9XSksIHppKFt7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFuY2hvclhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiYW5jaG9yWVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwiZ2x5cGhTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJudW1HbHlwaHNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICBuYW1lOiBcInZlcnRleFN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICBuYW1lOiBcImxpbmVTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQzMlwiLFxuICAgICAgbmFtZTogXCJsaW5lTGVuZ3RoXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJzZWdtZW50XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJsb3dlclNpemVcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInVwcGVyU2l6ZVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICBuYW1lOiBcImxpbmVPZmZzZXRYXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgIG5hbWU6IFwibGluZU9mZnNldFlcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDhcIixcbiAgICAgIG5hbWU6IFwid3JpdGluZ01vZGVcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDhcIixcbiAgICAgIG5hbWU6IFwicGxhY2VkT3JpZW50YXRpb25cIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDhcIixcbiAgICAgIG5hbWU6IFwiaGlkZGVuXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQzMlwiLFxuICAgICAgbmFtZTogXCJjcm9zc1RpbGVJRFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJhc3NvY2lhdGVkSWNvbkluZGV4XCJcbiAgICB9XSksIHppKFt7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFuY2hvclhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiYW5jaG9yWVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJyaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJjZW50ZXJKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwibGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJwbGFjZWRJY29uU3ltYm9sSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwidmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcImtleVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidGV4dEJveFN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInRleHRCb3hFbmRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidmVydGljYWxUZXh0Qm94U3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwidmVydGljYWxUZXh0Qm94RW5kSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcImljb25Cb3hTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJpY29uQm94RW5kSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInZlcnRpY2FsSWNvbkJveFN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInZlcnRpY2FsSWNvbkJveEVuZEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJmZWF0dXJlSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcIm51bUhvcml6b250YWxHbHlwaFZlcnRpY2VzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJudW1WZXJ0aWNhbEdseXBoVmVydGljZXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcIm51bUljb25WZXJ0aWNlc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwibnVtVmVydGljYWxJY29uVmVydGljZXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInVzZVJ1bnRpbWVDb2xsaXNpb25DaXJjbGVzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQzMlwiLFxuICAgICAgbmFtZTogXCJjcm9zc1RpbGVJRFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICBuYW1lOiBcInRleHRCb3hTY2FsZVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgbmFtZTogXCJ0ZXh0T2Zmc2V0XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgIG5hbWU6IFwiY29sbGlzaW9uQ2lyY2xlRGlhbWV0ZXJcIlxuICAgIH1dKSwgemkoW3tcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgbmFtZTogXCJvZmZzZXRYXCJcbiAgICB9XSksIHppKFt7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwieVwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ0aWxlVW5pdERpc3RhbmNlRnJvbUFuY2hvclwiXG4gICAgfV0pO1xuXG4gICAgdmFyIEpzID0ge1xuICAgICAgXCIhXCI6IFwi77iVXCIsXG4gICAgICBcIiNcIjogXCLvvINcIixcbiAgICAgICQ6IFwi77yEXCIsXG4gICAgICBcIiVcIjogXCLvvIVcIixcbiAgICAgIFwiJlwiOiBcIu+8hlwiLFxuICAgICAgXCIoXCI6IFwi77i1XCIsXG4gICAgICBcIilcIjogXCLvuLZcIixcbiAgICAgIFwiKlwiOiBcIu+8ilwiLFxuICAgICAgXCIrXCI6IFwi77yLXCIsXG4gICAgICBcIixcIjogXCLvuJBcIixcbiAgICAgIFwiLVwiOiBcIu+4slwiLFxuICAgICAgXCIuXCI6IFwi44O7XCIsXG4gICAgICBcIi9cIjogXCLvvI9cIixcbiAgICAgIFwiOlwiOiBcIu+4k1wiLFxuICAgICAgXCI7XCI6IFwi77iUXCIsXG4gICAgICBcIjxcIjogXCLvuL9cIixcbiAgICAgIFwiPVwiOiBcIu+8nVwiLFxuICAgICAgXCI+XCI6IFwi77mAXCIsXG4gICAgICBcIj9cIjogXCLvuJZcIixcbiAgICAgIFwiQFwiOiBcIu+8oFwiLFxuICAgICAgXCJbXCI6IFwi77mHXCIsXG4gICAgICBcIlxcXFxcIjogXCLvvLxcIixcbiAgICAgIFwiXVwiOiBcIu+5iFwiLFxuICAgICAgXCJeXCI6IFwi77y+XCIsXG4gICAgICBfOiBcIu+4s1wiLFxuICAgICAgXCJgXCI6IFwi772AXCIsXG4gICAgICBcIntcIjogXCLvuLdcIixcbiAgICAgIFwifFwiOiBcIuKAlVwiLFxuICAgICAgXCJ9XCI6IFwi77i4XCIsXG4gICAgICBcIn5cIjogXCLvvZ5cIixcbiAgICAgIFwiwqJcIjogXCLvv6BcIixcbiAgICAgIFwiwqNcIjogXCLvv6FcIixcbiAgICAgIFwiwqVcIjogXCLvv6VcIixcbiAgICAgIFwiwqZcIjogXCLvv6RcIixcbiAgICAgIFwiwqxcIjogXCLvv6JcIixcbiAgICAgIFwiwq9cIjogXCLvv6NcIixcbiAgICAgIFwi4oCTXCI6IFwi77iyXCIsXG4gICAgICBcIuKAlFwiOiBcIu+4sVwiLFxuICAgICAgXCLigJhcIjogXCLvuYNcIixcbiAgICAgIFwi4oCZXCI6IFwi77mEXCIsXG4gICAgICBcIuKAnFwiOiBcIu+5gVwiLFxuICAgICAgXCLigJ1cIjogXCLvuYJcIixcbiAgICAgIFwi4oCmXCI6IFwi77iZXCIsXG4gICAgICBcIuKAp1wiOiBcIuODu1wiLFxuICAgICAgXCLigqlcIjogXCLvv6ZcIixcbiAgICAgIFwi44CBXCI6IFwi77iRXCIsXG4gICAgICBcIuOAglwiOiBcIu+4klwiLFxuICAgICAgXCLjgIhcIjogXCLvuL9cIixcbiAgICAgIFwi44CJXCI6IFwi77mAXCIsXG4gICAgICBcIuOAilwiOiBcIu+4vVwiLFxuICAgICAgXCLjgItcIjogXCLvuL5cIixcbiAgICAgIFwi44CMXCI6IFwi77mBXCIsXG4gICAgICBcIuOAjVwiOiBcIu+5glwiLFxuICAgICAgXCLjgI5cIjogXCLvuYNcIixcbiAgICAgIFwi44CPXCI6IFwi77mEXCIsXG4gICAgICBcIuOAkFwiOiBcIu+4u1wiLFxuICAgICAgXCLjgJFcIjogXCLvuLxcIixcbiAgICAgIFwi44CUXCI6IFwi77i5XCIsXG4gICAgICBcIuOAlVwiOiBcIu+4ulwiLFxuICAgICAgXCLjgJZcIjogXCLvuJdcIixcbiAgICAgIFwi44CXXCI6IFwi77iYXCIsXG4gICAgICBcIu+8gVwiOiBcIu+4lVwiLFxuICAgICAgXCLvvIhcIjogXCLvuLVcIixcbiAgICAgIFwi77yJXCI6IFwi77i2XCIsXG4gICAgICBcIu+8jFwiOiBcIu+4kFwiLFxuICAgICAgXCLvvI1cIjogXCLvuLJcIixcbiAgICAgIFwi77yOXCI6IFwi44O7XCIsXG4gICAgICBcIu+8mlwiOiBcIu+4k1wiLFxuICAgICAgXCLvvJtcIjogXCLvuJRcIixcbiAgICAgIFwi77ycXCI6IFwi77i/XCIsXG4gICAgICBcIu+8nlwiOiBcIu+5gFwiLFxuICAgICAgXCLvvJ9cIjogXCLvuJZcIixcbiAgICAgIFwi77y7XCI6IFwi77mHXCIsXG4gICAgICBcIu+8vVwiOiBcIu+5iFwiLFxuICAgICAgXCLvvL9cIjogXCLvuLNcIixcbiAgICAgIFwi772bXCI6IFwi77i3XCIsXG4gICAgICBcIu+9nFwiOiBcIuKAlVwiLFxuICAgICAgXCLvvZ1cIjogXCLvuLhcIixcbiAgICAgIFwi772fXCI6IFwi77i1XCIsXG4gICAgICBcIu+9oFwiOiBcIu+4tlwiLFxuICAgICAgXCLvvaFcIjogXCLvuJJcIixcbiAgICAgIFwi772iXCI6IFwi77mBXCIsXG4gICAgICBcIu+9o1wiOiBcIu+5glwiXG4gICAgfSxcbiAgICAgICAgSHMgPSBmdW5jdGlvbiBIcyh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSxcbiAgICAgICAgICBvLFxuICAgICAgICAgIHMgPSA4ICogaSAtIG4gLSAxLFxuICAgICAgICAgIHUgPSAoMSA8PCBzKSAtIDEsXG4gICAgICAgICAgbCA9IHUgPj4gMSxcbiAgICAgICAgICBwID0gLTcsXG4gICAgICAgICAgYyA9IHIgPyBpIC0gMSA6IDAsXG4gICAgICAgICAgaCA9IHIgPyAtMSA6IDEsXG4gICAgICAgICAgZiA9IHRbZSArIGNdO1xuXG4gICAgICBmb3IgKGMgKz0gaCwgYSA9IGYgJiAoMSA8PCAtcCkgLSAxLCBmID4+PSAtcCwgcCArPSBzOyBwID4gMDsgYSA9IDI1NiAqIGEgKyB0W2UgKyBjXSwgYyArPSBoLCBwIC09IDgpIHtcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICBmb3IgKG8gPSBhICYgKDEgPDwgLXApIC0gMSwgYSA+Pj0gLXAsIHAgKz0gbjsgcCA+IDA7IG8gPSAyNTYgKiBvICsgdFtlICsgY10sIGMgKz0gaCwgcCAtPSA4KSB7XG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgaWYgKDAgPT09IGEpIGEgPSAxIC0gbDtlbHNlIHtcbiAgICAgICAgaWYgKGEgPT09IHUpIHJldHVybiBvID8gTmFOIDogMSAvIDAgKiAoZiA/IC0xIDogMSk7XG4gICAgICAgIG8gKz0gTWF0aC5wb3coMiwgbiksIGEgLT0gbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZiA/IC0xIDogMSkgKiBvICogTWF0aC5wb3coMiwgYSAtIG4pO1xuICAgIH0sXG4gICAgICAgIFlzID0gZnVuY3Rpb24gWXModCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdmFyIG8sXG4gICAgICAgICAgcyxcbiAgICAgICAgICB1LFxuICAgICAgICAgIGwgPSA4ICogYSAtIGkgLSAxLFxuICAgICAgICAgIHAgPSAoMSA8PCBsKSAtIDEsXG4gICAgICAgICAgYyA9IHAgPj4gMSxcbiAgICAgICAgICBoID0gMjMgPT09IGkgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDAsXG4gICAgICAgICAgZiA9IG4gPyAwIDogYSAtIDEsXG4gICAgICAgICAgeSA9IG4gPyAxIDogLTEsXG4gICAgICAgICAgZCA9IGUgPCAwIHx8IDAgPT09IGUgJiYgMSAvIGUgPCAwID8gMSA6IDA7XG5cbiAgICAgIGZvciAoZSA9IE1hdGguYWJzKGUpLCBpc05hTihlKSB8fCBlID09PSAxIC8gMCA/IChzID0gaXNOYU4oZSkgPyAxIDogMCwgbyA9IHApIDogKG8gPSBNYXRoLmZsb29yKE1hdGgubG9nKGUpIC8gTWF0aC5MTjIpLCBlICogKHUgPSBNYXRoLnBvdygyLCAtbykpIDwgMSAmJiAoby0tLCB1ICo9IDIpLCAoZSArPSBvICsgYyA+PSAxID8gaCAvIHUgOiBoICogTWF0aC5wb3coMiwgMSAtIGMpKSAqIHUgPj0gMiAmJiAobysrLCB1IC89IDIpLCBvICsgYyA+PSBwID8gKHMgPSAwLCBvID0gcCkgOiBvICsgYyA+PSAxID8gKHMgPSAoZSAqIHUgLSAxKSAqIE1hdGgucG93KDIsIGkpLCBvICs9IGMpIDogKHMgPSBlICogTWF0aC5wb3coMiwgYyAtIDEpICogTWF0aC5wb3coMiwgaSksIG8gPSAwKSk7IGkgPj0gODsgdFtyICsgZl0gPSAyNTUgJiBzLCBmICs9IHksIHMgLz0gMjU2LCBpIC09IDgpIHtcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICBmb3IgKG8gPSBvIDw8IGkgfCBzLCBsICs9IGk7IGwgPiAwOyB0W3IgKyBmXSA9IDI1NSAmIG8sIGYgKz0geSwgbyAvPSAyNTYsIGwgLT0gOCkge1xuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHRbciArIGYgLSB5XSB8PSAxMjggKiBkO1xuICAgIH0sXG4gICAgICAgICRzID0gV3M7XG5cbiAgICBmdW5jdGlvbiBXcyh0KSB7XG4gICAgICB0aGlzLmJ1ZiA9IEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodCkgPyB0IDogbmV3IFVpbnQ4QXJyYXkodCB8fCAwKSwgdGhpcy5wb3MgPSAwLCB0aGlzLnR5cGUgPSAwLCB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbiAgICB9XG5cbiAgICBXcy5WYXJpbnQgPSAwLCBXcy5GaXhlZDY0ID0gMSwgV3MuQnl0ZXMgPSAyLCBXcy5GaXhlZDMyID0gNTtcbiAgICB2YXIgUXMgPSBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBUZXh0RGVjb2RlciA/IG51bGwgOiBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpO1xuXG4gICAgZnVuY3Rpb24gdHUodCkge1xuICAgICAgcmV0dXJuIHQudHlwZSA9PT0gV3MuQnl0ZXMgPyB0LnJlYWRWYXJpbnQoKSArIHQucG9zIDogdC5wb3MgKyAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV1KHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiByID8gNDI5NDk2NzI5NiAqIGUgKyAodCA+Pj4gMCkgOiA0Mjk0OTY3Mjk2ICogKGUgPj4+IDApICsgKHQgPj4+IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZSA8PSAxNjM4MyA/IDEgOiBlIDw9IDIwOTcxNTEgPyAyIDogZSA8PSAyNjg0MzU0NTUgPyAzIDogTWF0aC5mbG9vcihNYXRoLmxvZyhlKSAvICg3ICogTWF0aC5MTjIpKTtcbiAgICAgIHIucmVhbGxvYyhuKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHIucG9zIC0gMTsgaSA+PSB0OyBpLS0pIHtcbiAgICAgICAgci5idWZbaSArIG5dID0gci5idWZbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbnUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVWYXJpbnQodFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVTVmFyaW50KHRbcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBlLndyaXRlRmxvYXQodFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3UodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVEb3VibGUodFtyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3UodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGUud3JpdGVCb29sZWFuKHRbcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBlLndyaXRlRml4ZWQzMih0W3JdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsdSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS53cml0ZVNGaXhlZDMyKHRbcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBlLndyaXRlRml4ZWQ2NCh0W3JdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZS53cml0ZVNGaXhlZDY0KHRbcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1KHQsIGUpIHtcbiAgICAgIHJldHVybiAodFtlXSB8IHRbZSArIDFdIDw8IDggfCB0W2UgKyAyXSA8PCAxNikgKyAxNjc3NzIxNiAqIHRbZSArIDNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZ1KHQsIGUsIHIpIHtcbiAgICAgIHRbcl0gPSBlLCB0W3IgKyAxXSA9IGUgPj4+IDgsIHRbciArIDJdID0gZSA+Pj4gMTYsIHRbciArIDNdID0gZSA+Pj4gMjQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geXUodCwgZSkge1xuICAgICAgcmV0dXJuICh0W2VdIHwgdFtlICsgMV0gPDwgOCB8IHRbZSArIDJdIDw8IDE2KSArICh0W2UgKyAzXSA8PCAyNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHUodCwgZSwgcikge1xuICAgICAgMSA9PT0gdCAmJiByLnJlYWRNZXNzYWdlKG11LCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdSh0LCBlLCByKSB7XG4gICAgICBpZiAoMyA9PT0gdCkge1xuICAgICAgICB2YXIgbiA9IHIucmVhZE1lc3NhZ2UodnUsIHt9KSxcbiAgICAgICAgICAgIGkgPSBuLndpZHRoLFxuICAgICAgICAgICAgYSA9IG4uaGVpZ2h0LFxuICAgICAgICAgICAgbyA9IG4ubGVmdCxcbiAgICAgICAgICAgIHMgPSBuLnRvcCxcbiAgICAgICAgICAgIHUgPSBuLmFkdmFuY2U7XG4gICAgICAgIGUucHVzaCh7XG4gICAgICAgICAgaWQ6IG4uaWQsXG4gICAgICAgICAgYml0bWFwOiBuZXcgeG8oe1xuICAgICAgICAgICAgd2lkdGg6IGkgKyA2LFxuICAgICAgICAgICAgaGVpZ2h0OiBhICsgNlxuICAgICAgICAgIH0sIG4uYml0bWFwKSxcbiAgICAgICAgICBtZXRyaWNzOiB7XG4gICAgICAgICAgICB3aWR0aDogaSxcbiAgICAgICAgICAgIGhlaWdodDogYSxcbiAgICAgICAgICAgIGxlZnQ6IG8sXG4gICAgICAgICAgICB0b3A6IHMsXG4gICAgICAgICAgICBhZHZhbmNlOiB1XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2dSh0LCBlLCByKSB7XG4gICAgICAxID09PSB0ID8gZS5pZCA9IHIucmVhZFZhcmludCgpIDogMiA9PT0gdCA/IGUuYml0bWFwID0gci5yZWFkQnl0ZXMoKSA6IDMgPT09IHQgPyBlLndpZHRoID0gci5yZWFkVmFyaW50KCkgOiA0ID09PSB0ID8gZS5oZWlnaHQgPSByLnJlYWRWYXJpbnQoKSA6IDUgPT09IHQgPyBlLmxlZnQgPSByLnJlYWRTVmFyaW50KCkgOiA2ID09PSB0ID8gZS50b3AgPSByLnJlYWRTVmFyaW50KCkgOiA3ID09PSB0ICYmIChlLmFkdmFuY2UgPSByLnJlYWRWYXJpbnQoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3UodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gMCwgaSA9IHQ7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgZSArPSBhLncgKiBhLmgsIHIgPSBNYXRoLm1heChyLCBhLncpO1xuICAgICAgfVxuXG4gICAgICB0LnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGUuaCAtIHQuaDtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBvID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguc3FydChlIC8gLjk1KSksIHIpLFxuICAgICAgICBoOiAxIC8gMFxuICAgICAgfV0sIHMgPSAwLCB1ID0gMCwgbCA9IDAsIHAgPSB0OyBsIDwgcC5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBjID0gcFtsXSwgaCA9IG8ubGVuZ3RoIC0gMTsgaCA+PSAwOyBoLS0pIHtcbiAgICAgICAgICB2YXIgZiA9IG9baF07XG5cbiAgICAgICAgICBpZiAoIShjLncgPiBmLncgfHwgYy5oID4gZi5oKSkge1xuICAgICAgICAgICAgaWYgKGMueCA9IGYueCwgYy55ID0gZi55LCB1ID0gTWF0aC5tYXgodSwgYy55ICsgYy5oKSwgcyA9IE1hdGgubWF4KHMsIGMueCArIGMudyksIGMudyA9PT0gZi53ICYmIGMuaCA9PT0gZi5oKSB7XG4gICAgICAgICAgICAgIHZhciB5ID0gby5wb3AoKTtcbiAgICAgICAgICAgICAgaCA8IG8ubGVuZ3RoICYmIChvW2hdID0geSk7XG4gICAgICAgICAgICB9IGVsc2UgYy5oID09PSBmLmggPyAoZi54ICs9IGMudywgZi53IC09IGMudykgOiBjLncgPT09IGYudyA/IChmLnkgKz0gYy5oLCBmLmggLT0gYy5oKSA6IChvLnB1c2goe1xuICAgICAgICAgICAgICB4OiBmLnggKyBjLncsXG4gICAgICAgICAgICAgIHk6IGYueSxcbiAgICAgICAgICAgICAgdzogZi53IC0gYy53LFxuICAgICAgICAgICAgICBoOiBjLmhcbiAgICAgICAgICAgIH0pLCBmLnkgKz0gYy5oLCBmLmggLT0gYy5oKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHMsXG4gICAgICAgIGg6IHUsXG4gICAgICAgIGZpbGw6IGUgLyAocyAqIHUpIHx8IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgV3MucHJvdG90eXBlID0ge1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWYgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHJlYWRGaWVsZHM6IGZ1bmN0aW9uIHJlYWRGaWVsZHModCwgZSwgcikge1xuICAgICAgICBmb3IgKHIgPSByIHx8IHRoaXMubGVuZ3RoOyB0aGlzLnBvcyA8IHI7KSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgaSA9IG4gPj4gMyxcbiAgICAgICAgICAgICAgYSA9IHRoaXMucG9zO1xuICAgICAgICAgIHRoaXMudHlwZSA9IDcgJiBuLCB0KGksIGUsIHRoaXMpLCB0aGlzLnBvcyA9PT0gYSAmJiB0aGlzLnNraXAobik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24gcmVhZE1lc3NhZ2UodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmllbGRzKHQsIGUsIHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MpO1xuICAgICAgfSxcbiAgICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbiByZWFkRml4ZWQzMigpIHtcbiAgICAgICAgdmFyIHQgPSBodSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gNCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkU0ZpeGVkMzI6IGZ1bmN0aW9uIHJlYWRTRml4ZWQzMigpIHtcbiAgICAgICAgdmFyIHQgPSB5dSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gNCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24gcmVhZEZpeGVkNjQoKSB7XG4gICAgICAgIHZhciB0ID0gaHUodGhpcy5idWYsIHRoaXMucG9zKSArIDQyOTQ5NjcyOTYgKiBodSh0aGlzLmJ1ZiwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zICs9IDgsIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFNGaXhlZDY0OiBmdW5jdGlvbiByZWFkU0ZpeGVkNjQoKSB7XG4gICAgICAgIHZhciB0ID0gaHUodGhpcy5idWYsIHRoaXMucG9zKSArIDQyOTQ5NjcyOTYgKiB5dSh0aGlzLmJ1ZiwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zICs9IDgsIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZEZsb2F0OiBmdW5jdGlvbiByZWFkRmxvYXQoKSB7XG4gICAgICAgIHZhciB0ID0gSHModGhpcy5idWYsIHRoaXMucG9zLCAhMCwgMjMsIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gNCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkRG91YmxlOiBmdW5jdGlvbiByZWFkRG91YmxlKCkge1xuICAgICAgICB2YXIgdCA9IEhzKHRoaXMuYnVmLCB0aGlzLnBvcywgITAsIDUyLCA4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zICs9IDgsIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFZhcmludDogZnVuY3Rpb24gcmVhZFZhcmludCh0KSB7XG4gICAgICAgIHZhciBlLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIG4gPSB0aGlzLmJ1ZjtcbiAgICAgICAgcmV0dXJuIGUgPSAxMjcgJiAociA9IG5bdGhpcy5wb3MrK10pLCByIDwgMTI4ID8gZSA6IChlIHw9ICgxMjcgJiAociA9IG5bdGhpcy5wb3MrK10pKSA8PCA3LCByIDwgMTI4ID8gZSA6IChlIHw9ICgxMjcgJiAociA9IG5bdGhpcy5wb3MrK10pKSA8PCAxNCwgciA8IDEyOCA/IGUgOiAoZSB8PSAoMTI3ICYgKHIgPSBuW3RoaXMucG9zKytdKSkgPDwgMjEsIHIgPCAxMjggPyBlIDogZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICB2YXIgbixcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgYSA9IHIuYnVmO1xuICAgICAgICAgIGlmIChuID0gKDExMiAmIChpID0gYVtyLnBvcysrXSkpID4+IDQsIGkgPCAxMjgpIHJldHVybiBldSh0LCBuLCBlKTtcbiAgICAgICAgICBpZiAobiB8PSAoMTI3ICYgKGkgPSBhW3IucG9zKytdKSkgPDwgMywgaSA8IDEyOCkgcmV0dXJuIGV1KHQsIG4sIGUpO1xuICAgICAgICAgIGlmIChuIHw9ICgxMjcgJiAoaSA9IGFbci5wb3MrK10pKSA8PCAxMCwgaSA8IDEyOCkgcmV0dXJuIGV1KHQsIG4sIGUpO1xuICAgICAgICAgIGlmIChuIHw9ICgxMjcgJiAoaSA9IGFbci5wb3MrK10pKSA8PCAxNywgaSA8IDEyOCkgcmV0dXJuIGV1KHQsIG4sIGUpO1xuICAgICAgICAgIGlmIChuIHw9ICgxMjcgJiAoaSA9IGFbci5wb3MrK10pKSA8PCAyNCwgaSA8IDEyOCkgcmV0dXJuIGV1KHQsIG4sIGUpO1xuICAgICAgICAgIGlmIChuIHw9ICgxICYgKGkgPSBhW3IucG9zKytdKSkgPDwgMzEsIGkgPCAxMjgpIHJldHVybiBldSh0LCBuLCBlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB2YXJpbnQgbm90IG1vcmUgdGhhbiAxMCBieXRlc1wiKTtcbiAgICAgICAgfShlIHw9ICgxNSAmIChyID0gblt0aGlzLnBvc10pKSA8PCAyOCwgdCwgdGhpcykpKSk7XG4gICAgICB9LFxuICAgICAgcmVhZFZhcmludDY0OiBmdW5jdGlvbiByZWFkVmFyaW50NjQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRWYXJpbnQoITApO1xuICAgICAgfSxcbiAgICAgIHJlYWRTVmFyaW50OiBmdW5jdGlvbiByZWFkU1ZhcmludCgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIHQgJSAyID09IDEgPyAodCArIDEpIC8gLTIgOiB0IC8gMjtcbiAgICAgIH0sXG4gICAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24gcmVhZEJvb2xlYW4oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICAgIH0sXG4gICAgICByZWFkU3RyaW5nOiBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBlID0gdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA9IHQsIHQgLSBlID49IDEyICYmIFFzID8gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gUXMuZGVjb2RlKHQuc3ViYXJyYXkoZSwgcikpO1xuICAgICAgICB9KHRoaXMuYnVmLCBlLCB0KSA6IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IFwiXCIsIGkgPSBlOyBpIDwgcjspIHtcbiAgICAgICAgICAgIHZhciBhLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICB1ID0gdFtpXSxcbiAgICAgICAgICAgICAgICBsID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwID0gdSA+IDIzOSA/IDQgOiB1ID4gMjIzID8gMyA6IHUgPiAxOTEgPyAyIDogMTtcbiAgICAgICAgICAgIGlmIChpICsgcCA+IHIpIGJyZWFrO1xuICAgICAgICAgICAgMSA9PT0gcCA/IHUgPCAxMjggJiYgKGwgPSB1KSA6IDIgPT09IHAgPyAxMjggPT0gKDE5MiAmIChhID0gdFtpICsgMV0pKSAmJiAobCA9ICgzMSAmIHUpIDw8IDYgfCA2MyAmIGEpIDw9IDEyNyAmJiAobCA9IG51bGwpIDogMyA9PT0gcCA/IChvID0gdFtpICsgMl0sIDEyOCA9PSAoMTkyICYgKGEgPSB0W2kgKyAxXSkpICYmIDEyOCA9PSAoMTkyICYgbykgJiYgKChsID0gKDE1ICYgdSkgPDwgMTIgfCAoNjMgJiBhKSA8PCA2IHwgNjMgJiBvKSA8PSAyMDQ3IHx8IGwgPj0gNTUyOTYgJiYgbCA8PSA1NzM0MykgJiYgKGwgPSBudWxsKSkgOiA0ID09PSBwICYmIChvID0gdFtpICsgMl0sIHMgPSB0W2kgKyAzXSwgMTI4ID09ICgxOTIgJiAoYSA9IHRbaSArIDFdKSkgJiYgMTI4ID09ICgxOTIgJiBvKSAmJiAxMjggPT0gKDE5MiAmIHMpICYmICgobCA9ICgxNSAmIHUpIDw8IDE4IHwgKDYzICYgYSkgPDwgMTIgfCAoNjMgJiBvKSA8PCA2IHwgNjMgJiBzKSA8PSA2NTUzNSB8fCBsID49IDExMTQxMTIpICYmIChsID0gbnVsbCkpLCBudWxsID09PSBsID8gKGwgPSA2NTUzMywgcCA9IDEpIDogbCA+IDY1NTM1ICYmIChsIC09IDY1NTM2LCBuICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobCA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpLCBsID0gNTYzMjAgfCAxMDIzICYgbCksIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsKSwgaSArPSBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KHRoaXMuYnVmLCBlLCB0KTtcbiAgICAgIH0sXG4gICAgICByZWFkQnl0ZXM6IGZ1bmN0aW9uIHJlYWRCeXRlcygpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgZSA9IHRoaXMuYnVmLnN1YmFycmF5KHRoaXMucG9zLCB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID0gdCwgZTtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkVmFyaW50OiBmdW5jdGlvbiByZWFkUGFja2VkVmFyaW50KHQsIGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gV3MuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkVmFyaW50KGUpKTtcbiAgICAgICAgdmFyIHIgPSB0dSh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IHI7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZFZhcmludChlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkU1ZhcmludDogZnVuY3Rpb24gcmVhZFBhY2tlZFNWYXJpbnQodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBXcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRTVmFyaW50KCkpO1xuICAgICAgICB2YXIgZSA9IHR1KHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbiByZWFkUGFja2VkQm9vbGVhbih0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHZhciBlID0gdHUodGhpcyk7XG5cbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCBlOykge1xuICAgICAgICAgIHQucHVzaCh0aGlzLnJlYWRCb29sZWFuKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZEZsb2F0OiBmdW5jdGlvbiByZWFkUGFja2VkRmxvYXQodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBXcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTtcbiAgICAgICAgdmFyIGUgPSB0dSh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZEZsb2F0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZERvdWJsZTogZnVuY3Rpb24gcmVhZFBhY2tlZERvdWJsZSh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgdmFyIGUgPSB0dSh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbiByZWFkUGFja2VkRml4ZWQzMih0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHZhciBlID0gdHUodGhpcyk7XG5cbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCBlOykge1xuICAgICAgICAgIHQucHVzaCh0aGlzLnJlYWRGaXhlZDMyKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbiByZWFkUGFja2VkU0ZpeGVkMzIodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBXcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTtcbiAgICAgICAgdmFyIGUgPSB0dSh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZFNGaXhlZDMyKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZEZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRQYWNrZWRGaXhlZDY0KHQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gV3MuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkRml4ZWQ2NCgpKTtcbiAgICAgICAgdmFyIGUgPSB0dSh0aGlzKTtcblxuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB7XG4gICAgICAgICAgdC5wdXNoKHRoaXMucmVhZEZpeGVkNjQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRQYWNrZWRTRml4ZWQ2NCh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICB2YXIgZSA9IHR1KHRoaXMpO1xuXG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHtcbiAgICAgICAgICB0LnB1c2godGhpcy5yZWFkU0ZpeGVkNjQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICBza2lwOiBmdW5jdGlvbiBza2lwKHQpIHtcbiAgICAgICAgdmFyIGUgPSA3ICYgdDtcbiAgICAgICAgaWYgKGUgPT09IFdzLlZhcmludCkgZm9yICg7IHRoaXMuYnVmW3RoaXMucG9zKytdID4gMTI3Oykge1xuICAgICAgICAgIDtcbiAgICAgICAgfSBlbHNlIGlmIChlID09PSBXcy5CeXRlcykgdGhpcy5wb3MgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zO2Vsc2UgaWYgKGUgPT09IFdzLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7ZWxzZSB7XG4gICAgICAgICAgaWYgKGUgIT09IFdzLkZpeGVkNjQpIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQgdHlwZTogXCIgKyBlKTtcbiAgICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGVUYWc6IGZ1bmN0aW9uIHdyaXRlVGFnKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh0IDw8IDMgfCBlKTtcbiAgICAgIH0sXG4gICAgICByZWFsbG9jOiBmdW5jdGlvbiByZWFsbG9jKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMubGVuZ3RoIHx8IDE2OyBlIDwgdGhpcy5wb3MgKyB0Oykge1xuICAgICAgICAgIGUgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciByID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gICAgICAgICAgci5zZXQodGhpcy5idWYpLCB0aGlzLmJ1ZiA9IHIsIHRoaXMubGVuZ3RoID0gZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSB0aGlzLnBvcywgdGhpcy5wb3MgPSAwLCB0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB9LFxuICAgICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbiB3cml0ZUZpeGVkMzIodCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCksIGZ1KHRoaXMuYnVmLCB0LCB0aGlzLnBvcyksIHRoaXMucG9zICs9IDQ7XG4gICAgICB9LFxuICAgICAgd3JpdGVTRml4ZWQzMjogZnVuY3Rpb24gd3JpdGVTRml4ZWQzMih0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KSwgZnUodGhpcy5idWYsIHQsIHRoaXMucG9zKSwgdGhpcy5wb3MgKz0gNDtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZpeGVkNjQ6IGZ1bmN0aW9uIHdyaXRlRml4ZWQ2NCh0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KSwgZnUodGhpcy5idWYsIC0xICYgdCwgdGhpcy5wb3MpLCBmdSh0aGlzLmJ1ZiwgTWF0aC5mbG9vcih0ICogKDEgLyA0Mjk0OTY3Mjk2KSksIHRoaXMucG9zICsgNCksIHRoaXMucG9zICs9IDg7XG4gICAgICB9LFxuICAgICAgd3JpdGVTRml4ZWQ2NDogZnVuY3Rpb24gd3JpdGVTRml4ZWQ2NCh0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KSwgZnUodGhpcy5idWYsIC0xICYgdCwgdGhpcy5wb3MpLCBmdSh0aGlzLmJ1ZiwgTWF0aC5mbG9vcih0ICogKDEgLyA0Mjk0OTY3Mjk2KSksIHRoaXMucG9zICsgNCksIHRoaXMucG9zICs9IDg7XG4gICAgICB9LFxuICAgICAgd3JpdGVWYXJpbnQ6IGZ1bmN0aW9uIHdyaXRlVmFyaW50KHQpIHtcbiAgICAgICAgKHQgPSArdCB8fCAwKSA+IDI2ODQzNTQ1NSB8fCB0IDwgMCA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIsIG47XG4gICAgICAgICAgaWYgKHQgPj0gMCA/IChyID0gdCAlIDQyOTQ5NjcyOTYgfCAwLCBuID0gdCAvIDQyOTQ5NjcyOTYgfCAwKSA6IChuID0gfigtdCAvIDQyOTQ5NjcyOTYpLCA0Mjk0OTY3Mjk1IF4gKHIgPSB+KC10ICUgNDI5NDk2NzI5NikpID8gciA9IHIgKyAxIHwgMCA6IChyID0gMCwgbiA9IG4gKyAxIHwgMCkpLCB0ID49IDB4MTAwMDAwMDAwMDAwMDAwMDAgfHwgdCA8IC0weDEwMDAwMDAwMDAwMDAwMDAwKSB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiB2YXJpbnQgZG9lc24ndCBmaXQgaW50byAxMCBieXRlc1wiKTtcbiAgICAgICAgICBlLnJlYWxsb2MoMTApLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCB0ID4+Pj0gNywgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCB0ID4+Pj0gNywgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCB0ID4+Pj0gNywgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCByLmJ1ZltyLnBvc10gPSAxMjcgJiAodCA+Pj49IDcpO1xuICAgICAgICAgIH0ociwgMCwgZSksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICB2YXIgciA9ICg3ICYgdCkgPDwgNDtcbiAgICAgICAgICAgIGUuYnVmW2UucG9zKytdIHw9IHIgfCAoKHQgPj4+PSAzKSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQpKSkpKTtcbiAgICAgICAgICB9KG4sIGUpO1xuICAgICAgICB9KHQsIHRoaXMpIDogKHRoaXMucmVhbGxvYyg0KSwgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAxMjcgJiB0IHwgKHQgPiAxMjcgPyAxMjggOiAwKSwgdCA8PSAxMjcgfHwgKHRoaXMuYnVmW3RoaXMucG9zKytdID0gMTI3ICYgKHQgPj4+PSA3KSB8ICh0ID4gMTI3ID8gMTI4IDogMCksIHQgPD0gMTI3IHx8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDEyNyAmICh0ID4+Pj0gNykgfCAodCA+IDEyNyA/IDEyOCA6IDApLCB0IDw9IDEyNyB8fCAodGhpcy5idWZbdGhpcy5wb3MrK10gPSB0ID4+PiA3ICYgMTI3KSkpKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVNWYXJpbnQ6IGZ1bmN0aW9uIHdyaXRlU1ZhcmludCh0KSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodCA8IDAgPyAyICogLXQgLSAxIDogMiAqIHQpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24gd3JpdGVCb29sZWFuKHQpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChCb29sZWFuKHQpKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVN0cmluZzogZnVuY3Rpb24gd3JpdGVTdHJpbmcodCkge1xuICAgICAgICB0ID0gU3RyaW5nKHQpLCB0aGlzLnJlYWxsb2MoNCAqIHQubGVuZ3RoKSwgdGhpcy5wb3MrKztcbiAgICAgICAgdmFyIGUgPSB0aGlzLnBvcztcblxuICAgICAgICB0aGlzLnBvcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiwgaSwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICBpZiAoKG4gPSBlLmNoYXJDb2RlQXQoYSkpID4gNTUyOTUgJiYgbiA8IDU3MzQ0KSB7XG4gICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgIG4gPiA1NjMxOSB8fCBhICsgMSA9PT0gZS5sZW5ndGggPyAodFtyKytdID0gMjM5LCB0W3IrK10gPSAxOTEsIHRbcisrXSA9IDE4OSkgOiBpID0gbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuIDwgNTYzMjApIHtcbiAgICAgICAgICAgICAgICB0W3IrK10gPSAyMzksIHRbcisrXSA9IDE5MSwgdFtyKytdID0gMTg5LCBpID0gbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG4gPSBpIC0gNTUyOTYgPDwgMTAgfCBuIC0gNTYzMjAgfCA2NTUzNiwgaSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaSAmJiAodFtyKytdID0gMjM5LCB0W3IrK10gPSAxOTEsIHRbcisrXSA9IDE4OSwgaSA9IG51bGwpO1xuXG4gICAgICAgICAgICBuIDwgMTI4ID8gdFtyKytdID0gbiA6IChuIDwgMjA0OCA/IHRbcisrXSA9IG4gPj4gNiB8IDE5MiA6IChuIDwgNjU1MzYgPyB0W3IrK10gPSBuID4+IDEyIHwgMjI0IDogKHRbcisrXSA9IG4gPj4gMTggfCAyNDAsIHRbcisrXSA9IG4gPj4gMTIgJiA2MyB8IDEyOCksIHRbcisrXSA9IG4gPj4gNiAmIDYzIHwgMTI4KSwgdFtyKytdID0gNjMgJiBuIHwgMTI4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MpO1xuXG4gICAgICAgIHZhciByID0gdGhpcy5wb3MgLSBlO1xuICAgICAgICByID49IDEyOCAmJiBydShlLCByLCB0aGlzKSwgdGhpcy5wb3MgPSBlIC0gMSwgdGhpcy53cml0ZVZhcmludChyKSwgdGhpcy5wb3MgKz0gcjtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZsb2F0OiBmdW5jdGlvbiB3cml0ZUZsb2F0KHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpLCBZcyh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MsICEwLCAyMywgNCksIHRoaXMucG9zICs9IDQ7XG4gICAgICB9LFxuICAgICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uIHdyaXRlRG91YmxlKHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpLCBZcyh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MsICEwLCA1MiwgOCksIHRoaXMucG9zICs9IDg7XG4gICAgICB9LFxuICAgICAgd3JpdGVCeXRlczogZnVuY3Rpb24gd3JpdGVCeXRlcyh0KSB7XG4gICAgICAgIHZhciBlID0gdC5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoZSksIHRoaXMucmVhbGxvYyhlKTtcblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGU7IHIrKykge1xuICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdFtyXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlUmF3TWVzc2FnZTogZnVuY3Rpb24gd3JpdGVSYXdNZXNzYWdlKHQsIGUpIHtcbiAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgdmFyIHIgPSB0aGlzLnBvcztcbiAgICAgICAgdChlLCB0aGlzKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnBvcyAtIHI7XG4gICAgICAgIG4gPj0gMTI4ICYmIHJ1KHIsIG4sIHRoaXMpLCB0aGlzLnBvcyA9IHIgLSAxLCB0aGlzLndyaXRlVmFyaW50KG4pLCB0aGlzLnBvcyArPSBuO1xuICAgICAgfSxcbiAgICAgIHdyaXRlTWVzc2FnZTogZnVuY3Rpb24gd3JpdGVNZXNzYWdlKHQsIGUsIHIpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5CeXRlcyksIHRoaXMud3JpdGVSYXdNZXNzYWdlKGUsIHIpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkVmFyaW50OiBmdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludCh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIG51LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uIHdyaXRlUGFja2VkU1ZhcmludCh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIGl1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZEJvb2xlYW46IGZ1bmN0aW9uIHdyaXRlUGFja2VkQm9vbGVhbih0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIHN1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZEZsb2F0OiBmdW5jdGlvbiB3cml0ZVBhY2tlZEZsb2F0KHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgYXUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkRG91YmxlOiBmdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZSh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIG91LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZEZpeGVkMzI6IGZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQzMih0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIHV1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgbHUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgcHUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkNjQodCwgZSkge1xuICAgICAgICBlLmxlbmd0aCAmJiB0aGlzLndyaXRlTWVzc2FnZSh0LCBjdSwgZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVCeXRlc0ZpZWxkOiBmdW5jdGlvbiB3cml0ZUJ5dGVzRmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLkJ5dGVzKSwgdGhpcy53cml0ZUJ5dGVzKGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbiB3cml0ZUZpeGVkMzJGaWVsZCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuRml4ZWQzMiksIHRoaXMud3JpdGVGaXhlZDMyKGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU0ZpeGVkMzJGaWVsZDogZnVuY3Rpb24gd3JpdGVTRml4ZWQzMkZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5GaXhlZDMyKSwgdGhpcy53cml0ZVNGaXhlZDMyKGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbiB3cml0ZUZpeGVkNjRGaWVsZCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuRml4ZWQ2NCksIHRoaXMud3JpdGVGaXhlZDY0KGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24gd3JpdGVTRml4ZWQ2NEZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5GaXhlZDY0KSwgdGhpcy53cml0ZVNGaXhlZDY0KGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uIHdyaXRlVmFyaW50RmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLlZhcmludCksIHRoaXMud3JpdGVWYXJpbnQoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uIHdyaXRlU1ZhcmludEZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5WYXJpbnQpLCB0aGlzLndyaXRlU1ZhcmludChlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbiB3cml0ZVN0cmluZ0ZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5CeXRlcyksIHRoaXMud3JpdGVTdHJpbmcoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVGbG9hdEZpZWxkOiBmdW5jdGlvbiB3cml0ZUZsb2F0RmllbGQodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLkZpeGVkMzIpLCB0aGlzLndyaXRlRmxvYXQoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24gd3JpdGVEb3VibGVGaWVsZCh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuRml4ZWQ2NCksIHRoaXMud3JpdGVEb3VibGUoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uIHdyaXRlQm9vbGVhbkZpZWxkKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludEZpZWxkKHQsIEJvb2xlYW4oZSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgeHUgPSBmdW5jdGlvbiB4dSh0LCBlKSB7XG4gICAgICB2YXIgciA9IGUucGl4ZWxSYXRpbyxcbiAgICAgICAgICBuID0gZS52ZXJzaW9uLFxuICAgICAgICAgIGkgPSBlLnN0cmV0Y2hYLFxuICAgICAgICAgIGEgPSBlLnN0cmV0Y2hZLFxuICAgICAgICAgIG8gPSBlLmNvbnRlbnQ7XG4gICAgICB0aGlzLnBhZGRlZFJlY3QgPSB0LCB0aGlzLnBpeGVsUmF0aW8gPSByLCB0aGlzLnN0cmV0Y2hYID0gaSwgdGhpcy5zdHJldGNoWSA9IGEsIHRoaXMuY29udGVudCA9IG8sIHRoaXMudmVyc2lvbiA9IG47XG4gICAgfSxcbiAgICAgICAgYnUgPSB7XG4gICAgICB0bDoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgYnI6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHRsYnI6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlTaXplOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYnUudGwuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLnBhZGRlZFJlY3QueCArIDEsIHRoaXMucGFkZGVkUmVjdC55ICsgMV07XG4gICAgfSwgYnUuYnIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLnBhZGRlZFJlY3QueCArIHRoaXMucGFkZGVkUmVjdC53IC0gMSwgdGhpcy5wYWRkZWRSZWN0LnkgKyB0aGlzLnBhZGRlZFJlY3QuaCAtIDFdO1xuICAgIH0sIGJ1LnRsYnIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGwuY29uY2F0KHRoaXMuYnIpO1xuICAgIH0sIGJ1LmRpc3BsYXlTaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbKHRoaXMucGFkZGVkUmVjdC53IC0gMikgLyB0aGlzLnBpeGVsUmF0aW8sICh0aGlzLnBhZGRlZFJlY3QuaCAtIDIpIC8gdGhpcy5waXhlbFJhdGlvXTtcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh4dS5wcm90b3R5cGUsIGJ1KTtcblxuICAgIHZhciB3dSA9IGZ1bmN0aW9uIHd1KHQsIGUpIHtcbiAgICAgIHZhciByID0ge30sXG4gICAgICAgICAgbiA9IHt9O1xuICAgICAgdGhpcy5oYXZlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gICAgICB2YXIgaSA9IFtdO1xuICAgICAgdGhpcy5hZGRJbWFnZXModCwgciwgaSksIHRoaXMuYWRkSW1hZ2VzKGUsIG4sIGkpO1xuICAgICAgdmFyIGEgPSBndShpKSxcbiAgICAgICAgICBvID0gbmV3IGJvKHtcbiAgICAgICAgd2lkdGg6IGEudyB8fCAxLFxuICAgICAgICBoZWlnaHQ6IGEuaCB8fCAxXG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgcyBpbiB0KSB7XG4gICAgICAgIHZhciB1ID0gdFtzXSxcbiAgICAgICAgICAgIGwgPSByW3NdLnBhZGRlZFJlY3Q7XG4gICAgICAgIGJvLmNvcHkodS5kYXRhLCBvLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBsLnggKyAxLFxuICAgICAgICAgIHk6IGwueSArIDFcbiAgICAgICAgfSwgdS5kYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcCBpbiBlKSB7XG4gICAgICAgIHZhciBjID0gZVtwXSxcbiAgICAgICAgICAgIGggPSBuW3BdLnBhZGRlZFJlY3QsXG4gICAgICAgICAgICBmID0gaC54ICsgMSxcbiAgICAgICAgICAgIHkgPSBoLnkgKyAxLFxuICAgICAgICAgICAgZCA9IGMuZGF0YS53aWR0aCxcbiAgICAgICAgICAgIG0gPSBjLmRhdGEuaGVpZ2h0O1xuICAgICAgICBiby5jb3B5KGMuZGF0YSwgbywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogZixcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0sIGMuZGF0YSksIGJvLmNvcHkoYy5kYXRhLCBvLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiBtIC0gMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogZixcbiAgICAgICAgICB5OiB5IC0gMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgd2lkdGg6IGQsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH0pLCBiby5jb3B5KGMuZGF0YSwgbywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogZixcbiAgICAgICAgICB5OiB5ICsgbVxuICAgICAgICB9LCB7XG4gICAgICAgICAgd2lkdGg6IGQsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH0pLCBiby5jb3B5KGMuZGF0YSwgbywge1xuICAgICAgICAgIHg6IGQgLSAxLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGYgLSAxLFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgIGhlaWdodDogbVxuICAgICAgICB9KSwgYm8uY29weShjLmRhdGEsIG8sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGYgKyBkLFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgIGhlaWdodDogbVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbWFnZSA9IG8sIHRoaXMuaWNvblBvc2l0aW9ucyA9IHIsIHRoaXMucGF0dGVyblBvc2l0aW9ucyA9IG47XG4gICAgfTtcblxuICAgIHd1LnByb3RvdHlwZS5hZGRJbWFnZXMgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiBpbiB0KSB7XG4gICAgICAgIHZhciBpID0gdFtuXSxcbiAgICAgICAgICAgIGEgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHc6IGkuZGF0YS53aWR0aCArIDIsXG4gICAgICAgICAgaDogaS5kYXRhLmhlaWdodCArIDJcbiAgICAgICAgfTtcbiAgICAgICAgci5wdXNoKGEpLCBlW25dID0gbmV3IHh1KGEsIGkpLCBpLmhhc1JlbmRlckNhbGxiYWNrICYmIHRoaXMuaGF2ZVJlbmRlckNhbGxiYWNrcy5wdXNoKG4pO1xuICAgICAgfVxuICAgIH0sIHd1LnByb3RvdHlwZS5wYXRjaFVwZGF0ZWRJbWFnZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciBpbiB0LmRpc3BhdGNoUmVuZGVyQ2FsbGJhY2tzKHRoaXMuaGF2ZVJlbmRlckNhbGxiYWNrcyksIHQudXBkYXRlZEltYWdlcykge1xuICAgICAgICB0aGlzLnBhdGNoVXBkYXRlZEltYWdlKHRoaXMuaWNvblBvc2l0aW9uc1tyXSwgdC5nZXRJbWFnZShyKSwgZSksIHRoaXMucGF0Y2hVcGRhdGVkSW1hZ2UodGhpcy5wYXR0ZXJuUG9zaXRpb25zW3JdLCB0LmdldEltYWdlKHIpLCBlKTtcbiAgICAgIH1cbiAgICB9LCB3dS5wcm90b3R5cGUucGF0Y2hVcGRhdGVkSW1hZ2UgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHQgJiYgZSAmJiB0LnZlcnNpb24gIT09IGUudmVyc2lvbikge1xuICAgICAgICB0LnZlcnNpb24gPSBlLnZlcnNpb247XG4gICAgICAgIHZhciBuID0gdC50bDtcbiAgICAgICAgci51cGRhdGUoZS5kYXRhLCB2b2lkIDAsIHtcbiAgICAgICAgICB4OiBuWzBdLFxuICAgICAgICAgIHk6IG5bMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgT24oXCJJbWFnZVBvc2l0aW9uXCIsIHh1KSwgT24oXCJJbWFnZUF0bGFzXCIsIHd1KTtcblxuICAgIHZhciBfdSA9IHtcbiAgICAgIGhvcml6b250YWw6IDEsXG4gICAgICB2ZXJ0aWNhbDogMixcbiAgICAgIGhvcml6b250YWxPbmx5OiAzXG4gICAgfSxcbiAgICAgICAgQXUgPSBmdW5jdGlvbiBBdSgpIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAxLCB0aGlzLmZvbnRTdGFjayA9IFwiXCIsIHRoaXMuaW1hZ2VOYW1lID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQXUuZm9yVGV4dCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBBdSgpO1xuICAgICAgcmV0dXJuIHIuc2NhbGUgPSB0IHx8IDEsIHIuZm9udFN0YWNrID0gZSwgcjtcbiAgICB9LCBBdS5mb3JJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG5ldyBBdSgpO1xuICAgICAgcmV0dXJuIGUuaW1hZ2VOYW1lID0gdCwgZTtcbiAgICB9O1xuXG4gICAgdmFyIFN1ID0gZnVuY3Rpb24gU3UoKSB7XG4gICAgICB0aGlzLnRleHQgPSBcIlwiLCB0aGlzLnNlY3Rpb25JbmRleCA9IFtdLCB0aGlzLnNlY3Rpb25zID0gW10sIHRoaXMuaW1hZ2VTZWN0aW9uSUQgPSBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBrdSh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkKSB7XG4gICAgICB2YXIgbSxcbiAgICAgICAgICB2ID0gU3UuZnJvbUZlYXR1cmUodCwgaSk7XG4gICAgICBjID09PSBfdS52ZXJ0aWNhbCAmJiB2LnZlcnRpY2FsaXplUHVuY3R1YXRpb24oKTtcbiAgICAgIHZhciBnID0gc2kucHJvY2Vzc0JpZGlyZWN0aW9uYWxUZXh0LFxuICAgICAgICAgIHggPSBzaS5wcm9jZXNzU3R5bGVkQmlkaXJlY3Rpb25hbFRleHQ7XG5cbiAgICAgIGlmIChnICYmIDEgPT09IHYuc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIG0gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBiID0gMCwgdyA9IGcodi50b1N0cmluZygpLCBCdSh2LCBsLCBhLCBlLCBuLCBmLCB5KSk7IGIgPCB3Lmxlbmd0aDsgYiArPSAxKSB7XG4gICAgICAgICAgdmFyIF8gPSB3W2JdLFxuICAgICAgICAgICAgICBBID0gbmV3IFN1KCk7XG4gICAgICAgICAgQS50ZXh0ID0gXywgQS5zZWN0aW9ucyA9IHYuc2VjdGlvbnM7XG5cbiAgICAgICAgICBmb3IgKHZhciBTID0gMDsgUyA8IF8ubGVuZ3RoOyBTKyspIHtcbiAgICAgICAgICAgIEEuc2VjdGlvbkluZGV4LnB1c2goMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbS5wdXNoKEEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHgpIHtcbiAgICAgICAgbSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBJID0geCh2LnRleHQsIHYuc2VjdGlvbkluZGV4LCBCdSh2LCBsLCBhLCBlLCBuLCBmLCB5KSk7IGsgPCBJLmxlbmd0aDsgayArPSAxKSB7XG4gICAgICAgICAgdmFyIHogPSBJW2tdLFxuICAgICAgICAgICAgICBDID0gbmV3IFN1KCk7XG4gICAgICAgICAgQy50ZXh0ID0gelswXSwgQy5zZWN0aW9uSW5kZXggPSB6WzFdLCBDLnNlY3Rpb25zID0gdi5zZWN0aW9ucywgbS5wdXNoKEMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgbSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSBbXSwgbiA9IHQudGV4dCwgaSA9IDAsIGEgPSAwLCBvID0gZTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICB2YXIgcyA9IG9bYV07XG4gICAgICAgICAgci5wdXNoKHQuc3Vic3RyaW5nKGksIHMpKSwgaSA9IHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaSA8IG4ubGVuZ3RoICYmIHIucHVzaCh0LnN1YnN0cmluZyhpLCBuLmxlbmd0aCkpLCByO1xuICAgICAgfSh2LCBCdSh2LCBsLCBhLCBlLCBuLCBmLCB5KSk7XG5cbiAgICAgIHZhciBFID0gW10sXG4gICAgICAgICAgUCA9IHtcbiAgICAgICAgcG9zaXRpb25lZExpbmVzOiBFLFxuICAgICAgICB0ZXh0OiB2LnRvU3RyaW5nKCksXG4gICAgICAgIHRvcDogcFsxXSxcbiAgICAgICAgYm90dG9tOiBwWzFdLFxuICAgICAgICBsZWZ0OiBwWzBdLFxuICAgICAgICByaWdodDogcFswXSxcbiAgICAgICAgd3JpdGluZ01vZGU6IGMsXG4gICAgICAgIGljb25zSW5UZXh0OiAhMSxcbiAgICAgICAgdmVydGljYWxpemFibGU6ICExXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGggPSAwLCBmID0gLTE3LCB5ID0gMCwgZCA9IDAsIG0gPSBcInJpZ2h0XCIgPT09IHMgPyAxIDogXCJsZWZ0XCIgPT09IHMgPyAwIDogLjUsIHYgPSAwLCBnID0gMCwgeCA9IGk7IGcgPCB4Lmxlbmd0aDsgZyArPSAxKSB7XG4gICAgICAgICAgdmFyIGIgPSB4W2ddO1xuICAgICAgICAgIGIudHJpbSgpO1xuXG4gICAgICAgICAgdmFyIHcgPSBiLmdldE1heFNjYWxlKCksXG4gICAgICAgICAgICAgIF8gPSAyNCAqICh3IC0gMSksXG4gICAgICAgICAgICAgIEEgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGhzOiBbXSxcbiAgICAgICAgICAgIGxpbmVPZmZzZXQ6IDBcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdC5wb3NpdGlvbmVkTGluZXNbdl0gPSBBO1xuICAgICAgICAgIHZhciBTID0gQS5wb3NpdGlvbmVkR2x5cGhzLFxuICAgICAgICAgICAgICBrID0gMDtcblxuICAgICAgICAgIGlmIChiLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBJID0gMDsgSSA8IGIubGVuZ3RoKCk7IEkrKykge1xuICAgICAgICAgICAgICB2YXIgeiA9IGIuZ2V0U2VjdGlvbihJKSxcbiAgICAgICAgICAgICAgICAgIEMgPSBiLmdldFNlY3Rpb25JbmRleChJKSxcbiAgICAgICAgICAgICAgICAgIEUgPSBiLmdldENoYXJDb2RlKEkpLFxuICAgICAgICAgICAgICAgICAgUCA9IDAsXG4gICAgICAgICAgICAgICAgICBNID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgIEIgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgVCA9IG51bGwsXG4gICAgICAgICAgICAgICAgICBWID0gMjQsXG4gICAgICAgICAgICAgICAgICBGID0gISh1ID09PSBfdS5ob3Jpem9udGFsIHx8ICFwICYmICFKbihFKSB8fCBwICYmIChJdVtFXSB8fCAoSyA9IEUsIFpuLkFyYWJpYyhLKSB8fCBabltcIkFyYWJpYyBTdXBwbGVtZW50XCJdKEspIHx8IFpuW1wiQXJhYmljIEV4dGVuZGVkLUFcIl0oSykgfHwgWm5bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcIl0oSykgfHwgWm5bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcIl0oSykpKSk7XG5cbiAgICAgICAgICAgICAgaWYgKHouaW1hZ2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIEQgPSBuW3ouaW1hZ2VOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIUQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIFQgPSB6LmltYWdlTmFtZSwgdC5pY29uc0luVGV4dCA9IHQuaWNvbnNJblRleHQgfHwgITAsIEIgPSBELnBhZGRlZFJlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIEwgPSBELmRpc3BsYXlTaXplO1xuICAgICAgICAgICAgICAgIHouc2NhbGUgPSAyNCAqIHouc2NhbGUgLyBjLCBQID0gXyArICgyNCAtIExbMV0gKiB6LnNjYWxlKSwgViA9IChNID0ge1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IExbMF0sXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IExbMV0sXG4gICAgICAgICAgICAgICAgICBsZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgdG9wOiAtMyxcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2U6IEYgPyBMWzFdIDogTFswXVxuICAgICAgICAgICAgICAgIH0pLmFkdmFuY2U7XG4gICAgICAgICAgICAgICAgdmFyIFIgPSBGID8gTFswXSAqIHouc2NhbGUgLSAyNCAqIHcgOiBMWzFdICogei5zY2FsZSAtIDI0ICogdztcbiAgICAgICAgICAgICAgICBSID4gMCAmJiBSID4gayAmJiAoayA9IFIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBPID0gclt6LmZvbnRTdGFja10sXG4gICAgICAgICAgICAgICAgICAgIFUgPSBPICYmIE9bRV07XG4gICAgICAgICAgICAgICAgaWYgKFUgJiYgVS5yZWN0KSBCID0gVS5yZWN0LCBNID0gVS5tZXRyaWNzO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGogPSBlW3ouZm9udFN0YWNrXSxcbiAgICAgICAgICAgICAgICAgICAgICBxID0gaiAmJiBqW0VdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFxKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIE0gPSBxLm1ldHJpY3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFAgPSAyNCAqICh3IC0gei5zY2FsZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBGID8gKHQudmVydGljYWxpemFibGUgPSAhMCwgUy5wdXNoKHtcbiAgICAgICAgICAgICAgICBnbHlwaDogRSxcbiAgICAgICAgICAgICAgICBpbWFnZU5hbWU6IFQsXG4gICAgICAgICAgICAgICAgeDogaCxcbiAgICAgICAgICAgICAgICB5OiBmICsgUCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogRixcbiAgICAgICAgICAgICAgICBzY2FsZTogei5zY2FsZSxcbiAgICAgICAgICAgICAgICBmb250U3RhY2s6IHouZm9udFN0YWNrLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleDogQyxcbiAgICAgICAgICAgICAgICBtZXRyaWNzOiBNLFxuICAgICAgICAgICAgICAgIHJlY3Q6IEJcbiAgICAgICAgICAgICAgfSksIGggKz0gViAqIHouc2NhbGUgKyBsKSA6IChTLnB1c2goe1xuICAgICAgICAgICAgICAgIGdseXBoOiBFLFxuICAgICAgICAgICAgICAgIGltYWdlTmFtZTogVCxcbiAgICAgICAgICAgICAgICB4OiBoLFxuICAgICAgICAgICAgICAgIHk6IGYgKyBQLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBGLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6LnNjYWxlLFxuICAgICAgICAgICAgICAgIGZvbnRTdGFjazogei5mb250U3RhY2ssXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4OiBDLFxuICAgICAgICAgICAgICAgIG1ldHJpY3M6IE0sXG4gICAgICAgICAgICAgICAgcmVjdDogQlxuICAgICAgICAgICAgICB9KSwgaCArPSBNLmFkdmFuY2UgKiB6LnNjYWxlICsgbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIDAgIT09IFMubGVuZ3RoICYmICh5ID0gTWF0aC5tYXgoaCAtIGwsIHkpLCBWdShTLCAwLCBTLmxlbmd0aCAtIDEsIG0sIGspKSwgaCA9IDA7XG4gICAgICAgICAgICB2YXIgTiA9IGEgKiB3ICsgaztcbiAgICAgICAgICAgIEEubGluZU9mZnNldCA9IE1hdGgubWF4KGssIF8pLCBmICs9IE4sIGQgPSBNYXRoLm1heChOLCBkKSwgKyt2O1xuICAgICAgICAgIH0gZWxzZSBmICs9IGEsICsrdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBLLFxuICAgICAgICAgICAgRyA9IGYgLSAtMTcsXG4gICAgICAgICAgICBaID0gVHUobyksXG4gICAgICAgICAgICBYID0gWi5ob3Jpem9udGFsQWxpZ24sXG4gICAgICAgICAgICBKID0gWi52ZXJ0aWNhbEFsaWduO1xuICAgICAgICAoZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUpIHtcbiAgICAgICAgICB2YXIgbCxcbiAgICAgICAgICAgICAgcCA9IChlIC0gcikgKiBpO1xuICAgICAgICAgIGwgPSBhICE9PSBvID8gLXMgKiBuIC0gLTE3IDogKC1uICogdSArIC41KSAqIG87XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMCwgaCA9IHQ7IGMgPCBoLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gMCwgeSA9IGhbY10ucG9zaXRpb25lZEdseXBoczsgZiA8IHkubGVuZ3RoOyBmICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSB5W2ZdO1xuICAgICAgICAgICAgICBkLnggKz0gcCwgZC55ICs9IGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0LnBvc2l0aW9uZWRMaW5lcywgbSwgWCwgSiwgeSwgZCwgYSwgRywgaS5sZW5ndGgpLCB0LnRvcCArPSAtSiAqIEcsIHQuYm90dG9tID0gdC50b3AgKyBHLCB0LmxlZnQgKz0gLVggKiB5LCB0LnJpZ2h0ID0gdC5sZWZ0ICsgeTtcbiAgICAgIH0oUCwgZSwgciwgbiwgbSwgbywgcywgdSwgYywgbCwgaCwgZCksICFmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgaWYgKDAgIT09IHJbZV0ucG9zaXRpb25lZEdseXBocy5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0oRSkgJiYgUDtcbiAgICB9XG5cbiAgICBTdS5mcm9tRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gbmV3IFN1KCksIG4gPSAwOyBuIDwgdC5zZWN0aW9ucy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgaSA9IHQuc2VjdGlvbnNbbl07XG4gICAgICAgIGkuaW1hZ2UgPyByLmFkZEltYWdlU2VjdGlvbihpKSA6IHIuYWRkVGV4dFNlY3Rpb24oaSwgZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIFN1LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9LCBTdS5wcm90b3R5cGUuZ2V0U2VjdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWN0aW9uc1t0aGlzLnNlY3Rpb25JbmRleFt0XV07XG4gICAgfSwgU3UucHJvdG90eXBlLmdldFNlY3Rpb25JbmRleCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWN0aW9uSW5kZXhbdF07XG4gICAgfSwgU3UucHJvdG90eXBlLmdldENoYXJDb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuY2hhckNvZGVBdCh0KTtcbiAgICB9LCBTdS5wcm90b3R5cGUudmVydGljYWxpemVQdW5jdHVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBcIlwiLCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICB2YXIgbiA9IHQuY2hhckNvZGVBdChyICsgMSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgaSA9IHQuY2hhckNvZGVBdChyIC0gMSkgfHwgbnVsbDtcbiAgICAgICAgICBlICs9IG4gJiYgSG4obikgJiYgIUpzW3RbciArIDFdXSB8fCBpICYmIEhuKGkpICYmICFKc1t0W3IgLSAxXV0gfHwgIUpzW3Rbcl1dID8gdFtyXSA6IEpzW3Rbcl1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KHRoaXMudGV4dCk7XG4gICAgfSwgU3UucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMCwgZSA9IDA7IGUgPCB0aGlzLnRleHQubGVuZ3RoICYmIEl1W3RoaXMudGV4dC5jaGFyQ29kZUF0KGUpXTsgZSsrKSB7XG4gICAgICAgIHQrKztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgciA9IHRoaXMudGV4dC5sZW5ndGgsIG4gPSB0aGlzLnRleHQubGVuZ3RoIC0gMTsgbiA+PSAwICYmIG4gPj0gdCAmJiBJdVt0aGlzLnRleHQuY2hhckNvZGVBdChuKV07IG4tLSkge1xuICAgICAgICByLS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcodCwgciksIHRoaXMuc2VjdGlvbkluZGV4ID0gdGhpcy5zZWN0aW9uSW5kZXguc2xpY2UodCwgcik7XG4gICAgfSwgU3UucHJvdG90eXBlLnN1YnN0cmluZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBTdSgpO1xuICAgICAgcmV0dXJuIHIudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcodCwgZSksIHIuc2VjdGlvbkluZGV4ID0gdGhpcy5zZWN0aW9uSW5kZXguc2xpY2UodCwgZSksIHIuc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLCByO1xuICAgIH0sIFN1LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfSwgU3UucHJvdG90eXBlLmdldE1heFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuc2VjdGlvbkluZGV4LnJlZHVjZShmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZSwgdC5zZWN0aW9uc1tyXS5zY2FsZSk7XG4gICAgICB9LCAwKTtcbiAgICB9LCBTdS5wcm90b3R5cGUuYWRkVGV4dFNlY3Rpb24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy50ZXh0ICs9IHQudGV4dCwgdGhpcy5zZWN0aW9ucy5wdXNoKEF1LmZvclRleHQodC5zY2FsZSwgdC5mb250U3RhY2sgfHwgZSkpO1xuXG4gICAgICBmb3IgKHZhciByID0gdGhpcy5zZWN0aW9ucy5sZW5ndGggLSAxLCBuID0gMDsgbiA8IHQudGV4dC5sZW5ndGg7ICsrbikge1xuICAgICAgICB0aGlzLnNlY3Rpb25JbmRleC5wdXNoKHIpO1xuICAgICAgfVxuICAgIH0sIFN1LnByb3RvdHlwZS5hZGRJbWFnZVNlY3Rpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmltYWdlID8gdC5pbWFnZS5uYW1lIDogXCJcIjtcblxuICAgICAgaWYgKDAgIT09IGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5nZXROZXh0SW1hZ2VTZWN0aW9uQ2hhckNvZGUoKTtcbiAgICAgICAgciA/ICh0aGlzLnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyKSwgdGhpcy5zZWN0aW9ucy5wdXNoKEF1LmZvckltYWdlKGUpKSwgdGhpcy5zZWN0aW9uSW5kZXgucHVzaCh0aGlzLnNlY3Rpb25zLmxlbmd0aCAtIDEpKSA6IEEoXCJSZWFjaGVkIG1heGltdW0gbnVtYmVyIG9mIGltYWdlcyA2NDAxXCIpO1xuICAgICAgfSBlbHNlIEEoXCJDYW4ndCBhZGQgRm9ybWF0dGVkU2VjdGlvbiB3aXRoIGFuIGVtcHR5IGltYWdlLlwiKTtcbiAgICB9LCBTdS5wcm90b3R5cGUuZ2V0TmV4dEltYWdlU2VjdGlvbkNoYXJDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VTZWN0aW9uSUQgPyB0aGlzLmltYWdlU2VjdGlvbklEID49IDYzNzQzID8gbnVsbCA6ICsrdGhpcy5pbWFnZVNlY3Rpb25JRCA6ICh0aGlzLmltYWdlU2VjdGlvbklEID0gNTczNDQsIHRoaXMuaW1hZ2VTZWN0aW9uSUQpO1xuICAgIH07XG4gICAgdmFyIEl1ID0ge1xuICAgICAgOTogITAsXG4gICAgICAxMDogITAsXG4gICAgICAxMTogITAsXG4gICAgICAxMjogITAsXG4gICAgICAxMzogITAsXG4gICAgICAzMjogITBcbiAgICB9LFxuICAgICAgICB6dSA9IHt9O1xuXG4gICAgZnVuY3Rpb24gQ3UodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgaWYgKGUuaW1hZ2VOYW1lKSB7XG4gICAgICAgIHZhciBvID0gbltlLmltYWdlTmFtZV07XG4gICAgICAgIHJldHVybiBvID8gby5kaXNwbGF5U2l6ZVswXSAqIGUuc2NhbGUgKiAyNCAvIGEgKyBpIDogMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHMgPSByW2UuZm9udFN0YWNrXSxcbiAgICAgICAgICB1ID0gcyAmJiBzW3RdO1xuICAgICAgcmV0dXJuIHUgPyB1Lm1ldHJpY3MuYWR2YW5jZSAqIGUuc2NhbGUgKyBpIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFdSh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IE1hdGgucG93KHQgLSBlLCAyKTtcbiAgICAgIHJldHVybiBuID8gdCA8IGUgPyBpIC8gMiA6IDIgKiBpIDogaSArIE1hdGguYWJzKHIpICogcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQdSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICByZXR1cm4gMTAgPT09IHQgJiYgKG4gLT0gMWU0KSwgciAmJiAobiArPSAxNTApLCA0MCAhPT0gdCAmJiA2NTI4OCAhPT0gdCB8fCAobiArPSA1MCksIDQxICE9PSBlICYmIDY1Mjg5ICE9PSBlIHx8IChuICs9IDUwKSwgbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNdSh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBmb3IgKHZhciBvID0gbnVsbCwgcyA9IEV1KGUsIHIsIGksIGEpLCB1ID0gMCwgbCA9IG47IHUgPCBsLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIHZhciBwID0gbFt1XSxcbiAgICAgICAgICAgIGMgPSBFdShlIC0gcC54LCByLCBpLCBhKSArIHAuYmFkbmVzcztcbiAgICAgICAgYyA8PSBzICYmIChvID0gcCwgcyA9IGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogdCxcbiAgICAgICAgeDogZSxcbiAgICAgICAgcHJpb3JCcmVhazogbyxcbiAgICAgICAgYmFkbmVzczogc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCdSh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICBpZiAoXCJwb2ludFwiICE9PSBhKSByZXR1cm4gW107XG4gICAgICBpZiAoIXQpIHJldHVybiBbXTtcblxuICAgICAgZm9yICh2YXIgcywgdSA9IFtdLCBsID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IDAsIHMgPSAwOyBzIDwgdC5sZW5ndGgoKTsgcysrKSB7XG4gICAgICAgICAgdmFyIHUgPSB0LmdldFNlY3Rpb24ocyk7XG4gICAgICAgICAgbyArPSBDdSh0LmdldENoYXJDb2RlKHMpLCB1LCBuLCBpLCBlLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvIC8gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKG8gLyByKSk7XG4gICAgICB9KHQsIGUsIHIsIG4sIGksIG8pLCBwID0gdC50ZXh0LmluZGV4T2YoXCLigItcIikgPj0gMCwgYyA9IDAsIGggPSAwOyBoIDwgdC5sZW5ndGgoKTsgaCsrKSB7XG4gICAgICAgIHZhciBmID0gdC5nZXRTZWN0aW9uKGgpLFxuICAgICAgICAgICAgeSA9IHQuZ2V0Q2hhckNvZGUoaCk7XG5cbiAgICAgICAgaWYgKEl1W3ldIHx8IChjICs9IEN1KHksIGYsIG4sIGksIGUsIG8pKSwgaCA8IHQubGVuZ3RoKCkgLSAxKSB7XG4gICAgICAgICAgdmFyIGQgPSAhKChzID0geSkgPCAxMTkwNCB8fCAhKFpuW1wiQm9wb21vZm8gRXh0ZW5kZWRcIl0ocykgfHwgWm4uQm9wb21vZm8ocykgfHwgWm5bXCJDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1wiXShzKSB8fCBabltcIkNKSyBDb21wYXRpYmlsaXR5IElkZW9ncmFwaHNcIl0ocykgfHwgWm5bXCJDSksgQ29tcGF0aWJpbGl0eVwiXShzKSB8fCBabltcIkNKSyBSYWRpY2FscyBTdXBwbGVtZW50XCJdKHMpIHx8IFpuW1wiQ0pLIFN0cm9rZXNcIl0ocykgfHwgWm5bXCJDSksgU3ltYm9scyBhbmQgUHVuY3R1YXRpb25cIl0ocykgfHwgWm5bXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBBXCJdKHMpIHx8IFpuW1wiQ0pLIFVuaWZpZWQgSWRlb2dyYXBoc1wiXShzKSB8fCBabltcIkVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHNcIl0ocykgfHwgWm5bXCJIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1wiXShzKSB8fCBabi5IaXJhZ2FuYShzKSB8fCBabltcIklkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcIl0ocykgfHwgWm5bXCJLYW5neGkgUmFkaWNhbHNcIl0ocykgfHwgWm5bXCJLYXRha2FuYSBQaG9uZXRpYyBFeHRlbnNpb25zXCJdKHMpIHx8IFpuLkthdGFrYW5hKHMpIHx8IFpuW1wiVmVydGljYWwgRm9ybXNcIl0ocykgfHwgWm5bXCJZaSBSYWRpY2Fsc1wiXShzKSB8fCBabltcIllpIFN5bGxhYmxlc1wiXShzKSkpO1xuICAgICAgICAgICh6dVt5XSB8fCBkIHx8IGYuaW1hZ2VOYW1lKSAmJiB1LnB1c2goTXUoaCArIDEsIGMsIGwsIHUsIFB1KHksIHQuZ2V0Q2hhckNvZGUoaCArIDEpLCBkICYmIHApLCAhMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgPyB0KGUucHJpb3JCcmVhaykuY29uY2F0KGUuaW5kZXgpIDogW107XG4gICAgICB9KE11KHQubGVuZ3RoKCksIGMsIGwsIHUsIDAsICEwKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHUodCkge1xuICAgICAgdmFyIGUgPSAuNSxcbiAgICAgICAgICByID0gLjU7XG5cbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgIGUgPSAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgIHIgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICByID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiBlLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiByXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFZ1KHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGlmIChuIHx8IGkpIGZvciAodmFyIGEgPSB0W3JdLCBvID0gKHRbcl0ueCArIGEubWV0cmljcy5hZHZhbmNlICogYS5zY2FsZSkgKiBuLCBzID0gZTsgcyA8PSByOyBzKyspIHtcbiAgICAgICAgdFtzXS54IC09IG8sIHRbc10ueSArPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZ1KHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHZhciBvLFxuICAgICAgICAgIHMgPSB0LmltYWdlO1xuXG4gICAgICBpZiAocy5jb250ZW50KSB7XG4gICAgICAgIHZhciB1ID0gcy5jb250ZW50LFxuICAgICAgICAgICAgbCA9IHMucGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBvID0gW3VbMF0gLyBsLCB1WzFdIC8gbCwgcy5kaXNwbGF5U2l6ZVswXSAtIHVbMl0gLyBsLCBzLmRpc3BsYXlTaXplWzFdIC0gdVszXSAvIGxdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZixcbiAgICAgICAgICB5ID0gZS5sZWZ0ICogYSxcbiAgICAgICAgICBkID0gZS5yaWdodCAqIGE7XG4gICAgICBcIndpZHRoXCIgPT09IHIgfHwgXCJib3RoXCIgPT09IHIgPyAoZiA9IGlbMF0gKyB5IC0gblszXSwgYyA9IGlbMF0gKyBkICsgblsxXSkgOiBjID0gKGYgPSBpWzBdICsgKHkgKyBkIC0gcy5kaXNwbGF5U2l6ZVswXSkgLyAyKSArIHMuZGlzcGxheVNpemVbMF07XG4gICAgICB2YXIgbSA9IGUudG9wICogYSxcbiAgICAgICAgICB2ID0gZS5ib3R0b20gKiBhO1xuICAgICAgcmV0dXJuIFwiaGVpZ2h0XCIgPT09IHIgfHwgXCJib3RoXCIgPT09IHIgPyAocCA9IGlbMV0gKyBtIC0gblswXSwgaCA9IGlbMV0gKyB2ICsgblsyXSkgOiBoID0gKHAgPSBpWzFdICsgKG0gKyB2IC0gcy5kaXNwbGF5U2l6ZVsxXSkgLyAyKSArIHMuZGlzcGxheVNpemVbMV0sIHtcbiAgICAgICAgaW1hZ2U6IHMsXG4gICAgICAgIHRvcDogcCxcbiAgICAgICAgcmlnaHQ6IGMsXG4gICAgICAgIGJvdHRvbTogaCxcbiAgICAgICAgbGVmdDogZixcbiAgICAgICAgY29sbGlzaW9uUGFkZGluZzogb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB6dVsxMF0gPSAhMCwgenVbMzJdID0gITAsIHp1WzM4XSA9ICEwLCB6dVs0MF0gPSAhMCwgenVbNDFdID0gITAsIHp1WzQzXSA9ICEwLCB6dVs0NV0gPSAhMCwgenVbNDddID0gITAsIHp1WzE3M10gPSAhMCwgenVbMTgzXSA9ICEwLCB6dVs4MjAzXSA9ICEwLCB6dVs4MjA4XSA9ICEwLCB6dVs4MjExXSA9ICEwLCB6dVs4MjMxXSA9ICEwO1xuXG4gICAgdmFyIER1ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgciwgbiwgaSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuYW5nbGUgPSBuLCB2b2lkIDAgIT09IGkgJiYgKHRoaXMuc2VnbWVudCA9IGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlKHRoaXMueCwgdGhpcy55LCB0aGlzLmFuZ2xlLCB0aGlzLnNlZ21lbnQpO1xuICAgICAgfSwgZTtcbiAgICB9KGkpO1xuXG4gICAgZnVuY3Rpb24gTHUodCwgZSkge1xuICAgICAgdmFyIHIgPSBlLmV4cHJlc3Npb247XG4gICAgICBpZiAoXCJjb25zdGFudFwiID09PSByLmtpbmQpIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgbGF5b3V0U2l6ZTogci5ldmFsdWF0ZShuZXcgdWkodCArIDEpKVxuICAgICAgfTtcbiAgICAgIGlmIChcInNvdXJjZVwiID09PSByLmtpbmQpIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwic291cmNlXCJcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIG4gPSByLnpvb21TdG9wcywgaSA9IHIuaW50ZXJwb2xhdGlvblR5cGUsIGEgPSAwOyBhIDwgbi5sZW5ndGggJiYgblthXSA8PSB0Oykge1xuICAgICAgICBhKys7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG8gPSBhID0gTWF0aC5tYXgoMCwgYSAtIDEpOyBvIDwgbi5sZW5ndGggJiYgbltvXSA8IHQgKyAxOykge1xuICAgICAgICBvKys7XG4gICAgICB9XG5cbiAgICAgIG8gPSBNYXRoLm1pbihuLmxlbmd0aCAtIDEsIG8pO1xuICAgICAgdmFyIHMgPSBuW2FdLFxuICAgICAgICAgIHUgPSBuW29dO1xuICAgICAgcmV0dXJuIFwiY29tcG9zaXRlXCIgPT09IHIua2luZCA/IHtcbiAgICAgICAga2luZDogXCJjb21wb3NpdGVcIixcbiAgICAgICAgbWluWm9vbTogcyxcbiAgICAgICAgbWF4Wm9vbTogdSxcbiAgICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IGlcbiAgICAgIH0gOiB7XG4gICAgICAgIGtpbmQ6IFwiY2FtZXJhXCIsXG4gICAgICAgIG1pblpvb206IHMsXG4gICAgICAgIG1heFpvb206IHUsXG4gICAgICAgIG1pblNpemU6IHIuZXZhbHVhdGUobmV3IHVpKHMpKSxcbiAgICAgICAgbWF4U2l6ZTogci5ldmFsdWF0ZShuZXcgdWkodSkpLFxuICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogaVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSdSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUudVNpemUsXG4gICAgICAgICAgaSA9IHIubG93ZXJTaXplO1xuICAgICAgcmV0dXJuIFwic291cmNlXCIgPT09IHQua2luZCA/IGkgLyAxMjggOiBcImNvbXBvc2l0ZVwiID09PSB0LmtpbmQgPyBHZShpIC8gMTI4LCByLnVwcGVyU2l6ZSAvIDEyOCwgZS51U2l6ZVQpIDogbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPdSh0LCBlKSB7XG4gICAgICB2YXIgciA9IDAsXG4gICAgICAgICAgbiA9IDA7XG4gICAgICBpZiAoXCJjb25zdGFudFwiID09PSB0LmtpbmQpIG4gPSB0LmxheW91dFNpemU7ZWxzZSBpZiAoXCJzb3VyY2VcIiAhPT0gdC5raW5kKSB7XG4gICAgICAgIHZhciBpID0gdC5pbnRlcnBvbGF0aW9uVHlwZSxcbiAgICAgICAgICAgIGEgPSBpID8gcChvci5pbnRlcnBvbGF0aW9uRmFjdG9yKGksIGUsIHQubWluWm9vbSwgdC5tYXhab29tKSwgMCwgMSkgOiAwO1xuICAgICAgICBcImNhbWVyYVwiID09PSB0LmtpbmQgPyBuID0gR2UodC5taW5TaXplLCB0Lm1heFNpemUsIGEpIDogciA9IGE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1U2l6ZVQ6IHIsXG4gICAgICAgIHVTaXplOiBuXG4gICAgICB9O1xuICAgIH1cblxuICAgIE9uKFwiQW5jaG9yXCIsIER1KTtcbiAgICB2YXIgVXUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIGdldFNpemVEYXRhOiBMdSxcbiAgICAgIGV2YWx1YXRlU2l6ZUZvckZlYXR1cmU6IFJ1LFxuICAgICAgZXZhbHVhdGVTaXplRm9yWm9vbTogT3UsXG4gICAgICBTSVpFX1BBQ0tfRkFDVE9SOiAxMjhcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGp1KHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUuc2VnbWVudCkgcmV0dXJuICEwO1xuXG4gICAgICBmb3IgKHZhciBhID0gZSwgbyA9IGUuc2VnbWVudCArIDEsIHMgPSAwOyBzID4gLXIgLyAyOykge1xuICAgICAgICBpZiAoLS1vIDwgMCkgcmV0dXJuICExO1xuICAgICAgICBzIC09IHRbb10uZGlzdChhKSwgYSA9IHRbb107XG4gICAgICB9XG5cbiAgICAgIHMgKz0gdFtvXS5kaXN0KHRbbyArIDFdKSwgbysrO1xuXG4gICAgICBmb3IgKHZhciB1ID0gW10sIGwgPSAwOyBzIDwgciAvIDI7KSB7XG4gICAgICAgIHZhciBwID0gdFtvXSxcbiAgICAgICAgICAgIGMgPSB0W28gKyAxXTtcbiAgICAgICAgaWYgKCFjKSByZXR1cm4gITE7XG4gICAgICAgIHZhciBoID0gdFtvIC0gMV0uYW5nbGVUbyhwKSAtIHAuYW5nbGVUbyhjKTtcblxuICAgICAgICBmb3IgKGggPSBNYXRoLmFicygoaCArIDMgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgLSBNYXRoLlBJKSwgdS5wdXNoKHtcbiAgICAgICAgICBkaXN0YW5jZTogcyxcbiAgICAgICAgICBhbmdsZURlbHRhOiBoXG4gICAgICAgIH0pLCBsICs9IGg7IHMgLSB1WzBdLmRpc3RhbmNlID4gbjspIHtcbiAgICAgICAgICBsIC09IHUuc2hpZnQoKS5hbmdsZURlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGwgPiBpKSByZXR1cm4gITE7XG4gICAgICAgIG8rKywgcyArPSBwLmRpc3QoYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdSh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IDA7IHIgPCB0Lmxlbmd0aCAtIDE7IHIrKykge1xuICAgICAgICBlICs9IHRbcl0uZGlzdCh0W3IgKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE51KHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0ID8gLjYgKiBlICogciA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gS3UodCwgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHQgPyB0LnJpZ2h0IC0gdC5sZWZ0IDogMCwgZSA/IGUucmlnaHQgLSBlLmxlZnQgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHdSh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBmb3IgKHZhciBvID0gTnUociwgaSwgYSksIHMgPSBLdShyLCBuKSAqIGEsIHUgPSAwLCBsID0gcXUodCkgLyAyLCBwID0gMDsgcCA8IHQubGVuZ3RoIC0gMTsgcCsrKSB7XG4gICAgICAgIHZhciBjID0gdFtwXSxcbiAgICAgICAgICAgIGggPSB0W3AgKyAxXSxcbiAgICAgICAgICAgIGYgPSBjLmRpc3QoaCk7XG5cbiAgICAgICAgaWYgKHUgKyBmID4gbCkge1xuICAgICAgICAgIHZhciB5ID0gKGwgLSB1KSAvIGYsXG4gICAgICAgICAgICAgIGQgPSBHZShjLngsIGgueCwgeSksXG4gICAgICAgICAgICAgIG0gPSBHZShjLnksIGgueSwgeSksXG4gICAgICAgICAgICAgIHYgPSBuZXcgRHUoZCwgbSwgaC5hbmdsZVRvKGMpLCBwKTtcbiAgICAgICAgICByZXR1cm4gdi5fcm91bmQoKSwgIW8gfHwganUodCwgdiwgcywgbywgZSkgPyB2IDogdm9pZCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdSArPSBmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFp1KHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUpIHtcbiAgICAgIHZhciBsID0gTnUobiwgYSwgbyksXG4gICAgICAgICAgcCA9IEt1KG4sIGkpLFxuICAgICAgICAgIGMgPSBwICogbyxcbiAgICAgICAgICBoID0gMCA9PT0gdFswXS54IHx8IHRbMF0ueCA9PT0gdSB8fCAwID09PSB0WzBdLnkgfHwgdFswXS55ID09PSB1O1xuICAgICAgcmV0dXJuIGUgLSBjIDwgZSAvIDQgJiYgKGUgPSBjICsgZSAvIDQpLCBmdW5jdGlvbiB0KGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IG8gLyAyLCBjID0gcXUoZSksIGggPSAwLCBmID0gciAtIG4sIHkgPSBbXSwgZCA9IDA7IGQgPCBlLmxlbmd0aCAtIDE7IGQrKykge1xuICAgICAgICAgIGZvciAodmFyIG0gPSBlW2RdLCB2ID0gZVtkICsgMV0sIGcgPSBtLmRpc3QodiksIHggPSB2LmFuZ2xlVG8obSk7IGYgKyBuIDwgaCArIGc7KSB7XG4gICAgICAgICAgICB2YXIgYiA9ICgoZiArPSBuKSAtIGgpIC8gZyxcbiAgICAgICAgICAgICAgICB3ID0gR2UobS54LCB2LngsIGIpLFxuICAgICAgICAgICAgICAgIF8gPSBHZShtLnksIHYueSwgYik7XG5cbiAgICAgICAgICAgIGlmICh3ID49IDAgJiYgdyA8IGwgJiYgXyA+PSAwICYmIF8gPCBsICYmIGYgLSBwID49IDAgJiYgZiArIHAgPD0gYykge1xuICAgICAgICAgICAgICB2YXIgQSA9IG5ldyBEdSh3LCBfLCB4LCBkKTtcbiAgICAgICAgICAgICAgQS5fcm91bmQoKSwgaSAmJiAhanUoZSwgQSwgbywgaSwgYSkgfHwgeS5wdXNoKEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGggKz0gZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1IHx8IHkubGVuZ3RoIHx8IHMgfHwgKHkgPSB0KGUsIGggLyAyLCBuLCBpLCBhLCBvLCBzLCAhMCwgbCkpLCB5O1xuICAgICAgfSh0LCBoID8gZSAvIDIgKiBzICUgZSA6IChwIC8gMiArIDIgKiBhKSAqIG8gKiBzICUgZSwgZSwgbCwgciwgYywgaCwgITEsIHUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFh1KHQsIGUsIHIsIG4sIGEpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSB0W3NdLCBsID0gdm9pZCAwLCBwID0gMDsgcCA8IHUubGVuZ3RoIC0gMTsgcCsrKSB7XG4gICAgICAgICAgdmFyIGMgPSB1W3BdLFxuICAgICAgICAgICAgICBoID0gdVtwICsgMV07XG4gICAgICAgICAgYy54IDwgZSAmJiBoLnggPCBlIHx8IChjLnggPCBlID8gYyA9IG5ldyBpKGUsIGMueSArIChlIC0gYy54KSAvIChoLnggLSBjLngpICogKGgueSAtIGMueSkpLl9yb3VuZCgpIDogaC54IDwgZSAmJiAoaCA9IG5ldyBpKGUsIGMueSArIChlIC0gYy54KSAvIChoLnggLSBjLngpICogKGgueSAtIGMueSkpLl9yb3VuZCgpKSwgYy55IDwgciAmJiBoLnkgPCByIHx8IChjLnkgPCByID8gYyA9IG5ldyBpKGMueCArIChyIC0gYy55KSAvIChoLnkgLSBjLnkpICogKGgueCAtIGMueCksIHIpLl9yb3VuZCgpIDogaC55IDwgciAmJiAoaCA9IG5ldyBpKGMueCArIChyIC0gYy55KSAvIChoLnkgLSBjLnkpICogKGgueCAtIGMueCksIHIpLl9yb3VuZCgpKSwgYy54ID49IG4gJiYgaC54ID49IG4gfHwgKGMueCA+PSBuID8gYyA9IG5ldyBpKG4sIGMueSArIChuIC0gYy54KSAvIChoLnggLSBjLngpICogKGgueSAtIGMueSkpLl9yb3VuZCgpIDogaC54ID49IG4gJiYgKGggPSBuZXcgaShuLCBjLnkgKyAobiAtIGMueCkgLyAoaC54IC0gYy54KSAqIChoLnkgLSBjLnkpKS5fcm91bmQoKSksIGMueSA+PSBhICYmIGgueSA+PSBhIHx8IChjLnkgPj0gYSA/IGMgPSBuZXcgaShjLnggKyAoYSAtIGMueSkgLyAoaC55IC0gYy55KSAqIChoLnggLSBjLngpLCBhKS5fcm91bmQoKSA6IGgueSA+PSBhICYmIChoID0gbmV3IGkoYy54ICsgKGEgLSBjLnkpIC8gKGgueSAtIGMueSkgKiAoaC54IC0gYy54KSwgYSkuX3JvdW5kKCkpLCBsICYmIGMuZXF1YWxzKGxbbC5sZW5ndGggLSAxXSkgfHwgby5wdXNoKGwgPSBbY10pLCBsLnB1c2goaCkpKSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEp1KHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBhID0gW10sXG4gICAgICAgICAgbyA9IHQuaW1hZ2UsXG4gICAgICAgICAgcyA9IG8ucGl4ZWxSYXRpbyxcbiAgICAgICAgICB1ID0gby5wYWRkZWRSZWN0LncgLSAyLFxuICAgICAgICAgIGwgPSBvLnBhZGRlZFJlY3QuaCAtIDIsXG4gICAgICAgICAgcCA9IHQucmlnaHQgLSB0LmxlZnQsXG4gICAgICAgICAgYyA9IHQuYm90dG9tIC0gdC50b3AsXG4gICAgICAgICAgaCA9IG8uc3RyZXRjaFggfHwgW1swLCB1XV0sXG4gICAgICAgICAgZiA9IG8uc3RyZXRjaFkgfHwgW1swLCBsXV0sXG4gICAgICAgICAgeSA9IGZ1bmN0aW9uIHkodCwgZSkge1xuICAgICAgICByZXR1cm4gdCArIGVbMV0gLSBlWzBdO1xuICAgICAgfSxcbiAgICAgICAgICBkID0gaC5yZWR1Y2UoeSwgMCksXG4gICAgICAgICAgbSA9IGYucmVkdWNlKHksIDApLFxuICAgICAgICAgIHYgPSB1IC0gZCxcbiAgICAgICAgICBnID0gbCAtIG0sXG4gICAgICAgICAgeCA9IDAsXG4gICAgICAgICAgYiA9IGQsXG4gICAgICAgICAgdyA9IDAsXG4gICAgICAgICAgXyA9IG0sXG4gICAgICAgICAgQSA9IDAsXG4gICAgICAgICAgUyA9IHYsXG4gICAgICAgICAgayA9IDAsXG4gICAgICAgICAgSSA9IGc7XG5cbiAgICAgIGlmIChvLmNvbnRlbnQgJiYgbikge1xuICAgICAgICB2YXIgeiA9IG8uY29udGVudDtcbiAgICAgICAgeCA9IEh1KGgsIDAsIHpbMF0pLCB3ID0gSHUoZiwgMCwgelsxXSksIGIgPSBIdShoLCB6WzBdLCB6WzJdKSwgXyA9IEh1KGYsIHpbMV0sIHpbM10pLCBBID0gelswXSAtIHgsIGsgPSB6WzFdIC0gdywgUyA9IHpbMl0gLSB6WzBdIC0gYiwgSSA9IHpbM10gLSB6WzFdIC0gXztcbiAgICAgIH1cblxuICAgICAgdmFyIEMgPSBmdW5jdGlvbiBDKG4sIGEsIHUsIGwpIHtcbiAgICAgICAgdmFyIGggPSAkdShuLnN0cmV0Y2ggLSB4LCBiLCBwLCB0LmxlZnQpLFxuICAgICAgICAgICAgZiA9IFd1KG4uZml4ZWQgLSBBLCBTLCBuLnN0cmV0Y2gsIGQpLFxuICAgICAgICAgICAgeSA9ICR1KGEuc3RyZXRjaCAtIHcsIF8sIGMsIHQudG9wKSxcbiAgICAgICAgICAgIHYgPSBXdShhLmZpeGVkIC0gaywgSSwgYS5zdHJldGNoLCBtKSxcbiAgICAgICAgICAgIGcgPSAkdSh1LnN0cmV0Y2ggLSB4LCBiLCBwLCB0LmxlZnQpLFxuICAgICAgICAgICAgeiA9IFd1KHUuZml4ZWQgLSBBLCBTLCB1LnN0cmV0Y2gsIGQpLFxuICAgICAgICAgICAgQyA9ICR1KGwuc3RyZXRjaCAtIHcsIF8sIGMsIHQudG9wKSxcbiAgICAgICAgICAgIEUgPSBXdShsLmZpeGVkIC0gaywgSSwgbC5zdHJldGNoLCBtKSxcbiAgICAgICAgICAgIFAgPSBuZXcgaShoLCB5KSxcbiAgICAgICAgICAgIE0gPSBuZXcgaShnLCB5KSxcbiAgICAgICAgICAgIEIgPSBuZXcgaShnLCBDKSxcbiAgICAgICAgICAgIFQgPSBuZXcgaShoLCBDKSxcbiAgICAgICAgICAgIFYgPSBuZXcgaShmIC8gcywgdiAvIHMpLFxuICAgICAgICAgICAgRiA9IG5ldyBpKHogLyBzLCBFIC8gcyksXG4gICAgICAgICAgICBEID0gZSAqIE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgaWYgKEQpIHtcbiAgICAgICAgICB2YXIgTCA9IE1hdGguc2luKEQpLFxuICAgICAgICAgICAgICBSID0gTWF0aC5jb3MoRCksXG4gICAgICAgICAgICAgIE8gPSBbUiwgLUwsIEwsIFJdO1xuICAgICAgICAgIFAuX21hdE11bHQoTyksIE0uX21hdE11bHQoTyksIFQuX21hdE11bHQoTyksIEIuX21hdE11bHQoTyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgVSA9IG4uc3RyZXRjaCArIG4uZml4ZWQsXG4gICAgICAgICAgICBqID0gYS5zdHJldGNoICsgYS5maXhlZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0bDogUCxcbiAgICAgICAgICB0cjogTSxcbiAgICAgICAgICBibDogVCxcbiAgICAgICAgICBicjogQixcbiAgICAgICAgICB0ZXg6IHtcbiAgICAgICAgICAgIHg6IG8ucGFkZGVkUmVjdC54ICsgMSArIFUsXG4gICAgICAgICAgICB5OiBvLnBhZGRlZFJlY3QueSArIDEgKyBqLFxuICAgICAgICAgICAgdzogdS5zdHJldGNoICsgdS5maXhlZCAtIFUsXG4gICAgICAgICAgICBoOiBsLnN0cmV0Y2ggKyBsLmZpeGVkIC0galxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGluZ01vZGU6IHZvaWQgMCxcbiAgICAgICAgICBnbHlwaE9mZnNldDogWzAsIDBdLFxuICAgICAgICAgIHNlY3Rpb25JbmRleDogMCxcbiAgICAgICAgICBwaXhlbE9mZnNldFRMOiBWLFxuICAgICAgICAgIHBpeGVsT2Zmc2V0QlI6IEYsXG4gICAgICAgICAgbWluRm9udFNjYWxlWDogUyAvIHMgLyBwLFxuICAgICAgICAgIG1pbkZvbnRTY2FsZVk6IEkgLyBzIC8gYyxcbiAgICAgICAgICBpc1NERjogclxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgaWYgKG4gJiYgKG8uc3RyZXRjaFggfHwgby5zdHJldGNoWSkpIGZvciAodmFyIEUgPSBZdShoLCB2LCBkKSwgUCA9IFl1KGYsIGcsIG0pLCBNID0gMDsgTSA8IEUubGVuZ3RoIC0gMTsgTSsrKSB7XG4gICAgICAgIGZvciAodmFyIEIgPSBFW01dLCBUID0gRVtNICsgMV0sIFYgPSAwOyBWIDwgUC5sZW5ndGggLSAxOyBWKyspIHtcbiAgICAgICAgICBhLnB1c2goQyhCLCBQW1ZdLCBULCBQW1YgKyAxXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgYS5wdXNoKEMoe1xuICAgICAgICBmaXhlZDogMCxcbiAgICAgICAgc3RyZXRjaDogLTFcbiAgICAgIH0sIHtcbiAgICAgICAgZml4ZWQ6IDAsXG4gICAgICAgIHN0cmV0Y2g6IC0xXG4gICAgICB9LCB7XG4gICAgICAgIGZpeGVkOiAwLFxuICAgICAgICBzdHJldGNoOiB1ICsgMVxuICAgICAgfSwge1xuICAgICAgICBmaXhlZDogMCxcbiAgICAgICAgc3RyZXRjaDogbCArIDFcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEh1KHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgbiArPSBNYXRoLm1heChlLCBNYXRoLm1pbihyLCBvWzFdKSkgLSBNYXRoLm1heChlLCBNYXRoLm1pbihyLCBvWzBdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFl1KHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSBbe1xuICAgICAgICBmaXhlZDogLTEsXG4gICAgICAgIHN0cmV0Y2g6IDBcbiAgICAgIH1dLCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXSxcbiAgICAgICAgICAgIHMgPSBvWzBdLFxuICAgICAgICAgICAgdSA9IG9bMV0sXG4gICAgICAgICAgICBsID0gbltuLmxlbmd0aCAtIDFdO1xuICAgICAgICBuLnB1c2goe1xuICAgICAgICAgIGZpeGVkOiBzIC0gbC5zdHJldGNoLFxuICAgICAgICAgIHN0cmV0Y2g6IGwuc3RyZXRjaFxuICAgICAgICB9KSwgbi5wdXNoKHtcbiAgICAgICAgICBmaXhlZDogcyAtIGwuc3RyZXRjaCxcbiAgICAgICAgICBzdHJldGNoOiBsLnN0cmV0Y2ggKyAodSAtIHMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbi5wdXNoKHtcbiAgICAgICAgZml4ZWQ6IGUgKyAxLFxuICAgICAgICBzdHJldGNoOiByXG4gICAgICB9KSwgbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkdSh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gdCAvIGUgKiByICsgbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXdSh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gdCAtIGUgKiByIC8gbjtcbiAgICB9XG5cbiAgICB2YXIgUXUgPSBmdW5jdGlvbiBRdSh0LCBlLCByLCBuLCBhLCBvLCBzLCB1LCBsLCBwKSB7XG4gICAgICBpZiAodGhpcy5ib3hTdGFydEluZGV4ID0gdC5sZW5ndGgsIGwpIHtcbiAgICAgICAgdmFyIGMgPSBvLnRvcCxcbiAgICAgICAgICAgIGggPSBvLmJvdHRvbSxcbiAgICAgICAgICAgIGYgPSBvLmNvbGxpc2lvblBhZGRpbmc7XG4gICAgICAgIGYgJiYgKGMgLT0gZlsxXSwgaCArPSBmWzNdKTtcbiAgICAgICAgdmFyIHkgPSBoIC0gYztcbiAgICAgICAgeSA+IDAgJiYgKHkgPSBNYXRoLm1heCgxMCwgeSksIHRoaXMuY2lyY2xlRGlhbWV0ZXIgPSB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkID0gby50b3AgKiBzIC0gdSxcbiAgICAgICAgICAgIG0gPSBvLmJvdHRvbSAqIHMgKyB1LFxuICAgICAgICAgICAgdiA9IG8ubGVmdCAqIHMgLSB1LFxuICAgICAgICAgICAgZyA9IG8ucmlnaHQgKiBzICsgdSxcbiAgICAgICAgICAgIHggPSBvLmNvbGxpc2lvblBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHggJiYgKHYgLT0geFswXSAqIHMsIGQgLT0geFsxXSAqIHMsIGcgKz0geFsyXSAqIHMsIG0gKz0geFszXSAqIHMpLCBwKSB7XG4gICAgICAgICAgdmFyIGIgPSBuZXcgaSh2LCBkKSxcbiAgICAgICAgICAgICAgdyA9IG5ldyBpKGcsIGQpLFxuICAgICAgICAgICAgICBfID0gbmV3IGkodiwgbSksXG4gICAgICAgICAgICAgIEEgPSBuZXcgaShnLCBtKSxcbiAgICAgICAgICAgICAgUyA9IHAgKiBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgICAgYi5fcm90YXRlKFMpLCB3Ll9yb3RhdGUoUyksIF8uX3JvdGF0ZShTKSwgQS5fcm90YXRlKFMpLCB2ID0gTWF0aC5taW4oYi54LCB3LngsIF8ueCwgQS54KSwgZyA9IE1hdGgubWF4KGIueCwgdy54LCBfLngsIEEueCksIGQgPSBNYXRoLm1pbihiLnksIHcueSwgXy55LCBBLnkpLCBtID0gTWF0aC5tYXgoYi55LCB3LnksIF8ueSwgQS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuZW1wbGFjZUJhY2soZS54LCBlLnksIHYsIGQsIGcsIG0sIHIsIG4sIGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJveEVuZEluZGV4ID0gdC5sZW5ndGg7XG4gICAgfSxcbiAgICAgICAgdGwgPSBmdW5jdGlvbiB0bCh0LCBlKSB7XG4gICAgICBpZiAodm9pZCAwID09PSB0ICYmICh0ID0gW10pLCB2b2lkIDAgPT09IGUgJiYgKGUgPSBlbCksIHRoaXMuZGF0YSA9IHQsIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCwgdGhpcy5jb21wYXJlID0gZSwgdGhpcy5sZW5ndGggPiAwKSBmb3IgKHZhciByID0gKHRoaXMubGVuZ3RoID4+IDEpIC0gMTsgciA+PSAwOyByLS0pIHtcbiAgICAgICAgdGhpcy5fZG93bihyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZWwodCwgZSkge1xuICAgICAgcmV0dXJuIHQgPCBlID8gLTEgOiB0ID4gZSA/IDEgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJsKHQsIGUsIHIpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDEpLCB2b2lkIDAgPT09IHIgJiYgKHIgPSAhMSk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAxIC8gMCwgYSA9IDEgLyAwLCBvID0gLTEgLyAwLCBzID0gLTEgLyAwLCB1ID0gdFswXSwgbCA9IDA7IGwgPCB1Lmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBwID0gdVtsXTtcbiAgICAgICAgKCFsIHx8IHAueCA8IG4pICYmIChuID0gcC54KSwgKCFsIHx8IHAueSA8IGEpICYmIChhID0gcC55KSwgKCFsIHx8IHAueCA+IG8pICYmIChvID0gcC54KSwgKCFsIHx8IHAueSA+IHMpICYmIChzID0gcC55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGMgPSBNYXRoLm1pbihvIC0gbiwgcyAtIGEpLFxuICAgICAgICAgIGggPSBjIC8gMixcbiAgICAgICAgICBmID0gbmV3IHRsKFtdLCBubCk7XG4gICAgICBpZiAoMCA9PT0gYykgcmV0dXJuIG5ldyBpKG4sIGEpO1xuXG4gICAgICBmb3IgKHZhciB5ID0gbjsgeSA8IG87IHkgKz0gYykge1xuICAgICAgICBmb3IgKHZhciBkID0gYTsgZCA8IHM7IGQgKz0gYykge1xuICAgICAgICAgIGYucHVzaChuZXcgaWwoeSArIGgsIGQgKyBoLCBoLCB0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gMCwgbiA9IDAsIGkgPSB0WzBdLCBhID0gMCwgbyA9IGkubGVuZ3RoLCBzID0gbyAtIDE7IGEgPCBvOyBzID0gYSsrKSB7XG4gICAgICAgICAgdmFyIHUgPSBpW2FdLFxuICAgICAgICAgICAgICBsID0gaVtzXSxcbiAgICAgICAgICAgICAgcCA9IHUueCAqIGwueSAtIGwueCAqIHUueTtcbiAgICAgICAgICByICs9ICh1LnggKyBsLngpICogcCwgbiArPSAodS55ICsgbC55KSAqIHAsIGUgKz0gMyAqIHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IGlsKHIgLyBlLCBuIC8gZSwgMCwgdCk7XG4gICAgICB9KHQpLCB2ID0gZi5sZW5ndGg7IGYubGVuZ3RoOykge1xuICAgICAgICB2YXIgZyA9IGYucG9wKCk7XG4gICAgICAgIChnLmQgPiBtLmQgfHwgIW0uZCkgJiYgKG0gPSBnLCByICYmIGNvbnNvbGUubG9nKFwiZm91bmQgYmVzdCAlZCBhZnRlciAlZCBwcm9iZXNcIiwgTWF0aC5yb3VuZCgxZTQgKiBnLmQpIC8gMWU0LCB2KSksIGcubWF4IC0gbS5kIDw9IGUgfHwgKGYucHVzaChuZXcgaWwoZy5wLnggLSAoaCA9IGcuaCAvIDIpLCBnLnAueSAtIGgsIGgsIHQpKSwgZi5wdXNoKG5ldyBpbChnLnAueCArIGgsIGcucC55IC0gaCwgaCwgdCkpLCBmLnB1c2gobmV3IGlsKGcucC54IC0gaCwgZy5wLnkgKyBoLCBoLCB0KSksIGYucHVzaChuZXcgaWwoZy5wLnggKyBoLCBnLnAueSArIGgsIGgsIHQpKSwgdiArPSA0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHIgJiYgKGNvbnNvbGUubG9nKFwibnVtIHByb2JlczogXCIgKyB2KSwgY29uc29sZS5sb2coXCJiZXN0IGRpc3RhbmNlOiBcIiArIG0uZCkpLCBtLnA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmwodCwgZSkge1xuICAgICAgcmV0dXJuIGUubWF4IC0gdC5tYXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWwodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5wID0gbmV3IGkodCwgZSksIHRoaXMuaCA9IHIsIHRoaXMuZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAhMSwgbiA9IDEgLyAwLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gZVtpXSwgbyA9IDAsIHMgPSBhLmxlbmd0aCwgdSA9IHMgLSAxOyBvIDwgczsgdSA9IG8rKykge1xuICAgICAgICAgICAgdmFyIGwgPSBhW29dLFxuICAgICAgICAgICAgICAgIHAgPSBhW3VdO1xuICAgICAgICAgICAgbC55ID4gdC55ICE9IHAueSA+IHQueSAmJiB0LnggPCAocC54IC0gbC54KSAqICh0LnkgLSBsLnkpIC8gKHAueSAtIGwueSkgKyBsLnggJiYgKHIgPSAhciksIG4gPSBNYXRoLm1pbihuLCAkYSh0LCBsLCBwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChyID8gMSA6IC0xKSAqIE1hdGguc3FydChuKTtcbiAgICAgIH0odGhpcy5wLCBuKSwgdGhpcy5tYXggPSB0aGlzLmQgKyB0aGlzLmggKiBNYXRoLlNRUlQyO1xuICAgIH1cblxuICAgIHRsLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuZGF0YS5wdXNoKHQpLCB0aGlzLmxlbmd0aCsrLCB0aGlzLl91cCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH0sIHRsLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoMCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmRhdGFbMF0sXG4gICAgICAgICAgICBlID0gdGhpcy5kYXRhLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgtLSwgdGhpcy5sZW5ndGggPiAwICYmICh0aGlzLmRhdGFbMF0gPSBlLCB0aGlzLl9kb3duKDApKSwgdDtcbiAgICAgIH1cbiAgICB9LCB0bC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfSwgdGwucHJvdG90eXBlLl91cCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5kYXRhLCByID0gdGhpcy5jb21wYXJlLCBuID0gZVt0XTsgdCA+IDA7KSB7XG4gICAgICAgIHZhciBpID0gdCAtIDEgPj4gMSxcbiAgICAgICAgICAgIGEgPSBlW2ldO1xuICAgICAgICBpZiAocihuLCBhKSA+PSAwKSBicmVhaztcbiAgICAgICAgZVt0XSA9IGEsIHQgPSBpO1xuICAgICAgfVxuXG4gICAgICBlW3RdID0gbjtcbiAgICB9LCB0bC5wcm90b3R5cGUuX2Rvd24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRoaXMuZGF0YSwgciA9IHRoaXMuY29tcGFyZSwgbiA9IHRoaXMubGVuZ3RoID4+IDEsIGkgPSBlW3RdOyB0IDwgbjspIHtcbiAgICAgICAgdmFyIGEgPSAxICsgKHQgPDwgMSksXG4gICAgICAgICAgICBvID0gZVthXSxcbiAgICAgICAgICAgIHMgPSBhICsgMTtcbiAgICAgICAgaWYgKHMgPCB0aGlzLmxlbmd0aCAmJiByKGVbc10sIG8pIDwgMCAmJiAoYSA9IHMsIG8gPSBlW3NdKSwgcihvLCBpKSA+PSAwKSBicmVhaztcbiAgICAgICAgZVt0XSA9IG8sIHQgPSBhO1xuICAgICAgfVxuXG4gICAgICBlW3RdID0gaTtcbiAgICB9O1xuICAgIHZhciBhbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIGZ1bmN0aW9uIG9sKHQsIGUpIHtcbiAgICAgIHJldHVybiBlWzFdICE9PSBhbCA/IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHN3aXRjaCAoZSA9IE1hdGguYWJzKGUpLCByID0gTWF0aC5hYnMociksIHQpIHtcbiAgICAgICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgaSA9IHIgLSA3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgaSA9IDcgLSByO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgIG4gPSAtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIG4gPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuLCBpXTtcbiAgICAgIH0odCwgZVswXSwgZVsxXSkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IDAsXG4gICAgICAgICAgICBuID0gMDtcbiAgICAgICAgZSA8IDAgJiYgKGUgPSAwKTtcbiAgICAgICAgdmFyIGkgPSBlIC8gTWF0aC5zcXJ0KDIpO1xuXG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICAgIG4gPSBpIC0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgICAgbiA9IDcgLSBpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICBuID0gNyAtIGU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgIG4gPSBlIC0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgICByID0gLWk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgICAgciA9IGk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICByID0gZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICByID0gLWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIG5dO1xuICAgICAgfSh0LCBlWzBdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbCh0KSB7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgICAgIHJldHVybiBcInJpZ2h0XCI7XG5cbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWwodCwgZSwgciwgbiwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCkge1xuICAgICAgdmFyIG0gPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcywgdSkge1xuICAgICAgICBmb3IgKHZhciBsID0gbi5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGVcIikuZXZhbHVhdGUobywge30pICogTWF0aC5QSSAvIDE4MCwgcCA9IFtdLCBjID0gMCwgaCA9IGUucG9zaXRpb25lZExpbmVzOyBjIDwgaC5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIGYgPSBoW2NdLCB5ID0gMCwgZCA9IGYucG9zaXRpb25lZEdseXBoczsgeSA8IGQubGVuZ3RoOyB5ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtID0gZFt5XTtcblxuICAgICAgICAgICAgaWYgKG0ucmVjdCkge1xuICAgICAgICAgICAgICB2YXIgdiA9IG0ucmVjdCB8fCB7fSxcbiAgICAgICAgICAgICAgICAgIGcgPSA0LFxuICAgICAgICAgICAgICAgICAgeCA9ICEwLFxuICAgICAgICAgICAgICAgICAgYiA9IDEsXG4gICAgICAgICAgICAgICAgICB3ID0gMCxcbiAgICAgICAgICAgICAgICAgIF8gPSAoYSB8fCB1KSAmJiBtLnZlcnRpY2FsLFxuICAgICAgICAgICAgICAgICAgQSA9IG0ubWV0cmljcy5hZHZhbmNlICogbS5zY2FsZSAvIDI7XG5cbiAgICAgICAgICAgICAgaWYgKHUgJiYgZS52ZXJ0aWNhbGl6YWJsZSAmJiAodyA9IGYubGluZU9mZnNldCAvIDIgLSAobS5pbWFnZU5hbWUgPyAtKDI0IC0gbS5tZXRyaWNzLndpZHRoICogbS5zY2FsZSkgLyAyIDogMjQgKiAobS5zY2FsZSAtIDEpKSksIG0uaW1hZ2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIFMgPSBzW20uaW1hZ2VOYW1lXTtcbiAgICAgICAgICAgICAgICB4ID0gUy5zZGYsIGcgPSAxIC8gKGIgPSBTLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGsgPSBhID8gW20ueCArIEEsIG0ueV0gOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICBJID0gYSA/IFswLCAwXSA6IFttLnggKyBBICsgclswXSwgbS55ICsgclsxXSAtIHddLFxuICAgICAgICAgICAgICAgICAgeiA9IFswLCAwXTtcbiAgICAgICAgICAgICAgXyAmJiAoeiA9IEksIEkgPSBbMCwgMF0pO1xuICAgICAgICAgICAgICB2YXIgQyA9IChtLm1ldHJpY3MubGVmdCAtIGcpICogbS5zY2FsZSAtIEEgKyBJWzBdLFxuICAgICAgICAgICAgICAgICAgRSA9ICgtbS5tZXRyaWNzLnRvcCAtIGcpICogbS5zY2FsZSArIElbMV0sXG4gICAgICAgICAgICAgICAgICBQID0gQyArIHYudyAqIG0uc2NhbGUgLyBiLFxuICAgICAgICAgICAgICAgICAgTSA9IEUgKyB2LmggKiBtLnNjYWxlIC8gYixcbiAgICAgICAgICAgICAgICAgIEIgPSBuZXcgaShDLCBFKSxcbiAgICAgICAgICAgICAgICAgIFQgPSBuZXcgaShQLCBFKSxcbiAgICAgICAgICAgICAgICAgIFYgPSBuZXcgaShDLCBNKSxcbiAgICAgICAgICAgICAgICAgIEYgPSBuZXcgaShQLCBNKTtcblxuICAgICAgICAgICAgICBpZiAoXykge1xuICAgICAgICAgICAgICAgIHZhciBEID0gbmV3IGkoLUEsIEEgLSAtMTcpLFxuICAgICAgICAgICAgICAgICAgICBMID0gLU1hdGguUEkgLyAyLFxuICAgICAgICAgICAgICAgICAgICBSID0gMTIgLSBBLFxuICAgICAgICAgICAgICAgICAgICBPID0gbmV3IGkoMjIgLSBSLCAtKG0uaW1hZ2VOYW1lID8gUiA6IDApKSxcbiAgICAgICAgICAgICAgICAgICAgVSA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoaSwgW251bGxdLmNvbmNhdCh6KSkpKCk7XG4gICAgICAgICAgICAgICAgQi5fcm90YXRlQXJvdW5kKEwsIEQpLl9hZGQoTykuX2FkZChVKSwgVC5fcm90YXRlQXJvdW5kKEwsIEQpLl9hZGQoTykuX2FkZChVKSwgVi5fcm90YXRlQXJvdW5kKEwsIEQpLl9hZGQoTykuX2FkZChVKSwgRi5fcm90YXRlQXJvdW5kKEwsIEQpLl9hZGQoTykuX2FkZChVKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBNYXRoLnNpbihsKSxcbiAgICAgICAgICAgICAgICAgICAgcSA9IE1hdGguY29zKGwpLFxuICAgICAgICAgICAgICAgICAgICBOID0gW3EsIC1qLCBqLCBxXTtcbiAgICAgICAgICAgICAgICBCLl9tYXRNdWx0KE4pLCBULl9tYXRNdWx0KE4pLCBWLl9tYXRNdWx0KE4pLCBGLl9tYXRNdWx0KE4pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIEsgPSBuZXcgaSgwLCAwKSxcbiAgICAgICAgICAgICAgICAgIEcgPSBuZXcgaSgwLCAwKTtcbiAgICAgICAgICAgICAgcC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0bDogQixcbiAgICAgICAgICAgICAgICB0cjogVCxcbiAgICAgICAgICAgICAgICBibDogVixcbiAgICAgICAgICAgICAgICBicjogRixcbiAgICAgICAgICAgICAgICB0ZXg6IHYsXG4gICAgICAgICAgICAgICAgd3JpdGluZ01vZGU6IGUud3JpdGluZ01vZGUsXG4gICAgICAgICAgICAgICAgZ2x5cGhPZmZzZXQ6IGssXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4OiBtLnNlY3Rpb25JbmRleCxcbiAgICAgICAgICAgICAgICBpc1NERjogeCxcbiAgICAgICAgICAgICAgICBwaXhlbE9mZnNldFRMOiBLLFxuICAgICAgICAgICAgICAgIHBpeGVsT2Zmc2V0QlI6IEcsXG4gICAgICAgICAgICAgICAgbWluRm9udFNjYWxlWDogMCxcbiAgICAgICAgICAgICAgICBtaW5Gb250U2NhbGVZOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSgwLCByLCB1LCBhLCBvLCBzLCBuLCB0LmFsbG93VmVydGljYWxQbGFjZW1lbnQpLFxuICAgICAgICAgIHYgPSB0LnRleHRTaXplRGF0YSxcbiAgICAgICAgICBnID0gbnVsbDtcblxuICAgICAgXCJzb3VyY2VcIiA9PT0gdi5raW5kID8gKGcgPSBbMTI4ICogYS5sYXlvdXQuZ2V0KFwidGV4dC1zaXplXCIpLmV2YWx1YXRlKHMsIHt9KV0pWzBdID4gMzI2NDAgJiYgQSh0LmxheWVySWRzWzBdICsgJzogVmFsdWUgZm9yIFwidGV4dC1zaXplXCIgaXMgPj0gMjU1LiBSZWR1Y2UgeW91ciBcInRleHQtc2l6ZVwiLicpIDogXCJjb21wb3NpdGVcIiA9PT0gdi5raW5kICYmICgoZyA9IFsxMjggKiB5LmNvbXBvc2l0ZVRleHRTaXplc1swXS5ldmFsdWF0ZShzLCB7fSwgZCksIDEyOCAqIHkuY29tcG9zaXRlVGV4dFNpemVzWzFdLmV2YWx1YXRlKHMsIHt9LCBkKV0pWzBdID4gMzI2NDAgfHwgZ1sxXSA+IDMyNjQwKSAmJiBBKHQubGF5ZXJJZHNbMF0gKyAnOiBWYWx1ZSBmb3IgXCJ0ZXh0LXNpemVcIiBpcyA+PSAyNTUuIFJlZHVjZSB5b3VyIFwidGV4dC1zaXplXCIuJyksIHQuYWRkU3ltYm9scyh0LnRleHQsIG0sIGcsIHUsIG8sIHMsIHAsIGUsIGwubGluZVN0YXJ0SW5kZXgsIGwubGluZUxlbmd0aCwgZiwgZCk7XG5cbiAgICAgIGZvciAodmFyIHggPSAwLCBiID0gYzsgeCA8IGIubGVuZ3RoOyB4ICs9IDEpIHtcbiAgICAgICAgaFtiW3hdXSA9IHQudGV4dC5wbGFjZWRTeW1ib2xBcnJheS5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gNCAqIG0ubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxsKHQpIHtcbiAgICAgIGZvciAodmFyIGUgaW4gdCkge1xuICAgICAgICByZXR1cm4gdFtlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGwodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSB0LmNvbXBhcmVUZXh0O1xuXG4gICAgICBpZiAoZSBpbiBpKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBpW2VdLCBvID0gYS5sZW5ndGggLSAxOyBvID49IDA7IG8tLSkge1xuICAgICAgICAgIGlmIChuLmRpc3QoYVtvXSkgPCByKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpW2VdID0gW107XG5cbiAgICAgIHJldHVybiBpW2VdLnB1c2gobiksICExO1xuICAgIH1cblxuICAgIHZhciBjbCA9IHdzLlZlY3RvclRpbGVGZWF0dXJlLnR5cGVzLFxuICAgICAgICBobCA9IFt7XG4gICAgICBuYW1lOiBcImFfZmFkZV9vcGFjaXR5XCIsXG4gICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgdHlwZTogXCJVaW50OFwiLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfV07XG5cbiAgICBmdW5jdGlvbiBmbCh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoKSB7XG4gICAgICB2YXIgZiA9IHMgPyBNYXRoLm1pbigzMjY0MCwgTWF0aC5yb3VuZChzWzBdKSkgOiAwLFxuICAgICAgICAgIHkgPSBzID8gTWF0aC5taW4oMzI2NDAsIE1hdGgucm91bmQoc1sxXSkpIDogMDtcbiAgICAgIHQuZW1wbGFjZUJhY2soZSwgciwgTWF0aC5yb3VuZCgzMiAqIG4pLCBNYXRoLnJvdW5kKDMyICogaSksIGEsIG8sIChmIDw8IDEpICsgKHUgPyAxIDogMCksIHksIDE2ICogbCwgMTYgKiBwLCAyNTYgKiBjLCAyNTYgKiBoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5bCh0LCBlLCByKSB7XG4gICAgICB0LmVtcGxhY2VCYWNrKGUueCwgZS55LCByKSwgdC5lbXBsYWNlQmFjayhlLngsIGUueSwgciksIHQuZW1wbGFjZUJhY2soZS54LCBlLnksIHIpLCB0LmVtcGxhY2VCYWNrKGUueCwgZS55LCByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkbCh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQuc2VjdGlvbnM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIGlmIChXbihyW2VdLnRleHQpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG5cbiAgICB2YXIgbWwgPSBmdW5jdGlvbiBtbCh0KSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IEZpKCksIHRoaXMuaW5kZXhBcnJheSA9IG5ldyBxaSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IHQsIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5keW5hbWljTGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgRGkoKSwgdGhpcy5vcGFjaXR5VmVydGV4QXJyYXkgPSBuZXcgTGkoKSwgdGhpcy5wbGFjZWRTeW1ib2xBcnJheSA9IG5ldyB0YSgpO1xuICAgIH07XG5cbiAgICBtbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCAmJiAwID09PSB0aGlzLmluZGV4QXJyYXkubGVuZ3RoICYmIDAgPT09IHRoaXMuZHluYW1pY0xheW91dFZlcnRleEFycmF5Lmxlbmd0aCAmJiAwID09PSB0aGlzLm9wYWNpdHlWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgfSwgbWwucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmlzRW1wdHkoKSB8fCAociAmJiAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmxheW91dFZlcnRleEFycmF5LCBxcy5tZW1iZXJzKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5LCBlKSwgdGhpcy5keW5hbWljTGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5keW5hbWljTGF5b3V0VmVydGV4QXJyYXksIE5zLm1lbWJlcnMsICEwKSwgdGhpcy5vcGFjaXR5VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5vcGFjaXR5VmVydGV4QXJyYXksIGhsLCAhMCksIHRoaXMub3BhY2l0eVZlcnRleEJ1ZmZlci5pdGVtU2l6ZSA9IDEpLCAociB8fCBuKSAmJiB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGxvYWQodCkpO1xuICAgIH0sIG1sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCksIHRoaXMuZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMub3BhY2l0eVZlcnRleEJ1ZmZlci5kZXN0cm95KCkpO1xuICAgIH0sIE9uKFwiU3ltYm9sQnVmZmVyc1wiLCBtbCk7XG5cbiAgICB2YXIgdmwgPSBmdW5jdGlvbiB2bCh0LCBlLCByKSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IHQoKSwgdGhpcy5sYXlvdXRBdHRyaWJ1dGVzID0gZSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IHIoKSwgdGhpcy5zZWdtZW50cyA9IG5ldyB1YSgpLCB0aGlzLmNvbGxpc2lvblZlcnRleEFycmF5ID0gbmV3IGppKCk7XG4gICAgfTtcblxuICAgIHZsLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmxheW91dFZlcnRleEFycmF5LCB0aGlzLmxheW91dEF0dHJpYnV0ZXMpLCB0aGlzLmluZGV4QnVmZmVyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXkpLCB0aGlzLmNvbGxpc2lvblZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuY29sbGlzaW9uVmVydGV4QXJyYXksIEtzLm1lbWJlcnMsICEwKTtcbiAgICB9LCB2bC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLnNlZ21lbnRzLmRlc3Ryb3koKSwgdGhpcy5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIuZGVzdHJveSgpKTtcbiAgICB9LCBPbihcIkNvbGxpc2lvbkJ1ZmZlcnNcIiwgdmwpO1xuXG4gICAgdmFyIGdsID0gZnVuY3Rpb24gZ2wodCkge1xuICAgICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IHQuY29sbGlzaW9uQm94QXJyYXksIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5vdmVyc2NhbGluZyA9IHQub3ZlcnNjYWxpbmcsIHRoaXMubGF5ZXJzID0gdC5sYXllcnMsIHRoaXMubGF5ZXJJZHMgPSB0aGlzLmxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMucGl4ZWxSYXRpbyA9IHQucGl4ZWxSYXRpbywgdGhpcy5zb3VyY2VMYXllckluZGV4ID0gdC5zb3VyY2VMYXllckluZGV4LCB0aGlzLmhhc1BhdHRlcm4gPSAhMSwgdGhpcy5oYXNSVExUZXh0ID0gITEsIHRoaXMuc29ydEtleVJhbmdlcyA9IFtdLCB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5ID0gW10sIHRoaXMucGxhY2VtZW50SW52UHJvak1hdHJpeCA9IHNvKFtdKSwgdGhpcy5wbGFjZW1lbnRWaWV3cG9ydE1hdHJpeCA9IHNvKFtdKTtcbiAgICAgIHZhciBlID0gdGhpcy5sYXllcnNbMF0uX3VuZXZhbHVhdGVkTGF5b3V0Ll92YWx1ZXM7XG4gICAgICB0aGlzLnRleHRTaXplRGF0YSA9IEx1KHRoaXMuem9vbSwgZVtcInRleHQtc2l6ZVwiXSksIHRoaXMuaWNvblNpemVEYXRhID0gTHUodGhpcy56b29tLCBlW1wiaWNvbi1zaXplXCJdKTtcbiAgICAgIHZhciByID0gdGhpcy5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICAgIG4gPSByLmdldChcInN5bWJvbC1zb3J0LWtleVwiKSxcbiAgICAgICAgICBpID0gci5nZXQoXCJzeW1ib2wtei1vcmRlclwiKTtcbiAgICAgIHRoaXMuY2FuT3ZlcmxhcCA9IHIuZ2V0KFwidGV4dC1hbGxvdy1vdmVybGFwXCIpIHx8IHIuZ2V0KFwiaWNvbi1hbGxvdy1vdmVybGFwXCIpIHx8IHIuZ2V0KFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCIpIHx8IHIuZ2V0KFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCIpLCB0aGlzLnNvcnRGZWF0dXJlc0J5S2V5ID0gXCJ2aWV3cG9ydC15XCIgIT09IGkgJiYgIW4uaXNDb25zdGFudCgpLCB0aGlzLnNvcnRGZWF0dXJlc0J5WSA9IChcInZpZXdwb3J0LXlcIiA9PT0gaSB8fCBcImF1dG9cIiA9PT0gaSAmJiAhdGhpcy5zb3J0RmVhdHVyZXNCeUtleSkgJiYgdGhpcy5jYW5PdmVybGFwLCBcInBvaW50XCIgPT09IHIuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSAmJiAodGhpcy53cml0aW5nTW9kZXMgPSByLmdldChcInRleHQtd3JpdGluZy1tb2RlXCIpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gX3VbdF07XG4gICAgICB9KSksIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcklkcyA9IHRoaXMubGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1N0YXRlRGVwZW5kZW50KCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5zb3VyY2VJRCA9IHQuc291cmNlSUQ7XG4gICAgfTtcblxuICAgIGdsLnByb3RvdHlwZS5jcmVhdGVBcnJheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRleHQgPSBuZXcgbWwobmV3IEZhKHRoaXMubGF5ZXJzLCB0aGlzLnpvb20sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAvXnRleHQvLnRlc3QodCk7XG4gICAgICB9KSksIHRoaXMuaWNvbiA9IG5ldyBtbChuZXcgRmEodGhpcy5sYXllcnMsIHRoaXMuem9vbSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIC9eaWNvbi8udGVzdCh0KTtcbiAgICAgIH0pKSwgdGhpcy5nbHlwaE9mZnNldEFycmF5ID0gbmV3IG5hKCksIHRoaXMubGluZVZlcnRleEFycmF5ID0gbmV3IGlhKCksIHRoaXMuc3ltYm9sSW5zdGFuY2VzID0gbmV3IHJhKCk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmNhbGN1bGF0ZUdseXBoRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgICBpZiAoZVt0LmNoYXJDb2RlQXQoYSldID0gITAsIChyIHx8IG4pICYmIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IEpzW3QuY2hhckF0KGEpXTtcbiAgICAgICAgICBvICYmIChlW28uY2hhckNvZGVBdCgwKV0gPSAhMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBnbC5wcm90b3R5cGUucG9wdWxhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0aGlzLmxheWVyc1swXSxcbiAgICAgICAgICBpID0gbi5sYXlvdXQsXG4gICAgICAgICAgYSA9IGkuZ2V0KFwidGV4dC1mb250XCIpLFxuICAgICAgICAgIG8gPSBpLmdldChcInRleHQtZmllbGRcIiksXG4gICAgICAgICAgcyA9IGkuZ2V0KFwiaWNvbi1pbWFnZVwiKSxcbiAgICAgICAgICB1ID0gKFwiY29uc3RhbnRcIiAhPT0gby52YWx1ZS5raW5kIHx8IG8udmFsdWUudmFsdWUgaW5zdGFuY2VvZiBpZSAmJiAhby52YWx1ZS52YWx1ZS5pc0VtcHR5KCkgfHwgby52YWx1ZS52YWx1ZS50b1N0cmluZygpLmxlbmd0aCA+IDApICYmIChcImNvbnN0YW50XCIgIT09IGEudmFsdWUua2luZCB8fCBhLnZhbHVlLnZhbHVlLmxlbmd0aCA+IDApLFxuICAgICAgICAgIGwgPSBcImNvbnN0YW50XCIgIT09IHMudmFsdWUua2luZCB8fCAhIXMudmFsdWUudmFsdWUgfHwgT2JqZWN0LmtleXMocy5wYXJhbWV0ZXJzKS5sZW5ndGggPiAwLFxuICAgICAgICAgIHAgPSBpLmdldChcInN5bWJvbC1zb3J0LWtleVwiKTtcblxuICAgICAgaWYgKHRoaXMuZmVhdHVyZXMgPSBbXSwgdSB8fCBsKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSBlLmljb25EZXBlbmRlbmNpZXMsIGggPSBlLmdseXBoRGVwZW5kZW5jaWVzLCBmID0gZS5hdmFpbGFibGVJbWFnZXMsIHkgPSBuZXcgdWkodGhpcy56b29tKSwgZCA9IDAsIG0gPSB0OyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgIHZhciB2ID0gbVtkXSxcbiAgICAgICAgICAgICAgZyA9IHYuZmVhdHVyZSxcbiAgICAgICAgICAgICAgeCA9IHYuaWQsXG4gICAgICAgICAgICAgIGIgPSB2LmluZGV4LFxuICAgICAgICAgICAgICB3ID0gdi5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgICAgICBfID0gbi5fZmVhdHVyZUZpbHRlci5uZWVkR2VvbWV0cnksXG4gICAgICAgICAgICAgIEEgPSBqYShnLCBfKTtcblxuICAgICAgICAgIGlmIChuLl9mZWF0dXJlRmlsdGVyLmZpbHRlcih5LCBBLCByKSkge1xuICAgICAgICAgICAgXyB8fCAoQS5nZW9tZXRyeSA9IFVhKGcpKTtcbiAgICAgICAgICAgIHZhciBTID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICB2YXIgayA9IG4uZ2V0VmFsdWVBbmRSZXNvbHZlVG9rZW5zKFwidGV4dC1maWVsZFwiLCBBLCByLCBmKSxcbiAgICAgICAgICAgICAgICAgIEkgPSBpZS5mYWN0b3J5KGspO1xuICAgICAgICAgICAgICBkbChJKSAmJiAodGhpcy5oYXNSVExUZXh0ID0gITApLCAoIXRoaXMuaGFzUlRMVGV4dCB8fCBcInVuYXZhaWxhYmxlXCIgPT09IGFpKCkgfHwgdGhpcy5oYXNSVExUZXh0ICYmIHNpLmlzUGFyc2VkKCkpICYmIChTID0gWHMoSSwgbiwgQSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICAgICAgdmFyIEMgPSBuLmdldFZhbHVlQW5kUmVzb2x2ZVRva2VucyhcImljb24taW1hZ2VcIiwgQSwgciwgZik7XG4gICAgICAgICAgICAgIHogPSBDIGluc3RhbmNlb2YgYWUgPyBDIDogYWUuZnJvbVN0cmluZyhDKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFMgfHwgeikge1xuICAgICAgICAgICAgICB2YXIgRSA9IHRoaXMuc29ydEZlYXR1cmVzQnlLZXkgPyBwLmV2YWx1YXRlKEEsIHt9LCByKSA6IHZvaWQgMDtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogeCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBTLFxuICAgICAgICAgICAgICAgIGljb246IHosXG4gICAgICAgICAgICAgICAgaW5kZXg6IGIsXG4gICAgICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogdyxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogQS5nZW9tZXRyeSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBnLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgdHlwZTogY2xbZy50eXBlXSxcbiAgICAgICAgICAgICAgICBzb3J0S2V5OiBFXG4gICAgICAgICAgICAgIH0pLCB6ICYmIChjW3oubmFtZV0gPSAhMCksIFMpIHtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IGEuZXZhbHVhdGUoQSwge30sIHIpLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICAgICAgICBNID0gXCJtYXBcIiA9PT0gaS5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSAmJiBcInBvaW50XCIgIT09IGkuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93VmVydGljYWxQbGFjZW1lbnQgPSB0aGlzLndyaXRpbmdNb2RlcyAmJiB0aGlzLndyaXRpbmdNb2Rlcy5pbmRleE9mKF91LnZlcnRpY2FsKSA+PSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgQiA9IDAsIFQgPSBTLnNlY3Rpb25zOyBCIDwgVC5sZW5ndGg7IEIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIFYgPSBUW0JdO1xuICAgICAgICAgICAgICAgICAgaWYgKFYuaW1hZ2UpIGNbVi5pbWFnZS5uYW1lXSA9ICEwO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRiA9IFhuKFMudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBEID0gVi5mb250U3RhY2sgfHwgUCxcbiAgICAgICAgICAgICAgICAgICAgICAgIEwgPSBoW0RdID0gaFtEXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVHbHlwaERlcGVuZGVuY2llcyhWLnRleHQsIEwsIE0sIHRoaXMuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCwgRik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXCJsaW5lXCIgPT09IGkuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSAmJiAodGhpcy5mZWF0dXJlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB7fSxcbiAgICAgICAgICAgICAgciA9IHt9LFxuICAgICAgICAgICAgICBuID0gW10sXG4gICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYShlKSB7XG4gICAgICAgICAgICBuLnB1c2godFtlXSksIGkrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvKHQsIGUsIGkpIHtcbiAgICAgICAgICAgIHZhciBhID0gclt0XTtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgclt0XSwgcltlXSA9IGEsIG5bYV0uZ2VvbWV0cnlbMF0ucG9wKCksIG5bYV0uZ2VvbWV0cnlbMF0gPSBuW2FdLmdlb21ldHJ5WzBdLmNvbmNhdChpWzBdKSwgYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzKHQsIHIsIGkpIHtcbiAgICAgICAgICAgIHZhciBhID0gZVtyXTtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgZVtyXSwgZVt0XSA9IGEsIG5bYV0uZ2VvbWV0cnlbMF0uc2hpZnQoKSwgblthXS5nZW9tZXRyeVswXSA9IGlbMF0uY29uY2F0KG5bYV0uZ2VvbWV0cnlbMF0pLCBhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHUodCwgZSwgcikge1xuICAgICAgICAgICAgdmFyIG4gPSByID8gZVswXVtlWzBdLmxlbmd0aCAtIDFdIDogZVswXVswXTtcbiAgICAgICAgICAgIHJldHVybiB0ICsgXCI6XCIgKyBuLnggKyBcIjpcIiArIG4ueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHQubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gdFtsXSxcbiAgICAgICAgICAgICAgICBjID0gcC5nZW9tZXRyeSxcbiAgICAgICAgICAgICAgICBoID0gcC50ZXh0ID8gcC50ZXh0LnRvU3RyaW5nKCkgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgICB2YXIgZiA9IHUoaCwgYyksXG4gICAgICAgICAgICAgICAgICB5ID0gdShoLCBjLCAhMCk7XG5cbiAgICAgICAgICAgICAgaWYgKGYgaW4gciAmJiB5IGluIGUgJiYgcltmXSAhPT0gZVt5XSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gcyhmLCB5LCBjKSxcbiAgICAgICAgICAgICAgICAgICAgbSA9IG8oZiwgeSwgbltkXS5nZW9tZXRyeSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVbZl0sIGRlbGV0ZSByW3ldLCByW3UoaCwgblttXS5nZW9tZXRyeSwgITApXSA9IG0sIG5bZF0uZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgZiBpbiByID8gbyhmLCB5LCBjKSA6IHkgaW4gZSA/IHMoZiwgeSwgYykgOiAoYShsKSwgZVtmXSA9IGkgLSAxLCByW3ldID0gaSAtIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGEobCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG4uZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5nZW9tZXRyeTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSh0aGlzLmZlYXR1cmVzKSksIHRoaXMuc29ydEZlYXR1cmVzQnlLZXkgJiYgdGhpcy5mZWF0dXJlcy5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQuc29ydEtleSAtIGUuc29ydEtleTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZ2wucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJzLmxlbmd0aCAmJiAodGhpcy50ZXh0LnByb2dyYW1Db25maWd1cmF0aW9ucy51cGRhdGVQYWludEFycmF5cyh0LCBlLCB0aGlzLmxheWVycywgciksIHRoaXMuaWNvbi5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5sYXllcnMsIHIpKTtcbiAgICB9LCBnbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGggJiYgIXRoaXMuaGFzUlRMVGV4dDtcbiAgICB9LCBnbC5wcm90b3R5cGUudXBsb2FkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy51cGxvYWRlZCB8fCB0aGlzLnRleHQucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkIHx8IHRoaXMuaWNvbi5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwgZ2wucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAhdGhpcy51cGxvYWRlZCAmJiB0aGlzLmhhc0RlYnVnRGF0YSgpICYmICh0aGlzLnRleHRDb2xsaXNpb25Cb3gudXBsb2FkKHQpLCB0aGlzLmljb25Db2xsaXNpb25Cb3gudXBsb2FkKHQpKSwgdGhpcy50ZXh0LnVwbG9hZCh0LCB0aGlzLnNvcnRGZWF0dXJlc0J5WSwgIXRoaXMudXBsb2FkZWQsIHRoaXMudGV4dC5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQpLCB0aGlzLmljb24udXBsb2FkKHQsIHRoaXMuc29ydEZlYXR1cmVzQnlZLCAhdGhpcy51cGxvYWRlZCwgdGhpcy5pY29uLnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZCksIHRoaXMudXBsb2FkZWQgPSAhMDtcbiAgICB9LCBnbC5wcm90b3R5cGUuZGVzdHJveURlYnVnRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGV4dENvbGxpc2lvbkJveC5kZXN0cm95KCksIHRoaXMuaWNvbkNvbGxpc2lvbkJveC5kZXN0cm95KCk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRleHQuZGVzdHJveSgpLCB0aGlzLmljb24uZGVzdHJveSgpLCB0aGlzLmhhc0RlYnVnRGF0YSgpICYmIHRoaXMuZGVzdHJveURlYnVnRGF0YSgpO1xuICAgIH0sIGdsLnByb3RvdHlwZS5hZGRUb0xpbmVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRoaXMubGluZVZlcnRleEFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHZvaWQgMCAhPT0gdC5zZWdtZW50KSB7XG4gICAgICAgIGZvciAodmFyIG4gPSB0LmRpc3QoZVt0LnNlZ21lbnQgKyAxXSksIGkgPSB0LmRpc3QoZVt0LnNlZ21lbnRdKSwgYSA9IHt9LCBvID0gdC5zZWdtZW50ICsgMTsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICBhW29dID0ge1xuICAgICAgICAgICAgeDogZVtvXS54LFxuICAgICAgICAgICAgeTogZVtvXS55LFxuICAgICAgICAgICAgdGlsZVVuaXREaXN0YW5jZUZyb21BbmNob3I6IG5cbiAgICAgICAgICB9LCBvIDwgZS5sZW5ndGggLSAxICYmIChuICs9IGVbbyArIDFdLmRpc3QoZVtvXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgcyA9IHQuc2VnbWVudCB8fCAwOyBzID49IDA7IHMtLSkge1xuICAgICAgICAgIGFbc10gPSB7XG4gICAgICAgICAgICB4OiBlW3NdLngsXG4gICAgICAgICAgICB5OiBlW3NdLnksXG4gICAgICAgICAgICB0aWxlVW5pdERpc3RhbmNlRnJvbUFuY2hvcjogaVxuICAgICAgICAgIH0sIHMgPiAwICYmIChpICs9IGVbcyAtIDFdLmRpc3QoZVtzXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBlLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgdmFyIGwgPSBhW3VdO1xuICAgICAgICAgIHRoaXMubGluZVZlcnRleEFycmF5LmVtcGxhY2VCYWNrKGwueCwgbC55LCBsLnRpbGVVbml0RGlzdGFuY2VGcm9tQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lU3RhcnRJbmRleDogcixcbiAgICAgICAgbGluZUxlbmd0aDogdGhpcy5saW5lVmVydGV4QXJyYXkubGVuZ3RoIC0gclxuICAgICAgfTtcbiAgICB9LCBnbC5wcm90b3R5cGUuYWRkU3ltYm9scyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjKSB7XG4gICAgICBmb3IgKHZhciBoID0gdC5pbmRleEFycmF5LCBmID0gdC5sYXlvdXRWZXJ0ZXhBcnJheSwgeSA9IHQuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQoNCAqIGUubGVuZ3RoLCBmLCBoLCB0aGlzLmNhbk92ZXJsYXAgPyBhLnNvcnRLZXkgOiB2b2lkIDApLCBkID0gdGhpcy5nbHlwaE9mZnNldEFycmF5Lmxlbmd0aCwgbSA9IHkudmVydGV4TGVuZ3RoLCB2ID0gdGhpcy5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIG8gPT09IF91LnZlcnRpY2FsID8gTWF0aC5QSSAvIDIgOiAwLCBnID0gYS50ZXh0ICYmIGEudGV4dC5zZWN0aW9ucywgeCA9IDA7IHggPCBlLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIHZhciBiID0gZVt4XSxcbiAgICAgICAgICAgIHcgPSBiLnRsLFxuICAgICAgICAgICAgXyA9IGIudHIsXG4gICAgICAgICAgICBBID0gYi5ibCxcbiAgICAgICAgICAgIFMgPSBiLmJyLFxuICAgICAgICAgICAgayA9IGIudGV4LFxuICAgICAgICAgICAgSSA9IGIucGl4ZWxPZmZzZXRUTCxcbiAgICAgICAgICAgIHogPSBiLnBpeGVsT2Zmc2V0QlIsXG4gICAgICAgICAgICBDID0gYi5taW5Gb250U2NhbGVYLFxuICAgICAgICAgICAgRSA9IGIubWluRm9udFNjYWxlWSxcbiAgICAgICAgICAgIFAgPSBiLmdseXBoT2Zmc2V0LFxuICAgICAgICAgICAgTSA9IGIuaXNTREYsXG4gICAgICAgICAgICBCID0gYi5zZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICBUID0geS52ZXJ0ZXhMZW5ndGgsXG4gICAgICAgICAgICBWID0gUFsxXTtcbiAgICAgICAgZmwoZiwgcy54LCBzLnksIHcueCwgViArIHcueSwgay54LCBrLnksIHIsIE0sIEkueCwgSS55LCBDLCBFKSwgZmwoZiwgcy54LCBzLnksIF8ueCwgViArIF8ueSwgay54ICsgay53LCBrLnksIHIsIE0sIHoueCwgSS55LCBDLCBFKSwgZmwoZiwgcy54LCBzLnksIEEueCwgViArIEEueSwgay54LCBrLnkgKyBrLmgsIHIsIE0sIEkueCwgei55LCBDLCBFKSwgZmwoZiwgcy54LCBzLnksIFMueCwgViArIFMueSwgay54ICsgay53LCBrLnkgKyBrLmgsIHIsIE0sIHoueCwgei55LCBDLCBFKSwgeWwodC5keW5hbWljTGF5b3V0VmVydGV4QXJyYXksIHMsIHYpLCBoLmVtcGxhY2VCYWNrKFQsIFQgKyAxLCBUICsgMiksIGguZW1wbGFjZUJhY2soVCArIDEsIFQgKyAyLCBUICsgMyksIHkudmVydGV4TGVuZ3RoICs9IDQsIHkucHJpbWl0aXZlTGVuZ3RoICs9IDIsIHRoaXMuZ2x5cGhPZmZzZXRBcnJheS5lbXBsYWNlQmFjayhQWzBdKSwgeCAhPT0gZS5sZW5ndGggLSAxICYmIEIgPT09IGVbeCArIDFdLnNlY3Rpb25JbmRleCB8fCB0LnByb2dyYW1Db25maWd1cmF0aW9ucy5wb3B1bGF0ZVBhaW50QXJyYXlzKGYubGVuZ3RoLCBhLCBhLmluZGV4LCB7fSwgYywgZyAmJiBnW0JdKTtcbiAgICAgIH1cblxuICAgICAgdC5wbGFjZWRTeW1ib2xBcnJheS5lbXBsYWNlQmFjayhzLngsIHMueSwgZCwgdGhpcy5nbHlwaE9mZnNldEFycmF5Lmxlbmd0aCAtIGQsIG0sIHUsIGwsIHMuc2VnbWVudCwgciA/IHJbMF0gOiAwLCByID8gclsxXSA6IDAsIG5bMF0sIG5bMV0sIG8sIDAsICExLCAwLCBwKTtcbiAgICB9LCBnbC5wcm90b3R5cGUuX2FkZENvbGxpc2lvbkRlYnVnVmVydGV4ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiBlLmVtcGxhY2VCYWNrKDAsIDApLCB0LmVtcGxhY2VCYWNrKHIueCwgci55LCBuLCBpLCBNYXRoLnJvdW5kKGEueCksIE1hdGgucm91bmQoYS55KSk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmFkZENvbGxpc2lvbkRlYnVnVmVydGljZXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcykge1xuICAgICAgdmFyIHUgPSBhLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIGEubGF5b3V0VmVydGV4QXJyYXksIGEuaW5kZXhBcnJheSksXG4gICAgICAgICAgbCA9IHUudmVydGV4TGVuZ3RoLFxuICAgICAgICAgIHAgPSBhLmxheW91dFZlcnRleEFycmF5LFxuICAgICAgICAgIGMgPSBhLmNvbGxpc2lvblZlcnRleEFycmF5LFxuICAgICAgICAgIGggPSBzLmFuY2hvclgsXG4gICAgICAgICAgZiA9IHMuYW5jaG9yWTtcbiAgICAgIHRoaXMuX2FkZENvbGxpc2lvbkRlYnVnVmVydGV4KHAsIGMsIG8sIGgsIGYsIG5ldyBpKHQsIGUpKSwgdGhpcy5fYWRkQ29sbGlzaW9uRGVidWdWZXJ0ZXgocCwgYywgbywgaCwgZiwgbmV3IGkociwgZSkpLCB0aGlzLl9hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRleChwLCBjLCBvLCBoLCBmLCBuZXcgaShyLCBuKSksIHRoaXMuX2FkZENvbGxpc2lvbkRlYnVnVmVydGV4KHAsIGMsIG8sIGgsIGYsIG5ldyBpKHQsIG4pKSwgdS52ZXJ0ZXhMZW5ndGggKz0gNDtcbiAgICAgIHZhciB5ID0gYS5pbmRleEFycmF5O1xuICAgICAgeS5lbXBsYWNlQmFjayhsLCBsICsgMSksIHkuZW1wbGFjZUJhY2sobCArIDEsIGwgKyAyKSwgeS5lbXBsYWNlQmFjayhsICsgMiwgbCArIDMpLCB5LmVtcGxhY2VCYWNrKGwgKyAzLCBsKSwgdS5wcmltaXRpdmVMZW5ndGggKz0gNDtcbiAgICB9LCBnbC5wcm90b3R5cGUuYWRkRGVidWdDb2xsaXNpb25Cb3hlcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gdDsgaSA8IGU7IGkrKykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXkuZ2V0KGkpO1xuICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkRlYnVnVmVydGljZXMoYS54MSwgYS55MSwgYS54MiwgYS55MiwgbiA/IHRoaXMudGV4dENvbGxpc2lvbkJveCA6IHRoaXMuaWNvbkNvbGxpc2lvbkJveCwgYS5hbmNob3JQb2ludCwgcik7XG4gICAgICB9XG4gICAgfSwgZ2wucHJvdG90eXBlLmdlbmVyYXRlQ29sbGlzaW9uRGVidWdCdWZmZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNEZWJ1Z0RhdGEoKSAmJiB0aGlzLmRlc3Ryb3lEZWJ1Z0RhdGEoKSwgdGhpcy50ZXh0Q29sbGlzaW9uQm94ID0gbmV3IHZsKE9pLCBHcy5tZW1iZXJzLCBKaSksIHRoaXMuaWNvbkNvbGxpc2lvbkJveCA9IG5ldyB2bChPaSwgR3MubWVtYmVycywgSmkpO1xuXG4gICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5zeW1ib2xJbnN0YW5jZXMuZ2V0KHQpO1xuICAgICAgICB0aGlzLmFkZERlYnVnQ29sbGlzaW9uQm94ZXMoZS50ZXh0Qm94U3RhcnRJbmRleCwgZS50ZXh0Qm94RW5kSW5kZXgsIGUsICEwKSwgdGhpcy5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzKGUudmVydGljYWxUZXh0Qm94U3RhcnRJbmRleCwgZS52ZXJ0aWNhbFRleHRCb3hFbmRJbmRleCwgZSwgITApLCB0aGlzLmFkZERlYnVnQ29sbGlzaW9uQm94ZXMoZS5pY29uQm94U3RhcnRJbmRleCwgZS5pY29uQm94RW5kSW5kZXgsIGUsICExKSwgdGhpcy5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzKGUudmVydGljYWxJY29uQm94U3RhcnRJbmRleCwgZS52ZXJ0aWNhbEljb25Cb3hFbmRJbmRleCwgZSwgITEpO1xuICAgICAgfVxuICAgIH0sIGdsLnByb3RvdHlwZS5fZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlc0ZvclN5bWJvbCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1KSB7XG4gICAgICBmb3IgKHZhciBsID0ge30sIHAgPSBlOyBwIDwgcjsgcCsrKSB7XG4gICAgICAgIHZhciBjID0gdC5nZXQocCk7XG4gICAgICAgIGwudGV4dEJveCA9IHtcbiAgICAgICAgICB4MTogYy54MSxcbiAgICAgICAgICB5MTogYy55MSxcbiAgICAgICAgICB4MjogYy54MixcbiAgICAgICAgICB5MjogYy55MixcbiAgICAgICAgICBhbmNob3JQb2ludFg6IGMuYW5jaG9yUG9pbnRYLFxuICAgICAgICAgIGFuY2hvclBvaW50WTogYy5hbmNob3JQb2ludFlcbiAgICAgICAgfSwgbC50ZXh0RmVhdHVyZUluZGV4ID0gYy5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBoID0gbjsgaCA8IGk7IGgrKykge1xuICAgICAgICB2YXIgZiA9IHQuZ2V0KGgpO1xuICAgICAgICBsLnZlcnRpY2FsVGV4dEJveCA9IHtcbiAgICAgICAgICB4MTogZi54MSxcbiAgICAgICAgICB5MTogZi55MSxcbiAgICAgICAgICB4MjogZi54MixcbiAgICAgICAgICB5MjogZi55MixcbiAgICAgICAgICBhbmNob3JQb2ludFg6IGYuYW5jaG9yUG9pbnRYLFxuICAgICAgICAgIGFuY2hvclBvaW50WTogZi5hbmNob3JQb2ludFlcbiAgICAgICAgfSwgbC52ZXJ0aWNhbFRleHRGZWF0dXJlSW5kZXggPSBmLmZlYXR1cmVJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHkgPSBhOyB5IDwgbzsgeSsrKSB7XG4gICAgICAgIHZhciBkID0gdC5nZXQoeSk7XG4gICAgICAgIGwuaWNvbkJveCA9IHtcbiAgICAgICAgICB4MTogZC54MSxcbiAgICAgICAgICB5MTogZC55MSxcbiAgICAgICAgICB4MjogZC54MixcbiAgICAgICAgICB5MjogZC55MixcbiAgICAgICAgICBhbmNob3JQb2ludFg6IGQuYW5jaG9yUG9pbnRYLFxuICAgICAgICAgIGFuY2hvclBvaW50WTogZC5hbmNob3JQb2ludFlcbiAgICAgICAgfSwgbC5pY29uRmVhdHVyZUluZGV4ID0gZC5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBtID0gczsgbSA8IHU7IG0rKykge1xuICAgICAgICB2YXIgdiA9IHQuZ2V0KG0pO1xuICAgICAgICBsLnZlcnRpY2FsSWNvbkJveCA9IHtcbiAgICAgICAgICB4MTogdi54MSxcbiAgICAgICAgICB5MTogdi55MSxcbiAgICAgICAgICB4Mjogdi54MixcbiAgICAgICAgICB5Mjogdi55MixcbiAgICAgICAgICBhbmNob3JQb2ludFg6IHYuYW5jaG9yUG9pbnRYLFxuICAgICAgICAgIGFuY2hvclBvaW50WTogdi5hbmNob3JQb2ludFlcbiAgICAgICAgfSwgbC52ZXJ0aWNhbEljb25GZWF0dXJlSW5kZXggPSB2LmZlYXR1cmVJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsO1xuICAgIH0sIGdsLnByb3RvdHlwZS5kZXNlcmlhbGl6ZUNvbGxpc2lvbkJveGVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuY29sbGlzaW9uQXJyYXlzID0gW107XG5cbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnN5bWJvbEluc3RhbmNlcy5nZXQoZSk7XG4gICAgICAgIHRoaXMuY29sbGlzaW9uQXJyYXlzLnB1c2godGhpcy5fZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlc0ZvclN5bWJvbCh0LCByLnRleHRCb3hTdGFydEluZGV4LCByLnRleHRCb3hFbmRJbmRleCwgci52ZXJ0aWNhbFRleHRCb3hTdGFydEluZGV4LCByLnZlcnRpY2FsVGV4dEJveEVuZEluZGV4LCByLmljb25Cb3hTdGFydEluZGV4LCByLmljb25Cb3hFbmRJbmRleCwgci52ZXJ0aWNhbEljb25Cb3hTdGFydEluZGV4LCByLnZlcnRpY2FsSWNvbkJveEVuZEluZGV4KSk7XG4gICAgICB9XG4gICAgfSwgZ2wucHJvdG90eXBlLmhhc1RleHREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAwO1xuICAgIH0sIGdsLnByb3RvdHlwZS5oYXNJY29uRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmljb24uc2VnbWVudHMuZ2V0KCkubGVuZ3RoID4gMDtcbiAgICB9LCBnbC5wcm90b3R5cGUuaGFzRGVidWdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dENvbGxpc2lvbkJveCAmJiB0aGlzLmljb25Db2xsaXNpb25Cb3g7XG4gICAgfSwgZ2wucHJvdG90eXBlLmhhc1RleHRDb2xsaXNpb25Cb3hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzRGVidWdEYXRhKCkgJiYgdGhpcy50ZXh0Q29sbGlzaW9uQm94LnNlZ21lbnRzLmdldCgpLmxlbmd0aCA+IDA7XG4gICAgfSwgZ2wucHJvdG90eXBlLmhhc0ljb25Db2xsaXNpb25Cb3hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzRGVidWdEYXRhKCkgJiYgdGhpcy5pY29uQ29sbGlzaW9uQm94LnNlZ21lbnRzLmdldCgpLmxlbmd0aCA+IDA7XG4gICAgfSwgZ2wucHJvdG90eXBlLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGUpLCBuID0gci52ZXJ0ZXhTdGFydEluZGV4ICsgNCAqIHIubnVtR2x5cGhzLCBpID0gci52ZXJ0ZXhTdGFydEluZGV4OyBpIDwgbjsgaSArPSA0KSB7XG4gICAgICAgIHQuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhpLCBpICsgMSwgaSArIDIpLCB0LmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaSArIDEsIGkgKyAyLCBpICsgMyk7XG4gICAgICB9XG4gICAgfSwgZ2wucHJvdG90eXBlLmdldFNvcnRlZFN5bWJvbEluZGV4ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMuc29ydGVkQW5nbGUgPT09IHQgJiYgdm9pZCAwICE9PSB0aGlzLnN5bWJvbEluc3RhbmNlSW5kZXhlcykgcmV0dXJuIHRoaXMuc3ltYm9sSW5zdGFuY2VJbmRleGVzO1xuXG4gICAgICBmb3IgKHZhciBlID0gTWF0aC5zaW4odCksIHIgPSBNYXRoLmNvcyh0KSwgbiA9IFtdLCBpID0gW10sIGEgPSBbXSwgbyA9IDA7IG8gPCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7ICsrbykge1xuICAgICAgICBhLnB1c2gobyk7XG4gICAgICAgIHZhciBzID0gdGhpcy5zeW1ib2xJbnN0YW5jZXMuZ2V0KG8pO1xuICAgICAgICBuLnB1c2goMCB8IE1hdGgucm91bmQoZSAqIHMuYW5jaG9yWCArIHIgKiBzLmFuY2hvclkpKSwgaS5wdXNoKHMuZmVhdHVyZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gblt0XSAtIG5bZV0gfHwgaVtlXSAtIGlbdF07XG4gICAgICB9KSwgYTtcbiAgICB9LCBnbC5wcm90b3R5cGUuYWRkVG9Tb3J0S2V5UmFuZ2VzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdGhpcy5zb3J0S2V5UmFuZ2VzW3RoaXMuc29ydEtleVJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgIHIgJiYgci5zb3J0S2V5ID09PSBlID8gci5zeW1ib2xJbnN0YW5jZUVuZCA9IHQgKyAxIDogdGhpcy5zb3J0S2V5UmFuZ2VzLnB1c2goe1xuICAgICAgICBzb3J0S2V5OiBlLFxuICAgICAgICBzeW1ib2xJbnN0YW5jZVN0YXJ0OiB0LFxuICAgICAgICBzeW1ib2xJbnN0YW5jZUVuZDogdCArIDFcbiAgICAgIH0pO1xuICAgIH0sIGdsLnByb3RvdHlwZS5zb3J0RmVhdHVyZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zb3J0RmVhdHVyZXNCeVkgJiYgdGhpcy5zb3J0ZWRBbmdsZSAhPT0gdCAmJiAhKHRoaXMudGV4dC5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAxIHx8IHRoaXMuaWNvbi5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAxKSkge1xuICAgICAgICB0aGlzLnN5bWJvbEluc3RhbmNlSW5kZXhlcyA9IHRoaXMuZ2V0U29ydGVkU3ltYm9sSW5kZXhlcyh0KSwgdGhpcy5zb3J0ZWRBbmdsZSA9IHQsIHRoaXMudGV4dC5pbmRleEFycmF5LmNsZWFyKCksIHRoaXMuaWNvbi5pbmRleEFycmF5LmNsZWFyKCksIHRoaXMuZmVhdHVyZVNvcnRPcmRlciA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gdGhpcy5zeW1ib2xJbnN0YW5jZUluZGV4ZXM7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLnN5bWJvbEluc3RhbmNlcy5nZXQobltyXSk7XG4gICAgICAgICAgdGhpcy5mZWF0dXJlU29ydE9yZGVyLnB1c2goaS5mZWF0dXJlSW5kZXgpLCBbaS5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgaS5jZW50ZXJKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIGkubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAodCwgciwgbikge1xuICAgICAgICAgICAgdCA+PSAwICYmIG4uaW5kZXhPZih0KSA9PT0gciAmJiBlLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2woZS50ZXh0LCB0KTtcbiAgICAgICAgICB9KSwgaS52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleCA+PSAwICYmIHRoaXMuYWRkSW5kaWNlc0ZvclBsYWNlZFN5bWJvbCh0aGlzLnRleHQsIGkudmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXgpLCBpLnBsYWNlZEljb25TeW1ib2xJbmRleCA+PSAwICYmIHRoaXMuYWRkSW5kaWNlc0ZvclBsYWNlZFN5bWJvbCh0aGlzLmljb24sIGkucGxhY2VkSWNvblN5bWJvbEluZGV4KSwgaS52ZXJ0aWNhbFBsYWNlZEljb25TeW1ib2xJbmRleCA+PSAwICYmIHRoaXMuYWRkSW5kaWNlc0ZvclBsYWNlZFN5bWJvbCh0aGlzLmljb24sIGkudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0LmluZGV4QnVmZmVyICYmIHRoaXMudGV4dC5pbmRleEJ1ZmZlci51cGRhdGVEYXRhKHRoaXMudGV4dC5pbmRleEFycmF5KSwgdGhpcy5pY29uLmluZGV4QnVmZmVyICYmIHRoaXMuaWNvbi5pbmRleEJ1ZmZlci51cGRhdGVEYXRhKHRoaXMuaWNvbi5pbmRleEFycmF5KTtcbiAgICAgIH1cbiAgICB9LCBPbihcIlN5bWJvbEJ1Y2tldFwiLCBnbCwge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCIsIFwiY29sbGlzaW9uQm94QXJyYXlcIiwgXCJmZWF0dXJlc1wiLCBcImNvbXBhcmVUZXh0XCJdXG4gICAgfSksIGdsLk1BWF9HTFlQSFMgPSA2NTUzNSwgZ2wuYWRkRHluYW1pY0F0dHJpYnV0ZXMgPSB5bDtcblxuICAgIHZhciB4bCA9IG5ldyBfaSh7XG4gICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJzeW1ib2wtcGxhY2VtZW50XCJdKSxcbiAgICAgIFwic3ltYm9sLXNwYWNpbmdcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJzeW1ib2wtc3BhY2luZ1wiXSksXG4gICAgICBcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInN5bWJvbC1hdm9pZC1lZGdlc1wiXSksXG4gICAgICBcInN5bWJvbC1zb3J0LWtleVwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInN5bWJvbC1zb3J0LWtleVwiXSksXG4gICAgICBcInN5bWJvbC16LW9yZGVyXCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wic3ltYm9sLXotb3JkZXJcIl0pLFxuICAgICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWFsbG93LW92ZXJsYXBcIl0pLFxuICAgICAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIl0pLFxuICAgICAgXCJpY29uLW9wdGlvbmFsXCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1vcHRpb25hbFwiXSksXG4gICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIl0pLFxuICAgICAgXCJpY29uLXNpemVcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLXNpemVcIl0pLFxuICAgICAgXCJpY29uLXRleHQtZml0XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi10ZXh0LWZpdFwiXSksXG4gICAgICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24tdGV4dC1maXQtcGFkZGluZ1wiXSksXG4gICAgICBcImljb24taW1hZ2VcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWltYWdlXCJdKSxcbiAgICAgIFwiaWNvbi1yb3RhdGVcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLXJvdGF0ZVwiXSksXG4gICAgICBcImljb24tcGFkZGluZ1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24tcGFkZGluZ1wiXSksXG4gICAgICBcImljb24ta2VlcC11cHJpZ2h0XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1rZWVwLXVwcmlnaHRcIl0pLFxuICAgICAgXCJpY29uLW9mZnNldFwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcImljb24tb2Zmc2V0XCJdKSxcbiAgICAgIFwiaWNvbi1hbmNob3JcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWFuY2hvclwiXSksXG4gICAgICBcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1waXRjaC1hbGlnbm1lbnRcIl0pLFxuICAgICAgXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtcGl0Y2gtYWxpZ25tZW50XCJdKSxcbiAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiXSksXG4gICAgICBcInRleHQtZmllbGRcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWZpZWxkXCJdKSxcbiAgICAgIFwidGV4dC1mb250XCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1mb250XCJdKSxcbiAgICAgIFwidGV4dC1zaXplXCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1zaXplXCJdKSxcbiAgICAgIFwidGV4dC1tYXgtd2lkdGhcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LW1heC13aWR0aFwiXSksXG4gICAgICBcInRleHQtbGluZS1oZWlnaHRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWxpbmUtaGVpZ2h0XCJdKSxcbiAgICAgIFwidGV4dC1sZXR0ZXItc3BhY2luZ1wiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtbGV0dGVyLXNwYWNpbmdcIl0pLFxuICAgICAgXCJ0ZXh0LWp1c3RpZnlcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWp1c3RpZnlcIl0pLFxuICAgICAgXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIl0pLFxuICAgICAgXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtdmFyaWFibGUtYW5jaG9yXCJdKSxcbiAgICAgIFwidGV4dC1hbmNob3JcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LWFuY2hvclwiXSksXG4gICAgICBcInRleHQtbWF4LWFuZ2xlXCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1tYXgtYW5nbGVcIl0pLFxuICAgICAgXCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtd3JpdGluZy1tb2RlXCJdKSxcbiAgICAgIFwidGV4dC1yb3RhdGVcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXJvdGF0ZVwiXSksXG4gICAgICBcInRleHQtcGFkZGluZ1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtcGFkZGluZ1wiXSksXG4gICAgICBcInRleHQta2VlcC11cHJpZ2h0XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1rZWVwLXVwcmlnaHRcIl0pLFxuICAgICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtdHJhbnNmb3JtXCJdKSxcbiAgICAgIFwidGV4dC1vZmZzZXRcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LW9mZnNldFwiXSksXG4gICAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtYWxsb3ctb3ZlcmxhcFwiXSksXG4gICAgICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtaWdub3JlLXBsYWNlbWVudFwiXSksXG4gICAgICBcInRleHQtb3B0aW9uYWxcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LW9wdGlvbmFsXCJdKVxuICAgIH0pLFxuICAgICAgICBibCA9IHtcbiAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICBcImljb24tb3BhY2l0eVwiOiBuZXcgZ2koUHQucGFpbnRfc3ltYm9sW1wiaWNvbi1vcGFjaXR5XCJdKSxcbiAgICAgICAgXCJpY29uLWNvbG9yXCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJpY29uLWNvbG9yXCJdKSxcbiAgICAgICAgXCJpY29uLWhhbG8tY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcImljb24taGFsby1jb2xvclwiXSksXG4gICAgICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJpY29uLWhhbG8td2lkdGhcIl0pLFxuICAgICAgICBcImljb24taGFsby1ibHVyXCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJpY29uLWhhbG8tYmx1clwiXSksXG4gICAgICAgIFwiaWNvbi10cmFuc2xhdGVcIjogbmV3IHZpKFB0LnBhaW50X3N5bWJvbFtcImljb24tdHJhbnNsYXRlXCJdKSxcbiAgICAgICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IHZpKFB0LnBhaW50X3N5bWJvbFtcImljb24tdHJhbnNsYXRlLWFuY2hvclwiXSksXG4gICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJ0ZXh0LW9wYWNpdHlcIl0pLFxuICAgICAgICBcInRleHQtY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcInRleHQtY29sb3JcIl0sIHtcbiAgICAgICAgICBydW50aW1lVHlwZTogcXQsXG4gICAgICAgICAgZ2V0T3ZlcnJpZGU6IGZ1bmN0aW9uIGdldE92ZXJyaWRlKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnRleHRDb2xvcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhc092ZXJyaWRlOiBmdW5jdGlvbiBoYXNPdmVycmlkZSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gISF0LnRleHRDb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBcInRleHQtaGFsby1jb2xvclwiOiBuZXcgZ2koUHQucGFpbnRfc3ltYm9sW1widGV4dC1oYWxvLWNvbG9yXCJdKSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcInRleHQtaGFsby13aWR0aFwiXSksXG4gICAgICAgIFwidGV4dC1oYWxvLWJsdXJcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcInRleHQtaGFsby1ibHVyXCJdKSxcbiAgICAgICAgXCJ0ZXh0LXRyYW5zbGF0ZVwiOiBuZXcgdmkoUHQucGFpbnRfc3ltYm9sW1widGV4dC10cmFuc2xhdGVcIl0pLFxuICAgICAgICBcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfc3ltYm9sW1widGV4dC10cmFuc2xhdGUtYW5jaG9yXCJdKVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IHhsXG4gICAgfSxcbiAgICAgICAgd2wgPSBmdW5jdGlvbiB3bCh0KSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LnByb3BlcnR5Lm92ZXJyaWRlcyA/IHQucHJvcGVydHkub3ZlcnJpZGVzLnJ1bnRpbWVUeXBlIDogUnQsIHRoaXMuZGVmYXVsdFZhbHVlID0gdDtcbiAgICB9O1xuXG4gICAgd2wucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0LmZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmRlZmF1bHRWYWx1ZS5wcm9wZXJ0eS5vdmVycmlkZXM7XG4gICAgICAgIGlmIChlICYmIGUuaGFzT3ZlcnJpZGUodC5mb3JtYXR0ZWRTZWN0aW9uKSkgcmV0dXJuIGUuZ2V0T3ZlcnJpZGUodC5mb3JtYXR0ZWRTZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQuZmVhdHVyZSAmJiB0LmZlYXR1cmVTdGF0ZSA/IHRoaXMuZGVmYXVsdFZhbHVlLmV2YWx1YXRlKHQuZmVhdHVyZSwgdC5mZWF0dXJlU3RhdGUpIDogdGhpcy5kZWZhdWx0VmFsdWUucHJvcGVydHkuc3BlY2lmaWNhdGlvbi5kZWZhdWx0O1xuICAgIH0sIHdsLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUuaXNDb25zdGFudCgpIHx8IHQodGhpcy5kZWZhdWx0VmFsdWUudmFsdWUuX3N0eWxlRXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgICB9LCB3bC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCB3bC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgT24oXCJGb3JtYXRTZWN0aW9uT3ZlcnJpZGVcIiwgd2wsIHtcbiAgICAgIG9taXQ6IFtcImRlZmF1bHRWYWx1ZVwiXVxuICAgIH0pO1xuXG4gICAgdmFyIF9sID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgYmwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgIGlmICh0LnByb3RvdHlwZS5yZWNhbGN1bGF0ZS5jYWxsKHRoaXMsIGUsIHIpLCBcImF1dG9cIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgKHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiXSA9IFwicG9pbnRcIiAhPT0gdGhpcy5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSA/IFwibWFwXCIgOiBcInZpZXdwb3J0XCIpLCBcImF1dG9cIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgKHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiXSA9IFwicG9pbnRcIiAhPT0gdGhpcy5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSA/IFwibWFwXCIgOiBcInZpZXdwb3J0XCIpLCBcImF1dG9cIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIikgJiYgKHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiXSA9IHRoaXMubGF5b3V0LmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpKSwgXCJhdXRvXCIgPT09IHRoaXMubGF5b3V0LmdldChcImljb24tcGl0Y2gtYWxpZ25tZW50XCIpICYmICh0aGlzLmxheW91dC5fdmFsdWVzW1wiaWNvbi1waXRjaC1hbGlnbm1lbnRcIl0gPSB0aGlzLmxheW91dC5nZXQoXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiKSksIFwicG9pbnRcIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5sYXlvdXQuZ2V0KFwidGV4dC13cml0aW5nLW1vZGVcIik7XG5cbiAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IFtdLCBhID0gMCwgbyA9IG47IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gb1thXTtcbiAgICAgICAgICAgICAgaS5pbmRleE9mKHMpIDwgMCAmJiBpLnB1c2gocyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXdyaXRpbmctbW9kZVwiXSA9IGk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXdyaXRpbmctbW9kZVwiXSA9IFtcImhvcml6b250YWxcIl07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRQYWludE92ZXJyaWRlcygpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZ2V0VmFsdWVBbmRSZXNvbHZlVG9rZW5zID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxheW91dC5nZXQodCkuZXZhbHVhdGUoZSwge30sIHIsIG4pLFxuICAgICAgICAgICAgYSA9IHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0Ll92YWx1ZXNbdF07XG4gICAgICAgIHJldHVybiBhLmlzRGF0YURyaXZlbigpIHx8IFpyKGEudmFsdWUpIHx8ICFpID8gaSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIGUucmVwbGFjZSgveyhbXnt9XSspfS9nLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgcmV0dXJuIHIgaW4gdCA/IFN0cmluZyh0W3JdKSA6IFwiXCI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0oZS5wcm9wZXJ0aWVzLCBpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgZ2wodCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeUludGVyc2VjdHNGZWF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fc2V0UGFpbnRPdmVycmlkZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSAwLCByID0gYmwucGFpbnQub3ZlcnJpZGFibGVQcm9wZXJ0aWVzOyB0IDwgci5sZW5ndGg7IHQgKz0gMSkge1xuICAgICAgICAgIHZhciBuID0gclt0XTtcblxuICAgICAgICAgIGlmIChlLmhhc1BhaW50T3ZlcnJpZGUodGhpcy5sYXlvdXQsIG4pKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5wYWludC5nZXQobiksXG4gICAgICAgICAgICAgICAgbyA9IG5ldyB3bChhKSxcbiAgICAgICAgICAgICAgICBzID0gbmV3IEdyKG8sIGEucHJvcGVydHkuc3BlY2lmaWNhdGlvbik7XG4gICAgICAgICAgICBpID0gXCJjb25zdGFudFwiID09PSBhLnZhbHVlLmtpbmQgfHwgXCJzb3VyY2VcIiA9PT0gYS52YWx1ZS5raW5kID8gbmV3IEpyKFwic291cmNlXCIsIHMpIDogbmV3IEhyKFwiY29tcG9zaXRlXCIsIHMsIGEudmFsdWUuem9vbVN0b3BzLCBhLnZhbHVlLl9pbnRlcnBvbGF0aW9uVHlwZSksIHRoaXMucGFpbnQuX3ZhbHVlc1tuXSA9IG5ldyBkaShhLnByb3BlcnR5LCBpLCBhLnBhcmFtZXRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgZS5wcm90b3R5cGUuX2hhbmRsZU92ZXJyaWRhYmxlUGFpbnRQcm9wZXJ0eVVwZGF0ZSA9IGZ1bmN0aW9uICh0LCByLCBuKSB7XG4gICAgICAgIHJldHVybiAhKCF0aGlzLmxheW91dCB8fCByLmlzRGF0YURyaXZlbigpIHx8IG4uaXNEYXRhRHJpdmVuKCkpICYmIGUuaGFzUGFpbnRPdmVycmlkZSh0aGlzLmxheW91dCwgdCk7XG4gICAgICB9LCBlLmhhc1BhaW50T3ZlcnJpZGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHQuZ2V0KFwidGV4dC1maWVsZFwiKSxcbiAgICAgICAgICAgIG4gPSBibC5wYWludC5wcm9wZXJ0aWVzW2VdLFxuICAgICAgICAgICAgaSA9ICExLFxuICAgICAgICAgICAgYSA9IGZ1bmN0aW9uIGEodCkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChuLm92ZXJyaWRlcyAmJiBuLm92ZXJyaWRlcy5oYXNPdmVycmlkZShyW2VdKSkgcmV0dXJuIHZvaWQgKGkgPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHIudmFsdWUua2luZCAmJiByLnZhbHVlLnZhbHVlIGluc3RhbmNlb2YgaWUpIGEoci52YWx1ZS52YWx1ZS5zZWN0aW9ucyk7ZWxzZSBpZiAoXCJzb3VyY2VcIiA9PT0gci52YWx1ZS5raW5kKSB7XG4gICAgICAgICAgdmFyIG8gPSBmdW5jdGlvbiBvKHQpIHtcbiAgICAgICAgICAgIGkgfHwgKHQgaW5zdGFuY2VvZiBwZSAmJiB1ZSh0LnZhbHVlKSA9PT0gWnQgPyBhKHQudmFsdWUuc2VjdGlvbnMpIDogdCBpbnN0YW5jZW9mIHllID8gYSh0LnNlY3Rpb25zKSA6IHQuZWFjaENoaWxkKG8pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzID0gci52YWx1ZTtcblxuICAgICAgICAgIHMuX3N0eWxlRXhwcmVzc2lvbiAmJiBvKHMuX3N0eWxlRXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0sIGU7XG4gICAgfShBaSksXG4gICAgICAgIEFsID0ge1xuICAgICAgcGFpbnQ6IG5ldyBfaSh7XG4gICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBuZXcgdmkoUHQucGFpbnRfYmFja2dyb3VuZFtcImJhY2tncm91bmQtY29sb3JcIl0pLFxuICAgICAgICBcImJhY2tncm91bmQtcGF0dGVyblwiOiBuZXcgYmkoUHQucGFpbnRfYmFja2dyb3VuZFtcImJhY2tncm91bmQtcGF0dGVyblwiXSksXG4gICAgICAgIFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IG5ldyB2aShQdC5wYWludF9iYWNrZ3JvdW5kW1wiYmFja2dyb3VuZC1vcGFjaXR5XCJdKVxuICAgICAgfSlcbiAgICB9LFxuICAgICAgICBTbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIEFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZTtcbiAgICB9KEFpKSxcbiAgICAgICAga2wgPSB7XG4gICAgICBwYWludDogbmV3IF9pKHtcbiAgICAgICAgXCJyYXN0ZXItb3BhY2l0eVwiOiBuZXcgdmkoUHQucGFpbnRfcmFzdGVyW1wicmFzdGVyLW9wYWNpdHlcIl0pLFxuICAgICAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IG5ldyB2aShQdC5wYWludF9yYXN0ZXJbXCJyYXN0ZXItaHVlLXJvdGF0ZVwiXSksXG4gICAgICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IG5ldyB2aShQdC5wYWludF9yYXN0ZXJbXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIl0pLFxuICAgICAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOiBuZXcgdmkoUHQucGFpbnRfcmFzdGVyW1wicmFzdGVyLWJyaWdodG5lc3MtbWF4XCJdKSxcbiAgICAgICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiBuZXcgdmkoUHQucGFpbnRfcmFzdGVyW1wicmFzdGVyLXNhdHVyYXRpb25cIl0pLFxuICAgICAgICBcInJhc3Rlci1jb250cmFzdFwiOiBuZXcgdmkoUHQucGFpbnRfcmFzdGVyW1wicmFzdGVyLWNvbnRyYXN0XCJdKSxcbiAgICAgICAgXCJyYXN0ZXItcmVzYW1wbGluZ1wiOiBuZXcgdmkoUHQucGFpbnRfcmFzdGVyW1wicmFzdGVyLXJlc2FtcGxpbmdcIl0pLFxuICAgICAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IG5ldyB2aShQdC5wYWludF9yYXN0ZXJbXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiXSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAgICAgSWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBrbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgfShBaSksXG4gICAgICAgIHpsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwge30pLCB0aGlzLmltcGxlbWVudGF0aW9uID0gZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuaXMzRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiM2RcIiA9PT0gdGhpcy5pbXBsZW1lbnRhdGlvbi5yZW5kZXJpbmdNb2RlO1xuICAgICAgfSwgZS5wcm90b3R5cGUuaGFzT2Zmc2NyZWVuUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdGhpcy5pbXBsZW1lbnRhdGlvbi5wcmVyZW5kZXI7XG4gICAgICB9LCBlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uICgpIHt9LCBlLnByb3RvdHlwZS51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHt9LCBlLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge30sIGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHt9LCBlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24ub25BZGQgJiYgdGhpcy5pbXBsZW1lbnRhdGlvbi5vbkFkZCh0LCB0LnBhaW50ZXIuY29udGV4dC5nbCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24ub25SZW1vdmUgJiYgdGhpcy5pbXBsZW1lbnRhdGlvbi5vblJlbW92ZSh0LCB0LnBhaW50ZXIuY29udGV4dC5nbCk7XG4gICAgICB9LCBlO1xuICAgIH0oQWkpLFxuICAgICAgICBDbCA9IHtcbiAgICAgIGNpcmNsZTogaG8sXG4gICAgICBoZWF0bWFwOiBBbyxcbiAgICAgIGhpbGxzaGFkZToga28sXG4gICAgICBmaWxsOiBjcyxcbiAgICAgIFwiZmlsbC1leHRydXNpb25cIjogQ3MsXG4gICAgICBsaW5lOiBVcyxcbiAgICAgIHN5bWJvbDogX2wsXG4gICAgICBiYWNrZ3JvdW5kOiBTbCxcbiAgICAgIHJhc3RlcjogSWxcbiAgICB9LFxuICAgICAgICBFbCA9IG8uSFRNTEltYWdlRWxlbWVudCxcbiAgICAgICAgUGwgPSBvLkhUTUxDYW52YXNFbGVtZW50LFxuICAgICAgICBNbCA9IG8uSFRNTFZpZGVvRWxlbWVudCxcbiAgICAgICAgQmwgPSBvLkltYWdlRGF0YSxcbiAgICAgICAgVGwgPSBvLkltYWdlQml0bWFwLFxuICAgICAgICBWbCA9IGZ1bmN0aW9uIFZsKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IHQsIHRoaXMuZm9ybWF0ID0gciwgdGhpcy50ZXh0dXJlID0gdC5nbC5jcmVhdGVUZXh0dXJlKCksIHRoaXMudXBkYXRlKGUsIG4pO1xuICAgIH07XG5cbiAgICBWbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdC53aWR0aCxcbiAgICAgICAgICBpID0gdC5oZWlnaHQsXG4gICAgICAgICAgYSA9ICEodGhpcy5zaXplICYmIHRoaXMuc2l6ZVswXSA9PT0gbiAmJiB0aGlzLnNpemVbMV0gPT09IGkgfHwgciksXG4gICAgICAgICAgbyA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBzID0gby5nbDtcbiAgICAgIGlmICh0aGlzLnVzZU1pcG1hcCA9IEJvb2xlYW4oZSAmJiBlLnVzZU1pcG1hcCksIHMuYmluZFRleHR1cmUocy5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpLCBvLnBpeGVsU3RvcmVVbnBhY2tGbGlwWS5zZXQoITEpLCBvLnBpeGVsU3RvcmVVbnBhY2suc2V0KDEpLCBvLnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhLnNldCh0aGlzLmZvcm1hdCA9PT0gcy5SR0JBICYmICghZSB8fCAhMSAhPT0gZS5wcmVtdWx0aXBseSkpLCBhKSB0aGlzLnNpemUgPSBbbiwgaV0sIHQgaW5zdGFuY2VvZiBFbCB8fCB0IGluc3RhbmNlb2YgUGwgfHwgdCBpbnN0YW5jZW9mIE1sIHx8IHQgaW5zdGFuY2VvZiBCbCB8fCBUbCAmJiB0IGluc3RhbmNlb2YgVGwgPyBzLnRleEltYWdlMkQocy5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgdGhpcy5mb3JtYXQsIHMuVU5TSUdORURfQllURSwgdCkgOiBzLnRleEltYWdlMkQocy5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgbiwgaSwgMCwgdGhpcy5mb3JtYXQsIHMuVU5TSUdORURfQllURSwgdC5kYXRhKTtlbHNlIHtcbiAgICAgICAgdmFyIHUgPSByIHx8IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGwgPSB1LngsXG4gICAgICAgICAgICBwID0gdS55O1xuICAgICAgICB0IGluc3RhbmNlb2YgRWwgfHwgdCBpbnN0YW5jZW9mIFBsIHx8IHQgaW5zdGFuY2VvZiBNbCB8fCB0IGluc3RhbmNlb2YgQmwgfHwgVGwgJiYgdCBpbnN0YW5jZW9mIFRsID8gcy50ZXhTdWJJbWFnZTJEKHMuVEVYVFVSRV8yRCwgMCwgbCwgcCwgcy5SR0JBLCBzLlVOU0lHTkVEX0JZVEUsIHQpIDogcy50ZXhTdWJJbWFnZTJEKHMuVEVYVFVSRV8yRCwgMCwgbCwgcCwgbiwgaSwgcy5SR0JBLCBzLlVOU0lHTkVEX0JZVEUsIHQuZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZU1pcG1hcCAmJiB0aGlzLmlzU2l6ZVBvd2VyT2ZUd28oKSAmJiBzLmdlbmVyYXRlTWlwbWFwKHMuVEVYVFVSRV8yRCk7XG4gICAgfSwgVmwucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICBuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKSwgciAhPT0gbi5MSU5FQVJfTUlQTUFQX05FQVJFU1QgfHwgdGhpcy5pc1NpemVQb3dlck9mVHdvKCkgfHwgKHIgPSBuLkxJTkVBUiksIHQgIT09IHRoaXMuZmlsdGVyICYmIChuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdCksIG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsIG4uVEVYVFVSRV9NSU5fRklMVEVSLCByIHx8IHQpLCB0aGlzLmZpbHRlciA9IHQpLCBlICE9PSB0aGlzLndyYXAgJiYgKG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsIG4uVEVYVFVSRV9XUkFQX1MsIGUpLCBuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELCBuLlRFWFRVUkVfV1JBUF9ULCBlKSwgdGhpcy53cmFwID0gZSk7XG4gICAgfSwgVmwucHJvdG90eXBlLmlzU2l6ZVBvd2VyT2ZUd28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplWzBdID09PSB0aGlzLnNpemVbMV0gJiYgTWF0aC5sb2codGhpcy5zaXplWzBdKSAvIE1hdGguTE4yICUgMSA9PSAwO1xuICAgIH0sIFZsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb250ZXh0LmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKSwgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIEZsID0gZnVuY3Rpb24gRmwodCkge1xuICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSB0LCB0aGlzLl90cmlnZ2VyZWQgPSAhMSwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgJiYgKHRoaXMuX2NoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSwgdGhpcy5fY2hhbm5lbC5wb3J0Mi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGUuX3RyaWdnZXJlZCA9ICExLCBlLl9jYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIEZsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgdGhpcy5fdHJpZ2dlcmVkIHx8ICh0aGlzLl90cmlnZ2VyZWQgPSAhMCwgdGhpcy5fY2hhbm5lbCA/IHRoaXMuX2NoYW5uZWwucG9ydDEucG9zdE1lc3NhZ2UoITApIDogc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQuX3RyaWdnZXJlZCA9ICExLCB0Ll9jYWxsYmFjaygpO1xuICAgICAgfSwgMCkpO1xuICAgIH0sIEZsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY2hhbm5lbCwgdGhpcy5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9O1xuXG4gICAgdmFyIERsID0gZnVuY3Rpb24gRGwodCwgZSwgcikge1xuICAgICAgdGhpcy50YXJnZXQgPSB0LCB0aGlzLnBhcmVudCA9IGUsIHRoaXMubWFwSWQgPSByLCB0aGlzLmNhbGxiYWNrcyA9IHt9LCB0aGlzLnRhc2tzID0ge30sIHRoaXMudGFza1F1ZXVlID0gW10sIHRoaXMuY2FuY2VsQ2FsbGJhY2tzID0ge30sIHYoW1wicmVjZWl2ZVwiLCBcInByb2Nlc3NcIl0sIHRoaXMpLCB0aGlzLmludm9rZXIgPSBuZXcgRmwodGhpcy5wcm9jZXNzKSwgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5yZWNlaXZlLCAhMSksIHRoaXMuZ2xvYmFsU2NvcGUgPSBJKCkgPyB0IDogbztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTGwodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSAyICogTWF0aC5QSSAqIDYzNzgxMzcgLyAyNTYgLyBNYXRoLnBvdygyLCByKTtcbiAgICAgIHJldHVybiBbdCAqIG4gLSAyICogTWF0aC5QSSAqIDYzNzgxMzcgLyAyLCBlICogbiAtIDIgKiBNYXRoLlBJICogNjM3ODEzNyAvIDJdO1xuICAgIH1cblxuICAgIERsLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9ICExKTtcbiAgICAgIHZhciBvID0gTWF0aC5yb3VuZCgxZTE4ICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICByICYmICh0aGlzLmNhbGxiYWNrc1tvXSA9IHIpO1xuICAgICAgdmFyIHMgPSBFKHRoaXMuZ2xvYmFsU2NvcGUpID8gdm9pZCAwIDogW107XG4gICAgICByZXR1cm4gdGhpcy50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogbyxcbiAgICAgICAgdHlwZTogdCxcbiAgICAgICAgaGFzQ2FsbGJhY2s6ICEhcixcbiAgICAgICAgdGFyZ2V0TWFwSWQ6IG4sXG4gICAgICAgIG11c3RRdWV1ZTogaSxcbiAgICAgICAgc291cmNlTWFwSWQ6IHRoaXMubWFwSWQsXG4gICAgICAgIGRhdGE6IE5uKGUsIHMpXG4gICAgICB9LCBzKSwge1xuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICByICYmIGRlbGV0ZSBhLmNhbGxiYWNrc1tvXSwgYS50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IG8sXG4gICAgICAgICAgICB0eXBlOiBcIjxjYW5jZWw+XCIsXG4gICAgICAgICAgICB0YXJnZXRNYXBJZDogbixcbiAgICAgICAgICAgIHNvdXJjZU1hcElkOiBhLm1hcElkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgRGwucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmRhdGEsXG4gICAgICAgICAgciA9IGUuaWQ7XG4gICAgICBpZiAociAmJiAoIWUudGFyZ2V0TWFwSWQgfHwgdGhpcy5tYXBJZCA9PT0gZS50YXJnZXRNYXBJZCkpIGlmIChcIjxjYW5jZWw+XCIgPT09IGUudHlwZSkge1xuICAgICAgICBkZWxldGUgdGhpcy50YXNrc1tyXTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNhbmNlbENhbGxiYWNrc1tyXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FuY2VsQ2FsbGJhY2tzW3JdLCBuICYmIG4oKTtcbiAgICAgIH0gZWxzZSBJKCkgfHwgZS5tdXN0UXVldWUgPyAodGhpcy50YXNrc1tyXSA9IGUsIHRoaXMudGFza1F1ZXVlLnB1c2gociksIHRoaXMuaW52b2tlci50cmlnZ2VyKCkpIDogdGhpcy5wcm9jZXNzVGFzayhyLCBlKTtcbiAgICB9LCBEbC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnRhc2tRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRhc2tRdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgZSA9IHRoaXMudGFza3NbdF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhc2tzW3RdLCB0aGlzLnRhc2tRdWV1ZS5sZW5ndGggJiYgdGhpcy5pbnZva2VyLnRyaWdnZXIoKSwgZSAmJiB0aGlzLnByb2Nlc3NUYXNrKHQsIGUpO1xuICAgICAgfVxuICAgIH0sIERsLnByb3RvdHlwZS5wcm9jZXNzVGFzayA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRoaXM7XG5cbiAgICAgIGlmIChcIjxyZXNwb25zZT5cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jYWxsYmFja3NbdF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1t0XSwgbiAmJiAoZS5lcnJvciA/IG4oS24oZS5lcnJvcikpIDogbihudWxsLCBLbihlLmRhdGEpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9ICExLFxuICAgICAgICAgICAgYSA9IEUodGhpcy5nbG9iYWxTY29wZSkgPyB2b2lkIDAgOiBbXSxcbiAgICAgICAgICAgIG8gPSBlLmhhc0NhbGxiYWNrID8gZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICBpID0gITAsIGRlbGV0ZSByLmNhbmNlbENhbGxiYWNrc1t0XSwgci50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IHQsXG4gICAgICAgICAgICB0eXBlOiBcIjxyZXNwb25zZT5cIixcbiAgICAgICAgICAgIHNvdXJjZU1hcElkOiByLm1hcElkLFxuICAgICAgICAgICAgZXJyb3I6IGUgPyBObihlKSA6IG51bGwsXG4gICAgICAgICAgICBkYXRhOiBObihuLCBhKVxuICAgICAgICAgIH0sIGEpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpID0gITA7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBzID0gbnVsbCxcbiAgICAgICAgICAgIHUgPSBLbihlLmRhdGEpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRbZS50eXBlXSkgcyA9IHRoaXMucGFyZW50W2UudHlwZV0oZS5zb3VyY2VNYXBJZCwgdSwgbyk7ZWxzZSBpZiAodGhpcy5wYXJlbnQuZ2V0V29ya2VyU291cmNlKSB7XG4gICAgICAgICAgdmFyIGwgPSBlLnR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIHMgPSB0aGlzLnBhcmVudC5nZXRXb3JrZXJTb3VyY2UoZS5zb3VyY2VNYXBJZCwgbFswXSwgdS5zb3VyY2UpW2xbMV1dKHUsIG8pO1xuICAgICAgICB9IGVsc2UgbyhuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBmdW5jdGlvbiBcIiArIGUudHlwZSkpO1xuICAgICAgICAhaSAmJiBzICYmIHMuY2FuY2VsICYmICh0aGlzLmNhbmNlbENhbGxiYWNrc1t0XSA9IHMuY2FuY2VsKTtcbiAgICAgIH1cbiAgICB9LCBEbC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pbnZva2VyLnJlbW92ZSgpLCB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLnJlY2VpdmUsICExKTtcbiAgICB9O1xuXG4gICAgdmFyIFJsID0gZnVuY3Rpb24gUmwodCwgZSkge1xuICAgICAgdCAmJiAoZSA/IHRoaXMuc2V0U291dGhXZXN0KHQpLnNldE5vcnRoRWFzdChlKSA6IDQgPT09IHQubGVuZ3RoID8gdGhpcy5zZXRTb3V0aFdlc3QoW3RbMF0sIHRbMV1dKS5zZXROb3J0aEVhc3QoW3RbMl0sIHRbM11dKSA6IHRoaXMuc2V0U291dGhXZXN0KHRbMF0pLnNldE5vcnRoRWFzdCh0WzFdKSk7XG4gICAgfTtcblxuICAgIFJsLnByb3RvdHlwZS5zZXROb3J0aEVhc3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lID0gdCBpbnN0YW5jZW9mIE9sID8gbmV3IE9sKHQubG5nLCB0LmxhdCkgOiBPbC5jb252ZXJ0KHQpLCB0aGlzO1xuICAgIH0sIFJsLnByb3RvdHlwZS5zZXRTb3V0aFdlc3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N3ID0gdCBpbnN0YW5jZW9mIE9sID8gbmV3IE9sKHQubG5nLCB0LmxhdCkgOiBPbC5jb252ZXJ0KHQpLCB0aGlzO1xuICAgIH0sIFJsLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgcixcbiAgICAgICAgICBuID0gdGhpcy5fc3csXG4gICAgICAgICAgaSA9IHRoaXMuX25lO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBPbCkgZSA9IHQsIHIgPSB0O2Vsc2Uge1xuICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgUmwpKSByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IDQgPT09IHQubGVuZ3RoIHx8IHQuZXZlcnkoQXJyYXkuaXNBcnJheSkgPyB0aGlzLmV4dGVuZChSbC5jb252ZXJ0KHQpKSA6IHRoaXMuZXh0ZW5kKE9sLmNvbnZlcnQodCkpIDogdGhpcztcbiAgICAgICAgaWYgKHIgPSB0Ll9uZSwgIShlID0gdC5fc3cpIHx8ICFyKSByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuIHx8IGkgPyAobi5sbmcgPSBNYXRoLm1pbihlLmxuZywgbi5sbmcpLCBuLmxhdCA9IE1hdGgubWluKGUubGF0LCBuLmxhdCksIGkubG5nID0gTWF0aC5tYXgoci5sbmcsIGkubG5nKSwgaS5sYXQgPSBNYXRoLm1heChyLmxhdCwgaS5sYXQpKSA6ICh0aGlzLl9zdyA9IG5ldyBPbChlLmxuZywgZS5sYXQpLCB0aGlzLl9uZSA9IG5ldyBPbChyLmxuZywgci5sYXQpKSwgdGhpcztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBPbCgodGhpcy5fc3cubG5nICsgdGhpcy5fbmUubG5nKSAvIDIsICh0aGlzLl9zdy5sYXQgKyB0aGlzLl9uZS5sYXQpIC8gMik7XG4gICAgfSwgUmwucHJvdG90eXBlLmdldFNvdXRoV2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0Tm9ydGhFYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lO1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXROb3J0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9sKHRoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldE5vcnRoKCkpO1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXRTb3V0aEVhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9sKHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldFNvdXRoKCkpO1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXRXZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N3LmxuZztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0U291dGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3cubGF0O1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXRFYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lLmxuZztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0Tm9ydGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmUubGF0O1xuICAgIH0sIFJsLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLl9zdy50b0FycmF5KCksIHRoaXMuX25lLnRvQXJyYXkoKV07XG4gICAgfSwgUmwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiTG5nTGF0Qm91bmRzKFwiICsgdGhpcy5fc3cudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX25lLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9LCBSbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuX3N3ICYmIHRoaXMuX25lKTtcbiAgICB9LCBSbC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBPbC5jb252ZXJ0KHQpLFxuICAgICAgICAgIHIgPSBlLmxuZyxcbiAgICAgICAgICBuID0gZS5sYXQsXG4gICAgICAgICAgaSA9IHRoaXMuX3N3LmxuZyA8PSByICYmIHIgPD0gdGhpcy5fbmUubG5nO1xuICAgICAgcmV0dXJuIHRoaXMuX3N3LmxuZyA+IHRoaXMuX25lLmxuZyAmJiAoaSA9IHRoaXMuX3N3LmxuZyA+PSByICYmIHIgPj0gdGhpcy5fbmUubG5nKSwgdGhpcy5fc3cubGF0IDw9IG4gJiYgbiA8PSB0aGlzLl9uZS5sYXQgJiYgaTtcbiAgICB9LCBSbC5jb252ZXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAhdCB8fCB0IGluc3RhbmNlb2YgUmwgPyB0IDogbmV3IFJsKHQpO1xuICAgIH07XG5cbiAgICB2YXIgT2wgPSBmdW5jdGlvbiBPbCh0LCBlKSB7XG4gICAgICBpZiAoaXNOYU4odCkgfHwgaXNOYU4oZSkpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTG5nTGF0IG9iamVjdDogKFwiICsgdCArIFwiLCBcIiArIGUgKyBcIilcIik7XG4gICAgICBpZiAodGhpcy5sbmcgPSArdCwgdGhpcy5sYXQgPSArZSwgdGhpcy5sYXQgPiA5MCB8fCB0aGlzLmxhdCA8IC05MCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMbmdMYXQgbGF0aXR1ZGUgdmFsdWU6IG11c3QgYmUgYmV0d2VlbiAtOTAgYW5kIDkwXCIpO1xuICAgIH07XG5cbiAgICBPbC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgT2woYyh0aGlzLmxuZywgLTE4MCwgMTgwKSwgdGhpcy5sYXQpO1xuICAgIH0sIE9sLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmxuZywgdGhpcy5sYXRdO1xuICAgIH0sIE9sLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIkxuZ0xhdChcIiArIHRoaXMubG5nICsgXCIsIFwiICsgdGhpcy5sYXQgKyBcIilcIjtcbiAgICB9LCBPbC5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgICAgciA9IHRoaXMubGF0ICogZSxcbiAgICAgICAgICBuID0gdC5sYXQgKiBlLFxuICAgICAgICAgIGkgPSBNYXRoLnNpbihyKSAqIE1hdGguc2luKG4pICsgTWF0aC5jb3MocikgKiBNYXRoLmNvcyhuKSAqIE1hdGguY29zKCh0LmxuZyAtIHRoaXMubG5nKSAqIGUpO1xuICAgICAgcmV0dXJuIDYzNzEwMDguOCAqIE1hdGguYWNvcyhNYXRoLm1pbihpLCAxKSk7XG4gICAgfSwgT2wucHJvdG90eXBlLnRvQm91bmRzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IDApO1xuICAgICAgdmFyIGUgPSAzNjAgKiB0IC8gNDAwNzUwMTcsXG4gICAgICAgICAgciA9IGUgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogdGhpcy5sYXQpO1xuICAgICAgcmV0dXJuIG5ldyBSbChuZXcgT2wodGhpcy5sbmcgLSByLCB0aGlzLmxhdCAtIGUpLCBuZXcgT2wodGhpcy5sbmcgKyByLCB0aGlzLmxhdCArIGUpKTtcbiAgICB9LCBPbC5jb252ZXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgT2wpIHJldHVybiB0O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkgJiYgKDIgPT09IHQubGVuZ3RoIHx8IDMgPT09IHQubGVuZ3RoKSkgcmV0dXJuIG5ldyBPbChOdW1iZXIodFswXSksIE51bWJlcih0WzFdKSk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodCkgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSByZXR1cm4gbmV3IE9sKE51bWJlcihcImxuZ1wiIGluIHQgPyB0LmxuZyA6IHQubG9uKSwgTnVtYmVyKHQubGF0KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgTG5nTGF0TGlrZWAgYXJndW1lbnQgbXVzdCBiZSBzcGVjaWZpZWQgYXMgYSBMbmdMYXQgaW5zdGFuY2UsIGFuIG9iamVjdCB7bG5nOiA8bG5nPiwgbGF0OiA8bGF0Pn0sIGFuIG9iamVjdCB7bG9uOiA8bG5nPiwgbGF0OiA8bGF0Pn0sIG9yIGFuIGFycmF5IG9mIFs8bG5nPiwgPGxhdD5dXCIpO1xuICAgIH07XG4gICAgdmFyIFVsID0gMiAqIE1hdGguUEkgKiA2MzcxMDA4Ljg7XG5cbiAgICBmdW5jdGlvbiBqbCh0KSB7XG4gICAgICByZXR1cm4gVWwgKiBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDE4MCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcWwodCkge1xuICAgICAgcmV0dXJuICgxODAgKyB0KSAvIDM2MDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBObCh0KSB7XG4gICAgICByZXR1cm4gKDE4MCAtIDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIHQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEtsKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IC8gamwoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR2wodCkge1xuICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoKDE4MCAtIDM2MCAqIHQpICogTWF0aC5QSSAvIDE4MCkpIC0gOTA7XG4gICAgfVxuXG4gICAgdmFyIFpsID0gZnVuY3Rpb24gWmwodCwgZSwgcikge1xuICAgICAgdm9pZCAwID09PSByICYmIChyID0gMCksIHRoaXMueCA9ICt0LCB0aGlzLnkgPSArZSwgdGhpcy56ID0gK3I7XG4gICAgfTtcblxuICAgIFpsLmZyb21MbmdMYXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMCk7XG4gICAgICB2YXIgciA9IE9sLmNvbnZlcnQodCk7XG4gICAgICByZXR1cm4gbmV3IFpsKHFsKHIubG5nKSwgTmwoci5sYXQpLCBLbChlLCByLmxhdCkpO1xuICAgIH0sIFpsLnByb3RvdHlwZS50b0xuZ0xhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgT2woMzYwICogdGhpcy54IC0gMTgwLCBHbCh0aGlzLnkpKTtcbiAgICB9LCBabC5wcm90b3R5cGUudG9BbHRpdHVkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnogKiBqbChHbCh0aGlzLnkpKTtcbiAgICB9LCBabC5wcm90b3R5cGUubWV0ZXJJbk1lcmNhdG9yQ29vcmRpbmF0ZVVuaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDEgLyBVbCAqICh0ID0gR2wodGhpcy55KSwgMSAvIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMTgwKSk7XG4gICAgICB2YXIgdDtcbiAgICB9O1xuXG4gICAgdmFyIFhsID0gZnVuY3Rpb24gWGwodCwgZSwgcikge1xuICAgICAgdGhpcy56ID0gdCwgdGhpcy54ID0gZSwgdGhpcy55ID0gciwgdGhpcy5rZXkgPSBZbCgwLCB0LCB0LCBlLCByKTtcbiAgICB9O1xuXG4gICAgWGwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy56ID09PSB0LnogJiYgdGhpcy54ID09PSB0LnggJiYgdGhpcy55ID09PSB0Lnk7XG4gICAgfSwgWGwucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgcixcbiAgICAgICAgICBuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgYSxcbiAgICAgICAgICBvLFxuICAgICAgICAgIHMgPSAobiA9IHRoaXMueSwgaSA9IHRoaXMueiwgYSA9IExsKDI1NiAqIChyID0gdGhpcy54KSwgMjU2ICogKG4gPSBNYXRoLnBvdygyLCBpKSAtIG4gLSAxKSwgaSksIG8gPSBMbCgyNTYgKiAociArIDEpLCAyNTYgKiAobiArIDEpLCBpKSwgYVswXSArIFwiLFwiICsgYVsxXSArIFwiLFwiICsgb1swXSArIFwiLFwiICsgb1sxXSksXG4gICAgICAgICAgdSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIGZvciAodmFyIG4sIGkgPSBcIlwiLCBhID0gdDsgYSA+IDA7IGEtLSkge1xuICAgICAgICAgIGkgKz0gKGUgJiAobiA9IDEgPDwgYSAtIDEpID8gMSA6IDApICsgKHIgJiBuID8gMiA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KHRoaXMueiwgdGhpcy54LCB0aGlzLnkpO1xuXG4gICAgICByZXR1cm4gdFsodGhpcy54ICsgdGhpcy55KSAlIHQubGVuZ3RoXS5yZXBsYWNlKFwie3ByZWZpeH1cIiwgKHRoaXMueCAlIDE2KS50b1N0cmluZygxNikgKyAodGhpcy55ICUgMTYpLnRvU3RyaW5nKDE2KSkucmVwbGFjZShcInt6fVwiLCBTdHJpbmcodGhpcy56KSkucmVwbGFjZShcInt4fVwiLCBTdHJpbmcodGhpcy54KSkucmVwbGFjZShcInt5fVwiLCBTdHJpbmcoXCJ0bXNcIiA9PT0gZSA/IE1hdGgucG93KDIsIHRoaXMueikgLSB0aGlzLnkgLSAxIDogdGhpcy55KSkucmVwbGFjZShcIntxdWFka2V5fVwiLCB1KS5yZXBsYWNlKFwie2Jib3gtZXBzZy0zODU3fVwiLCBzKTtcbiAgICB9LCBYbC5wcm90b3R5cGUuZ2V0VGlsZVBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gTWF0aC5wb3coMiwgdGhpcy56KTtcbiAgICAgIHJldHVybiBuZXcgaSg4MTkyICogKHQueCAqIGUgLSB0aGlzLngpLCA4MTkyICogKHQueSAqIGUgLSB0aGlzLnkpKTtcbiAgICB9LCBYbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy56ICsgXCIvXCIgKyB0aGlzLnggKyBcIi9cIiArIHRoaXMueTtcbiAgICB9O1xuXG4gICAgdmFyIEpsID0gZnVuY3Rpb24gSmwodCwgZSkge1xuICAgICAgdGhpcy53cmFwID0gdCwgdGhpcy5jYW5vbmljYWwgPSBlLCB0aGlzLmtleSA9IFlsKHQsIGUueiwgZS56LCBlLngsIGUueSk7XG4gICAgfSxcbiAgICAgICAgSGwgPSBmdW5jdGlvbiBIbCh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLm92ZXJzY2FsZWRaID0gdCwgdGhpcy53cmFwID0gZSwgdGhpcy5jYW5vbmljYWwgPSBuZXcgWGwociwgK24sICtpKSwgdGhpcy5rZXkgPSBZbChlLCB0LCByLCBuLCBpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gWWwodCwgZSwgciwgbiwgaSkge1xuICAgICAgKHQgKj0gMikgPCAwICYmICh0ID0gLTEgKiB0IC0gMSk7XG4gICAgICB2YXIgYSA9IDEgPDwgcjtcbiAgICAgIHJldHVybiAoYSAqIGEgKiB0ICsgYSAqIGkgKyBuKS50b1N0cmluZygzNikgKyByLnRvU3RyaW5nKDM2KSArIGUudG9TdHJpbmcoMzYpO1xuICAgIH1cblxuICAgIEhsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMub3ZlcnNjYWxlZFogPT09IHQub3ZlcnNjYWxlZFogJiYgdGhpcy53cmFwID09PSB0LndyYXAgJiYgdGhpcy5jYW5vbmljYWwuZXF1YWxzKHQuY2Fub25pY2FsKTtcbiAgICB9LCBIbC5wcm90b3R5cGUuc2NhbGVkVG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNhbm9uaWNhbC56IC0gdDtcbiAgICAgIHJldHVybiB0ID4gdGhpcy5jYW5vbmljYWwueiA/IG5ldyBIbCh0LCB0aGlzLndyYXAsIHRoaXMuY2Fub25pY2FsLnosIHRoaXMuY2Fub25pY2FsLngsIHRoaXMuY2Fub25pY2FsLnkpIDogbmV3IEhsKHQsIHRoaXMud3JhcCwgdCwgdGhpcy5jYW5vbmljYWwueCA+PiBlLCB0aGlzLmNhbm9uaWNhbC55ID4+IGUpO1xuICAgIH0sIEhsLnByb3RvdHlwZS5jYWxjdWxhdGVTY2FsZWRLZXkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzLmNhbm9uaWNhbC56IC0gdDtcbiAgICAgIHJldHVybiB0ID4gdGhpcy5jYW5vbmljYWwueiA/IFlsKHRoaXMud3JhcCAqICtlLCB0LCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KSA6IFlsKHRoaXMud3JhcCAqICtlLCB0LCB0LCB0aGlzLmNhbm9uaWNhbC54ID4+IHIsIHRoaXMuY2Fub25pY2FsLnkgPj4gcik7XG4gICAgfSwgSGwucHJvdG90eXBlLmlzQ2hpbGRPZiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodC53cmFwICE9PSB0aGlzLndyYXApIHJldHVybiAhMTtcbiAgICAgIHZhciBlID0gdGhpcy5jYW5vbmljYWwueiAtIHQuY2Fub25pY2FsLno7XG4gICAgICByZXR1cm4gMCA9PT0gdC5vdmVyc2NhbGVkWiB8fCB0Lm92ZXJzY2FsZWRaIDwgdGhpcy5vdmVyc2NhbGVkWiAmJiB0LmNhbm9uaWNhbC54ID09PSB0aGlzLmNhbm9uaWNhbC54ID4+IGUgJiYgdC5jYW5vbmljYWwueSA9PT0gdGhpcy5jYW5vbmljYWwueSA+PiBlO1xuICAgIH0sIEhsLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodGhpcy5vdmVyc2NhbGVkWiA+PSB0KSByZXR1cm4gW25ldyBIbCh0aGlzLm92ZXJzY2FsZWRaICsgMSwgdGhpcy53cmFwLCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KV07XG4gICAgICB2YXIgZSA9IHRoaXMuY2Fub25pY2FsLnogKyAxLFxuICAgICAgICAgIHIgPSAyICogdGhpcy5jYW5vbmljYWwueCxcbiAgICAgICAgICBuID0gMiAqIHRoaXMuY2Fub25pY2FsLnk7XG4gICAgICByZXR1cm4gW25ldyBIbChlLCB0aGlzLndyYXAsIGUsIHIsIG4pLCBuZXcgSGwoZSwgdGhpcy53cmFwLCBlLCByICsgMSwgbiksIG5ldyBIbChlLCB0aGlzLndyYXAsIGUsIHIsIG4gKyAxKSwgbmV3IEhsKGUsIHRoaXMud3JhcCwgZSwgciArIDEsIG4gKyAxKV07XG4gICAgfSwgSGwucHJvdG90eXBlLmlzTGVzc1RoYW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMud3JhcCA8IHQud3JhcCB8fCAhKHRoaXMud3JhcCA+IHQud3JhcCkgJiYgKHRoaXMub3ZlcnNjYWxlZFogPCB0Lm92ZXJzY2FsZWRaIHx8ICEodGhpcy5vdmVyc2NhbGVkWiA+IHQub3ZlcnNjYWxlZFopICYmICh0aGlzLmNhbm9uaWNhbC54IDwgdC5jYW5vbmljYWwueCB8fCAhKHRoaXMuY2Fub25pY2FsLnggPiB0LmNhbm9uaWNhbC54KSAmJiB0aGlzLmNhbm9uaWNhbC55IDwgdC5jYW5vbmljYWwueSkpO1xuICAgIH0sIEhsLnByb3RvdHlwZS53cmFwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBIbCh0aGlzLm92ZXJzY2FsZWRaLCAwLCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KTtcbiAgICB9LCBIbC5wcm90b3R5cGUudW53cmFwVG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5ldyBIbCh0aGlzLm92ZXJzY2FsZWRaLCB0LCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KTtcbiAgICB9LCBIbC5wcm90b3R5cGUub3ZlcnNjYWxlRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIHRoaXMub3ZlcnNjYWxlZFogLSB0aGlzLmNhbm9uaWNhbC56KTtcbiAgICB9LCBIbC5wcm90b3R5cGUudG9VbndyYXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEpsKHRoaXMud3JhcCwgdGhpcy5jYW5vbmljYWwpO1xuICAgIH0sIEhsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJzY2FsZWRaICsgXCIvXCIgKyB0aGlzLmNhbm9uaWNhbC54ICsgXCIvXCIgKyB0aGlzLmNhbm9uaWNhbC55O1xuICAgIH0sIEhsLnByb3RvdHlwZS5nZXRUaWxlUG9pbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsLmdldFRpbGVQb2ludChuZXcgWmwodC54IC0gdGhpcy53cmFwLCB0LnkpKTtcbiAgICB9LCBPbihcIkNhbm9uaWNhbFRpbGVJRFwiLCBYbCksIE9uKFwiT3ZlcnNjYWxlZFRpbGVJRFwiLCBIbCwge1xuICAgICAgb21pdDogW1wicG9zTWF0cml4XCJdXG4gICAgfSk7XG5cbiAgICB2YXIgJGwgPSBmdW5jdGlvbiAkbCh0LCBlLCByKSB7XG4gICAgICBpZiAodGhpcy51aWQgPSB0LCBlLmhlaWdodCAhPT0gZS53aWR0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJERU0gdGlsZXMgbXVzdCBiZSBzcXVhcmVcIik7XG4gICAgICBpZiAociAmJiBcIm1hcGJveFwiICE9PSByICYmIFwidGVycmFyaXVtXCIgIT09IHIpIHJldHVybiBBKCdcIicgKyByICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGVuY29kaW5nIHR5cGUuIFZhbGlkIHR5cGVzIGluY2x1ZGUgXCJtYXBib3hcIiBhbmQgXCJ0ZXJyYXJpdW1cIi4nKTtcbiAgICAgIHRoaXMuc3RyaWRlID0gZS5oZWlnaHQ7XG4gICAgICB2YXIgbiA9IHRoaXMuZGltID0gZS5oZWlnaHQgLSAyO1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KGUuZGF0YS5idWZmZXIpLCB0aGlzLmVuY29kaW5nID0gciB8fCBcIm1hcGJveFwiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5faWR4KC0xLCBpKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KDAsIGkpXSwgdGhpcy5kYXRhW3RoaXMuX2lkeChuLCBpKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KG4gLSAxLCBpKV0sIHRoaXMuZGF0YVt0aGlzLl9pZHgoaSwgLTEpXSA9IHRoaXMuZGF0YVt0aGlzLl9pZHgoaSwgMCldLCB0aGlzLmRhdGFbdGhpcy5faWR4KGksIG4pXSA9IHRoaXMuZGF0YVt0aGlzLl9pZHgoaSwgbiAtIDEpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhW3RoaXMuX2lkeCgtMSwgLTEpXSA9IHRoaXMuZGF0YVt0aGlzLl9pZHgoMCwgMCldLCB0aGlzLmRhdGFbdGhpcy5faWR4KG4sIC0xKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KG4gLSAxLCAwKV0sIHRoaXMuZGF0YVt0aGlzLl9pZHgoLTEsIG4pXSA9IHRoaXMuZGF0YVt0aGlzLl9pZHgoMCwgbiAtIDEpXSwgdGhpcy5kYXRhW3RoaXMuX2lkeChuLCBuKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KG4gLSAxLCBuIC0gMSldO1xuICAgIH07XG5cbiAgICAkbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciksXG4gICAgICAgICAgbiA9IDQgKiB0aGlzLl9pZHgodCwgZSk7XG5cbiAgICAgIHJldHVybiAoXCJ0ZXJyYXJpdW1cIiA9PT0gdGhpcy5lbmNvZGluZyA/IHRoaXMuX3VucGFja1RlcnJhcml1bSA6IHRoaXMuX3VucGFja01hcGJveCkocltuXSwgcltuICsgMV0sIHJbbiArIDJdKTtcbiAgICB9LCAkbC5wcm90b3R5cGUuZ2V0VW5wYWNrVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwidGVycmFyaXVtXCIgPT09IHRoaXMuZW5jb2RpbmcgPyBbMjU2LCAxLCAxIC8gMjU2LCAzMjc2OF0gOiBbNjU1My42LCAyNS42LCAuMSwgMWU0XTtcbiAgICB9LCAkbC5wcm90b3R5cGUuX2lkeCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodCA8IC0xIHx8IHQgPj0gdGhpcy5kaW0gKyAxIHx8IGUgPCAtMSB8fCBlID49IHRoaXMuZGltICsgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2Ugc291cmNlIGNvb3JkaW5hdGVzIGZvciBERU0gZGF0YVwiKTtcbiAgICAgIHJldHVybiAoZSArIDEpICogdGhpcy5zdHJpZGUgKyAodCArIDEpO1xuICAgIH0sICRsLnByb3RvdHlwZS5fdW5wYWNrTWFwYm94ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiAoMjU2ICogdCAqIDI1NiArIDI1NiAqIGUgKyByKSAvIDEwIC0gMWU0O1xuICAgIH0sICRsLnByb3RvdHlwZS5fdW5wYWNrVGVycmFyaXVtID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiAyNTYgKiB0ICsgZSArIHIgLyAyNTYgLSAzMjc2ODtcbiAgICB9LCAkbC5wcm90b3R5cGUuZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBibyh7XG4gICAgICAgIHdpZHRoOiB0aGlzLnN0cmlkZSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnN0cmlkZVxuICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcikpO1xuICAgIH0sICRsLnByb3RvdHlwZS5iYWNrZmlsbEJvcmRlciA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBpZiAodGhpcy5kaW0gIT09IHQuZGltKSB0aHJvdyBuZXcgRXJyb3IoXCJkZW0gZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICAgICAgdmFyIG4gPSBlICogdGhpcy5kaW0sXG4gICAgICAgICAgaSA9IGUgKiB0aGlzLmRpbSArIHRoaXMuZGltLFxuICAgICAgICAgIGEgPSByICogdGhpcy5kaW0sXG4gICAgICAgICAgbyA9IHIgKiB0aGlzLmRpbSArIHRoaXMuZGltO1xuXG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBuID0gaSAtIDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGkgPSBuICsgMTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChyKSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgYSA9IG8gLSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvID0gYSArIDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHMgPSAtZSAqIHRoaXMuZGltLCB1ID0gLXIgKiB0aGlzLmRpbSwgbCA9IGE7IGwgPCBvOyBsKyspIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IG47IHAgPCBpOyBwKyspIHtcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5faWR4KHAsIGwpXSA9IHQuZGF0YVt0aGlzLl9pZHgocCArIHMsIGwgKyB1KV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBPbihcIkRFTURhdGFcIiwgJGwpO1xuXG4gICAgdmFyIFdsID0gZnVuY3Rpb24gV2wodCkge1xuICAgICAgdGhpcy5fc3RyaW5nVG9OdW1iZXIgPSB7fSwgdGhpcy5fbnVtYmVyVG9TdHJpbmcgPSBbXTtcblxuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIHZhciByID0gdFtlXTtcbiAgICAgICAgdGhpcy5fc3RyaW5nVG9OdW1iZXJbcl0gPSBlLCB0aGlzLl9udW1iZXJUb1N0cmluZ1tlXSA9IHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFdsLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ1RvTnVtYmVyW3RdO1xuICAgIH0sIFdsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX251bWJlclRvU3RyaW5nW3RdO1xuICAgIH07XG5cbiAgICB2YXIgUWwgPSBmdW5jdGlvbiBRbCh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLnR5cGUgPSBcIkZlYXR1cmVcIiwgdGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUgPSB0LCB0Ll96ID0gZSwgdC5feCA9IHIsIHQuX3kgPSBuLCB0aGlzLnByb3BlcnRpZXMgPSB0LnByb3BlcnRpZXMsIHRoaXMuaWQgPSBpO1xuICAgIH0sXG4gICAgICAgIHRwID0ge1xuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cC5nZW9tZXRyeS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSB0aGlzLl9nZW9tZXRyeSAmJiAodGhpcy5fZ2VvbWV0cnkgPSB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS50b0dlb0pTT04odGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUuX3gsIHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlLl95LCB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS5feikuZ2VvbWV0cnkpLCB0aGlzLl9nZW9tZXRyeTtcbiAgICB9LCB0cC5nZW9tZXRyeS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkgPSB0O1xuICAgIH0sIFFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IHRoaXMuZ2VvbWV0cnlcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGUgaW4gdGhpcykge1xuICAgICAgICBcIl9nZW9tZXRyeVwiICE9PSBlICYmIFwiX3ZlY3RvclRpbGVGZWF0dXJlXCIgIT09IGUgJiYgKHRbZV0gPSB0aGlzW2VdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUWwucHJvdG90eXBlLCB0cCk7XG5cbiAgICB2YXIgZXAgPSBmdW5jdGlvbiBlcCgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7fSwgdGhpcy5zdGF0ZUNoYW5nZXMgPSB7fSwgdGhpcy5kZWxldGVkU3RhdGVzID0ge307XG4gICAgfTtcblxuICAgIGVwLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IFN0cmluZyhlKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlQ2hhbmdlc1t0XSA9IHRoaXMuc3RhdGVDaGFuZ2VzW3RdIHx8IHt9LCB0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSA9IHRoaXMuc3RhdGVDaGFuZ2VzW3RdW25dIHx8IHt9LCBoKHRoaXMuc3RhdGVDaGFuZ2VzW3RdW25dLCByKSwgbnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdKSBmb3IgKHZhciBpIGluIHRoaXMuZGVsZXRlZFN0YXRlc1t0XSA9IHt9LCB0aGlzLnN0YXRlW3RdKSB7XG4gICAgICAgIGkgIT09IG4gJiYgKHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtpXSA9IG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gJiYgbnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dKSBmb3IgKHZhciBhIGluIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSA9IHt9LCB0aGlzLnN0YXRlW3RdW25dKSB7XG4gICAgICAgIHJbYV0gfHwgKHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXVthXSA9IG51bGwpO1xuICAgICAgfSBlbHNlIGZvciAodmFyIG8gaW4gcikge1xuICAgICAgICB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gJiYgdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dICYmIG51bGwgPT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXVtvXSAmJiBkZWxldGUgdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dW29dO1xuICAgICAgfVxuICAgIH0sIGVwLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKG51bGwgIT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XSkge1xuICAgICAgICB2YXIgbiA9IFN0cmluZyhlKTtcbiAgICAgICAgaWYgKHRoaXMuZGVsZXRlZFN0YXRlc1t0XSA9IHRoaXMuZGVsZXRlZFN0YXRlc1t0XSB8fCB7fSwgciAmJiB2b2lkIDAgIT09IGUpIG51bGwgIT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSAmJiAodGhpcy5kZWxldGVkU3RhdGVzW3RdW25dID0gdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dIHx8IHt9LCB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl1bcl0gPSBudWxsKTtlbHNlIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZUNoYW5nZXNbdF0gJiYgdGhpcy5zdGF0ZUNoYW5nZXNbdF1bbl0pIGZvciAociBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gPSB7fSwgdGhpcy5zdGF0ZUNoYW5nZXNbdF1bbl0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXVtyXSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sIGVwLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IFN0cmluZyhlKSxcbiAgICAgICAgICBuID0gaCh7fSwgKHRoaXMuc3RhdGVbdF0gfHwge30pW3JdLCAodGhpcy5zdGF0ZUNoYW5nZXNbdF0gfHwge30pW3JdKTtcbiAgICAgIGlmIChudWxsID09PSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0pIHJldHVybiB7fTtcblxuICAgICAgaWYgKHRoaXMuZGVsZXRlZFN0YXRlc1t0XSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtlXTtcbiAgICAgICAgaWYgKG51bGwgPT09IGkpIHJldHVybiB7fTtcblxuICAgICAgICBmb3IgKHZhciBhIGluIGkpIHtcbiAgICAgICAgICBkZWxldGUgblthXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBlcC5wcm90b3R5cGUuaW5pdGlhbGl6ZVRpbGVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0LnNldEZlYXR1cmVTdGF0ZSh0aGlzLnN0YXRlLCBlKTtcbiAgICB9LCBlcC5wcm90b3R5cGUuY29hbGVzY2VDaGFuZ2VzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0ge307XG5cbiAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5zdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVtuXSA9IHRoaXMuc3RhdGVbbl0gfHwge307XG4gICAgICAgIHZhciBpID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLnN0YXRlQ2hhbmdlc1tuXSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbl1bYV0gfHwgKHRoaXMuc3RhdGVbbl1bYV0gPSB7fSksIGgodGhpcy5zdGF0ZVtuXVthXSwgdGhpcy5zdGF0ZUNoYW5nZXNbbl1bYV0pLCBpW2FdID0gdGhpcy5zdGF0ZVtuXVthXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJbbl0gPSBpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBvIGluIHRoaXMuZGVsZXRlZFN0YXRlcykge1xuICAgICAgICB0aGlzLnN0YXRlW29dID0gdGhpcy5zdGF0ZVtvXSB8fCB7fTtcbiAgICAgICAgdmFyIHMgPSB7fTtcbiAgICAgICAgaWYgKG51bGwgPT09IHRoaXMuZGVsZXRlZFN0YXRlc1tvXSkgZm9yICh2YXIgdSBpbiB0aGlzLnN0YXRlW29dKSB7XG4gICAgICAgICAgc1t1XSA9IHt9LCB0aGlzLnN0YXRlW29dW3VdID0ge307XG4gICAgICAgIH0gZWxzZSBmb3IgKHZhciBsIGluIHRoaXMuZGVsZXRlZFN0YXRlc1tvXSkge1xuICAgICAgICAgIGlmIChudWxsID09PSB0aGlzLmRlbGV0ZWRTdGF0ZXNbb11bbF0pIHRoaXMuc3RhdGVbb11bbF0gPSB7fTtlbHNlIGZvciAodmFyIHAgPSAwLCBjID0gT2JqZWN0LmtleXModGhpcy5kZWxldGVkU3RhdGVzW29dW2xdKTsgcCA8IGMubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0YXRlW29dW2xdW2NbcF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzW2xdID0gdGhpcy5zdGF0ZVtvXVtsXTtcbiAgICAgICAgfVxuICAgICAgICByW29dID0gcltvXSB8fCB7fSwgaChyW29dLCBzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdGVDaGFuZ2VzID0ge30sIHRoaXMuZGVsZXRlZFN0YXRlcyA9IHt9LCAwICE9PSBPYmplY3Qua2V5cyhyKS5sZW5ndGgpIGZvciAodmFyIGYgaW4gdCkge1xuICAgICAgICB0W2ZdLnNldEZlYXR1cmVTdGF0ZShyLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJwID0gZnVuY3Rpb24gcnAodCwgZSkge1xuICAgICAgdGhpcy50aWxlSUQgPSB0LCB0aGlzLnggPSB0LmNhbm9uaWNhbC54LCB0aGlzLnkgPSB0LmNhbm9uaWNhbC55LCB0aGlzLnogPSB0LmNhbm9uaWNhbC56LCB0aGlzLmdyaWQgPSBuZXcgVm4oODE5MiwgMTYsIDApLCB0aGlzLmdyaWQzRCA9IG5ldyBWbig4MTkyLCAxNiwgMCksIHRoaXMuZmVhdHVyZUluZGV4QXJyYXkgPSBuZXcgb2EoKSwgdGhpcy5wcm9tb3RlSWQgPSBlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBucCh0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4geCh0LCBmdW5jdGlvbiAodCwgYSkge1xuICAgICAgICB2YXIgbyA9IGUgaW5zdGFuY2VvZiBtaSA/IGUuZ2V0KGEpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIG8gJiYgby5ldmFsdWF0ZSA/IG8uZXZhbHVhdGUociwgbiwgaSkgOiBvO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDEgLyAwLCByID0gMSAvIDAsIG4gPSAtMSAvIDAsIGkgPSAtMSAvIDAsIGEgPSAwLCBvID0gdDsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgdmFyIHMgPSBvW2FdO1xuICAgICAgICBlID0gTWF0aC5taW4oZSwgcy54KSwgciA9IE1hdGgubWluKHIsIHMueSksIG4gPSBNYXRoLm1heChuLCBzLngpLCBpID0gTWF0aC5tYXgoaSwgcy55KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogZSxcbiAgICAgICAgbWluWTogcixcbiAgICAgICAgbWF4WDogbixcbiAgICAgICAgbWF4WTogaVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcCh0LCBlKSB7XG4gICAgICByZXR1cm4gZSAtIHQ7XG4gICAgfVxuXG4gICAgcnAucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuZmVhdHVyZUluZGV4QXJyYXkubGVuZ3RoO1xuICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5lbXBsYWNlQmFjayhyLCBuLCBpKTtcblxuICAgICAgZm9yICh2YXIgcyA9IGEgPyB0aGlzLmdyaWQzRCA6IHRoaXMuZ3JpZCwgdSA9IDA7IHUgPCBlLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBlW3VdLCBwID0gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdLCBjID0gMDsgYyA8IGwubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICB2YXIgaCA9IGxbY107XG4gICAgICAgICAgcFswXSA9IE1hdGgubWluKHBbMF0sIGgueCksIHBbMV0gPSBNYXRoLm1pbihwWzFdLCBoLnkpLCBwWzJdID0gTWF0aC5tYXgocFsyXSwgaC54KSwgcFszXSA9IE1hdGgubWF4KHBbM10sIGgueSk7XG4gICAgICAgIH1cblxuICAgICAgICBwWzBdIDwgODE5MiAmJiBwWzFdIDwgODE5MiAmJiBwWzJdID49IDAgJiYgcFszXSA+PSAwICYmIHMuaW5zZXJ0KG8sIHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pO1xuICAgICAgfVxuICAgIH0sIHJwLnByb3RvdHlwZS5sb2FkVlRMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52dExheWVycyB8fCAodGhpcy52dExheWVycyA9IG5ldyB3cy5WZWN0b3JUaWxlKG5ldyAkcyh0aGlzLnJhd1RpbGVEYXRhKSkubGF5ZXJzLCB0aGlzLnNvdXJjZUxheWVyQ29kZXIgPSBuZXcgV2wodGhpcy52dExheWVycyA/IE9iamVjdC5rZXlzKHRoaXMudnRMYXllcnMpLnNvcnQoKSA6IFtcIl9nZW9qc29uVGlsZUxheWVyXCJdKSksIHRoaXMudnRMYXllcnM7XG4gICAgfSwgcnAucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIHRoaXMubG9hZFZUTGF5ZXJzKCk7XG5cbiAgICAgIGZvciAodmFyIG8gPSB0LnBhcmFtcyB8fCB7fSwgcyA9IDgxOTIgLyB0LnRpbGVTaXplIC8gdC5zY2FsZSwgdSA9IHNuKG8uZmlsdGVyKSwgbCA9IHQucXVlcnlHZW9tZXRyeSwgcCA9IHQucXVlcnlQYWRkaW5nICogcywgYyA9IGlwKGwpLCBoID0gdGhpcy5ncmlkLnF1ZXJ5KGMubWluWCAtIHAsIGMubWluWSAtIHAsIGMubWF4WCArIHAsIGMubWF4WSArIHApLCBmID0gaXAodC5jYW1lcmFRdWVyeUdlb21ldHJ5KSwgeSA9IHRoaXMuZ3JpZDNELnF1ZXJ5KGYubWluWCAtIHAsIGYubWluWSAtIHAsIGYubWF4WCArIHAsIGYubWF4WSArIHAsIGZ1bmN0aW9uIChlLCByLCBuLCBhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSkge1xuICAgICAgICAgIGZvciAodmFyIG8gPSAwLCBzID0gdDsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB1ID0gc1tvXTtcbiAgICAgICAgICAgIGlmIChlIDw9IHUueCAmJiByIDw9IHUueSAmJiBuID49IHUueCAmJiBhID49IHUueSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsID0gW25ldyBpKGUsIHIpLCBuZXcgaShlLCBhKSwgbmV3IGkobiwgYSksIG5ldyBpKG4sIHIpXTtcbiAgICAgICAgICBpZiAodC5sZW5ndGggPiAyKSBmb3IgKHZhciBwID0gMCwgYyA9IGw7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoUWEodCwgY1twXSkpIHJldHVybiAhMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IHQubGVuZ3RoIC0gMTsgaCsrKSB7XG4gICAgICAgICAgICBpZiAodG8odFtoXSwgdFtoICsgMV0sIGwpKSByZXR1cm4gITA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9KHQuY2FtZXJhUXVlcnlHZW9tZXRyeSwgZSAtIHAsIHIgLSBwLCBuICsgcCwgYSArIHApO1xuICAgICAgfSksIGQgPSAwLCBtID0geTsgZCA8IG0ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgaC5wdXNoKG1bZF0pO1xuICAgICAgfVxuXG4gICAgICBoLnNvcnQoYXApO1xuXG4gICAgICBmb3IgKHZhciB2LCBnID0ge30sIHggPSBmdW5jdGlvbiB4KGkpIHtcbiAgICAgICAgdmFyIHAgPSBoW2ldO1xuXG4gICAgICAgIGlmIChwICE9PSB2KSB7XG4gICAgICAgICAgdiA9IHA7XG4gICAgICAgICAgdmFyIGMgPSBhLmZlYXR1cmVJbmRleEFycmF5LmdldChwKSxcbiAgICAgICAgICAgICAgZiA9IG51bGw7XG4gICAgICAgICAgYS5sb2FkTWF0Y2hpbmdGZWF0dXJlKGcsIGMuYnVja2V0SW5kZXgsIGMuc291cmNlTGF5ZXJJbmRleCwgYy5mZWF0dXJlSW5kZXgsIHUsIG8ubGF5ZXJzLCBvLmF2YWlsYWJsZUltYWdlcywgZSwgciwgbiwgZnVuY3Rpb24gKGUsIHIsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBmIHx8IChmID0gVWEoZSkpLCByLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUobCwgZSwgbiwgZiwgYS56LCB0LnRyYW5zZm9ybSwgcywgdC5waXhlbFBvc01hdHJpeCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGIgPSAwOyBiIDwgaC5sZW5ndGg7IGIrKykge1xuICAgICAgICB4KGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9LCBycC5wcm90b3R5cGUubG9hZE1hdGNoaW5nRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuYnVja2V0TGF5ZXJJRHNbZV07XG5cbiAgICAgIGlmICghYSB8fCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHRbcl0pID49IDApIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0oYSwgYykpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLnNvdXJjZUxheWVyQ29kZXIuZGVjb2RlKHIpLFxuICAgICAgICAgICAgeSA9IHRoaXMudnRMYXllcnNbZl0uZmVhdHVyZShuKTtcblxuICAgICAgICBpZiAoaS5uZWVkR2VvbWV0cnkpIHtcbiAgICAgICAgICB2YXIgZCA9IGphKHksICEwKTtcbiAgICAgICAgICBpZiAoIWkuZmlsdGVyKG5ldyB1aSh0aGlzLnRpbGVJRC5vdmVyc2NhbGVkWiksIGQsIHRoaXMudGlsZUlELmNhbm9uaWNhbCkpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICghaS5maWx0ZXIobmV3IHVpKHRoaXMudGlsZUlELm92ZXJzY2FsZWRaKSwgeSkpIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBtID0gdGhpcy5nZXRJZCh5LCBmKSwgdiA9IDA7IHYgPCBjLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgdmFyIGcgPSBjW3ZdO1xuXG4gICAgICAgICAgaWYgKCEoYSAmJiBhLmluZGV4T2YoZykgPCAwKSkge1xuICAgICAgICAgICAgdmFyIHggPSBzW2ddO1xuXG4gICAgICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgICB2YXIgYiA9IHt9O1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IG0gJiYgbCAmJiAoYiA9IGwuZ2V0U3RhdGUoeC5zb3VyY2VMYXllciB8fCBcIl9nZW9qc29uVGlsZUxheWVyXCIsIG0pKTtcbiAgICAgICAgICAgICAgdmFyIHcgPSBoKHt9LCB1W2ddKTtcbiAgICAgICAgICAgICAgdy5wYWludCA9IG5wKHcucGFpbnQsIHgucGFpbnQsIHksIGIsIG8pLCB3LmxheW91dCA9IG5wKHcubGF5b3V0LCB4LmxheW91dCwgeSwgYiwgbyk7XG5cbiAgICAgICAgICAgICAgdmFyIF8gPSAhcCB8fCBwKHksIHgsIGIpO1xuXG4gICAgICAgICAgICAgIGlmIChfKSB7XG4gICAgICAgICAgICAgICAgdmFyIEEgPSBuZXcgUWwoeSwgdGhpcy56LCB0aGlzLngsIHRoaXMueSwgbSk7XG4gICAgICAgICAgICAgICAgQS5sYXllciA9IHc7XG4gICAgICAgICAgICAgICAgdmFyIFMgPSB0W2ddO1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gUyAmJiAoUyA9IHRbZ10gPSBbXSksIFMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXg6IG4sXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlOiBBLFxuICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uWjogX1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgcnAucHJvdG90eXBlLmxvb2t1cFN5bWJvbEZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMpIHtcbiAgICAgIHZhciB1ID0ge307XG4gICAgICB0aGlzLmxvYWRWVExheWVycygpO1xuXG4gICAgICBmb3IgKHZhciBsID0gc24oaSksIHAgPSAwLCBjID0gdDsgcCA8IGMubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgdGhpcy5sb2FkTWF0Y2hpbmdGZWF0dXJlKHUsIHIsIG4sIGNbcF0sIGwsIGEsIG8sIHMsIGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdTtcbiAgICB9LCBycC5wcm90b3R5cGUuaGFzTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0aGlzLmJ1Y2tldExheWVySURzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHJbZV07IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgaWYgKHQgPT09IGlbbl0pIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgcnAucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdC5pZDtcbiAgICAgIHJldHVybiB0aGlzLnByb21vdGVJZCAmJiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgKHIgPSB0LnByb3BlcnRpZXNbXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5wcm9tb3RlSWQgPyB0aGlzLnByb21vdGVJZCA6IHRoaXMucHJvbW90ZUlkW2VdXSkgJiYgKHIgPSBOdW1iZXIocikpLCByO1xuICAgIH0sIE9uKFwiRmVhdHVyZUluZGV4XCIsIHJwLCB7XG4gICAgICBvbWl0OiBbXCJyYXdUaWxlRGF0YVwiLCBcInNvdXJjZUxheWVyQ29kZXJcIl1cbiAgICB9KTtcblxuICAgIHZhciBvcCA9IGZ1bmN0aW9uIG9wKHQsIGUpIHtcbiAgICAgIHRoaXMudGlsZUlEID0gdCwgdGhpcy51aWQgPSB5KCksIHRoaXMudXNlcyA9IDAsIHRoaXMudGlsZVNpemUgPSBlLCB0aGlzLmJ1Y2tldHMgPSB7fSwgdGhpcy5leHBpcmF0aW9uVGltZSA9IG51bGwsIHRoaXMucXVlcnlQYWRkaW5nID0gMCwgdGhpcy5oYXNTeW1ib2xCdWNrZXRzID0gITEsIHRoaXMuaGFzUlRMVGV4dCA9ICExLCB0aGlzLmRlcGVuZGVuY2llcyA9IHt9LCB0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgPSAwLCB0aGlzLnN0YXRlID0gXCJsb2FkaW5nXCI7XG4gICAgfTtcblxuICAgIG9wLnByb3RvdHlwZS5yZWdpc3RlckZhZGVEdXJhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQgKyB0aGlzLnRpbWVBZGRlZDtcbiAgICAgIGUgPCBSLm5vdygpIHx8IHRoaXMuZmFkZUVuZFRpbWUgJiYgZSA8IHRoaXMuZmFkZUVuZFRpbWUgfHwgKHRoaXMuZmFkZUVuZFRpbWUgPSBlKTtcbiAgICB9LCBvcC5wcm90b3R5cGUud2FzUmVxdWVzdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiZXJyb3JlZFwiID09PSB0aGlzLnN0YXRlIHx8IFwibG9hZGVkXCIgPT09IHRoaXMuc3RhdGUgfHwgXCJyZWxvYWRpbmdcIiA9PT0gdGhpcy5zdGF0ZTtcbiAgICB9LCBvcC5wcm90b3R5cGUubG9hZFZlY3RvckRhdGEgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHRoaXMuaGFzRGF0YSgpICYmIHRoaXMudW5sb2FkVmVjdG9yRGF0YSgpLCB0aGlzLnN0YXRlID0gXCJsb2FkZWRcIiwgdCkge1xuICAgICAgICBmb3IgKHZhciBuIGluIHQuZmVhdHVyZUluZGV4ICYmICh0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCA9IHQuZmVhdHVyZUluZGV4LCB0LnJhd1RpbGVEYXRhID8gKHRoaXMubGF0ZXN0UmF3VGlsZURhdGEgPSB0LnJhd1RpbGVEYXRhLCB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5yYXdUaWxlRGF0YSA9IHQucmF3VGlsZURhdGEpIDogdGhpcy5sYXRlc3RSYXdUaWxlRGF0YSAmJiAodGhpcy5sYXRlc3RGZWF0dXJlSW5kZXgucmF3VGlsZURhdGEgPSB0aGlzLmxhdGVzdFJhd1RpbGVEYXRhKSksIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSB0LmNvbGxpc2lvbkJveEFycmF5LCB0aGlzLmJ1Y2tldHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0ge307XG4gICAgICAgICAgaWYgKCFlKSByZXR1cm4gcjtcblxuICAgICAgICAgIGZvciAodmFyIG4gPSBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBhW2ldLFxuICAgICAgICAgICAgICAgIG4gPSB0LmxheWVySWRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gZS5nZXRMYXllcih0KTtcbiAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICAgICAgaWYgKDAgIT09IG4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHQubGF5ZXJzID0gbiwgdC5zdGF0ZURlcGVuZGVudExheWVySWRzICYmICh0LnN0YXRlRGVwZW5kZW50TGF5ZXJzID0gdC5zdGF0ZURlcGVuZGVudExheWVySWRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT09IHQ7XG4gICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMCwgcyA9IG47IG8gPCBzLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgICAgICAgcltzW29dLmlkXSA9IHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBuKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0odC5idWNrZXRzLCBlLnN0eWxlKSwgdGhpcy5oYXNTeW1ib2xCdWNrZXRzID0gITEsIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5idWNrZXRzW25dO1xuXG4gICAgICAgICAgaWYgKGkgaW5zdGFuY2VvZiBnbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU3ltYm9sQnVja2V0cyA9ICEwLCAhcikgYnJlYWs7XG4gICAgICAgICAgICBpLmp1c3RSZWxvYWRlZCA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc1JUTFRleHQgPSAhMSwgdGhpcy5oYXNTeW1ib2xCdWNrZXRzKSBmb3IgKHZhciBhIGluIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgIHZhciBvID0gdGhpcy5idWNrZXRzW2FdO1xuXG4gICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBnbCAmJiBvLmhhc1JUTFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzUlRMVGV4dCA9ICEwLCBzaS5pc0xvYWRpbmcoKSB8fCBzaS5pc0xvYWRlZCgpIHx8IFwiZGVmZXJyZWRcIiAhPT0gYWkoKSB8fCBvaSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgcyBpbiB0aGlzLnF1ZXJ5UGFkZGluZyA9IDAsIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgIHZhciB1ID0gdGhpcy5idWNrZXRzW3NdO1xuICAgICAgICAgIHRoaXMucXVlcnlQYWRkaW5nID0gTWF0aC5tYXgodGhpcy5xdWVyeVBhZGRpbmcsIGUuc3R5bGUuZ2V0TGF5ZXIocykucXVlcnlSYWRpdXModSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdC5pbWFnZUF0bGFzICYmICh0aGlzLmltYWdlQXRsYXMgPSB0LmltYWdlQXRsYXMpLCB0LmdseXBoQXRsYXNJbWFnZSAmJiAodGhpcy5nbHlwaEF0bGFzSW1hZ2UgPSB0LmdseXBoQXRsYXNJbWFnZSk7XG4gICAgICB9IGVsc2UgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IG5ldyBXaSgpO1xuICAgIH0sIG9wLnByb3RvdHlwZS51bmxvYWRWZWN0b3JEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzW3RdLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWNrZXRzID0ge30sIHRoaXMuaW1hZ2VBdGxhc1RleHR1cmUgJiYgdGhpcy5pbWFnZUF0bGFzVGV4dHVyZS5kZXN0cm95KCksIHRoaXMuaW1hZ2VBdGxhcyAmJiAodGhpcy5pbWFnZUF0bGFzID0gbnVsbCksIHRoaXMuZ2x5cGhBdGxhc1RleHR1cmUgJiYgdGhpcy5nbHlwaEF0bGFzVGV4dHVyZS5kZXN0cm95KCksIHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4ID0gbnVsbCwgdGhpcy5zdGF0ZSA9IFwidW5sb2FkZWRcIjtcbiAgICB9LCBvcC5wcm90b3R5cGUuZ2V0QnVja2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNbdC5pZF07XG4gICAgfSwgb3AucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYnVja2V0cykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYnVja2V0c1tlXTtcbiAgICAgICAgci51cGxvYWRQZW5kaW5nKCkgJiYgci51cGxvYWQodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gdC5nbDtcbiAgICAgIHRoaXMuaW1hZ2VBdGxhcyAmJiAhdGhpcy5pbWFnZUF0bGFzLnVwbG9hZGVkICYmICh0aGlzLmltYWdlQXRsYXNUZXh0dXJlID0gbmV3IFZsKHQsIHRoaXMuaW1hZ2VBdGxhcy5pbWFnZSwgbi5SR0JBKSwgdGhpcy5pbWFnZUF0bGFzLnVwbG9hZGVkID0gITApLCB0aGlzLmdseXBoQXRsYXNJbWFnZSAmJiAodGhpcy5nbHlwaEF0bGFzVGV4dHVyZSA9IG5ldyBWbCh0LCB0aGlzLmdseXBoQXRsYXNJbWFnZSwgbi5BTFBIQSksIHRoaXMuZ2x5cGhBdGxhc0ltYWdlID0gbnVsbCk7XG4gICAgfSwgb3AucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5pbWFnZUF0bGFzICYmIHRoaXMuaW1hZ2VBdGxhcy5wYXRjaFVwZGF0ZWRJbWFnZXModCwgdGhpcy5pbWFnZUF0bGFzVGV4dHVyZSk7XG4gICAgfSwgb3AucHJvdG90eXBlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRlc3RGZWF0dXJlSW5kZXggJiYgdGhpcy5sYXRlc3RGZWF0dXJlSW5kZXgucmF3VGlsZURhdGEgPyB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5xdWVyeSh7XG4gICAgICAgIHF1ZXJ5R2VvbWV0cnk6IG4sXG4gICAgICAgIGNhbWVyYVF1ZXJ5R2VvbWV0cnk6IGksXG4gICAgICAgIHNjYWxlOiBhLFxuICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgcGl4ZWxQb3NNYXRyaXg6IGwsXG4gICAgICAgIHRyYW5zZm9ybTogcyxcbiAgICAgICAgcGFyYW1zOiBvLFxuICAgICAgICBxdWVyeVBhZGRpbmc6IHRoaXMucXVlcnlQYWRkaW5nICogdVxuICAgICAgfSwgdCwgZSwgcikgOiB7fTtcbiAgICB9LCBvcC5wcm90b3R5cGUucXVlcnlTb3VyY2VGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4O1xuXG4gICAgICBpZiAociAmJiByLnJhd1RpbGVEYXRhKSB7XG4gICAgICAgIHZhciBuID0gci5sb2FkVlRMYXllcnMoKSxcbiAgICAgICAgICAgIGkgPSBlID8gZS5zb3VyY2VMYXllciA6IFwiXCIsXG4gICAgICAgICAgICBhID0gbi5fZ2VvanNvblRpbGVMYXllciB8fCBuW2ldO1xuICAgICAgICBpZiAoYSkgZm9yICh2YXIgbyA9IHNuKGUgJiYgZS5maWx0ZXIpLCBzID0gdGhpcy50aWxlSUQuY2Fub25pY2FsLCB1ID0gcy56LCBsID0gcy54LCBwID0gcy55LCBjID0ge1xuICAgICAgICAgIHo6IHUsXG4gICAgICAgICAgeDogbCxcbiAgICAgICAgICB5OiBwXG4gICAgICAgIH0sIGggPSAwOyBoIDwgYS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHZhciBmID0gYS5mZWF0dXJlKGgpO1xuXG4gICAgICAgICAgaWYgKG8ubmVlZEdlb21ldHJ5KSB7XG4gICAgICAgICAgICB2YXIgeSA9IGphKGYsICEwKTtcbiAgICAgICAgICAgIGlmICghby5maWx0ZXIobmV3IHVpKHRoaXMudGlsZUlELm92ZXJzY2FsZWRaKSwgeSwgdGhpcy50aWxlSUQuY2Fub25pY2FsKSkgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghby5maWx0ZXIobmV3IHVpKHRoaXMudGlsZUlELm92ZXJzY2FsZWRaKSwgZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgdmFyIGQgPSByLmdldElkKGYsIGkpLFxuICAgICAgICAgICAgICBtID0gbmV3IFFsKGYsIHUsIGwsIHAsIGQpO1xuICAgICAgICAgIG0udGlsZSA9IGMsIHQucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIG9wLnByb3RvdHlwZS5oYXNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwibG9hZGVkXCIgPT09IHRoaXMuc3RhdGUgfHwgXCJyZWxvYWRpbmdcIiA9PT0gdGhpcy5zdGF0ZSB8fCBcImV4cGlyZWRcIiA9PT0gdGhpcy5zdGF0ZTtcbiAgICB9LCBvcC5wcm90b3R5cGUucGF0dGVybnNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZUF0bGFzICYmICEhT2JqZWN0LmtleXModGhpcy5pbWFnZUF0bGFzLnBhdHRlcm5Qb3NpdGlvbnMpLmxlbmd0aDtcbiAgICB9LCBvcC5wcm90b3R5cGUuc2V0RXhwaXJ5RGF0YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuZXhwaXJhdGlvblRpbWU7XG5cbiAgICAgIGlmICh0LmNhY2hlQ29udHJvbCkge1xuICAgICAgICB2YXIgciA9IHoodC5jYWNoZUNvbnRyb2wpO1xuICAgICAgICByW1wibWF4LWFnZVwiXSAmJiAodGhpcy5leHBpcmF0aW9uVGltZSA9IERhdGUubm93KCkgKyAxZTMgKiByW1wibWF4LWFnZVwiXSk7XG4gICAgICB9IGVsc2UgdC5leHBpcmVzICYmICh0aGlzLmV4cGlyYXRpb25UaW1lID0gbmV3IERhdGUodC5leHBpcmVzKS5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSkge1xuICAgICAgICB2YXIgbiA9IERhdGUubm93KCksXG4gICAgICAgICAgICBpID0gITE7XG4gICAgICAgIGlmICh0aGlzLmV4cGlyYXRpb25UaW1lID4gbikgaSA9ICExO2Vsc2UgaWYgKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSA8IGUpIGkgPSAhMDtlbHNlIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5leHBpcmF0aW9uVGltZSAtIGU7XG4gICAgICAgICAgICBhID8gdGhpcy5leHBpcmF0aW9uVGltZSA9IG4gKyBNYXRoLm1heChhLCAzZTQpIDogaSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGkgPSAhMDtcbiAgICAgICAgaSA/ICh0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQrKywgdGhpcy5zdGF0ZSA9IFwiZXhwaXJlZFwiKSA6IHRoaXMuZXhwaXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfSwgb3AucHJvdG90eXBlLmdldEV4cGlyeVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSkgcmV0dXJuIHRoaXMuZXhwaXJlZFJlcXVlc3RDb3VudCA/IDFlMyAqICgxIDw8IE1hdGgubWluKHRoaXMuZXhwaXJlZFJlcXVlc3RDb3VudCAtIDEsIDMxKSkgOiBNYXRoLm1pbih0aGlzLmV4cGlyYXRpb25UaW1lIC0gbmV3IERhdGUoKS5nZXRUaW1lKCksIE1hdGgucG93KDIsIDMxKSAtIDEpO1xuICAgIH0sIG9wLnByb3RvdHlwZS5zZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4ICYmIHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4LnJhd1RpbGVEYXRhICYmIDAgIT09IE9iamVjdC5rZXlzKHQpLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4LmxvYWRWVExheWVycygpO1xuXG4gICAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5idWNrZXRzKSB7XG4gICAgICAgICAgaWYgKGUuc3R5bGUuaGFzTGF5ZXIobikpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5idWNrZXRzW25dLFxuICAgICAgICAgICAgICAgIGEgPSBpLmxheWVyc1swXS5zb3VyY2VMYXllciB8fCBcIl9nZW9qc29uVGlsZUxheWVyXCIsXG4gICAgICAgICAgICAgICAgbyA9IHJbYV0sXG4gICAgICAgICAgICAgICAgcyA9IHRbYV07XG5cbiAgICAgICAgICAgIGlmIChvICYmIHMgJiYgMCAhPT0gT2JqZWN0LmtleXMocykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGkudXBkYXRlKHMsIG8sIHRoaXMuaW1hZ2VBdGxhcyAmJiB0aGlzLmltYWdlQXRsYXMucGF0dGVyblBvc2l0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgIHZhciB1ID0gZSAmJiBlLnN0eWxlICYmIGUuc3R5bGUuZ2V0TGF5ZXIobik7XG4gICAgICAgICAgICAgIHUgJiYgKHRoaXMucXVlcnlQYWRkaW5nID0gTWF0aC5tYXgodGhpcy5xdWVyeVBhZGRpbmcsIHUucXVlcnlSYWRpdXMoaSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvcC5wcm90b3R5cGUuaG9sZGluZ0ZvckZhZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSB0aGlzLnN5bWJvbEZhZGVIb2xkVW50aWw7XG4gICAgfSwgb3AucHJvdG90eXBlLnN5bWJvbEZhZGVGaW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsIHx8IHRoaXMuc3ltYm9sRmFkZUhvbGRVbnRpbCA8IFIubm93KCk7XG4gICAgfSwgb3AucHJvdG90eXBlLmNsZWFyRmFkZUhvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnN5bWJvbEZhZGVIb2xkVW50aWwgPSB2b2lkIDA7XG4gICAgfSwgb3AucHJvdG90eXBlLnNldEhvbGREdXJhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnN5bWJvbEZhZGVIb2xkVW50aWwgPSBSLm5vdygpICsgdDtcbiAgICB9LCBvcC5wcm90b3R5cGUuc2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSB7fSwgbiA9IDAsIGkgPSBlOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICByW2lbbl1dID0gITA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzW3RdID0gcjtcbiAgICB9LCBvcC5wcm90b3R5cGUuaGFzRGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMCwgbiA9IHQ7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5kZXBlbmRlbmNpZXNbbltyXV07XG4gICAgICAgIGlmIChpKSBmb3IgKHZhciBhID0gMCwgbyA9IGU7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgaWYgKGlbb1thXV0pIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcblxuICAgIHZhciBzcCA9IG8ucGVyZm9ybWFuY2UsXG4gICAgICAgIHVwID0gZnVuY3Rpb24gdXAodCkge1xuICAgICAgdGhpcy5fbWFya3MgPSB7XG4gICAgICAgIHN0YXJ0OiBbdC51cmwsIFwic3RhcnRcIl0uam9pbihcIiNcIiksXG4gICAgICAgIGVuZDogW3QudXJsLCBcImVuZFwiXS5qb2luKFwiI1wiKSxcbiAgICAgICAgbWVhc3VyZTogdC51cmwudG9TdHJpbmcoKVxuICAgICAgfSwgc3AubWFyayh0aGlzLl9tYXJrcy5zdGFydCk7XG4gICAgfTtcblxuICAgIHVwLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzcC5tYXJrKHRoaXMuX21hcmtzLmVuZCk7XG4gICAgICB2YXIgdCA9IHNwLmdldEVudHJpZXNCeU5hbWUodGhpcy5fbWFya3MubWVhc3VyZSk7XG4gICAgICByZXR1cm4gMCA9PT0gdC5sZW5ndGggJiYgKHNwLm1lYXN1cmUodGhpcy5fbWFya3MubWVhc3VyZSwgdGhpcy5fbWFya3Muc3RhcnQsIHRoaXMuX21hcmtzLmVuZCksIHQgPSBzcC5nZXRFbnRyaWVzQnlOYW1lKHRoaXMuX21hcmtzLm1lYXN1cmUpLCBzcC5jbGVhck1hcmtzKHRoaXMuX21hcmtzLnN0YXJ0KSwgc3AuY2xlYXJNYXJrcyh0aGlzLl9tYXJrcy5lbmQpLCBzcC5jbGVhck1lYXN1cmVzKHRoaXMuX21hcmtzLm1lYXN1cmUpKSwgdDtcbiAgICB9LCB0LkFjdG9yID0gRGwsIHQuQWxwaGFJbWFnZSA9IHhvLCB0LkNhbm9uaWNhbFRpbGVJRCA9IFhsLCB0LkNvbGxpc2lvbkJveEFycmF5ID0gV2ksIHQuQ29sb3IgPSBlZSwgdC5ERU1EYXRhID0gJGwsIHQuRGF0YUNvbnN0YW50UHJvcGVydHkgPSB2aSwgdC5EaWN0aW9uYXJ5Q29kZXIgPSBXbCwgdC5FWFRFTlQgPSA4MTkyLCB0LkVycm9yRXZlbnQgPSBDdCwgdC5FdmFsdWF0aW9uUGFyYW1ldGVycyA9IHVpLCB0LkV2ZW50ID0genQsIHQuRXZlbnRlZCA9IEV0LCB0LkZlYXR1cmVJbmRleCA9IHJwLCB0LkZpbGxCdWNrZXQgPSB1cywgdC5GaWxsRXh0cnVzaW9uQnVja2V0ID0ga3MsIHQuSW1hZ2VBdGxhcyA9IHd1LCB0LkltYWdlUG9zaXRpb24gPSB4dSwgdC5MaW5lQnVja2V0ID0gRHMsIHQuTG5nTGF0ID0gT2wsIHQuTG5nTGF0Qm91bmRzID0gUmwsIHQuTWVyY2F0b3JDb29yZGluYXRlID0gWmwsIHQuT05FX0VNID0gMjQsIHQuT3ZlcnNjYWxlZFRpbGVJRCA9IEhsLCB0LlBvaW50ID0gaSwgdC5Qb2ludCQxID0gaSwgdC5Qcm9wZXJ0aWVzID0gX2ksIHQuUHJvdG9idWYgPSAkcywgdC5SR0JBSW1hZ2UgPSBibywgdC5SZXF1ZXN0TWFuYWdlciA9IEcsIHQuUmVxdWVzdFBlcmZvcm1hbmNlID0gdXAsIHQuUmVzb3VyY2VUeXBlID0geXQsIHQuU2VnbWVudFZlY3RvciA9IHVhLCB0LlNvdXJjZUZlYXR1cmVTdGF0ZSA9IGVwLCB0LlN0cnVjdEFycmF5TGF5b3V0MXVpMiA9IEhpLCB0LlN0cnVjdEFycmF5TGF5b3V0MmYxZjJpMTYgPSBVaSwgdC5TdHJ1Y3RBcnJheUxheW91dDJpNCA9IEVpLCB0LlN0cnVjdEFycmF5TGF5b3V0M3VpNiA9IHFpLCB0LlN0cnVjdEFycmF5TGF5b3V0NGk4ID0gUGksIHQuU3ltYm9sQnVja2V0ID0gZ2wsIHQuVGV4dHVyZSA9IFZsLCB0LlRpbGUgPSBvcCwgdC5UcmFuc2l0aW9uYWJsZSA9IGNpLCB0LlVuaWZvcm0xZiA9IHdhLCB0LlVuaWZvcm0xaSA9IGJhLCB0LlVuaWZvcm0yZiA9IF9hLCB0LlVuaWZvcm0zZiA9IEFhLCB0LlVuaWZvcm00ZiA9IFNhLCB0LlVuaWZvcm1Db2xvciA9IGthLCB0LlVuaWZvcm1NYXRyaXg0ZiA9IHphLCB0LlVud3JhcHBlZFRpbGVJRCA9IEpsLCB0LlZhbGlkYXRpb25FcnJvciA9IE10LCB0LldyaXRpbmdNb2RlID0gX3UsIHQuWm9vbUhpc3RvcnkgPSBHbiwgdC5hZGQgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRbMF0gPSBlWzBdICsgclswXSwgdFsxXSA9IGVbMV0gKyByWzFdLCB0WzJdID0gZVsyXSArIHJbMl0sIHQ7XG4gICAgfSwgdC5hZGREeW5hbWljQXR0cmlidXRlcyA9IHlsLCB0LmFzeW5jQWxsID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmICghdC5sZW5ndGgpIHJldHVybiByKG51bGwsIFtdKTtcbiAgICAgIHZhciBuID0gdC5sZW5ndGgsXG4gICAgICAgICAgaSA9IG5ldyBBcnJheSh0Lmxlbmd0aCksXG4gICAgICAgICAgYSA9IG51bGw7XG4gICAgICB0LmZvckVhY2goZnVuY3Rpb24gKHQsIG8pIHtcbiAgICAgICAgZSh0LCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHQgJiYgKGEgPSB0KSwgaVtvXSA9IGUsIDAgPT0gLS1uICYmIHIoYSwgaSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgdC5iZXppZXIgPSB1LCB0LmJpbmRBbGwgPSB2LCB0LmJyb3dzZXIgPSBSLCB0LmNhY2hlRW50cnlQb3NzaWJseUFkZGVkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICsraHQgPiB1dCAmJiAodC5nZXRBY3RvcigpLnNlbmQoXCJlbmZvcmNlQ2FjaGVTaXplTGltaXRcIiwgc3QpLCBodCA9IDApO1xuICAgIH0sIHQuY2xhbXAgPSBwLCB0LmNsZWFyVGlsZUNhY2hlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gby5jYWNoZXMuZGVsZXRlKFwibWFwYm94LXRpbGVzXCIpO1xuICAgICAgdCAmJiBlLmNhdGNoKHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdCgpO1xuICAgICAgfSk7XG4gICAgfSwgdC5jbGlwTGluZSA9IFh1LCB0LmNsb25lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gbmV3IG9vKDE2KTtcbiAgICAgIHJldHVybiBlWzBdID0gdFswXSwgZVsxXSA9IHRbMV0sIGVbMl0gPSB0WzJdLCBlWzNdID0gdFszXSwgZVs0XSA9IHRbNF0sIGVbNV0gPSB0WzVdLCBlWzZdID0gdFs2XSwgZVs3XSA9IHRbN10sIGVbOF0gPSB0WzhdLCBlWzldID0gdFs5XSwgZVsxMF0gPSB0WzEwXSwgZVsxMV0gPSB0WzExXSwgZVsxMl0gPSB0WzEyXSwgZVsxM10gPSB0WzEzXSwgZVsxNF0gPSB0WzE0XSwgZVsxNV0gPSB0WzE1XSwgZTtcbiAgICB9LCB0LmNsb25lJDEgPSB3LCB0LmNsb25lJDIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBuZXcgb28oMyk7XG4gICAgICByZXR1cm4gZVswXSA9IHRbMF0sIGVbMV0gPSB0WzFdLCBlWzJdID0gdFsyXSwgZTtcbiAgICB9LCB0LmNvbGxpc2lvbkNpcmNsZUxheW91dCA9IFpzLCB0LmNvbmZpZyA9IE8sIHQuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgb28oMTYpO1xuICAgICAgcmV0dXJuIG9vICE9IEZsb2F0MzJBcnJheSAmJiAodFsxXSA9IDAsIHRbMl0gPSAwLCB0WzNdID0gMCwgdFs0XSA9IDAsIHRbNl0gPSAwLCB0WzddID0gMCwgdFs4XSA9IDAsIHRbOV0gPSAwLCB0WzExXSA9IDAsIHRbMTJdID0gMCwgdFsxM10gPSAwLCB0WzE0XSA9IDApLCB0WzBdID0gMSwgdFs1XSA9IDEsIHRbMTBdID0gMSwgdFsxNV0gPSAxLCB0O1xuICAgIH0sIHQuY3JlYXRlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IG5ldyBvbyg5KTtcbiAgICAgIHJldHVybiBvbyAhPSBGbG9hdDMyQXJyYXkgJiYgKHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDAsIHRbNV0gPSAwLCB0WzZdID0gMCwgdFs3XSA9IDApLCB0WzBdID0gMSwgdFs0XSA9IDEsIHRbOF0gPSAxLCB0O1xuICAgIH0sIHQuY3JlYXRlJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IG5ldyBvbyg0KTtcbiAgICAgIHJldHVybiBvbyAhPSBGbG9hdDMyQXJyYXkgJiYgKHRbMV0gPSAwLCB0WzJdID0gMCksIHRbMF0gPSAxLCB0WzNdID0gMSwgdDtcbiAgICB9LCB0LmNyZWF0ZUNvbW1vbmpzTW9kdWxlID0gZSwgdC5jcmVhdGVFeHByZXNzaW9uID0gWHIsIHQuY3JlYXRlTGF5b3V0ID0gemksIHQuY3JlYXRlU3R5bGVMYXllciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gXCJjdXN0b21cIiA9PT0gdC50eXBlID8gbmV3IHpsKHQpIDogbmV3IENsW3QudHlwZV0odCk7XG4gICAgfSwgdC5jcm9zcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGVbMF0sXG4gICAgICAgICAgaSA9IGVbMV0sXG4gICAgICAgICAgYSA9IGVbMl0sXG4gICAgICAgICAgbyA9IHJbMF0sXG4gICAgICAgICAgcyA9IHJbMV0sXG4gICAgICAgICAgdSA9IHJbMl07XG4gICAgICByZXR1cm4gdFswXSA9IGkgKiB1IC0gYSAqIHMsIHRbMV0gPSBhICogbyAtIG4gKiB1LCB0WzJdID0gbiAqIHMgLSBpICogbywgdDtcbiAgICB9LCB0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIHQoZSwgcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IGUubGVuZ3RoICE9PSByLmxlbmd0aCkgcmV0dXJuICExO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICAgIGlmICghdChlW25dLCByW25dKSkgcmV0dXJuICExO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBudWxsICE9PSBlICYmIG51bGwgIT09IHIpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHIpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGUpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocikubGVuZ3RoKSByZXR1cm4gITE7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBlKSB7XG4gICAgICAgICAgaWYgKCF0KGVbaV0sIHJbaV0pKSByZXR1cm4gITE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlID09PSByO1xuICAgIH0sIHQuZG90ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0WzBdICogZVswXSArIHRbMV0gKiBlWzFdICsgdFsyXSAqIGVbMl07XG4gICAgfSwgdC5kb3QkMSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdFswXSAqIGVbMF0gKyB0WzFdICogZVsxXSArIHRbMl0gKiBlWzJdICsgdFszXSAqIGVbM107XG4gICAgfSwgdC5lYXNlID0gbCwgdC5lbWl0VmFsaWRhdGlvbkVycm9ycyA9IFRuLCB0LmVuZHNXaXRoID0gZywgdC5lbmZvcmNlQ2FjaGVTaXplTGltaXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgbHQoKSwgdHQgJiYgdHQudGhlbihmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmtleXMoKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCByLmxlbmd0aCAtIHQ7IG4rKykge1xuICAgICAgICAgICAgZS5kZWxldGUocltuXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIHQuZXZhbHVhdGVTaXplRm9yRmVhdHVyZSA9IFJ1LCB0LmV2YWx1YXRlU2l6ZUZvclpvb20gPSBPdSwgdC5ldmFsdWF0ZVZhcmlhYmxlT2Zmc2V0ID0gb2wsIHQuZXZlbnRlZCA9IGlpLCB0LmV4dGVuZCA9IGgsIHQuZmVhdHVyZUZpbHRlciA9IHNuLCB0LmZpbHRlck9iamVjdCA9IGIsIHQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zaW4oZSksXG4gICAgICAgICAgbiA9IE1hdGguY29zKGUpO1xuICAgICAgcmV0dXJuIHRbMF0gPSBuLCB0WzFdID0gciwgdFsyXSA9IDAsIHRbM10gPSAtciwgdFs0XSA9IG4sIHRbNV0gPSAwLCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAxLCB0O1xuICAgIH0sIHQuZ2V0QW5jaG9yQWxpZ25tZW50ID0gVHUsIHQuZ2V0QW5jaG9ySnVzdGlmaWNhdGlvbiA9IHNsLCB0LmdldEFycmF5QnVmZmVyID0gd3QsIHQuZ2V0SW1hZ2UgPSBTdCwgdC5nZXRKU09OID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiBidChoKHQsIHtcbiAgICAgICAgdHlwZTogXCJqc29uXCJcbiAgICAgIH0pLCBlKTtcbiAgICB9LCB0LmdldFJUTFRleHRQbHVnaW5TdGF0dXMgPSBhaSwgdC5nZXRSZWZlcnJlciA9IG10LCB0LmdldFZpZGVvID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgaSA9IG8uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgaS5tdXRlZCA9ICEwLCBpLm9ubG9hZHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlKG51bGwsIGkpO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciBzID0gby5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgICByID0gdFthXSwgbiA9IHZvaWQgMCwgKG4gPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKS5ocmVmID0gciwgKG4ucHJvdG9jb2wgIT09IG8uZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgfHwgbi5ob3N0ICE9PSBvLmRvY3VtZW50LmxvY2F0aW9uLmhvc3QpICYmIChpLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIiksIHMuc3JjID0gdFthXSwgaS5hcHBlbmRDaGlsZChzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7fVxuICAgICAgfTtcbiAgICB9LCB0LmlkZW50aXR5ID0gc28sIHQuaW52ZXJ0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICBuID0gZVsxXSxcbiAgICAgICAgICBpID0gZVsyXSxcbiAgICAgICAgICBhID0gZVszXSxcbiAgICAgICAgICBvID0gZVs0XSxcbiAgICAgICAgICBzID0gZVs1XSxcbiAgICAgICAgICB1ID0gZVs2XSxcbiAgICAgICAgICBsID0gZVs3XSxcbiAgICAgICAgICBwID0gZVs4XSxcbiAgICAgICAgICBjID0gZVs5XSxcbiAgICAgICAgICBoID0gZVsxMF0sXG4gICAgICAgICAgZiA9IGVbMTFdLFxuICAgICAgICAgIHkgPSBlWzEyXSxcbiAgICAgICAgICBkID0gZVsxM10sXG4gICAgICAgICAgbSA9IGVbMTRdLFxuICAgICAgICAgIHYgPSBlWzE1XSxcbiAgICAgICAgICBnID0gciAqIHMgLSBuICogbyxcbiAgICAgICAgICB4ID0gciAqIHUgLSBpICogbyxcbiAgICAgICAgICBiID0gciAqIGwgLSBhICogbyxcbiAgICAgICAgICB3ID0gbiAqIHUgLSBpICogcyxcbiAgICAgICAgICBfID0gbiAqIGwgLSBhICogcyxcbiAgICAgICAgICBBID0gaSAqIGwgLSBhICogdSxcbiAgICAgICAgICBTID0gcCAqIGQgLSBjICogeSxcbiAgICAgICAgICBrID0gcCAqIG0gLSBoICogeSxcbiAgICAgICAgICBJID0gcCAqIHYgLSBmICogeSxcbiAgICAgICAgICB6ID0gYyAqIG0gLSBoICogZCxcbiAgICAgICAgICBDID0gYyAqIHYgLSBmICogZCxcbiAgICAgICAgICBFID0gaCAqIHYgLSBmICogbSxcbiAgICAgICAgICBQID0gZyAqIEUgLSB4ICogQyArIGIgKiB6ICsgdyAqIEkgLSBfICogayArIEEgKiBTO1xuXG4gICAgICByZXR1cm4gUCA/ICh0WzBdID0gKHMgKiBFIC0gdSAqIEMgKyBsICogeikgKiAoUCA9IDEgLyBQKSwgdFsxXSA9IChpICogQyAtIG4gKiBFIC0gYSAqIHopICogUCwgdFsyXSA9IChkICogQSAtIG0gKiBfICsgdiAqIHcpICogUCwgdFszXSA9IChoICogXyAtIGMgKiBBIC0gZiAqIHcpICogUCwgdFs0XSA9ICh1ICogSSAtIG8gKiBFIC0gbCAqIGspICogUCwgdFs1XSA9IChyICogRSAtIGkgKiBJICsgYSAqIGspICogUCwgdFs2XSA9IChtICogYiAtIHkgKiBBIC0gdiAqIHgpICogUCwgdFs3XSA9IChwICogQSAtIGggKiBiICsgZiAqIHgpICogUCwgdFs4XSA9IChvICogQyAtIHMgKiBJICsgbCAqIFMpICogUCwgdFs5XSA9IChuICogSSAtIHIgKiBDIC0gYSAqIFMpICogUCwgdFsxMF0gPSAoeSAqIF8gLSBkICogYiArIHYgKiBnKSAqIFAsIHRbMTFdID0gKGMgKiBiIC0gcCAqIF8gLSBmICogZykgKiBQLCB0WzEyXSA9IChzICogayAtIG8gKiB6IC0gdSAqIFMpICogUCwgdFsxM10gPSAociAqIHogLSBuICogayArIGkgKiBTKSAqIFAsIHRbMTRdID0gKGQgKiB4IC0geSAqIHcgLSBtICogZykgKiBQLCB0WzE1XSA9IChwICogdyAtIGMgKiB4ICsgaCAqIGcpICogUCwgdCkgOiBudWxsO1xuICAgIH0sIHQuaXNDaGFyID0gWm4sIHQuaXNNYXBib3hVUkwgPSBaLCB0LmtleXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gW107XG5cbiAgICAgIGZvciAodmFyIG4gaW4gdCkge1xuICAgICAgICBuIGluIGUgfHwgci5wdXNoKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCB0Lm1ha2VSZXF1ZXN0ID0gYnQsIHQubWFwT2JqZWN0ID0geCwgdC5tZXJjYXRvclhmcm9tTG5nID0gcWwsIHQubWVyY2F0b3JZZnJvbUxhdCA9IE5sLCB0Lm1lcmNhdG9yWmZyb21BbHRpdHVkZSA9IEtsLCB0Lm11bCA9IHBvLCB0Lm11bHRpcGx5ID0gdW8sIHQubXZ0ID0gd3MsIHQubmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgPD0gMSA/IDEgOiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2codCkgLyBNYXRoLkxOMikpO1xuICAgIH0sIHQubm9ybWFsaXplID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICBuID0gZVsxXSxcbiAgICAgICAgICBpID0gZVsyXSxcbiAgICAgICAgICBhID0gciAqIHIgKyBuICogbiArIGkgKiBpO1xuICAgICAgcmV0dXJuIGEgPiAwICYmIChhID0gMSAvIE1hdGguc3FydChhKSksIHRbMF0gPSBlWzBdICogYSwgdFsxXSA9IGVbMV0gKiBhLCB0WzJdID0gZVsyXSAqIGEsIHQ7XG4gICAgfSwgdC5udW1iZXIgPSBHZSwgdC5vZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSBmdCwgdC5vcnRobyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICB2YXIgcyA9IDEgLyAoZSAtIHIpLFxuICAgICAgICAgIHUgPSAxIC8gKG4gLSBpKSxcbiAgICAgICAgICBsID0gMSAvIChhIC0gbyk7XG4gICAgICByZXR1cm4gdFswXSA9IC0yICogcywgdFsxXSA9IDAsIHRbMl0gPSAwLCB0WzNdID0gMCwgdFs0XSA9IDAsIHRbNV0gPSAtMiAqIHUsIHRbNl0gPSAwLCB0WzddID0gMCwgdFs4XSA9IDAsIHRbOV0gPSAwLCB0WzEwXSA9IDIgKiBsLCB0WzExXSA9IDAsIHRbMTJdID0gKGUgKyByKSAqIHMsIHRbMTNdID0gKGkgKyBuKSAqIHUsIHRbMTRdID0gKG8gKyBhKSAqIGwsIHRbMTVdID0gMSwgdDtcbiAgICB9LCB0LnBhcnNlR2x5cGhQQkYgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5ldyAkcyh0KS5yZWFkRmllbGRzKGR1LCBbXSk7XG4gICAgfSwgdC5wYmYgPSAkcywgdC5wZXJmb3JtU3ltYm9sTGF5b3V0ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8pIHtcbiAgICAgIHQuY3JlYXRlQXJyYXlzKCksIHQudGlsZVBpeGVsUmF0aW8gPSA4MTkyIC8gKDUxMiAqIHQub3ZlcnNjYWxpbmcpLCB0LmNvbXBhcmVUZXh0ID0ge30sIHQuaWNvbnNOZWVkTGluZWFyID0gITE7XG4gICAgICB2YXIgcyA9IHQubGF5ZXJzWzBdLmxheW91dCxcbiAgICAgICAgICB1ID0gdC5sYXllcnNbMF0uX3VuZXZhbHVhdGVkTGF5b3V0Ll92YWx1ZXMsXG4gICAgICAgICAgbCA9IHt9O1xuXG4gICAgICBpZiAoXCJjb21wb3NpdGVcIiA9PT0gdC50ZXh0U2l6ZURhdGEua2luZCkge1xuICAgICAgICB2YXIgcCA9IHQudGV4dFNpemVEYXRhLFxuICAgICAgICAgICAgYyA9IHAubWF4Wm9vbTtcbiAgICAgICAgbC5jb21wb3NpdGVUZXh0U2l6ZXMgPSBbdVtcInRleHQtc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aShwLm1pblpvb20pLCBvKSwgdVtcInRleHQtc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aShjKSwgbyldO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJjb21wb3NpdGVcIiA9PT0gdC5pY29uU2l6ZURhdGEua2luZCkge1xuICAgICAgICB2YXIgaCA9IHQuaWNvblNpemVEYXRhLFxuICAgICAgICAgICAgZiA9IGgubWF4Wm9vbTtcbiAgICAgICAgbC5jb21wb3NpdGVJY29uU2l6ZXMgPSBbdVtcImljb24tc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aShoLm1pblpvb20pLCBvKSwgdVtcImljb24tc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aShmKSwgbyldO1xuICAgICAgfVxuXG4gICAgICBsLmxheW91dFRleHRTaXplID0gdVtcInRleHQtc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aSh0Lnpvb20gKyAxKSwgbyksIGwubGF5b3V0SWNvblNpemUgPSB1W1wiaWNvbi1zaXplXCJdLnBvc3NpYmx5RXZhbHVhdGUobmV3IHVpKHQuem9vbSArIDEpLCBvKSwgbC50ZXh0TWF4U2l6ZSA9IHVbXCJ0ZXh0LXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgdWkoMTgpKTtcblxuICAgICAgZm9yICh2YXIgeSA9IDI0ICogcy5nZXQoXCJ0ZXh0LWxpbmUtaGVpZ2h0XCIpLCBkID0gXCJtYXBcIiA9PT0gcy5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSAmJiBcInBvaW50XCIgIT09IHMuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSwgbSA9IHMuZ2V0KFwidGV4dC1rZWVwLXVwcmlnaHRcIiksIHYgPSBzLmdldChcInRleHQtc2l6ZVwiKSwgZyA9IGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHZhciBhID0gYlt4XSxcbiAgICAgICAgICAgIHUgPSBzLmdldChcInRleHQtZm9udFwiKS5ldmFsdWF0ZShhLCB7fSwgbykuam9pbihcIixcIiksXG4gICAgICAgICAgICBwID0gdi5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICBjID0gbC5sYXlvdXRUZXh0U2l6ZS5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICBoID0gbC5sYXlvdXRJY29uU2l6ZS5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICBmID0ge1xuICAgICAgICAgIGhvcml6b250YWw6IHt9LFxuICAgICAgICAgIHZlcnRpY2FsOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGcgPSBhLnRleHQsXG4gICAgICAgICAgICB3ID0gWzAsIDBdO1xuXG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgdmFyIF8gPSBnLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgIFMgPSAyNCAqIHMuZ2V0KFwidGV4dC1sZXR0ZXItc3BhY2luZ1wiKS5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICAgIGsgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAobiA9IHJbZV0uY2hhckNvZGVBdCgwKSwgWm4uQXJhYmljKG4pIHx8IFpuW1wiQXJhYmljIFN1cHBsZW1lbnRcIl0obikgfHwgWm5bXCJBcmFiaWMgRXh0ZW5kZWQtQVwiXShuKSB8fCBabltcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVwiXShuKSB8fCBabltcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlwiXShuKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB9KF8pID8gUyA6IDAsXG4gICAgICAgICAgICAgIEkgPSBzLmdldChcInRleHQtYW5jaG9yXCIpLmV2YWx1YXRlKGEsIHt9LCBvKSxcbiAgICAgICAgICAgICAgeiA9IHMuZ2V0KFwidGV4dC12YXJpYWJsZS1hbmNob3JcIik7XG5cbiAgICAgICAgICBpZiAoIXopIHtcbiAgICAgICAgICAgIHZhciBDID0gcy5nZXQoXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIikuZXZhbHVhdGUoYSwge30sIG8pO1xuICAgICAgICAgICAgdyA9IEMgPyBvbChJLCBbMjQgKiBDLCBhbF0pIDogcy5nZXQoXCJ0ZXh0LW9mZnNldFwiKS5ldmFsdWF0ZShhLCB7fSwgbykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAyNCAqIHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgRSA9IGQgPyBcImNlbnRlclwiIDogcy5nZXQoXCJ0ZXh0LWp1c3RpZnlcIikuZXZhbHVhdGUoYSwge30sIG8pLFxuICAgICAgICAgICAgICBQID0gcy5nZXQoXCJzeW1ib2wtcGxhY2VtZW50XCIpLFxuICAgICAgICAgICAgICBNID0gXCJwb2ludFwiID09PSBQID8gMjQgKiBzLmdldChcInRleHQtbWF4LXdpZHRoXCIpLmV2YWx1YXRlKGEsIHt9LCBvKSA6IDAsXG4gICAgICAgICAgICAgIEIgPSBmdW5jdGlvbiBCKCkge1xuICAgICAgICAgICAgdC5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIFhuKF8pICYmIChmLnZlcnRpY2FsID0ga3UoZywgZSwgciwgaSwgdSwgTSwgeSwgSSwgXCJsZWZ0XCIsIGssIHcsIF91LnZlcnRpY2FsLCAhMCwgUCwgYywgcCkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoIWQgJiYgeikge1xuICAgICAgICAgICAgZm9yICh2YXIgVCA9IFwiYXV0b1wiID09PSBFID8gei5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNsKHQpO1xuICAgICAgICAgICAgfSkgOiBbRV0sIFYgPSAhMSwgRiA9IDA7IEYgPCBULmxlbmd0aDsgRisrKSB7XG4gICAgICAgICAgICAgIHZhciBEID0gVFtGXTtcbiAgICAgICAgICAgICAgaWYgKCFmLmhvcml6b250YWxbRF0pIGlmIChWKSBmLmhvcml6b250YWxbRF0gPSBmLmhvcml6b250YWxbMF07ZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIEwgPSBrdShnLCBlLCByLCBpLCB1LCBNLCB5LCBcImNlbnRlclwiLCBELCBrLCB3LCBfdS5ob3Jpem9udGFsLCAhMSwgUCwgYywgcCk7XG4gICAgICAgICAgICAgICAgTCAmJiAoZi5ob3Jpem9udGFsW0RdID0gTCwgViA9IDEgPT09IEwucG9zaXRpb25lZExpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBcImF1dG9cIiA9PT0gRSAmJiAoRSA9IHNsKEkpKTtcbiAgICAgICAgICAgIHZhciBSID0ga3UoZywgZSwgciwgaSwgdSwgTSwgeSwgSSwgRSwgaywgdywgX3UuaG9yaXpvbnRhbCwgITEsIFAsIGMsIHApO1xuICAgICAgICAgICAgUiAmJiAoZi5ob3Jpem9udGFsW0VdID0gUiksIEIoKSwgWG4oXykgJiYgZCAmJiBtICYmIChmLnZlcnRpY2FsID0ga3UoZywgZSwgciwgaSwgdSwgTSwgeSwgSSwgRSwgaywgdywgX3UudmVydGljYWwsICExLCBQLCBjLCBwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIE8gPSB2b2lkIDAsXG4gICAgICAgICAgICBVID0gITE7XG5cbiAgICAgICAgaWYgKGEuaWNvbiAmJiBhLmljb24ubmFtZSkge1xuICAgICAgICAgIHZhciBqID0gblthLmljb24ubmFtZV07XG4gICAgICAgICAgaiAmJiAoTyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgICB2YXIgbiA9IFR1KHIpLFxuICAgICAgICAgICAgICAgIGkgPSBlWzBdIC0gdC5kaXNwbGF5U2l6ZVswXSAqIG4uaG9yaXpvbnRhbEFsaWduLFxuICAgICAgICAgICAgICAgIGEgPSBlWzFdIC0gdC5kaXNwbGF5U2l6ZVsxXSAqIG4udmVydGljYWxBbGlnbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGltYWdlOiB0LFxuICAgICAgICAgICAgICB0b3A6IGEsXG4gICAgICAgICAgICAgIGJvdHRvbTogYSArIHQuZGlzcGxheVNpemVbMV0sXG4gICAgICAgICAgICAgIGxlZnQ6IGksXG4gICAgICAgICAgICAgIHJpZ2h0OiBpICsgdC5kaXNwbGF5U2l6ZVswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KGlbYS5pY29uLm5hbWVdLCBzLmdldChcImljb24tb2Zmc2V0XCIpLmV2YWx1YXRlKGEsIHt9LCBvKSwgcy5nZXQoXCJpY29uLWFuY2hvclwiKS5ldmFsdWF0ZShhLCB7fSwgbykpLCBVID0gai5zZGYsIHZvaWQgMCA9PT0gdC5zZGZJY29ucyA/IHQuc2RmSWNvbnMgPSBqLnNkZiA6IHQuc2RmSWNvbnMgIT09IGouc2RmICYmIEEoXCJTdHlsZSBzaGVldCB3YXJuaW5nOiBDYW5ub3QgbWl4IFNERiBhbmQgbm9uLVNERiBpY29ucyBpbiBvbmUgYnVmZmVyXCIpLCAoai5waXhlbFJhdGlvICE9PSB0LnBpeGVsUmF0aW8gfHwgMCAhPT0gcy5nZXQoXCJpY29uLXJvdGF0ZVwiKS5jb25zdGFudE9yKDEpKSAmJiAodC5pY29uc05lZWRMaW5lYXIgPSAhMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHEgPSBsbChmLmhvcml6b250YWwpIHx8IGYudmVydGljYWw7XG4gICAgICAgIHQuaWNvbnNJblRleHQgPSAhIXEgJiYgcS5pY29uc0luVGV4dCwgKHEgfHwgTykgJiYgZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHApIHtcbiAgICAgICAgICB2YXIgYyA9IGEudGV4dE1heFNpemUuZXZhbHVhdGUoZSwge30pO1xuICAgICAgICAgIHZvaWQgMCA9PT0gYyAmJiAoYyA9IG8pO1xuXG4gICAgICAgICAgdmFyIGgsXG4gICAgICAgICAgICAgIGYgPSB0LmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgICAgICAgIHkgPSBmLmdldChcImljb24tb2Zmc2V0XCIpLmV2YWx1YXRlKGUsIHt9LCBwKSxcbiAgICAgICAgICAgICAgZCA9IGxsKHIuaG9yaXpvbnRhbCksXG4gICAgICAgICAgICAgIG0gPSBvIC8gMjQsXG4gICAgICAgICAgICAgIHYgPSB0LnRpbGVQaXhlbFJhdGlvICogbSxcbiAgICAgICAgICAgICAgZyA9IHQudGlsZVBpeGVsUmF0aW8gKiBjIC8gMjQsXG4gICAgICAgICAgICAgIHggPSB0LnRpbGVQaXhlbFJhdGlvICogcyxcbiAgICAgICAgICAgICAgYiA9IHQudGlsZVBpeGVsUmF0aW8gKiBmLmdldChcInN5bWJvbC1zcGFjaW5nXCIpLFxuICAgICAgICAgICAgICB3ID0gZi5nZXQoXCJ0ZXh0LXBhZGRpbmdcIikgKiB0LnRpbGVQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICBfID0gZi5nZXQoXCJpY29uLXBhZGRpbmdcIikgKiB0LnRpbGVQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICBTID0gZi5nZXQoXCJ0ZXh0LW1heC1hbmdsZVwiKSAvIDE4MCAqIE1hdGguUEksXG4gICAgICAgICAgICAgIGsgPSBcIm1hcFwiID09PSBmLmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpICYmIFwicG9pbnRcIiAhPT0gZi5nZXQoXCJzeW1ib2wtcGxhY2VtZW50XCIpLFxuICAgICAgICAgICAgICBJID0gXCJtYXBcIiA9PT0gZi5nZXQoXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiKSAmJiBcInBvaW50XCIgIT09IGYuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSxcbiAgICAgICAgICAgICAgeiA9IGYuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSxcbiAgICAgICAgICAgICAgQyA9IGIgLyAyLFxuICAgICAgICAgICAgICBFID0gZi5nZXQoXCJpY29uLXRleHQtZml0XCIpO1xuXG4gICAgICAgICAgbiAmJiBcIm5vbmVcIiAhPT0gRSAmJiAodC5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIHIudmVydGljYWwgJiYgKGggPSBGdShuLCByLnZlcnRpY2FsLCBFLCBmLmdldChcImljb24tdGV4dC1maXQtcGFkZGluZ1wiKSwgeSwgbSkpLCBkICYmIChuID0gRnUobiwgZCwgRSwgZi5nZXQoXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIiksIHksIG0pKSk7XG5cbiAgICAgICAgICB2YXIgUCA9IGZ1bmN0aW9uIFAocywgYykge1xuICAgICAgICAgICAgYy54IDwgMCB8fCBjLnggPj0gODE5MiB8fCBjLnkgPCAwIHx8IGMueSA+PSA4MTkyIHx8IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtLCB2LCBnLCB4LCBiLCB3LCBfLCBTLCBrKSB7XG4gICAgICAgICAgICAgIHZhciBJLFxuICAgICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgICAgICAgIEMsXG4gICAgICAgICAgICAgICAgICBFLFxuICAgICAgICAgICAgICAgICAgUCxcbiAgICAgICAgICAgICAgICAgIE0gPSB0LmFkZFRvTGluZVZlcnRleEFycmF5KGUsIHIpLFxuICAgICAgICAgICAgICAgICAgQiA9IDAsXG4gICAgICAgICAgICAgICAgICBUID0gMCxcbiAgICAgICAgICAgICAgICAgIFYgPSAwLFxuICAgICAgICAgICAgICAgICAgRiA9IDAsXG4gICAgICAgICAgICAgICAgICBEID0gLTEsXG4gICAgICAgICAgICAgICAgICBMID0gLTEsXG4gICAgICAgICAgICAgICAgICBSID0ge30sXG4gICAgICAgICAgICAgICAgICBPID0gZmEoXCJcIiksXG4gICAgICAgICAgICAgICAgICBVID0gMCxcbiAgICAgICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHMuX3VuZXZhbHVhdGVkTGF5b3V0LmdldFZhbHVlKFwidGV4dC1yYWRpYWwtb2Zmc2V0XCIpID8gKFUgPSAoSSA9IHMubGF5b3V0LmdldChcInRleHQtb2Zmc2V0XCIpLmV2YWx1YXRlKGIsIHt9LCBTKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjQgKiB0O1xuICAgICAgICAgICAgICB9KSlbMF0sIGogPSBJWzFdKSA6IChVID0gMjQgKiBzLmxheW91dC5nZXQoXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIikuZXZhbHVhdGUoYiwge30sIFMpLCBqID0gYWwpLCB0LmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgbi52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHZhciBxID0gcy5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGVcIikuZXZhbHVhdGUoYiwge30sIFMpICsgOTA7XG4gICAgICAgICAgICAgICAgRSA9IG5ldyBRdSh1LCBlLCBsLCBwLCBjLCBuLnZlcnRpY2FsLCBoLCBmLCB5LCBxKSwgbyAmJiAoUCA9IG5ldyBRdSh1LCBlLCBsLCBwLCBjLCBvLCBtLCB2LCB5LCBxKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBOID0gcy5sYXlvdXQuZ2V0KFwiaWNvbi1yb3RhdGVcIikuZXZhbHVhdGUoYiwge30pLFxuICAgICAgICAgICAgICAgICAgICBLID0gXCJub25lXCIgIT09IHMubGF5b3V0LmdldChcImljb24tdGV4dC1maXRcIiksXG4gICAgICAgICAgICAgICAgICAgIEcgPSBKdShpLCBOLCBfLCBLKSxcbiAgICAgICAgICAgICAgICAgICAgWiA9IG8gPyBKdShvLCBOLCBfLCBLKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBDID0gbmV3IFF1KHUsIGUsIGwsIHAsIGMsIGksIG0sIHYsICExLCBOKSwgQiA9IDQgKiBHLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgWCA9IHQuaWNvblNpemVEYXRhLFxuICAgICAgICAgICAgICAgICAgICBKID0gbnVsbDtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiID09PSBYLmtpbmQgPyAoSiA9IFsxMjggKiBzLmxheW91dC5nZXQoXCJpY29uLXNpemVcIikuZXZhbHVhdGUoYiwge30pXSlbMF0gPiAzMjY0MCAmJiBBKHQubGF5ZXJJZHNbMF0gKyAnOiBWYWx1ZSBmb3IgXCJpY29uLXNpemVcIiBpcyA+PSAyNTUuIFJlZHVjZSB5b3VyIFwiaWNvbi1zaXplXCIuJykgOiBcImNvbXBvc2l0ZVwiID09PSBYLmtpbmQgJiYgKChKID0gWzEyOCAqIHcuY29tcG9zaXRlSWNvblNpemVzWzBdLmV2YWx1YXRlKGIsIHt9LCBTKSwgMTI4ICogdy5jb21wb3NpdGVJY29uU2l6ZXNbMV0uZXZhbHVhdGUoYiwge30sIFMpXSlbMF0gPiAzMjY0MCB8fCBKWzFdID4gMzI2NDApICYmIEEodC5sYXllcklkc1swXSArICc6IFZhbHVlIGZvciBcImljb24tc2l6ZVwiIGlzID49IDI1NS4gUmVkdWNlIHlvdXIgXCJpY29uLXNpemVcIi4nKSwgdC5hZGRTeW1ib2xzKHQuaWNvbiwgRywgSiwgeCwgZywgYiwgITEsIGUsIE0ubGluZVN0YXJ0SW5kZXgsIE0ubGluZUxlbmd0aCwgLTEsIFMpLCBEID0gdC5pY29uLnBsYWNlZFN5bWJvbEFycmF5Lmxlbmd0aCAtIDEsIFogJiYgKFQgPSA0ICogWi5sZW5ndGgsIHQuYWRkU3ltYm9scyh0Lmljb24sIFosIEosIHgsIGcsIGIsIF91LnZlcnRpY2FsLCBlLCBNLmxpbmVTdGFydEluZGV4LCBNLmxpbmVMZW5ndGgsIC0xLCBTKSwgTCA9IHQuaWNvbi5wbGFjZWRTeW1ib2xBcnJheS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIEggaW4gbi5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIFkgPSBuLmhvcml6b250YWxbSF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXopIHtcbiAgICAgICAgICAgICAgICAgIE8gPSBmYShZLnRleHQpO1xuICAgICAgICAgICAgICAgICAgdmFyICQgPSBzLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0ZVwiKS5ldmFsdWF0ZShiLCB7fSwgUyk7XG4gICAgICAgICAgICAgICAgICB6ID0gbmV3IFF1KHUsIGUsIGwsIHAsIGMsIFksIGgsIGYsIHksICQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBXID0gMSA9PT0gWS5wb3NpdGlvbmVkTGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChWICs9IHVsKHQsIGUsIFksIGEsIHMsIHksIGIsIGQsIE0sIG4udmVydGljYWwgPyBfdS5ob3Jpem9udGFsIDogX3UuaG9yaXpvbnRhbE9ubHksIFcgPyBPYmplY3Qua2V5cyhuLmhvcml6b250YWwpIDogW0hdLCBSLCBELCB3LCBTKSwgVykgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuLnZlcnRpY2FsICYmIChGICs9IHVsKHQsIGUsIG4udmVydGljYWwsIGEsIHMsIHksIGIsIGQsIE0sIF91LnZlcnRpY2FsLCBbXCJ2ZXJ0aWNhbFwiXSwgUiwgTCwgdywgUykpO1xuXG4gICAgICAgICAgICAgIHZhciBRID0geiA/IHouYm94U3RhcnRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgdHQgPSB6ID8gei5ib3hFbmRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgZXQgPSBFID8gRS5ib3hTdGFydEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBydCA9IEUgPyBFLmJveEVuZEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBudCA9IEMgPyBDLmJveFN0YXJ0SW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGl0ID0gQyA/IEMuYm94RW5kSW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGF0ID0gUCA/IFAuYm94U3RhcnRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgb3QgPSBQID8gUC5ib3hFbmRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgc3QgPSAtMSxcbiAgICAgICAgICAgICAgICAgIHV0ID0gZnVuY3Rpb24gdXQodCwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ICYmIHQuY2lyY2xlRGlhbWV0ZXIgPyBNYXRoLm1heCh0LmNpcmNsZURpYW1ldGVyLCBlKSA6IGU7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc3QgPSB1dCh6LCBzdCksIHN0ID0gdXQoRSwgc3QpLCBzdCA9IHV0KEMsIHN0KTtcbiAgICAgICAgICAgICAgdmFyIGx0ID0gKHN0ID0gdXQoUCwgc3QpKSA+IC0xID8gMSA6IDA7XG4gICAgICAgICAgICAgIGx0ICYmIChzdCAqPSBrIC8gMjQpLCB0LmdseXBoT2Zmc2V0QXJyYXkubGVuZ3RoID49IGdsLk1BWF9HTFlQSFMgJiYgQShcIlRvbyBtYW55IGdseXBocyBiZWluZyByZW5kZXJlZCBpbiBhIHRpbGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMjkwN1wiKSwgdm9pZCAwICE9PSBiLnNvcnRLZXkgJiYgdC5hZGRUb1NvcnRLZXlSYW5nZXModC5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoLCBiLnNvcnRLZXkpLCB0LnN5bWJvbEluc3RhbmNlcy5lbXBsYWNlQmFjayhlLngsIGUueSwgUi5yaWdodCA+PSAwID8gUi5yaWdodCA6IC0xLCBSLmNlbnRlciA+PSAwID8gUi5jZW50ZXIgOiAtMSwgUi5sZWZ0ID49IDAgPyBSLmxlZnQgOiAtMSwgUi52ZXJ0aWNhbCB8fCAtMSwgRCwgTCwgTywgUSwgdHQsIGV0LCBydCwgbnQsIGl0LCBhdCwgb3QsIGwsIFYsIEYsIEIsIFQsIGx0LCAwLCBoLCBVLCBqLCBzdCk7XG4gICAgICAgICAgICB9KHQsIGMsIHMsIHIsIG4sIGksIGgsIHQubGF5ZXJzWzBdLCB0LmNvbGxpc2lvbkJveEFycmF5LCBlLmluZGV4LCBlLnNvdXJjZUxheWVySW5kZXgsIHQuaW5kZXgsIHYsIHcsIGssIHUsIHgsIF8sIEksIHksIGUsIGEsIGwsIHAsIG8pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoXCJsaW5lXCIgPT09IHopIGZvciAodmFyIE0gPSAwLCBCID0gWHUoZS5nZW9tZXRyeSwgMCwgMCwgODE5MiwgODE5Mik7IE0gPCBCLmxlbmd0aDsgTSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBUID0gQltNXSwgViA9IDAsIEYgPSBadShULCBiLCBTLCByLnZlcnRpY2FsIHx8IGQsIG4sIDI0LCBnLCB0Lm92ZXJzY2FsaW5nLCA4MTkyKTsgViA8IEYubGVuZ3RoOyBWICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEQgPSBGW1ZdO1xuICAgICAgICAgICAgICBkICYmIHBsKHQsIGQudGV4dCwgQywgRCkgfHwgUChULCBEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFwibGluZS1jZW50ZXJcIiA9PT0geikgZm9yICh2YXIgTCA9IDAsIFIgPSBlLmdlb21ldHJ5OyBMIDwgUi5sZW5ndGg7IEwgKz0gMSkge1xuICAgICAgICAgICAgdmFyIE8gPSBSW0xdO1xuXG4gICAgICAgICAgICBpZiAoTy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBVID0gR3UoTywgUywgci52ZXJ0aWNhbCB8fCBkLCBuLCAyNCwgZyk7XG4gICAgICAgICAgICAgIFUgJiYgUChPLCBVKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFwiUG9seWdvblwiID09PSBlLnR5cGUpIGZvciAodmFyIGogPSAwLCBxID0gaXMoZS5nZW9tZXRyeSwgMCk7IGogPCBxLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgTiA9IHFbal0sXG4gICAgICAgICAgICAgICAgSyA9IHJsKE4sIDE2KTtcbiAgICAgICAgICAgIFAoTlswXSwgbmV3IER1KEsueCwgSy55LCAwKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gZS50eXBlKSBmb3IgKHZhciBHID0gMCwgWiA9IGUuZ2VvbWV0cnk7IEcgPCBaLmxlbmd0aDsgRyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgWCA9IFpbR107XG4gICAgICAgICAgICBQKFgsIG5ldyBEdShYWzBdLngsIFhbMF0ueSwgMCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJQb2ludFwiID09PSBlLnR5cGUpIGZvciAodmFyIEogPSAwLCBIID0gZS5nZW9tZXRyeTsgSiA8IEgubGVuZ3RoOyBKICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFkgPSAwLCAkID0gSFtKXTsgWSA8ICQubGVuZ3RoOyBZICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIFcgPSAkW1ldO1xuICAgICAgICAgICAgICBQKFtXXSwgbmV3IER1KFcueCwgVy55LCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KHQsIGEsIGYsIE8sIG4sIGwsIGMsIGgsIHcsIFUsIG8pO1xuICAgICAgfSwgeCA9IDAsIGIgPSB0LmZlYXR1cmVzOyB4IDwgYi5sZW5ndGg7IHggKz0gMSkge1xuICAgICAgICBnKCk7XG4gICAgICB9XG5cbiAgICAgIGEgJiYgdC5nZW5lcmF0ZUNvbGxpc2lvbkRlYnVnQnVmZmVycygpO1xuICAgIH0sIHQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdmFyIGEsXG4gICAgICAgICAgbyA9IDEgLyBNYXRoLnRhbihlIC8gMik7XG4gICAgICByZXR1cm4gdFswXSA9IG8gLyByLCB0WzFdID0gMCwgdFsyXSA9IDAsIHRbM10gPSAwLCB0WzRdID0gMCwgdFs1XSA9IG8sIHRbNl0gPSAwLCB0WzddID0gMCwgdFs4XSA9IDAsIHRbOV0gPSAwLCB0WzExXSA9IC0xLCB0WzEyXSA9IDAsIHRbMTNdID0gMCwgdFsxNV0gPSAwLCBudWxsICE9IGkgJiYgaSAhPT0gMSAvIDAgPyAodFsxMF0gPSAoaSArIG4pICogKGEgPSAxIC8gKG4gLSBpKSksIHRbMTRdID0gMiAqIGkgKiBuICogYSkgOiAodFsxMF0gPSAtMSwgdFsxNF0gPSAtMiAqIG4pLCB0O1xuICAgIH0sIHQucGljayA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0ge30sIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgaSA9IGVbbl07XG4gICAgICAgIGkgaW4gdCAmJiAocltpXSA9IHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCB0LnBsdWdpbiA9IHNpLCB0LnBvbHlnb25JbnRlcnNlY3RzUG9seWdvbiA9IEthLCB0LnBvc3RNYXBMb2FkRXZlbnQgPSBvdCwgdC5wb3N0VHVybnN0aWxlRXZlbnQgPSBpdCwgdC5wb3RwYWNrID0gZ3UsIHQucmVmUHJvcGVydGllcyA9IFtcInR5cGVcIiwgXCJzb3VyY2VcIiwgXCJzb3VyY2UtbGF5ZXJcIiwgXCJtaW56b29tXCIsIFwibWF4em9vbVwiLCBcImZpbHRlclwiLCBcImxheW91dFwiXSwgdC5yZWdpc3RlciA9IE9uLCB0LnJlZ2lzdGVyRm9yUGx1Z2luU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBwbHVnaW5TdGF0dXM6IHRpLFxuICAgICAgICBwbHVnaW5VUkw6IGVpXG4gICAgICB9KSwgaWkub24oXCJwbHVnaW5TdGF0ZUNoYW5nZVwiLCB0KSwgdDtcbiAgICB9LCB0LnJlbmRlckNvbG9yUmFtcCA9IF9vLCB0LnJvdGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGVbMF0sXG4gICAgICAgICAgaSA9IGVbMV0sXG4gICAgICAgICAgYSA9IGVbMl0sXG4gICAgICAgICAgbyA9IGVbM10sXG4gICAgICAgICAgcyA9IE1hdGguc2luKHIpLFxuICAgICAgICAgIHUgPSBNYXRoLmNvcyhyKTtcbiAgICAgIHJldHVybiB0WzBdID0gbiAqIHUgKyBhICogcywgdFsxXSA9IGkgKiB1ICsgbyAqIHMsIHRbMl0gPSBuICogLXMgKyBhICogdSwgdFszXSA9IGkgKiAtcyArIG8gKiB1LCB0O1xuICAgIH0sIHQucm90YXRlWCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IE1hdGguc2luKHIpLFxuICAgICAgICAgIGkgPSBNYXRoLmNvcyhyKSxcbiAgICAgICAgICBhID0gZVs0XSxcbiAgICAgICAgICBvID0gZVs1XSxcbiAgICAgICAgICBzID0gZVs2XSxcbiAgICAgICAgICB1ID0gZVs3XSxcbiAgICAgICAgICBsID0gZVs4XSxcbiAgICAgICAgICBwID0gZVs5XSxcbiAgICAgICAgICBjID0gZVsxMF0sXG4gICAgICAgICAgaCA9IGVbMTFdO1xuICAgICAgcmV0dXJuIGUgIT09IHQgJiYgKHRbMF0gPSBlWzBdLCB0WzFdID0gZVsxXSwgdFsyXSA9IGVbMl0sIHRbM10gPSBlWzNdLCB0WzEyXSA9IGVbMTJdLCB0WzEzXSA9IGVbMTNdLCB0WzE0XSA9IGVbMTRdLCB0WzE1XSA9IGVbMTVdKSwgdFs0XSA9IGEgKiBpICsgbCAqIG4sIHRbNV0gPSBvICogaSArIHAgKiBuLCB0WzZdID0gcyAqIGkgKyBjICogbiwgdFs3XSA9IHUgKiBpICsgaCAqIG4sIHRbOF0gPSBsICogaSAtIGEgKiBuLCB0WzldID0gcCAqIGkgLSBvICogbiwgdFsxMF0gPSBjICogaSAtIHMgKiBuLCB0WzExXSA9IGggKiBpIC0gdSAqIG4sIHQ7XG4gICAgfSwgdC5yb3RhdGVaID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gTWF0aC5zaW4ociksXG4gICAgICAgICAgaSA9IE1hdGguY29zKHIpLFxuICAgICAgICAgIGEgPSBlWzBdLFxuICAgICAgICAgIG8gPSBlWzFdLFxuICAgICAgICAgIHMgPSBlWzJdLFxuICAgICAgICAgIHUgPSBlWzNdLFxuICAgICAgICAgIGwgPSBlWzRdLFxuICAgICAgICAgIHAgPSBlWzVdLFxuICAgICAgICAgIGMgPSBlWzZdLFxuICAgICAgICAgIGggPSBlWzddO1xuICAgICAgcmV0dXJuIGUgIT09IHQgJiYgKHRbOF0gPSBlWzhdLCB0WzldID0gZVs5XSwgdFsxMF0gPSBlWzEwXSwgdFsxMV0gPSBlWzExXSwgdFsxMl0gPSBlWzEyXSwgdFsxM10gPSBlWzEzXSwgdFsxNF0gPSBlWzE0XSwgdFsxNV0gPSBlWzE1XSksIHRbMF0gPSBhICogaSArIGwgKiBuLCB0WzFdID0gbyAqIGkgKyBwICogbiwgdFsyXSA9IHMgKiBpICsgYyAqIG4sIHRbM10gPSB1ICogaSArIGggKiBuLCB0WzRdID0gbCAqIGkgLSBhICogbiwgdFs1XSA9IHAgKiBpIC0gbyAqIG4sIHRbNl0gPSBjICogaSAtIHMgKiBuLCB0WzddID0gaCAqIGkgLSB1ICogbiwgdDtcbiAgICB9LCB0LnNjYWxlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gclswXSxcbiAgICAgICAgICBpID0gclsxXSxcbiAgICAgICAgICBhID0gclsyXTtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSAqIG4sIHRbMV0gPSBlWzFdICogbiwgdFsyXSA9IGVbMl0gKiBuLCB0WzNdID0gZVszXSAqIG4sIHRbNF0gPSBlWzRdICogaSwgdFs1XSA9IGVbNV0gKiBpLCB0WzZdID0gZVs2XSAqIGksIHRbN10gPSBlWzddICogaSwgdFs4XSA9IGVbOF0gKiBhLCB0WzldID0gZVs5XSAqIGEsIHRbMTBdID0gZVsxMF0gKiBhLCB0WzExXSA9IGVbMTFdICogYSwgdFsxMl0gPSBlWzEyXSwgdFsxM10gPSBlWzEzXSwgdFsxNF0gPSBlWzE0XSwgdFsxNV0gPSBlWzE1XSwgdDtcbiAgICB9LCB0LnNjYWxlJDEgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRbMF0gPSBlWzBdICogciwgdFsxXSA9IGVbMV0gKiByLCB0WzJdID0gZVsyXSAqIHIsIHRbM10gPSBlWzNdICogciwgdDtcbiAgICB9LCB0LnNjYWxlJDIgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRbMF0gPSBlWzBdICogciwgdFsxXSA9IGVbMV0gKiByLCB0WzJdID0gZVsyXSAqIHIsIHQ7XG4gICAgfSwgdC5zZXRDYWNoZUxpbWl0cyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBzdCA9IHQsIHV0ID0gZTtcbiAgICB9LCB0LnNldFJUTFRleHRQbHVnaW4gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gciAmJiAociA9ICExKSwgXCJkZWZlcnJlZFwiID09PSB0aSB8fCBcImxvYWRpbmdcIiA9PT0gdGkgfHwgXCJsb2FkZWRcIiA9PT0gdGkpIHRocm93IG5ldyBFcnJvcihcInNldFJUTFRleHRQbHVnaW4gY2Fubm90IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cIik7XG4gICAgICBlaSA9IFIucmVzb2x2ZVVSTCh0KSwgdGkgPSBcImRlZmVycmVkXCIsIFFuID0gZSwgbmkoKSwgciB8fCBvaSgpO1xuICAgIH0sIHQuc3BoZXJpY2FsVG9DYXJ0ZXNpYW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0WzBdLFxuICAgICAgICAgIHIgPSB0WzFdLFxuICAgICAgICAgIG4gPSB0WzJdO1xuICAgICAgcmV0dXJuIHIgKz0gOTAsIHIgKj0gTWF0aC5QSSAvIDE4MCwgbiAqPSBNYXRoLlBJIC8gMTgwLCB7XG4gICAgICAgIHg6IGUgKiBNYXRoLmNvcyhyKSAqIE1hdGguc2luKG4pLFxuICAgICAgICB5OiBlICogTWF0aC5zaW4ocikgKiBNYXRoLnNpbihuKSxcbiAgICAgICAgejogZSAqIE1hdGguY29zKG4pXG4gICAgICB9O1xuICAgIH0sIHQuc3FyTGVuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdFswXSxcbiAgICAgICAgICByID0gdFsxXTtcbiAgICAgIHJldHVybiBlICogZSArIHIgKiByO1xuICAgIH0sIHQuc3R5bGVTcGVjID0gUHQsIHQuc3ViID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSAtIHJbMF0sIHRbMV0gPSBlWzFdIC0gclsxXSwgdFsyXSA9IGVbMl0gLSByWzJdLCB0O1xuICAgIH0sIHQuc3ltYm9sU2l6ZSA9IFV1LCB0LnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICAgIGkgPSBlWzFdLFxuICAgICAgICAgIGEgPSBlWzJdO1xuICAgICAgcmV0dXJuIHRbMF0gPSBuICogclswXSArIGkgKiByWzNdICsgYSAqIHJbNl0sIHRbMV0gPSBuICogclsxXSArIGkgKiByWzRdICsgYSAqIHJbN10sIHRbMl0gPSBuICogclsyXSArIGkgKiByWzVdICsgYSAqIHJbOF0sIHQ7XG4gICAgfSwgdC50cmFuc2Zvcm1NYXQ0ID0gY28sIHQudHJhbnNsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgYSxcbiAgICAgICAgICBvLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBoLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkID0gclswXSxcbiAgICAgICAgICBtID0gclsxXSxcbiAgICAgICAgICB2ID0gclsyXTtcbiAgICAgIHJldHVybiBlID09PSB0ID8gKHRbMTJdID0gZVswXSAqIGQgKyBlWzRdICogbSArIGVbOF0gKiB2ICsgZVsxMl0sIHRbMTNdID0gZVsxXSAqIGQgKyBlWzVdICogbSArIGVbOV0gKiB2ICsgZVsxM10sIHRbMTRdID0gZVsyXSAqIGQgKyBlWzZdICogbSArIGVbMTBdICogdiArIGVbMTRdLCB0WzE1XSA9IGVbM10gKiBkICsgZVs3XSAqIG0gKyBlWzExXSAqIHYgKyBlWzE1XSkgOiAoaSA9IGVbMV0sIGEgPSBlWzJdLCBvID0gZVszXSwgcyA9IGVbNF0sIHUgPSBlWzVdLCBsID0gZVs2XSwgcCA9IGVbN10sIGMgPSBlWzhdLCBoID0gZVs5XSwgZiA9IGVbMTBdLCB5ID0gZVsxMV0sIHRbMF0gPSBuID0gZVswXSwgdFsxXSA9IGksIHRbMl0gPSBhLCB0WzNdID0gbywgdFs0XSA9IHMsIHRbNV0gPSB1LCB0WzZdID0gbCwgdFs3XSA9IHAsIHRbOF0gPSBjLCB0WzldID0gaCwgdFsxMF0gPSBmLCB0WzExXSA9IHksIHRbMTJdID0gbiAqIGQgKyBzICogbSArIGMgKiB2ICsgZVsxMl0sIHRbMTNdID0gaSAqIGQgKyB1ICogbSArIGggKiB2ICsgZVsxM10sIHRbMTRdID0gYSAqIGQgKyBsICogbSArIGYgKiB2ICsgZVsxNF0sIHRbMTVdID0gbyAqIGQgKyBwICogbSArIHkgKiB2ICsgZVsxNV0pLCB0O1xuICAgIH0sIHQudHJpZ2dlclBsdWdpbkNvbXBsZXRpb25FdmVudCA9IHJpLCB0LnVuaXF1ZUlkID0geSwgdC52YWxpZGF0ZUN1c3RvbVN0eWxlTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICByID0gdC5pZDtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IHIgJiYgZS5wdXNoKHtcbiAgICAgICAgbWVzc2FnZTogXCJsYXllcnMuXCIgKyByICsgJzogbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcImlkXCInXG4gICAgICB9KSwgdm9pZCAwID09PSB0LnJlbmRlciAmJiBlLnB1c2goe1xuICAgICAgICBtZXNzYWdlOiBcImxheWVycy5cIiArIHIgKyAnOiBtaXNzaW5nIHJlcXVpcmVkIG1ldGhvZCBcInJlbmRlclwiJ1xuICAgICAgfSksIHQucmVuZGVyaW5nTW9kZSAmJiBcIjJkXCIgIT09IHQucmVuZGVyaW5nTW9kZSAmJiBcIjNkXCIgIT09IHQucmVuZGVyaW5nTW9kZSAmJiBlLnB1c2goe1xuICAgICAgICBtZXNzYWdlOiBcImxheWVycy5cIiArIHIgKyAnOiBwcm9wZXJ0eSBcInJlbmRlcmluZ01vZGVcIiBtdXN0IGJlIGVpdGhlciBcIjJkXCIgb3IgXCIzZFwiJ1xuICAgICAgfSksIGU7XG4gICAgfSwgdC52YWxpZGF0ZUxpZ2h0ID0gUG4sIHQudmFsaWRhdGVTdHlsZSA9IEVuLCB0LnZhbHVlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciByIGluIHQpIHtcbiAgICAgICAgZS5wdXNoKHRbcl0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9LCB0LnZlY3RvclRpbGUgPSB3cywgdC52ZXJzaW9uID0gXCIxLjE1LjBcIiwgdC53YXJuT25jZSA9IEEsIHQud2VicFN1cHBvcnRlZCA9IFUsIHQud2luZG93ID0gbywgdC53cmFwID0gYztcbiAgfSk7XG4gIGRlZmluZShbXCIuL3NoYXJlZFwiXSwgZnVuY3Rpb24gKGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgdmFyIHIgPSB0eXBlb2YgZTtcbiAgICAgIGlmIChcIm51bWJlclwiID09PSByIHx8IFwiYm9vbGVhblwiID09PSByIHx8IFwic3RyaW5nXCIgPT09IHIgfHwgbnVsbCA9PSBlKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBcIltcIiwgbyA9IDAsIG4gPSBlOyBvIDwgbi5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgIGkgKz0gdChuW29dKSArIFwiLFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGkgKyBcIl1cIjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcyA9IE9iamVjdC5rZXlzKGUpLnNvcnQoKSwgYSA9IFwie1wiLCBsID0gMDsgbCA8IHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgYSArPSBKU09OLnN0cmluZ2lmeShzW2xdKSArIFwiOlwiICsgdChlW3NbbF1dKSArIFwiLFwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYSArIFwifVwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHIocikge1xuICAgICAgZm9yICh2YXIgaSA9IFwiXCIsIG8gPSAwLCBuID0gZS5yZWZQcm9wZXJ0aWVzOyBvIDwgbi5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICBpICs9IFwiL1wiICsgdChyW25bb11dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBmdW5jdGlvbiBpKGUpIHtcbiAgICAgIHRoaXMua2V5Q2FjaGUgPSB7fSwgZSAmJiB0aGlzLnJlcGxhY2UoZSk7XG4gICAgfTtcblxuICAgIGkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fbGF5ZXJDb25maWdzID0ge30sIHRoaXMuX2xheWVycyA9IHt9LCB0aGlzLnVwZGF0ZShlLCBbXSk7XG4gICAgfSwgaS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSB0aGlzLCBuID0gMCwgcyA9IHQ7IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gc1tuXTtcbiAgICAgICAgdGhpcy5fbGF5ZXJDb25maWdzW2EuaWRdID0gYTtcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9sYXllcnNbYS5pZF0gPSBlLmNyZWF0ZVN0eWxlTGF5ZXIoYSk7XG4gICAgICAgIGwuX2ZlYXR1cmVGaWx0ZXIgPSBlLmZlYXR1cmVGaWx0ZXIobC5maWx0ZXIpLCB0aGlzLmtleUNhY2hlW2EuaWRdICYmIGRlbGV0ZSB0aGlzLmtleUNhY2hlW2EuaWRdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciB1ID0gMCwgaCA9IGk7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gaFt1XTtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5Q2FjaGVbY10sIGRlbGV0ZSB0aGlzLl9sYXllckNvbmZpZ3NbY10sIGRlbGV0ZSB0aGlzLl9sYXllcnNbY107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmFtaWxpZXNCeVNvdXJjZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBwID0gMCwgZiA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB7fSwgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgdmFyIG4gPSB0ICYmIHRbZVtvXS5pZF0gfHwgcihlW29dKTtcbiAgICAgICAgICB0ICYmICh0W2Vbb10uaWRdID0gbik7XG4gICAgICAgICAgdmFyIHMgPSBpW25dO1xuICAgICAgICAgIHMgfHwgKHMgPSBpW25dID0gW10pLCBzLnB1c2goZVtvXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGwgaW4gaSkge1xuICAgICAgICAgIGEucHVzaChpW2xdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfShlLnZhbHVlcyh0aGlzLl9sYXllckNvbmZpZ3MpLCB0aGlzLmtleUNhY2hlKTsgcCA8IGYubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgdmFyIGQgPSBmW3BdLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBvLl9sYXllcnNbZS5pZF07XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgZyA9IGRbMF07XG5cbiAgICAgICAgaWYgKFwibm9uZVwiICE9PSBnLnZpc2liaWxpdHkpIHtcbiAgICAgICAgICB2YXIgdiA9IGcuc291cmNlIHx8IFwiXCIsXG4gICAgICAgICAgICAgIG0gPSB0aGlzLmZhbWlsaWVzQnlTb3VyY2Vbdl07XG4gICAgICAgICAgbSB8fCAobSA9IHRoaXMuZmFtaWxpZXNCeVNvdXJjZVt2XSA9IHt9KTtcbiAgICAgICAgICB2YXIgeSA9IGcuc291cmNlTGF5ZXIgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLFxuICAgICAgICAgICAgICB4ID0gbVt5XTtcbiAgICAgICAgICB4IHx8ICh4ID0gbVt5XSA9IFtdKSwgeC5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvID0gZnVuY3Rpb24gbyh0KSB7XG4gICAgICB2YXIgciA9IHt9LFxuICAgICAgICAgIGkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbyBpbiB0KSB7XG4gICAgICAgIHZhciBuID0gdFtvXSxcbiAgICAgICAgICAgIHMgPSByW29dID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiBuKSB7XG4gICAgICAgICAgdmFyIGwgPSBuWythXTtcblxuICAgICAgICAgIGlmIChsICYmIDAgIT09IGwuYml0bWFwLndpZHRoICYmIDAgIT09IGwuYml0bWFwLmhlaWdodCkge1xuICAgICAgICAgICAgdmFyIHUgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHc6IGwuYml0bWFwLndpZHRoICsgMixcbiAgICAgICAgICAgICAgaDogbC5iaXRtYXAuaGVpZ2h0ICsgMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGkucHVzaCh1KSwgc1thXSA9IHtcbiAgICAgICAgICAgICAgcmVjdDogdSxcbiAgICAgICAgICAgICAgbWV0cmljczogbC5tZXRyaWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IGUucG90cGFjayhpKSxcbiAgICAgICAgICBjID0gbmV3IGUuQWxwaGFJbWFnZSh7XG4gICAgICAgIHdpZHRoOiBoLncgfHwgMSxcbiAgICAgICAgaGVpZ2h0OiBoLmggfHwgMVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gdCkge1xuICAgICAgICB2YXIgZiA9IHRbcF07XG5cbiAgICAgICAgZm9yICh2YXIgZCBpbiBmKSB7XG4gICAgICAgICAgdmFyIGcgPSBmWytkXTtcblxuICAgICAgICAgIGlmIChnICYmIDAgIT09IGcuYml0bWFwLndpZHRoICYmIDAgIT09IGcuYml0bWFwLmhlaWdodCkge1xuICAgICAgICAgICAgdmFyIHYgPSByW3BdW2RdLnJlY3Q7XG4gICAgICAgICAgICBlLkFscGhhSW1hZ2UuY29weShnLmJpdG1hcCwgYywge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHg6IHYueCArIDEsXG4gICAgICAgICAgICAgIHk6IHYueSArIDFcbiAgICAgICAgICAgIH0sIGcuYml0bWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbWFnZSA9IGMsIHRoaXMucG9zaXRpb25zID0gcjtcbiAgICB9O1xuXG4gICAgZS5yZWdpc3RlcihcIkdseXBoQXRsYXNcIiwgbyk7XG5cbiAgICB2YXIgbiA9IGZ1bmN0aW9uIG4odCkge1xuICAgICAgdGhpcy50aWxlSUQgPSBuZXcgZS5PdmVyc2NhbGVkVGlsZUlEKHQudGlsZUlELm92ZXJzY2FsZWRaLCB0LnRpbGVJRC53cmFwLCB0LnRpbGVJRC5jYW5vbmljYWwueiwgdC50aWxlSUQuY2Fub25pY2FsLngsIHQudGlsZUlELmNhbm9uaWNhbC55KSwgdGhpcy51aWQgPSB0LnVpZCwgdGhpcy56b29tID0gdC56b29tLCB0aGlzLnBpeGVsUmF0aW8gPSB0LnBpeGVsUmF0aW8sIHRoaXMudGlsZVNpemUgPSB0LnRpbGVTaXplLCB0aGlzLnNvdXJjZSA9IHQuc291cmNlLCB0aGlzLm92ZXJzY2FsaW5nID0gdGhpcy50aWxlSUQub3ZlcnNjYWxlRmFjdG9yKCksIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzID0gdC5zaG93Q29sbGlzaW9uQm94ZXMsIHRoaXMuY29sbGVjdFJlc291cmNlVGltaW5nID0gISF0LmNvbGxlY3RSZXNvdXJjZVRpbWluZywgdGhpcy5yZXR1cm5EZXBlbmRlbmNpZXMgPSAhIXQucmV0dXJuRGVwZW5kZW5jaWVzLCB0aGlzLnByb21vdGVJZCA9IHQucHJvbW90ZUlkO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzKHQsIHIsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSBuZXcgZS5FdmFsdWF0aW9uUGFyYW1ldGVycyhyKSwgbiA9IDAsIHMgPSB0OyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICBzW25dLnJlY2FsY3VsYXRlKG8sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGEodCwgcikge1xuICAgICAgdmFyIGkgPSBlLmdldEFycmF5QnVmZmVyKHQucmVxdWVzdCwgZnVuY3Rpb24gKHQsIGksIG8sIG4pIHtcbiAgICAgICAgdCA/IHIodCkgOiBpICYmIHIobnVsbCwge1xuICAgICAgICAgIHZlY3RvclRpbGU6IG5ldyBlLnZlY3RvclRpbGUuVmVjdG9yVGlsZShuZXcgZS5wYmYoaSkpLFxuICAgICAgICAgIHJhd0RhdGE6IGksXG4gICAgICAgICAgY2FjaGVDb250cm9sOiBvLFxuICAgICAgICAgIGV4cGlyZXM6IG5cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGkuY2FuY2VsKCksIHIoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodCwgciwgaSwgbiwgYSkge1xuICAgICAgdmFyIGwgPSB0aGlzO1xuICAgICAgdGhpcy5zdGF0dXMgPSBcInBhcnNpbmdcIiwgdGhpcy5kYXRhID0gdCwgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IG5ldyBlLkNvbGxpc2lvbkJveEFycmF5KCk7XG4gICAgICB2YXIgdSA9IG5ldyBlLkRpY3Rpb25hcnlDb2RlcihPYmplY3Qua2V5cyh0LmxheWVycykuc29ydCgpKSxcbiAgICAgICAgICBoID0gbmV3IGUuRmVhdHVyZUluZGV4KHRoaXMudGlsZUlELCB0aGlzLnByb21vdGVJZCk7XG4gICAgICBoLmJ1Y2tldExheWVySURzID0gW107XG4gICAgICB2YXIgYyxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgZCxcbiAgICAgICAgICBnID0ge30sXG4gICAgICAgICAgdiA9IHtcbiAgICAgICAgZmVhdHVyZUluZGV4OiBoLFxuICAgICAgICBpY29uRGVwZW5kZW5jaWVzOiB7fSxcbiAgICAgICAgcGF0dGVybkRlcGVuZGVuY2llczoge30sXG4gICAgICAgIGdseXBoRGVwZW5kZW5jaWVzOiB7fSxcbiAgICAgICAgYXZhaWxhYmxlSW1hZ2VzOiBpXG4gICAgICB9LFxuICAgICAgICAgIG0gPSByLmZhbWlsaWVzQnlTb3VyY2VbdGhpcy5zb3VyY2VdO1xuXG4gICAgICBmb3IgKHZhciB5IGluIG0pIHtcbiAgICAgICAgdmFyIHggPSB0LmxheWVyc1t5XTtcblxuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIDEgPT09IHgudmVyc2lvbiAmJiBlLndhcm5PbmNlKCdWZWN0b3IgdGlsZSBzb3VyY2UgXCInICsgdGhpcy5zb3VyY2UgKyAnXCIgbGF5ZXIgXCInICsgeSArICdcIiBkb2VzIG5vdCB1c2UgdmVjdG9yIHRpbGUgc3BlYyB2MiBhbmQgdGhlcmVmb3JlIG1heSBoYXZlIHNvbWUgcmVuZGVyaW5nIGVycm9ycy4nKTtcblxuICAgICAgICAgIGZvciAodmFyIHcgPSB1LmVuY29kZSh5KSwgUyA9IFtdLCBJID0gMDsgSSA8IHgubGVuZ3RoOyBJKyspIHtcbiAgICAgICAgICAgIHZhciBNID0geC5mZWF0dXJlKEkpLFxuICAgICAgICAgICAgICAgIGIgPSBoLmdldElkKE0sIHkpO1xuICAgICAgICAgICAgUy5wdXNoKHtcbiAgICAgICAgICAgICAgZmVhdHVyZTogTSxcbiAgICAgICAgICAgICAgaWQ6IGIsXG4gICAgICAgICAgICAgIGluZGV4OiBJLFxuICAgICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiB3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfID0gMCwgayA9IG1beV07IF8gPCBrLmxlbmd0aDsgXyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgUCA9IGtbX10sXG4gICAgICAgICAgICAgICAgVCA9IFBbMF07XG4gICAgICAgICAgICBULm1pbnpvb20gJiYgdGhpcy56b29tIDwgTWF0aC5mbG9vcihULm1pbnpvb20pIHx8IFQubWF4em9vbSAmJiB0aGlzLnpvb20gPj0gVC5tYXh6b29tIHx8IFwibm9uZVwiICE9PSBULnZpc2liaWxpdHkgJiYgKHMoUCwgdGhpcy56b29tLCBpKSwgKGdbVC5pZF0gPSBULmNyZWF0ZUJ1Y2tldCh7XG4gICAgICAgICAgICAgIGluZGV4OiBoLmJ1Y2tldExheWVySURzLmxlbmd0aCxcbiAgICAgICAgICAgICAgbGF5ZXJzOiBQLFxuICAgICAgICAgICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICAgICAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgb3ZlcnNjYWxpbmc6IHRoaXMub3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiB0aGlzLmNvbGxpc2lvbkJveEFycmF5LFxuICAgICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiB3LFxuICAgICAgICAgICAgICBzb3VyY2VJRDogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgIH0pKS5wb3B1bGF0ZShTLCB2LCB0aGlzLnRpbGVJRC5jYW5vbmljYWwpLCBoLmJ1Y2tldExheWVySURzLnB1c2goUC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUuaWQ7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgQyA9IGUubWFwT2JqZWN0KHYuZ2x5cGhEZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5tYXAoTnVtYmVyKTtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXMoQykubGVuZ3RoID8gbi5zZW5kKFwiZ2V0R2x5cGhzXCIsIHtcbiAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgc3RhY2tzOiBDXG4gICAgICB9LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBjIHx8IChjID0gZSwgcCA9IHQsIHouY2FsbChsKSk7XG4gICAgICB9KSA6IHAgPSB7fTtcbiAgICAgIHZhciBEID0gT2JqZWN0LmtleXModi5pY29uRGVwZW5kZW5jaWVzKTtcbiAgICAgIEQubGVuZ3RoID8gbi5zZW5kKFwiZ2V0SW1hZ2VzXCIsIHtcbiAgICAgICAgaWNvbnM6IEQsXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHRpbGVJRDogdGhpcy50aWxlSUQsXG4gICAgICAgIHR5cGU6IFwiaWNvbnNcIlxuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYyB8fCAoYyA9IGUsIGYgPSB0LCB6LmNhbGwobCkpO1xuICAgICAgfSkgOiBmID0ge307XG4gICAgICB2YXIgTCA9IE9iamVjdC5rZXlzKHYucGF0dGVybkRlcGVuZGVuY2llcyk7XG5cbiAgICAgIGZ1bmN0aW9uIHooKSB7XG4gICAgICAgIGlmIChjKSByZXR1cm4gYShjKTtcblxuICAgICAgICBpZiAocCAmJiBmICYmIGQpIHtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBvKHApLFxuICAgICAgICAgICAgICByID0gbmV3IGUuSW1hZ2VBdGxhcyhmLCBkKTtcblxuICAgICAgICAgIGZvciAodmFyIG4gaW4gZykge1xuICAgICAgICAgICAgdmFyIGwgPSBnW25dO1xuICAgICAgICAgICAgbCBpbnN0YW5jZW9mIGUuU3ltYm9sQnVja2V0ID8gKHMobC5sYXllcnMsIHRoaXMuem9vbSwgaSksIGUucGVyZm9ybVN5bWJvbExheW91dChsLCBwLCB0LnBvc2l0aW9ucywgZiwgci5pY29uUG9zaXRpb25zLCB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcywgdGhpcy50aWxlSUQuY2Fub25pY2FsKSkgOiBsLmhhc1BhdHRlcm4gJiYgKGwgaW5zdGFuY2VvZiBlLkxpbmVCdWNrZXQgfHwgbCBpbnN0YW5jZW9mIGUuRmlsbEJ1Y2tldCB8fCBsIGluc3RhbmNlb2YgZS5GaWxsRXh0cnVzaW9uQnVja2V0KSAmJiAocyhsLmxheWVycywgdGhpcy56b29tLCBpKSwgbC5hZGRGZWF0dXJlcyh2LCB0aGlzLnRpbGVJRC5jYW5vbmljYWwsIHIucGF0dGVyblBvc2l0aW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJkb25lXCIsIGEobnVsbCwge1xuICAgICAgICAgICAgYnVja2V0czogZS52YWx1ZXMoZykuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhZS5pc0VtcHR5KCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleDogaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiB0aGlzLmNvbGxpc2lvbkJveEFycmF5LFxuICAgICAgICAgICAgZ2x5cGhBdGxhc0ltYWdlOiB0LmltYWdlLFxuICAgICAgICAgICAgaW1hZ2VBdGxhczogcixcbiAgICAgICAgICAgIGdseXBoTWFwOiB0aGlzLnJldHVybkRlcGVuZGVuY2llcyA/IHAgOiBudWxsLFxuICAgICAgICAgICAgaWNvbk1hcDogdGhpcy5yZXR1cm5EZXBlbmRlbmNpZXMgPyBmIDogbnVsbCxcbiAgICAgICAgICAgIGdseXBoUG9zaXRpb25zOiB0aGlzLnJldHVybkRlcGVuZGVuY2llcyA/IHQucG9zaXRpb25zIDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEwubGVuZ3RoID8gbi5zZW5kKFwiZ2V0SW1hZ2VzXCIsIHtcbiAgICAgICAgaWNvbnM6IEwsXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHRpbGVJRDogdGhpcy50aWxlSUQsXG4gICAgICAgIHR5cGU6IFwicGF0dGVybnNcIlxuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYyB8fCAoYyA9IGUsIGQgPSB0LCB6LmNhbGwobCkpO1xuICAgICAgfSkgOiBkID0ge30sIHouY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgdmFyIGwgPSBmdW5jdGlvbiBsKGUsIHQsIHIsIGkpIHtcbiAgICAgIHRoaXMuYWN0b3IgPSBlLCB0aGlzLmxheWVySW5kZXggPSB0LCB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IHIsIHRoaXMubG9hZFZlY3RvckRhdGEgPSBpIHx8IGEsIHRoaXMubG9hZGluZyA9IHt9LCB0aGlzLmxvYWRlZCA9IHt9O1xuICAgIH07XG5cbiAgICBsLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0LCByKSB7XG4gICAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgICAgbyA9IHQudWlkO1xuICAgICAgdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB7fSk7XG4gICAgICB2YXIgcyA9ICEhKHQgJiYgdC5yZXF1ZXN0ICYmIHQucmVxdWVzdC5jb2xsZWN0UmVzb3VyY2VUaW1pbmcpICYmIG5ldyBlLlJlcXVlc3RQZXJmb3JtYW5jZSh0LnJlcXVlc3QpLFxuICAgICAgICAgIGEgPSB0aGlzLmxvYWRpbmdbb10gPSBuZXcgbih0KTtcbiAgICAgIGEuYWJvcnQgPSB0aGlzLmxvYWRWZWN0b3JEYXRhKHQsIGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgIGlmIChkZWxldGUgaS5sb2FkaW5nW29dLCB0IHx8ICFuKSByZXR1cm4gYS5zdGF0dXMgPSBcImRvbmVcIiwgaS5sb2FkZWRbb10gPSBhLCByKHQpO1xuICAgICAgICB2YXIgbCA9IG4ucmF3RGF0YSxcbiAgICAgICAgICAgIHUgPSB7fTtcbiAgICAgICAgbi5leHBpcmVzICYmICh1LmV4cGlyZXMgPSBuLmV4cGlyZXMpLCBuLmNhY2hlQ29udHJvbCAmJiAodS5jYWNoZUNvbnRyb2wgPSBuLmNhY2hlQ29udHJvbCk7XG4gICAgICAgIHZhciBoID0ge307XG5cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICB2YXIgYyA9IHMuZmluaXNoKCk7XG4gICAgICAgICAgYyAmJiAoaC5yZXNvdXJjZVRpbWluZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEudmVjdG9yVGlsZSA9IG4udmVjdG9yVGlsZSwgYS5wYXJzZShuLnZlY3RvclRpbGUsIGkubGF5ZXJJbmRleCwgaS5hdmFpbGFibGVJbWFnZXMsIGkuYWN0b3IsIGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgaWYgKHQgfHwgIWkpIHJldHVybiByKHQpO1xuICAgICAgICAgIHIobnVsbCwgZS5leHRlbmQoe1xuICAgICAgICAgICAgcmF3VGlsZURhdGE6IGwuc2xpY2UoMClcbiAgICAgICAgICB9LCBpLCB1LCBoKSk7XG4gICAgICAgIH0pLCBpLmxvYWRlZCA9IGkubG9hZGVkIHx8IHt9LCBpLmxvYWRlZFtvXSA9IGE7XG4gICAgICB9KTtcbiAgICB9LCBsLnByb3RvdHlwZS5yZWxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgICBpID0gdGhpcy5sb2FkZWQsXG4gICAgICAgICAgbyA9IGUudWlkLFxuICAgICAgICAgIG4gPSB0aGlzO1xuXG4gICAgICBpZiAoaSAmJiBpW29dKSB7XG4gICAgICAgIHZhciBzID0gaVtvXTtcbiAgICAgICAgcy5zaG93Q29sbGlzaW9uQm94ZXMgPSBlLnNob3dDb2xsaXNpb25Cb3hlcztcblxuICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uIGEoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gcy5yZWxvYWRDYWxsYmFjaztcbiAgICAgICAgICBvICYmIChkZWxldGUgcy5yZWxvYWRDYWxsYmFjaywgcy5wYXJzZShzLnZlY3RvclRpbGUsIG4ubGF5ZXJJbmRleCwgci5hdmFpbGFibGVJbWFnZXMsIG4uYWN0b3IsIG8pKSwgdChlLCBpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBcInBhcnNpbmdcIiA9PT0gcy5zdGF0dXMgPyBzLnJlbG9hZENhbGxiYWNrID0gYSA6IFwiZG9uZVwiID09PSBzLnN0YXR1cyAmJiAocy52ZWN0b3JUaWxlID8gcy5wYXJzZShzLnZlY3RvclRpbGUsIHRoaXMubGF5ZXJJbmRleCwgdGhpcy5hdmFpbGFibGVJbWFnZXMsIHRoaXMuYWN0b3IsIGEpIDogYSgpKTtcbiAgICAgIH1cbiAgICB9LCBsLnByb3RvdHlwZS5hYm9ydFRpbGUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgdmFyIHIgPSB0aGlzLmxvYWRpbmcsXG4gICAgICAgICAgaSA9IGUudWlkO1xuICAgICAgciAmJiByW2ldICYmIHJbaV0uYWJvcnQgJiYgKHJbaV0uYWJvcnQoKSwgZGVsZXRlIHJbaV0pLCB0KCk7XG4gICAgfSwgbC5wcm90b3R5cGUucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB2YXIgciA9IHRoaXMubG9hZGVkLFxuICAgICAgICAgIGkgPSBlLnVpZDtcbiAgICAgIHIgJiYgcltpXSAmJiBkZWxldGUgcltpXSwgdCgpO1xuICAgIH07XG5cbiAgICB2YXIgdSA9IGUud2luZG93LkltYWdlQml0bWFwLFxuICAgICAgICBoID0gZnVuY3Rpb24gaCgpIHtcbiAgICAgIHRoaXMubG9hZGVkID0ge307XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGMoZSwgdCkge1xuICAgICAgaWYgKDAgIT09IGUubGVuZ3RoKSB7XG4gICAgICAgIHAoZVswXSwgdCk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgcChlW3JdLCAhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBuID0gbyAtIDE7IGkgPCBvOyBuID0gaSsrKSB7XG4gICAgICAgIHIgKz0gKGVbaV1bMF0gLSBlW25dWzBdKSAqIChlW25dWzFdICsgZVtpXVsxXSk7XG4gICAgICB9XG5cbiAgICAgIHIgPj0gMCAhPSAhIXQgJiYgZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgaC5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgcikge1xuICAgICAgdmFyIGkgPSB0LnVpZCxcbiAgICAgICAgICBvID0gdC5lbmNvZGluZyxcbiAgICAgICAgICBuID0gdC5yYXdJbWFnZURhdGEsXG4gICAgICAgICAgcyA9IHUgJiYgbiBpbnN0YW5jZW9mIHUgPyB0aGlzLmdldEltYWdlRGF0YShuKSA6IG4sXG4gICAgICAgICAgYSA9IG5ldyBlLkRFTURhdGEoaSwgcywgbyk7XG4gICAgICB0aGlzLmxvYWRlZCA9IHRoaXMubG9hZGVkIHx8IHt9LCB0aGlzLmxvYWRlZFtpXSA9IGEsIHIobnVsbCwgYSk7XG4gICAgfSwgaC5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzICYmIHRoaXMub2Zmc2NyZWVuQ2FudmFzQ29udGV4dCB8fCAodGhpcy5vZmZzY3JlZW5DYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHQud2lkdGgsIHQuaGVpZ2h0KSwgdGhpcy5vZmZzY3JlZW5DYW52YXNDb250ZXh0ID0gdGhpcy5vZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKSwgdGhpcy5vZmZzY3JlZW5DYW52YXMud2lkdGggPSB0LndpZHRoLCB0aGlzLm9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSB0LmhlaWdodCwgdGhpcy5vZmZzY3JlZW5DYW52YXNDb250ZXh0LmRyYXdJbWFnZSh0LCAwLCAwLCB0LndpZHRoLCB0LmhlaWdodCk7XG4gICAgICB2YXIgciA9IHRoaXMub2Zmc2NyZWVuQ2FudmFzQ29udGV4dC5nZXRJbWFnZURhdGEoLTEsIC0xLCB0LndpZHRoICsgMiwgdC5oZWlnaHQgKyAyKTtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNjcmVlbkNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoLCB0aGlzLm9mZnNjcmVlbkNhbnZhcy5oZWlnaHQpLCBuZXcgZS5SR0JBSW1hZ2Uoe1xuICAgICAgICB3aWR0aDogci53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfSwgci5kYXRhKTtcbiAgICB9LCBoLnByb3RvdHlwZS5yZW1vdmVUaWxlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5sb2FkZWQsXG4gICAgICAgICAgciA9IGUudWlkO1xuICAgICAgdCAmJiB0W3JdICYmIGRlbGV0ZSB0W3JdO1xuICAgIH07XG5cbiAgICB2YXIgZiA9IGUudmVjdG9yVGlsZS5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OLFxuICAgICAgICBkID0gZnVuY3Rpb24gZCh0KSB7XG4gICAgICB0aGlzLl9mZWF0dXJlID0gdCwgdGhpcy5leHRlbnQgPSBlLkVYVEVOVCwgdGhpcy50eXBlID0gdC50eXBlLCB0aGlzLnByb3BlcnRpZXMgPSB0LnRhZ3MsIFwiaWRcIiBpbiB0ICYmICFpc05hTih0LmlkKSAmJiAodGhpcy5pZCA9IHBhcnNlSW50KHQuaWQsIDEwKSk7XG4gICAgfTtcblxuICAgIGQucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgxID09PSB0aGlzLl9mZWF0dXJlLnR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IFtdLCByID0gMCwgaSA9IHRoaXMuX2ZlYXR1cmUuZ2VvbWV0cnk7IHIgPCBpLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgdmFyIG8gPSBpW3JdO1xuICAgICAgICAgIHQucHVzaChbbmV3IGUuUG9pbnQkMShvWzBdLCBvWzFdKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSBbXSwgcyA9IDAsIGEgPSB0aGlzLl9mZWF0dXJlLmdlb21ldHJ5OyBzIDwgYS5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBsID0gW10sIHUgPSAwLCBoID0gYVtzXTsgdSA8IGgubGVuZ3RoOyB1ICs9IDEpIHtcbiAgICAgICAgICB2YXIgYyA9IGhbdV07XG4gICAgICAgICAgbC5wdXNoKG5ldyBlLlBvaW50JDEoY1swXSwgY1sxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbi5wdXNoKGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBkLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgcmV0dXJuIGYuY2FsbCh0aGlzLCBlLCB0LCByKTtcbiAgICB9O1xuXG4gICAgdmFyIGcgPSBmdW5jdGlvbiBnKHQpIHtcbiAgICAgIHRoaXMubGF5ZXJzID0ge1xuICAgICAgICBfZ2VvanNvblRpbGVMYXllcjogdGhpc1xuICAgICAgfSwgdGhpcy5uYW1lID0gXCJfZ2VvanNvblRpbGVMYXllclwiLCB0aGlzLmV4dGVudCA9IGUuRVhURU5ULCB0aGlzLmxlbmd0aCA9IHQubGVuZ3RoLCB0aGlzLl9mZWF0dXJlcyA9IHQ7XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBkKHRoaXMuX2ZlYXR1cmVzW2VdKTtcbiAgICB9O1xuXG4gICAgdmFyIHYgPSBlLnZlY3RvclRpbGUuVmVjdG9yVGlsZUZlYXR1cmUsXG4gICAgICAgIG0gPSB5O1xuXG4gICAgZnVuY3Rpb24geShlLCB0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB0IHx8IHt9LCB0aGlzLmZlYXR1cmVzID0gZSwgdGhpcy5sZW5ndGggPSBlLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB4KGUsIHQpIHtcbiAgICAgIHRoaXMuaWQgPSBcIm51bWJlclwiID09IHR5cGVvZiBlLmlkID8gZS5pZCA6IHZvaWQgMCwgdGhpcy50eXBlID0gZS50eXBlLCB0aGlzLnJhd0dlb21ldHJ5ID0gMSA9PT0gZS50eXBlID8gW2UuZ2VvbWV0cnldIDogZS5nZW9tZXRyeSwgdGhpcy5wcm9wZXJ0aWVzID0gZS50YWdzLCB0aGlzLmV4dGVudCA9IHQgfHwgNDA5NjtcbiAgICB9XG5cbiAgICB5LnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBuZXcgeCh0aGlzLmZlYXR1cmVzW2VdLCB0aGlzLm9wdGlvbnMuZXh0ZW50KTtcbiAgICB9LCB4LnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMucmF3R2VvbWV0cnk7XG4gICAgICB0aGlzLmdlb21ldHJ5ID0gW107XG5cbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBmb3IgKHZhciBpID0gdFtyXSwgbyA9IFtdLCBuID0gMDsgbiA8IGkubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBvLnB1c2gobmV3IGUuUG9pbnQkMShpW25dWzBdLCBpW25dWzFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlb21ldHJ5LnB1c2gobyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5O1xuICAgIH0sIHgucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5IHx8IHRoaXMubG9hZEdlb21ldHJ5KCk7XG5cbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLmdlb21ldHJ5LCB0ID0gMSAvIDAsIHIgPSAtMSAvIDAsIGkgPSAxIC8gMCwgbyA9IC0xIC8gMCwgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBlW25dLCBhID0gMDsgYSA8IHMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICB2YXIgbCA9IHNbYV07XG4gICAgICAgICAgdCA9IE1hdGgubWluKHQsIGwueCksIHIgPSBNYXRoLm1heChyLCBsLngpLCBpID0gTWF0aC5taW4oaSwgbC55KSwgbyA9IE1hdGgubWF4KG8sIGwueSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt0LCBpLCByLCBvXTtcbiAgICB9LCB4LnByb3RvdHlwZS50b0dlb0pTT04gPSB2LnByb3RvdHlwZS50b0dlb0pTT047XG4gICAgdmFyIHcgPSBJLFxuICAgICAgICBTID0gbTtcblxuICAgIGZ1bmN0aW9uIEkodCkge1xuICAgICAgdmFyIHIgPSBuZXcgZS5wYmYoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBmb3IgKHZhciByIGluIGUubGF5ZXJzKSB7XG4gICAgICAgICAgdC53cml0ZU1lc3NhZ2UoMywgTSwgZS5sYXllcnNbcl0pO1xuICAgICAgICB9XG4gICAgICB9KHQsIHIpLCByLmZpbmlzaCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE0oZSwgdCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0LndyaXRlVmFyaW50RmllbGQoMTUsIGUudmVyc2lvbiB8fCAxKSwgdC53cml0ZVN0cmluZ0ZpZWxkKDEsIGUubmFtZSB8fCBcIlwiKSwgdC53cml0ZVZhcmludEZpZWxkKDUsIGUuZXh0ZW50IHx8IDQwOTYpO1xuICAgICAgdmFyIGkgPSB7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICBrZXljYWNoZToge30sXG4gICAgICAgIHZhbHVlY2FjaGU6IHt9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICBpLmZlYXR1cmUgPSBlLmZlYXR1cmUociksIHQud3JpdGVNZXNzYWdlKDIsIGIsIGkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbyA9IGkua2V5cztcblxuICAgICAgZm9yIChyID0gMDsgciA8IG8ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdC53cml0ZVN0cmluZ0ZpZWxkKDMsIG9bcl0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IGkudmFsdWVzO1xuXG4gICAgICBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykge1xuICAgICAgICB0LndyaXRlTWVzc2FnZSg0LCBDLCBuW3JdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS5mZWF0dXJlO1xuICAgICAgdm9pZCAwICE9PSByLmlkICYmIHQud3JpdGVWYXJpbnRGaWVsZCgxLCByLmlkKSwgdC53cml0ZU1lc3NhZ2UoMiwgXywgZSksIHQud3JpdGVWYXJpbnRGaWVsZCgzLCByLnR5cGUpLCB0LndyaXRlTWVzc2FnZSg0LCBULCByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS5mZWF0dXJlLFxuICAgICAgICAgIGkgPSBlLmtleXMsXG4gICAgICAgICAgbyA9IGUudmFsdWVzLFxuICAgICAgICAgIG4gPSBlLmtleWNhY2hlLFxuICAgICAgICAgIHMgPSBlLnZhbHVlY2FjaGU7XG5cbiAgICAgIGZvciAodmFyIGEgaW4gci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBsID0gblthXTtcbiAgICAgICAgdm9pZCAwID09PSBsICYmIChpLnB1c2goYSksIG5bYV0gPSBsID0gaS5sZW5ndGggLSAxKSwgdC53cml0ZVZhcmludChsKTtcbiAgICAgICAgdmFyIHUgPSByLnByb3BlcnRpZXNbYV0sXG4gICAgICAgICAgICBoID0gdHlwZW9mIHU7XG4gICAgICAgIFwic3RyaW5nXCIgIT09IGggJiYgXCJib29sZWFuXCIgIT09IGggJiYgXCJudW1iZXJcIiAhPT0gaCAmJiAodSA9IEpTT04uc3RyaW5naWZ5KHUpKTtcbiAgICAgICAgdmFyIGMgPSBoICsgXCI6XCIgKyB1LFxuICAgICAgICAgICAgcCA9IHNbY107XG4gICAgICAgIHZvaWQgMCA9PT0gcCAmJiAoby5wdXNoKHUpLCBzW2NdID0gcCA9IG8ubGVuZ3RoIC0gMSksIHQud3JpdGVWYXJpbnQocCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gayhlLCB0KSB7XG4gICAgICByZXR1cm4gKHQgPDwgMykgKyAoNyAmIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFAoZSkge1xuICAgICAgcmV0dXJuIGUgPDwgMSBeIGUgPj4gMzE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVChlLCB0KSB7XG4gICAgICBmb3IgKHZhciByID0gZS5sb2FkR2VvbWV0cnkoKSwgaSA9IGUudHlwZSwgbyA9IDAsIG4gPSAwLCBzID0gci5sZW5ndGgsIGEgPSAwOyBhIDwgczsgYSsrKSB7XG4gICAgICAgIHZhciBsID0gclthXSxcbiAgICAgICAgICAgIHUgPSAxO1xuICAgICAgICAxID09PSBpICYmICh1ID0gbC5sZW5ndGgpLCB0LndyaXRlVmFyaW50KGsoMSwgdSkpO1xuXG4gICAgICAgIGZvciAodmFyIGggPSAzID09PSBpID8gbC5sZW5ndGggLSAxIDogbC5sZW5ndGgsIGMgPSAwOyBjIDwgaDsgYysrKSB7XG4gICAgICAgICAgMSA9PT0gYyAmJiAxICE9PSBpICYmIHQud3JpdGVWYXJpbnQoaygyLCBoIC0gMSkpO1xuICAgICAgICAgIHZhciBwID0gbFtjXS54IC0gbyxcbiAgICAgICAgICAgICAgZiA9IGxbY10ueSAtIG47XG4gICAgICAgICAgdC53cml0ZVZhcmludChQKHApKSwgdC53cml0ZVZhcmludChQKGYpKSwgbyArPSBwLCBuICs9IGY7XG4gICAgICAgIH1cblxuICAgICAgICAzID09PSBpICYmIHQud3JpdGVWYXJpbnQoayg3LCAxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQyhlLCB0KSB7XG4gICAgICB2YXIgciA9IHR5cGVvZiBlO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gciA/IHQud3JpdGVTdHJpbmdGaWVsZCgxLCBlKSA6IFwiYm9vbGVhblwiID09PSByID8gdC53cml0ZUJvb2xlYW5GaWVsZCg3LCBlKSA6IFwibnVtYmVyXCIgPT09IHIgJiYgKGUgJSAxICE9IDAgPyB0LndyaXRlRG91YmxlRmllbGQoMywgZSkgOiBlIDwgMCA/IHQud3JpdGVTVmFyaW50RmllbGQoNiwgZSkgOiB0LndyaXRlVmFyaW50RmllbGQoNSwgZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEQoZSwgdCwgciwgaSkge1xuICAgICAgTChlLCByLCBpKSwgTCh0LCAyICogciwgMiAqIGkpLCBMKHQsIDIgKiByICsgMSwgMiAqIGkgKyAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gZVt0XTtcbiAgICAgIGVbdF0gPSBlW3JdLCBlW3JdID0gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6KGUsIHQsIHIsIGkpIHtcbiAgICAgIHZhciBvID0gZSAtIHIsXG4gICAgICAgICAgbiA9IHQgLSBpO1xuICAgICAgcmV0dXJuIG8gKiBvICsgbiAqIG47XG4gICAgfVxuXG4gICAgdy5mcm9tVmVjdG9yVGlsZUpzID0gSSwgdy5mcm9tR2VvanNvblZ0ID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHQgPSB0IHx8IHt9O1xuICAgICAgdmFyIHIgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBlKSB7XG4gICAgICAgIHJbaV0gPSBuZXcgbShlW2ldLmZlYXR1cmVzLCB0KSwgcltpXS5uYW1lID0gaSwgcltpXS52ZXJzaW9uID0gdC52ZXJzaW9uLCByW2ldLmV4dGVudCA9IHQuZXh0ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSSh7XG4gICAgICAgIGxheWVyczogclxuICAgICAgfSk7XG4gICAgfSwgdy5HZW9KU09OV3JhcHBlciA9IFM7XG5cbiAgICB2YXIgTyA9IGZ1bmN0aW9uIE8oZSkge1xuICAgICAgcmV0dXJuIGVbMF07XG4gICAgfSxcbiAgICAgICAgRSA9IGZ1bmN0aW9uIEUoZSkge1xuICAgICAgcmV0dXJuIGVbMV07XG4gICAgfSxcbiAgICAgICAgRiA9IGZ1bmN0aW9uIEYoZSwgdCwgciwgaSwgbykge1xuICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gTyksIHZvaWQgMCA9PT0gciAmJiAociA9IEUpLCB2b2lkIDAgPT09IGkgJiYgKGkgPSA2NCksIHZvaWQgMCA9PT0gbyAmJiAobyA9IEZsb2F0NjRBcnJheSksIHRoaXMubm9kZVNpemUgPSBpLCB0aGlzLnBvaW50cyA9IGU7XG5cbiAgICAgIGZvciAodmFyIG4gPSBlLmxlbmd0aCA8IDY1NTM2ID8gVWludDE2QXJyYXkgOiBVaW50MzJBcnJheSwgcyA9IHRoaXMuaWRzID0gbmV3IG4oZS5sZW5ndGgpLCBhID0gdGhpcy5jb29yZHMgPSBuZXcgbygyICogZS5sZW5ndGgpLCBsID0gMDsgbCA8IGUubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgc1tsXSA9IGwsIGFbMiAqIGxdID0gdChlW2xdKSwgYVsyICogbCArIDFdID0gcihlW2xdKTtcbiAgICAgIH1cblxuICAgICAgIWZ1bmN0aW9uIGUodCwgciwgaSwgbywgbiwgcykge1xuICAgICAgICBpZiAoIShuIC0gbyA8PSBpKSkge1xuICAgICAgICAgIHZhciBhID0gbyArIG4gPj4gMTtcbiAgICAgICAgICAhZnVuY3Rpb24gZSh0LCByLCBpLCBvLCBuLCBzKSB7XG4gICAgICAgICAgICBmb3IgKDsgbiA+IG87KSB7XG4gICAgICAgICAgICAgIGlmIChuIC0gbyA+IDYwMCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gbiAtIG8gKyAxLFxuICAgICAgICAgICAgICAgICAgICBsID0gaSAtIG8gKyAxLFxuICAgICAgICAgICAgICAgICAgICB1ID0gTWF0aC5sb2coYSksXG4gICAgICAgICAgICAgICAgICAgIGggPSAuNSAqIE1hdGguZXhwKDIgKiB1IC8gMyksXG4gICAgICAgICAgICAgICAgICAgIGMgPSAuNSAqIE1hdGguc3FydCh1ICogaCAqIChhIC0gaCkgLyBhKSAqIChsIC0gYSAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBlKHQsIHIsIGksIE1hdGgubWF4KG8sIE1hdGguZmxvb3IoaSAtIGwgKiBoIC8gYSArIGMpKSwgTWF0aC5taW4obiwgTWF0aC5mbG9vcihpICsgKGEgLSBsKSAqIGggLyBhICsgYykpLCBzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwID0gclsyICogaSArIHNdLFxuICAgICAgICAgICAgICAgICAgZiA9IG8sXG4gICAgICAgICAgICAgICAgICBkID0gbjtcblxuICAgICAgICAgICAgICBmb3IgKEQodCwgciwgbywgaSksIHJbMiAqIG4gKyBzXSA+IHAgJiYgRCh0LCByLCBvLCBuKTsgZiA8IGQ7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChEKHQsIHIsIGYsIGQpLCBmKyssIGQtLTsgclsyICogZiArIHNdIDwgcDspIHtcbiAgICAgICAgICAgICAgICAgIGYrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgclsyICogZCArIHNdID4gcDspIHtcbiAgICAgICAgICAgICAgICAgIGQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByWzIgKiBvICsgc10gPT09IHAgPyBEKHQsIHIsIG8sIGQpIDogRCh0LCByLCArK2QsIG4pLCBkIDw9IGkgJiYgKG8gPSBkICsgMSksIGkgPD0gZCAmJiAobiA9IGQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KHQsIHIsIGEsIG8sIG4sIHMgJSAyKSwgZSh0LCByLCBpLCBvLCBhIC0gMSwgcyArIDEpLCBlKHQsIHIsIGksIGEgKyAxLCBuLCBzICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0ocywgYSwgaSwgMCwgcy5sZW5ndGggLSAxLCAwKTtcbiAgICB9O1xuXG4gICAgRi5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoZSwgdCwgciwgaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCB0LCByLCBpLCBvLCBuLCBzKSB7XG4gICAgICAgIGZvciAodmFyIGEsIGwsIHUgPSBbMCwgZS5sZW5ndGggLSAxLCAwXSwgaCA9IFtdOyB1Lmxlbmd0aDspIHtcbiAgICAgICAgICB2YXIgYyA9IHUucG9wKCksXG4gICAgICAgICAgICAgIHAgPSB1LnBvcCgpLFxuICAgICAgICAgICAgICBmID0gdS5wb3AoKTtcbiAgICAgICAgICBpZiAocCAtIGYgPD0gcykgZm9yICh2YXIgZCA9IGY7IGQgPD0gcDsgZCsrKSB7XG4gICAgICAgICAgICBsID0gdFsyICogZCArIDFdLCAoYSA9IHRbMiAqIGRdKSA+PSByICYmIGEgPD0gbyAmJiBsID49IGkgJiYgbCA8PSBuICYmIGgucHVzaChlW2RdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGcgPSBNYXRoLmZsb29yKChmICsgcCkgLyAyKTtcbiAgICAgICAgICAgIGwgPSB0WzIgKiBnICsgMV0sIChhID0gdFsyICogZ10pID49IHIgJiYgYSA8PSBvICYmIGwgPj0gaSAmJiBsIDw9IG4gJiYgaC5wdXNoKGVbZ10pO1xuICAgICAgICAgICAgdmFyIHYgPSAoYyArIDEpICUgMjtcbiAgICAgICAgICAgICgwID09PSBjID8gciA8PSBhIDogaSA8PSBsKSAmJiAodS5wdXNoKGYpLCB1LnB1c2goZyAtIDEpLCB1LnB1c2godikpLCAoMCA9PT0gYyA/IG8gPj0gYSA6IG4gPj0gbCkgJiYgKHUucHVzaChnICsgMSksIHUucHVzaChwKSwgdS5wdXNoKHYpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH0odGhpcy5pZHMsIHRoaXMuY29vcmRzLCBlLCB0LCByLCBpLCB0aGlzLm5vZGVTaXplKTtcbiAgICB9LCBGLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBbMCwgZS5sZW5ndGggLSAxLCAwXSwgYSA9IFtdLCBsID0gbyAqIG87IHMubGVuZ3RoOykge1xuICAgICAgICAgIHZhciB1ID0gcy5wb3AoKSxcbiAgICAgICAgICAgICAgaCA9IHMucG9wKCksXG4gICAgICAgICAgICAgIGMgPSBzLnBvcCgpO1xuICAgICAgICAgIGlmIChoIC0gYyA8PSBuKSBmb3IgKHZhciBwID0gYzsgcCA8PSBoOyBwKyspIHtcbiAgICAgICAgICAgIHoodFsyICogcF0sIHRbMiAqIHAgKyAxXSwgciwgaSkgPD0gbCAmJiBhLnB1c2goZVtwXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gTWF0aC5mbG9vcigoYyArIGgpIC8gMiksXG4gICAgICAgICAgICAgICAgZCA9IHRbMiAqIGZdLFxuICAgICAgICAgICAgICAgIGcgPSB0WzIgKiBmICsgMV07XG4gICAgICAgICAgICB6KGQsIGcsIHIsIGkpIDw9IGwgJiYgYS5wdXNoKGVbZl0pO1xuICAgICAgICAgICAgdmFyIHYgPSAodSArIDEpICUgMjtcbiAgICAgICAgICAgICgwID09PSB1ID8gciAtIG8gPD0gZCA6IGkgLSBvIDw9IGcpICYmIChzLnB1c2goYyksIHMucHVzaChmIC0gMSksIHMucHVzaCh2KSksICgwID09PSB1ID8gciArIG8gPj0gZCA6IGkgKyBvID49IGcpICYmIChzLnB1c2goZiArIDEpLCBzLnB1c2goaCksIHMucHVzaCh2KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9KHRoaXMuaWRzLCB0aGlzLmNvb3JkcywgZSwgdCwgciwgdGhpcy5ub2RlU2l6ZSk7XG4gICAgfTtcblxuICAgIHZhciBOID0ge1xuICAgICAgbWluWm9vbTogMCxcbiAgICAgIG1heFpvb206IDE2LFxuICAgICAgbWluUG9pbnRzOiAyLFxuICAgICAgcmFkaXVzOiA0MCxcbiAgICAgIGV4dGVudDogNTEyLFxuICAgICAgbm9kZVNpemU6IDY0LFxuICAgICAgbG9nOiAhMSxcbiAgICAgIGdlbmVyYXRlSWQ6ICExLFxuICAgICAgcmVkdWNlOiBudWxsLFxuICAgICAgbWFwOiBmdW5jdGlvbiBtYXAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBKID0gZnVuY3Rpb24gSihlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBWKE9iamVjdC5jcmVhdGUoTiksIGUpLCB0aGlzLnRyZWVzID0gbmV3IEFycmF5KHRoaXMub3B0aW9ucy5tYXhab29tICsgMSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFooZSwgdCwgciwgaSwgbykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZSxcbiAgICAgICAgeTogdCxcbiAgICAgICAgem9vbTogMSAvIDAsXG4gICAgICAgIGlkOiByLFxuICAgICAgICBwYXJlbnRJZDogLTEsXG4gICAgICAgIG51bVBvaW50czogaSxcbiAgICAgICAgcHJvcGVydGllczogb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgICAgICBpID0gclsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IFkoclswXSksXG4gICAgICAgIHk6IGooaSksXG4gICAgICAgIHpvb206IDEgLyAwLFxuICAgICAgICBpbmRleDogdCxcbiAgICAgICAgcGFyZW50SWQ6IC0xXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEIoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgIGlkOiBlLmlkLFxuICAgICAgICBwcm9wZXJ0aWVzOiBHKGUpLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICBjb29yZGluYXRlczogWyhpID0gZS54LCAzNjAgKiAoaSAtIC41KSksICh0ID0gZS55LCByID0gKDE4MCAtIDM2MCAqIHQpICogTWF0aC5QSSAvIDE4MCwgMzYwICogTWF0aC5hdGFuKE1hdGguZXhwKHIpKSAvIE1hdGguUEkgLSA5MCldXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgdCwgciwgaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHKGUpIHtcbiAgICAgIHZhciB0ID0gZS5udW1Qb2ludHMsXG4gICAgICAgICAgciA9IHQgPj0gMWU0ID8gTWF0aC5yb3VuZCh0IC8gMWUzKSArIFwia1wiIDogdCA+PSAxZTMgPyBNYXRoLnJvdW5kKHQgLyAxMDApIC8gMTAgKyBcImtcIiA6IHQ7XG4gICAgICByZXR1cm4gVihWKHt9LCBlLnByb3BlcnRpZXMpLCB7XG4gICAgICAgIGNsdXN0ZXI6ICEwLFxuICAgICAgICBjbHVzdGVyX2lkOiBlLmlkLFxuICAgICAgICBwb2ludF9jb3VudDogdCxcbiAgICAgICAgcG9pbnRfY291bnRfYWJicmV2aWF0ZWQ6IHJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFkoZSkge1xuICAgICAgcmV0dXJuIGUgLyAzNjAgKyAuNTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqKGUpIHtcbiAgICAgIHZhciB0ID0gTWF0aC5zaW4oZSAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgIHIgPSAuNSAtIC4yNSAqIE1hdGgubG9nKCgxICsgdCkgLyAoMSAtIHQpKSAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gciA8IDAgPyAwIDogciA+IDEgPyAxIDogcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBWKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkge1xuICAgICAgICBlW3JdID0gdFtyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWChlKSB7XG4gICAgICByZXR1cm4gZS54O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFcoZSkge1xuICAgICAgcmV0dXJuIGUueTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIHZhciBzID0gbyAtIHIsXG4gICAgICAgICAgYSA9IG4gLSBpO1xuXG4gICAgICBpZiAoMCAhPT0gcyB8fCAwICE9PSBhKSB7XG4gICAgICAgIHZhciBsID0gKChlIC0gcikgKiBzICsgKHQgLSBpKSAqIGEpIC8gKHMgKiBzICsgYSAqIGEpO1xuICAgICAgICBsID4gMSA/IChyID0gbywgaSA9IG4pIDogbCA+IDAgJiYgKHIgKz0gcyAqIGwsIGkgKz0gYSAqIGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKHMgPSBlIC0gcikgKiBzICsgKGEgPSB0IC0gaSkgKiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHEoZSwgdCwgciwgaSkge1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgIGlkOiB2b2lkIDAgPT09IGUgPyBudWxsIDogZSxcbiAgICAgICAgdHlwZTogdCxcbiAgICAgICAgZ2VvbWV0cnk6IHIsXG4gICAgICAgIHRhZ3M6IGksXG4gICAgICAgIG1pblg6IDEgLyAwLFxuICAgICAgICBtaW5ZOiAxIC8gMCxcbiAgICAgICAgbWF4WDogLTEgLyAwLFxuICAgICAgICBtYXhZOiAtMSAvIDBcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHQgPSBlLmdlb21ldHJ5LFxuICAgICAgICAgICAgciA9IGUudHlwZTtcbiAgICAgICAgaWYgKFwiUG9pbnRcIiA9PT0gciB8fCBcIk11bHRpUG9pbnRcIiA9PT0gciB8fCBcIkxpbmVTdHJpbmdcIiA9PT0gcikgVShlLCB0KTtlbHNlIGlmIChcIlBvbHlnb25cIiA9PT0gciB8fCBcIk11bHRpTGluZVN0cmluZ1wiID09PSByKSBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBVKGUsIHRbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IHIpIGZvciAoaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCB0W2ldLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBVKGUsIHRbaV1bb10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfShvKSwgbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIgKz0gMykge1xuICAgICAgICBlLm1pblggPSBNYXRoLm1pbihlLm1pblgsIHRbcl0pLCBlLm1pblkgPSBNYXRoLm1pbihlLm1pblksIHRbciArIDFdKSwgZS5tYXhYID0gTWF0aC5tYXgoZS5tYXhYLCB0W3JdKSwgZS5tYXhZID0gTWF0aC5tYXgoZS5tYXhZLCB0W3IgKyAxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJChlLCB0LCByLCBpKSB7XG4gICAgICBpZiAodC5nZW9tZXRyeSkge1xuICAgICAgICB2YXIgbyA9IHQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBuID0gdC5nZW9tZXRyeS50eXBlLFxuICAgICAgICAgICAgcyA9IE1hdGgucG93KHIudG9sZXJhbmNlIC8gKCgxIDw8IHIubWF4Wm9vbSkgKiByLmV4dGVudCksIDIpLFxuICAgICAgICAgICAgYSA9IFtdLFxuICAgICAgICAgICAgbCA9IHQuaWQ7XG4gICAgICAgIGlmIChyLnByb21vdGVJZCA/IGwgPSB0LnByb3BlcnRpZXNbci5wcm9tb3RlSWRdIDogci5nZW5lcmF0ZUlkICYmIChsID0gaSB8fCAwKSwgXCJQb2ludFwiID09PSBuKSBIKG8sIGEpO2Vsc2UgaWYgKFwiTXVsdGlQb2ludFwiID09PSBuKSBmb3IgKHZhciB1ID0gMDsgdSA8IG8ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICBIKG9bdV0sIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiTGluZVN0cmluZ1wiID09PSBuKSBLKG8sIGEsIHMsICExKTtlbHNlIGlmIChcIk11bHRpTGluZVN0cmluZ1wiID09PSBuKSB7XG4gICAgICAgICAgaWYgKHIubGluZU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGZvciAodSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgIEsob1t1XSwgYSA9IFtdLCBzLCAhMSksIGUucHVzaChxKGwsIFwiTGluZVN0cmluZ1wiLCBhLCB0LnByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFEobywgYSwgcywgITEpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiUG9seWdvblwiID09PSBuKSBRKG8sIGEsIHMsICEwKTtlbHNlIHtcbiAgICAgICAgICBpZiAoXCJNdWx0aVBvbHlnb25cIiAhPT0gbikge1xuICAgICAgICAgICAgaWYgKFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPT09IG4pIHtcbiAgICAgICAgICAgICAgZm9yICh1ID0gMDsgdSA8IHQuZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICQoZSwge1xuICAgICAgICAgICAgICAgICAgaWQ6IGwsXG4gICAgICAgICAgICAgICAgICBnZW9tZXRyeTogdC5nZW9tZXRyeS5nZW9tZXRyaWVzW3VdLFxuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogdC5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgciwgaSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICB2YXIgaCA9IFtdO1xuICAgICAgICAgICAgUShvW3VdLCBoLCBzLCAhMCksIGEucHVzaChoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5wdXNoKHEobCwgbiwgYSwgdC5wcm9wZXJ0aWVzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSChlLCB0KSB7XG4gICAgICB0LnB1c2goZWUoZVswXSkpLCB0LnB1c2godGUoZVsxXSkpLCB0LnB1c2goMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSyhlLCB0LCByLCBpKSB7XG4gICAgICBmb3IgKHZhciBvLCBuLCBzID0gMCwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciBsID0gZWUoZVthXVswXSksXG4gICAgICAgICAgICB1ID0gdGUoZVthXVsxXSk7XG4gICAgICAgIHQucHVzaChsKSwgdC5wdXNoKHUpLCB0LnB1c2goMCksIGEgPiAwICYmIChzICs9IGkgPyAobyAqIHUgLSBsICogbikgLyAyIDogTWF0aC5zcXJ0KE1hdGgucG93KGwgLSBvLCAyKSArIE1hdGgucG93KHUgLSBuLCAyKSkpLCBvID0gbCwgbiA9IHU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gdC5sZW5ndGggLSAzO1xuICAgICAgdFsyXSA9IDEsIGZ1bmN0aW9uIGUodCwgciwgaSwgbykge1xuICAgICAgICBmb3IgKHZhciBuLCBzID0gbywgYSA9IGkgLSByID4+IDEsIGwgPSBpIC0gciwgdSA9IHRbcl0sIGggPSB0W3IgKyAxXSwgYyA9IHRbaV0sIHAgPSB0W2kgKyAxXSwgZiA9IHIgKyAzOyBmIDwgaTsgZiArPSAzKSB7XG4gICAgICAgICAgdmFyIGQgPSBSKHRbZl0sIHRbZiArIDFdLCB1LCBoLCBjLCBwKTtcbiAgICAgICAgICBpZiAoZCA+IHMpIG4gPSBmLCBzID0gZDtlbHNlIGlmIChkID09PSBzKSB7XG4gICAgICAgICAgICB2YXIgZyA9IE1hdGguYWJzKGYgLSBhKTtcbiAgICAgICAgICAgIGcgPCBsICYmIChuID0gZiwgbCA9IGcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHMgPiBvICYmIChuIC0gciA+IDMgJiYgZSh0LCByLCBuLCBvKSwgdFtuICsgMl0gPSBzLCBpIC0gbiA+IDMgJiYgZSh0LCBuLCBpLCBvKSk7XG4gICAgICB9KHQsIDAsIGgsIHIpLCB0W2ggKyAyXSA9IDEsIHQuc2l6ZSA9IE1hdGguYWJzKHMpLCB0LnN0YXJ0ID0gMCwgdC5lbmQgPSB0LnNpemU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUShlLCB0LCByLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgdmFyIG4gPSBbXTtcbiAgICAgICAgSyhlW29dLCBuLCByLCBpKSwgdC5wdXNoKG4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVlKGUpIHtcbiAgICAgIHJldHVybiBlIC8gMzYwICsgLjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGUoZSkge1xuICAgICAgdmFyIHQgPSBNYXRoLnNpbihlICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgciA9IC41IC0gLjI1ICogTWF0aC5sb2coKDEgKyB0KSAvICgxIC0gdCkpIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiByIDwgMCA/IDAgOiByID4gMSA/IDEgOiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlKGUsIHQsIHIsIGksIG8sIG4sIHMsIGEpIHtcbiAgICAgIGlmIChpIC89IHQsIG4gPj0gKHIgLz0gdCkgJiYgcyA8IGkpIHJldHVybiBlO1xuICAgICAgaWYgKHMgPCByIHx8IG4gPj0gaSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGZvciAodmFyIGwgPSBbXSwgdSA9IDA7IHUgPCBlLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIHZhciBoID0gZVt1XSxcbiAgICAgICAgICAgIGMgPSBoLmdlb21ldHJ5LFxuICAgICAgICAgICAgcCA9IGgudHlwZSxcbiAgICAgICAgICAgIGYgPSAwID09PSBvID8gaC5taW5YIDogaC5taW5ZLFxuICAgICAgICAgICAgZCA9IDAgPT09IG8gPyBoLm1heFggOiBoLm1heFk7XG4gICAgICAgIGlmIChmID49IHIgJiYgZCA8IGkpIGwucHVzaChoKTtlbHNlIGlmICghKGQgPCByIHx8IGYgPj0gaSkpIHtcbiAgICAgICAgICB2YXIgZyA9IFtdO1xuICAgICAgICAgIGlmIChcIlBvaW50XCIgPT09IHAgfHwgXCJNdWx0aVBvaW50XCIgPT09IHApIGllKGMsIGcsIHIsIGksIG8pO2Vsc2UgaWYgKFwiTGluZVN0cmluZ1wiID09PSBwKSBvZShjLCBnLCByLCBpLCBvLCAhMSwgYS5saW5lTWV0cmljcyk7ZWxzZSBpZiAoXCJNdWx0aUxpbmVTdHJpbmdcIiA9PT0gcCkgc2UoYywgZywgciwgaSwgbywgITEpO2Vsc2UgaWYgKFwiUG9seWdvblwiID09PSBwKSBzZShjLCBnLCByLCBpLCBvLCAhMCk7ZWxzZSBpZiAoXCJNdWx0aVBvbHlnb25cIiA9PT0gcCkgZm9yICh2YXIgdiA9IDA7IHYgPCBjLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgc2UoY1t2XSwgbSwgciwgaSwgbywgITApLCBtLmxlbmd0aCAmJiBnLnB1c2gobSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGcubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYS5saW5lTWV0cmljcyAmJiBcIkxpbmVTdHJpbmdcIiA9PT0gcCkge1xuICAgICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgZy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgICAgIGwucHVzaChxKGguaWQsIHAsIGdbdl0sIGgudGFncykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFwiTGluZVN0cmluZ1wiICE9PSBwICYmIFwiTXVsdGlMaW5lU3RyaW5nXCIgIT09IHAgfHwgKDEgPT09IGcubGVuZ3RoID8gKHAgPSBcIkxpbmVTdHJpbmdcIiwgZyA9IGdbMF0pIDogcCA9IFwiTXVsdGlMaW5lU3RyaW5nXCIpLCBcIlBvaW50XCIgIT09IHAgJiYgXCJNdWx0aVBvaW50XCIgIT09IHAgfHwgKHAgPSAzID09PSBnLmxlbmd0aCA/IFwiUG9pbnRcIiA6IFwiTXVsdGlQb2ludFwiKSwgbC5wdXNoKHEoaC5pZCwgcCwgZywgaC50YWdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsLmxlbmd0aCA/IGwgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGllKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4gKz0gMykge1xuICAgICAgICB2YXIgcyA9IGVbbiArIG9dO1xuICAgICAgICBzID49IHIgJiYgcyA8PSBpICYmICh0LnB1c2goZVtuXSksIHQucHVzaChlW24gKyAxXSksIHQucHVzaChlW24gKyAyXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9lKGUsIHQsIHIsIGksIG8sIG4sIHMpIHtcbiAgICAgIGZvciAodmFyIGEsIGwsIHUgPSBuZShlKSwgaCA9IDAgPT09IG8gPyBsZSA6IHVlLCBjID0gZS5zdGFydCwgcCA9IDA7IHAgPCBlLmxlbmd0aCAtIDM7IHAgKz0gMykge1xuICAgICAgICB2YXIgZiA9IGVbcF0sXG4gICAgICAgICAgICBkID0gZVtwICsgMV0sXG4gICAgICAgICAgICBnID0gZVtwICsgMl0sXG4gICAgICAgICAgICB2ID0gZVtwICsgM10sXG4gICAgICAgICAgICBtID0gZVtwICsgNF0sXG4gICAgICAgICAgICB5ID0gMCA9PT0gbyA/IGYgOiBkLFxuICAgICAgICAgICAgeCA9IDAgPT09IG8gPyB2IDogbSxcbiAgICAgICAgICAgIHcgPSAhMTtcbiAgICAgICAgcyAmJiAoYSA9IE1hdGguc3FydChNYXRoLnBvdyhmIC0gdiwgMikgKyBNYXRoLnBvdyhkIC0gbSwgMikpKSwgeSA8IHIgPyB4ID4gciAmJiAobCA9IGgodSwgZiwgZCwgdiwgbSwgciksIHMgJiYgKHUuc3RhcnQgPSBjICsgYSAqIGwpKSA6IHkgPiBpID8geCA8IGkgJiYgKGwgPSBoKHUsIGYsIGQsIHYsIG0sIGkpLCBzICYmICh1LnN0YXJ0ID0gYyArIGEgKiBsKSkgOiBhZSh1LCBmLCBkLCBnKSwgeCA8IHIgJiYgeSA+PSByICYmIChsID0gaCh1LCBmLCBkLCB2LCBtLCByKSwgdyA9ICEwKSwgeCA+IGkgJiYgeSA8PSBpICYmIChsID0gaCh1LCBmLCBkLCB2LCBtLCBpKSwgdyA9ICEwKSwgIW4gJiYgdyAmJiAocyAmJiAodS5lbmQgPSBjICsgYSAqIGwpLCB0LnB1c2godSksIHUgPSBuZShlKSksIHMgJiYgKGMgKz0gYSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBTID0gZS5sZW5ndGggLSAzO1xuICAgICAgZiA9IGVbU10sIGQgPSBlW1MgKyAxXSwgZyA9IGVbUyArIDJdLCAoeSA9IDAgPT09IG8gPyBmIDogZCkgPj0gciAmJiB5IDw9IGkgJiYgYWUodSwgZiwgZCwgZyksIFMgPSB1Lmxlbmd0aCAtIDMsIG4gJiYgUyA+PSAzICYmICh1W1NdICE9PSB1WzBdIHx8IHVbUyArIDFdICE9PSB1WzFdKSAmJiBhZSh1LCB1WzBdLCB1WzFdLCB1WzJdKSwgdS5sZW5ndGggJiYgdC5wdXNoKHUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5lKGUpIHtcbiAgICAgIHZhciB0ID0gW107XG4gICAgICByZXR1cm4gdC5zaXplID0gZS5zaXplLCB0LnN0YXJ0ID0gZS5zdGFydCwgdC5lbmQgPSBlLmVuZCwgdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZShlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGUubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgb2UoZVtzXSwgdCwgciwgaSwgbywgbiwgITEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFlKGUsIHQsIHIsIGkpIHtcbiAgICAgIGUucHVzaCh0KSwgZS5wdXNoKHIpLCBlLnB1c2goaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGUoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgdmFyIHMgPSAobiAtIHQpIC8gKGkgLSB0KTtcbiAgICAgIHJldHVybiBlLnB1c2gobiksIGUucHVzaChyICsgKG8gLSByKSAqIHMpLCBlLnB1c2goMSksIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWUoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgdmFyIHMgPSAobiAtIHIpIC8gKG8gLSByKTtcbiAgICAgIHJldHVybiBlLnB1c2godCArIChpIC0gdCkgKiBzKSwgZS5wdXNoKG4pLCBlLnB1c2goMSksIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGUoZSwgdCkge1xuICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG8sXG4gICAgICAgICAgICBuID0gZVtpXSxcbiAgICAgICAgICAgIHMgPSBuLnR5cGU7XG4gICAgICAgIGlmIChcIlBvaW50XCIgPT09IHMgfHwgXCJNdWx0aVBvaW50XCIgPT09IHMgfHwgXCJMaW5lU3RyaW5nXCIgPT09IHMpIG8gPSBjZShuLmdlb21ldHJ5LCB0KTtlbHNlIGlmIChcIk11bHRpTGluZVN0cmluZ1wiID09PSBzIHx8IFwiUG9seWdvblwiID09PSBzKSB7XG4gICAgICAgICAgbyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBuLmdlb21ldHJ5Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICBvLnB1c2goY2Uobi5nZW9tZXRyeVthXSwgdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcIk11bHRpUG9seWdvblwiID09PSBzKSBmb3IgKG8gPSBbXSwgYSA9IDA7IGEgPCBuLmdlb21ldHJ5Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IFtdLCB1ID0gMDsgdSA8IG4uZ2VvbWV0cnlbYV0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGwucHVzaChjZShuLmdlb21ldHJ5W2FdW3VdLCB0KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgby5wdXNoKGwpO1xuICAgICAgICB9XG4gICAgICAgIHIucHVzaChxKG4uaWQsIHMsIG8sIG4udGFncykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjZShlLCB0KSB7XG4gICAgICB2YXIgciA9IFtdO1xuICAgICAgci5zaXplID0gZS5zaXplLCB2b2lkIDAgIT09IGUuc3RhcnQgJiYgKHIuc3RhcnQgPSBlLnN0YXJ0LCByLmVuZCA9IGUuZW5kKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHIucHVzaChlW2ldICsgdCwgZVtpICsgMV0sIGVbaSArIDJdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGUoZSwgdCkge1xuICAgICAgaWYgKGUudHJhbnNmb3JtZWQpIHJldHVybiBlO1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBvLFxuICAgICAgICAgIG4gPSAxIDw8IGUueixcbiAgICAgICAgICBzID0gZS54LFxuICAgICAgICAgIGEgPSBlLnk7XG5cbiAgICAgIGZvciAociA9IDA7IHIgPCBlLmZlYXR1cmVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciBsID0gZS5mZWF0dXJlc1tyXSxcbiAgICAgICAgICAgIHUgPSBsLmdlb21ldHJ5LFxuICAgICAgICAgICAgaCA9IGwudHlwZTtcbiAgICAgICAgaWYgKGwuZ2VvbWV0cnkgPSBbXSwgMSA9PT0gaCkgZm9yIChpID0gMDsgaSA8IHUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBsLmdlb21ldHJ5LnB1c2goZmUodVtpXSwgdVtpICsgMV0sIHQsIG4sIHMsIGEpKTtcbiAgICAgICAgfSBlbHNlIGZvciAoaSA9IDA7IGkgPCB1Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGMgPSBbXTtcblxuICAgICAgICAgIGZvciAobyA9IDA7IG8gPCB1W2ldLmxlbmd0aDsgbyArPSAyKSB7XG4gICAgICAgICAgICBjLnB1c2goZmUodVtpXVtvXSwgdVtpXVtvICsgMV0sIHQsIG4sIHMsIGEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsLmdlb21ldHJ5LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUudHJhbnNmb3JtZWQgPSAhMCwgZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmZShlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICByZXR1cm4gW01hdGgucm91bmQociAqIChlICogaSAtIG8pKSwgTWF0aC5yb3VuZChyICogKHQgKiBpIC0gbikpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZShlLCB0LCByLCBpLCBvKSB7XG4gICAgICBmb3IgKHZhciBuID0gdCA9PT0gby5tYXhab29tID8gMCA6IG8udG9sZXJhbmNlIC8gKCgxIDw8IHQpICogby5leHRlbnQpLCBzID0ge1xuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIG51bVBvaW50czogMCxcbiAgICAgICAgbnVtU2ltcGxpZmllZDogMCxcbiAgICAgICAgbnVtRmVhdHVyZXM6IDAsXG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogaSxcbiAgICAgICAgejogdCxcbiAgICAgICAgdHJhbnNmb3JtZWQ6ICExLFxuICAgICAgICBtaW5YOiAyLFxuICAgICAgICBtaW5ZOiAxLFxuICAgICAgICBtYXhYOiAtMSxcbiAgICAgICAgbWF4WTogMFxuICAgICAgfSwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHMubnVtRmVhdHVyZXMrKywgZ2UocywgZVthXSwgbiwgbyk7XG4gICAgICAgIHZhciBsID0gZVthXS5taW5YLFxuICAgICAgICAgICAgdSA9IGVbYV0ubWluWSxcbiAgICAgICAgICAgIGggPSBlW2FdLm1heFgsXG4gICAgICAgICAgICBjID0gZVthXS5tYXhZO1xuICAgICAgICBsIDwgcy5taW5YICYmIChzLm1pblggPSBsKSwgdSA8IHMubWluWSAmJiAocy5taW5ZID0gdSksIGggPiBzLm1heFggJiYgKHMubWF4WCA9IGgpLCBjID4gcy5tYXhZICYmIChzLm1heFkgPSBjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2UoZSwgdCwgciwgaSkge1xuICAgICAgdmFyIG8gPSB0Lmdlb21ldHJ5LFxuICAgICAgICAgIG4gPSB0LnR5cGUsXG4gICAgICAgICAgcyA9IFtdO1xuICAgICAgaWYgKFwiUG9pbnRcIiA9PT0gbiB8fCBcIk11bHRpUG9pbnRcIiA9PT0gbikgZm9yICh2YXIgYSA9IDA7IGEgPCBvLmxlbmd0aDsgYSArPSAzKSB7XG4gICAgICAgIHMucHVzaChvW2FdKSwgcy5wdXNoKG9bYSArIDFdKSwgZS5udW1Qb2ludHMrKywgZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICB9IGVsc2UgaWYgKFwiTGluZVN0cmluZ1wiID09PSBuKSB2ZShzLCBvLCBlLCByLCAhMSwgITEpO2Vsc2UgaWYgKFwiTXVsdGlMaW5lU3RyaW5nXCIgPT09IG4gfHwgXCJQb2x5Z29uXCIgPT09IG4pIGZvciAoYSA9IDA7IGEgPCBvLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZlKHMsIG9bYV0sIGUsIHIsIFwiUG9seWdvblwiID09PSBuLCAwID09PSBhKTtcbiAgICAgIH0gZWxzZSBpZiAoXCJNdWx0aVBvbHlnb25cIiA9PT0gbikgZm9yICh2YXIgbCA9IDA7IGwgPCBvLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciB1ID0gb1tsXTtcblxuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgdS5sZW5ndGg7IGErKykge1xuICAgICAgICAgIHZlKHMsIHVbYV0sIGUsIHIsICEwLCAwID09PSBhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGggPSB0LnRhZ3MgfHwgbnVsbDtcblxuICAgICAgICBpZiAoXCJMaW5lU3RyaW5nXCIgPT09IG4gJiYgaS5saW5lTWV0cmljcykge1xuICAgICAgICAgIGZvciAodmFyIGMgaW4gaCA9IHt9LCB0LnRhZ3MpIHtcbiAgICAgICAgICAgIGhbY10gPSB0LnRhZ3NbY107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaC5tYXBib3hfY2xpcF9zdGFydCA9IG8uc3RhcnQgLyBvLnNpemUsIGgubWFwYm94X2NsaXBfZW5kID0gby5lbmQgLyBvLnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICBnZW9tZXRyeTogcyxcbiAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIiA9PT0gbiB8fCBcIk11bHRpUG9seWdvblwiID09PSBuID8gMyA6IFwiTGluZVN0cmluZ1wiID09PSBuIHx8IFwiTXVsdGlMaW5lU3RyaW5nXCIgPT09IG4gPyAyIDogMSxcbiAgICAgICAgICB0YWdzOiBoXG4gICAgICAgIH07XG4gICAgICAgIG51bGwgIT09IHQuaWQgJiYgKHAuaWQgPSB0LmlkKSwgZS5mZWF0dXJlcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIHZhciBzID0gaSAqIGk7XG4gICAgICBpZiAoaSA+IDAgJiYgdC5zaXplIDwgKG8gPyBzIDogaSkpIHIubnVtUG9pbnRzICs9IHQubGVuZ3RoIC8gMztlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBsID0gMDsgbCA8IHQubGVuZ3RoOyBsICs9IDMpIHtcbiAgICAgICAgICAoMCA9PT0gaSB8fCB0W2wgKyAyXSA+IHMpICYmIChyLm51bVNpbXBsaWZpZWQrKywgYS5wdXNoKHRbbF0pLCBhLnB1c2godFtsICsgMV0pKSwgci5udW1Qb2ludHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIG8gJiYgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gMCwgaSA9IDAsIG8gPSBlLmxlbmd0aCwgbiA9IG8gLSAyOyBpIDwgbzsgbiA9IGksIGkgKz0gMikge1xuICAgICAgICAgICAgciArPSAoZVtpXSAtIGVbbl0pICogKGVbaSArIDFdICsgZVtuICsgMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyID4gMCA9PT0gdCkgZm9yIChpID0gMCwgbyA9IGUubGVuZ3RoOyBpIDwgbyAvIDI7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIHMgPSBlW2ldLFxuICAgICAgICAgICAgICAgIGEgPSBlW2kgKyAxXTtcbiAgICAgICAgICAgIGVbaV0gPSBlW28gLSAyIC0gaV0sIGVbaSArIDFdID0gZVtvIC0gMSAtIGldLCBlW28gLSAyIC0gaV0gPSBzLCBlW28gLSAxIC0gaV0gPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgfShhLCBuKSwgZS5wdXNoKGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lKGUsIHQpIHtcbiAgICAgIHZhciByID0gKHQgPSB0aGlzLm9wdGlvbnMgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBmb3IgKHZhciByIGluIHQpIHtcbiAgICAgICAgICBlW3JdID0gdFtyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyksIHQpKS5kZWJ1ZztcblxuICAgICAgaWYgKHIgJiYgY29uc29sZS50aW1lKFwicHJlcHJvY2VzcyBkYXRhXCIpLCB0Lm1heFpvb20gPCAwIHx8IHQubWF4Wm9vbSA+IDI0KSB0aHJvdyBuZXcgRXJyb3IoXCJtYXhab29tIHNob3VsZCBiZSBpbiB0aGUgMC0yNCByYW5nZVwiKTtcbiAgICAgIGlmICh0LnByb21vdGVJZCAmJiB0LmdlbmVyYXRlSWQpIHRocm93IG5ldyBFcnJvcihcInByb21vdGVJZCBhbmQgZ2VuZXJhdGVJZCBjYW5ub3QgYmUgdXNlZCB0b2dldGhlci5cIik7XG5cbiAgICAgIHZhciBpID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgaWYgKFwiRmVhdHVyZUNvbGxlY3Rpb25cIiA9PT0gZS50eXBlKSBmb3IgKHZhciBpID0gMDsgaSA8IGUuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAkKHIsIGUuZmVhdHVyZXNbaV0sIHQsIGkpO1xuICAgICAgICB9IGVsc2UgJChyLCBcIkZlYXR1cmVcIiA9PT0gZS50eXBlID8gZSA6IHtcbiAgICAgICAgICBnZW9tZXRyeTogZVxuICAgICAgICB9LCB0KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9KGUsIHQpO1xuXG4gICAgICB0aGlzLnRpbGVzID0ge30sIHRoaXMudGlsZUNvb3JkcyA9IFtdLCByICYmIChjb25zb2xlLnRpbWVFbmQoXCJwcmVwcm9jZXNzIGRhdGFcIiksIGNvbnNvbGUubG9nKFwiaW5kZXg6IG1heFpvb206ICVkLCBtYXhQb2ludHM6ICVkXCIsIHQuaW5kZXhNYXhab29tLCB0LmluZGV4TWF4UG9pbnRzKSwgY29uc29sZS50aW1lKFwiZ2VuZXJhdGUgdGlsZXNcIiksIHRoaXMuc3RhdHMgPSB7fSwgdGhpcy50b3RhbCA9IDApLCAoaSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciByID0gdC5idWZmZXIgLyB0LmV4dGVudCxcbiAgICAgICAgICAgIGkgPSBlLFxuICAgICAgICAgICAgbyA9IHJlKGUsIDEsIC0xIC0gciwgciwgMCwgLTEsIDIsIHQpLFxuICAgICAgICAgICAgbiA9IHJlKGUsIDEsIDEgLSByLCAyICsgciwgMCwgLTEsIDIsIHQpO1xuICAgICAgICByZXR1cm4gKG8gfHwgbikgJiYgKGkgPSByZShlLCAxLCAtciwgMSArIHIsIDAsIC0xLCAyLCB0KSB8fCBbXSwgbyAmJiAoaSA9IGhlKG8sIDEpLmNvbmNhdChpKSksIG4gJiYgKGkgPSBpLmNvbmNhdChoZShuLCAtMSkpKSksIGk7XG4gICAgICB9KGksIHQpKS5sZW5ndGggJiYgdGhpcy5zcGxpdFRpbGUoaSwgMCwgMCwgMCksIHIgJiYgKGkubGVuZ3RoICYmIGNvbnNvbGUubG9nKFwiZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkXCIsIHRoaXMudGlsZXNbMF0ubnVtRmVhdHVyZXMsIHRoaXMudGlsZXNbMF0ubnVtUG9pbnRzKSwgY29uc29sZS50aW1lRW5kKFwiZ2VuZXJhdGUgdGlsZXNcIiksIGNvbnNvbGUubG9nKFwidGlsZXMgZ2VuZXJhdGVkOlwiLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHllKGUsIHQsIHIpIHtcbiAgICAgIHJldHVybiAzMiAqICgoMSA8PCBlKSAqIHIgKyB0KSArIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geGUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBlLnRpbGVJRC5jYW5vbmljYWw7XG4gICAgICBpZiAoIXRoaXMuX2dlb0pTT05JbmRleCkgcmV0dXJuIHQobnVsbCwgbnVsbCk7XG5cbiAgICAgIHZhciBpID0gdGhpcy5fZ2VvSlNPTkluZGV4LmdldFRpbGUoci56LCByLngsIHIueSk7XG5cbiAgICAgIGlmICghaSkgcmV0dXJuIHQobnVsbCwgbnVsbCk7XG4gICAgICB2YXIgbyA9IG5ldyBnKGkuZmVhdHVyZXMpLFxuICAgICAgICAgIG4gPSB3KG8pO1xuICAgICAgMCA9PT0gbi5ieXRlT2Zmc2V0ICYmIG4uYnl0ZUxlbmd0aCA9PT0gbi5idWZmZXIuYnl0ZUxlbmd0aCB8fCAobiA9IG5ldyBVaW50OEFycmF5KG4pKSwgdChudWxsLCB7XG4gICAgICAgIHZlY3RvclRpbGU6IG8sXG4gICAgICAgIHJhd0RhdGE6IG4uYnVmZmVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBKLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHIgPSB0LmxvZyxcbiAgICAgICAgICBpID0gdC5taW5ab29tLFxuICAgICAgICAgIG8gPSB0Lm1heFpvb20sXG4gICAgICAgICAgbiA9IHQubm9kZVNpemU7XG4gICAgICByICYmIGNvbnNvbGUudGltZShcInRvdGFsIHRpbWVcIik7XG4gICAgICB2YXIgcyA9IFwicHJlcGFyZSBcIiArIGUubGVuZ3RoICsgXCIgcG9pbnRzXCI7XG4gICAgICByICYmIGNvbnNvbGUudGltZShzKSwgdGhpcy5wb2ludHMgPSBlO1xuXG4gICAgICBmb3IgKHZhciBhID0gW10sIGwgPSAwOyBsIDwgZS5sZW5ndGg7IGwrKykge1xuICAgICAgICBlW2xdLmdlb21ldHJ5ICYmIGEucHVzaChBKGVbbF0sIGwpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmVlc1tvICsgMV0gPSBuZXcgRihhLCBYLCBXLCBuLCBGbG9hdDMyQXJyYXkpLCByICYmIGNvbnNvbGUudGltZUVuZChzKTtcblxuICAgICAgZm9yICh2YXIgdSA9IG87IHUgPj0gaTsgdS0tKSB7XG4gICAgICAgIHZhciBoID0gK0RhdGUubm93KCk7XG4gICAgICAgIGEgPSB0aGlzLl9jbHVzdGVyKGEsIHUpLCB0aGlzLnRyZWVzW3VdID0gbmV3IEYoYSwgWCwgVywgbiwgRmxvYXQzMkFycmF5KSwgciAmJiBjb25zb2xlLmxvZyhcInolZDogJWQgY2x1c3RlcnMgaW4gJWRtc1wiLCB1LCBhLmxlbmd0aCwgK0RhdGUubm93KCkgLSBoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHIgJiYgY29uc29sZS50aW1lRW5kKFwidG90YWwgdGltZVwiKSwgdGhpcztcbiAgICB9LCBKLnByb3RvdHlwZS5nZXRDbHVzdGVycyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB2YXIgciA9ICgoZVswXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwLFxuICAgICAgICAgIGkgPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBlWzFdKSksXG4gICAgICAgICAgbyA9IDE4MCA9PT0gZVsyXSA/IDE4MCA6ICgoZVsyXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwLFxuICAgICAgICAgIG4gPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBlWzNdKSk7XG4gICAgICBpZiAoZVsyXSAtIGVbMF0gPj0gMzYwKSByID0gLTE4MCwgbyA9IDE4MDtlbHNlIGlmIChyID4gbykge1xuICAgICAgICB2YXIgcyA9IHRoaXMuZ2V0Q2x1c3RlcnMoW3IsIGksIDE4MCwgbl0sIHQpLFxuICAgICAgICAgICAgYSA9IHRoaXMuZ2V0Q2x1c3RlcnMoWy0xODAsIGksIG8sIG5dLCB0KTtcbiAgICAgICAgcmV0dXJuIHMuY29uY2F0KGEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20odCldLCB1ID0gW10sIGggPSAwLCBjID0gbC5yYW5nZShZKHIpLCBqKG4pLCBZKG8pLCBqKGkpKTsgaCA8IGMubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgdmFyIHAgPSBsLnBvaW50c1tjW2hdXTtcbiAgICAgICAgdS5wdXNoKHAubnVtUG9pbnRzID8gQihwKSA6IHRoaXMucG9pbnRzW3AuaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9nZXRPcmlnaW5JZChlKSxcbiAgICAgICAgICByID0gdGhpcy5fZ2V0T3JpZ2luWm9vbShlKSxcbiAgICAgICAgICBpID0gXCJObyBjbHVzdGVyIHdpdGggdGhlIHNwZWNpZmllZCBpZC5cIixcbiAgICAgICAgICBvID0gdGhpcy50cmVlc1tyXTtcblxuICAgICAgaWYgKCFvKSB0aHJvdyBuZXcgRXJyb3IoaSk7XG4gICAgICB2YXIgbiA9IG8ucG9pbnRzW3RdO1xuICAgICAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoaSk7XG5cbiAgICAgIGZvciAodmFyIHMgPSB0aGlzLm9wdGlvbnMucmFkaXVzIC8gKHRoaXMub3B0aW9ucy5leHRlbnQgKiBNYXRoLnBvdygyLCByIC0gMSkpLCBhID0gW10sIGwgPSAwLCB1ID0gby53aXRoaW4obi54LCBuLnksIHMpOyBsIDwgdS5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgICB2YXIgaCA9IG8ucG9pbnRzW3VbbF1dO1xuICAgICAgICBoLnBhcmVudElkID09PSBlICYmIGEucHVzaChoLm51bVBvaW50cyA/IEIoaCkgOiB0aGlzLnBvaW50c1toLmluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgwID09PSBhLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGkpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0TGVhdmVzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gW107XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kTGVhdmVzKGksIGUsIHQgPSB0IHx8IDEwLCByID0gciB8fCAwLCAwKSwgaTtcbiAgICB9LCBKLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oZSldLFxuICAgICAgICAgIG8gPSBNYXRoLnBvdygyLCBlKSxcbiAgICAgICAgICBuID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHMgPSBuLnJhZGl1cyAvIG4uZXh0ZW50LFxuICAgICAgICAgIGEgPSAociAtIHMpIC8gbyxcbiAgICAgICAgICBsID0gKHIgKyAxICsgcykgLyBvLFxuICAgICAgICAgIHUgPSB7XG4gICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhpLnJhbmdlKCh0IC0gcykgLyBvLCBhLCAodCArIDEgKyBzKSAvIG8sIGwpLCBpLnBvaW50cywgdCwgciwgbywgdSksIDAgPT09IHQgJiYgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKGkucmFuZ2UoMSAtIHMgLyBvLCBhLCAxLCBsKSwgaS5wb2ludHMsIG8sIHIsIG8sIHUpLCB0ID09PSBvIC0gMSAmJiB0aGlzLl9hZGRUaWxlRmVhdHVyZXMoaS5yYW5nZSgwLCBhLCBzIC8gbywgbCksIGkucG9pbnRzLCAtMSwgciwgbywgdSksIHUuZmVhdHVyZXMubGVuZ3RoID8gdSA6IG51bGw7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0Q2x1c3RlckV4cGFuc2lvblpvb20gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZm9yICh2YXIgdCA9IHRoaXMuX2dldE9yaWdpblpvb20oZSkgLSAxOyB0IDw9IHRoaXMub3B0aW9ucy5tYXhab29tOykge1xuICAgICAgICB2YXIgciA9IHRoaXMuZ2V0Q2hpbGRyZW4oZSk7XG4gICAgICAgIGlmICh0KyssIDEgIT09IHIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgZSA9IHJbMF0ucHJvcGVydGllcy5jbHVzdGVyX2lkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBKLnByb3RvdHlwZS5fYXBwZW5kTGVhdmVzID0gZnVuY3Rpb24gKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBzID0gdGhpcy5nZXRDaGlsZHJlbih0KTsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBzW25dLFxuICAgICAgICAgICAgbCA9IGEucHJvcGVydGllcztcbiAgICAgICAgaWYgKGwgJiYgbC5jbHVzdGVyID8gbyArIGwucG9pbnRfY291bnQgPD0gaSA/IG8gKz0gbC5wb2ludF9jb3VudCA6IG8gPSB0aGlzLl9hcHBlbmRMZWF2ZXMoZSwgbC5jbHVzdGVyX2lkLCByLCBpLCBvKSA6IG8gPCBpID8gbysrIDogZS5wdXNoKGEpLCBlLmxlbmd0aCA9PT0gcikgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvO1xuICAgIH0sIEoucHJvdG90eXBlLl9hZGRUaWxlRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgZm9yICh2YXIgcyA9IDAsIGEgPSBlOyBzIDwgYS5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICB2YXIgbCA9IHRbYVtzXV0sXG4gICAgICAgICAgICB1ID0gbC5udW1Qb2ludHMsXG4gICAgICAgICAgICBoID0ge1xuICAgICAgICAgIHR5cGU6IDEsXG4gICAgICAgICAgZ2VvbWV0cnk6IFtbTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuZXh0ZW50ICogKGwueCAqIG8gLSByKSksIE1hdGgucm91bmQodGhpcy5vcHRpb25zLmV4dGVudCAqIChsLnkgKiBvIC0gaSkpXV0sXG4gICAgICAgICAgdGFnczogdSA/IEcobCkgOiB0aGlzLnBvaW50c1tsLmluZGV4XS5wcm9wZXJ0aWVzXG4gICAgICAgIH0sXG4gICAgICAgICAgICBjID0gdm9pZCAwO1xuICAgICAgICB1ID8gYyA9IGwuaWQgOiB0aGlzLm9wdGlvbnMuZ2VuZXJhdGVJZCA/IGMgPSBsLmluZGV4IDogdGhpcy5wb2ludHNbbC5pbmRleF0uaWQgJiYgKGMgPSB0aGlzLnBvaW50c1tsLmluZGV4XS5pZCksIHZvaWQgMCAhPT0gYyAmJiAoaC5pZCA9IGMpLCBuLmZlYXR1cmVzLnB1c2goaCk7XG4gICAgICB9XG4gICAgfSwgSi5wcm90b3R5cGUuX2xpbWl0Wm9vbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLm1pblpvb20sIE1hdGgubWluKCtlLCB0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpKTtcbiAgICB9LCBKLnByb3RvdHlwZS5fY2x1c3RlciA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICBmb3IgKHZhciByID0gW10sIGkgPSB0aGlzLm9wdGlvbnMsIG8gPSBpLnJlZHVjZSwgbiA9IGkubWluUG9pbnRzLCBzID0gaS5yYWRpdXMgLyAoaS5leHRlbnQgKiBNYXRoLnBvdygyLCB0KSksIGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbCA9IGVbYV07XG5cbiAgICAgICAgaWYgKCEobC56b29tIDw9IHQpKSB7XG4gICAgICAgICAgbC56b29tID0gdDtcblxuICAgICAgICAgIGZvciAodmFyIHUgPSB0aGlzLnRyZWVzW3QgKyAxXSwgaCA9IHUud2l0aGluKGwueCwgbC55LCBzKSwgYyA9IGwubnVtUG9pbnRzIHx8IDEsIHAgPSBjLCBmID0gMCwgZCA9IGg7IGYgPCBkLmxlbmd0aDsgZiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZyA9IHUucG9pbnRzW2RbZl1dO1xuICAgICAgICAgICAgZy56b29tID4gdCAmJiAocCArPSBnLm51bVBvaW50cyB8fCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA+PSBuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gbC54ICogYywgbSA9IGwueSAqIGMsIHkgPSBvICYmIGMgPiAxID8gdGhpcy5fbWFwKGwsICEwKSA6IG51bGwsIHggPSAoYSA8PCA1KSArICh0ICsgMSkgKyB0aGlzLnBvaW50cy5sZW5ndGgsIHcgPSAwLCBTID0gaDsgdyA8IFMubGVuZ3RoOyB3ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSB1LnBvaW50c1tTW3ddXTtcblxuICAgICAgICAgICAgICBpZiAoIShJLnpvb20gPD0gdCkpIHtcbiAgICAgICAgICAgICAgICBJLnpvb20gPSB0O1xuICAgICAgICAgICAgICAgIHZhciBNID0gSS5udW1Qb2ludHMgfHwgMTtcbiAgICAgICAgICAgICAgICB2ICs9IEkueCAqIE0sIG0gKz0gSS55ICogTSwgSS5wYXJlbnRJZCA9IHgsIG8gJiYgKHkgfHwgKHkgPSB0aGlzLl9tYXAobCwgITApKSwgbyh5LCB0aGlzLl9tYXAoSSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsLnBhcmVudElkID0geCwgci5wdXNoKFoodiAvIHAsIG0gLyBwLCB4LCBwLCB5KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyLnB1c2gobCksIHAgPiAxKSBmb3IgKHZhciBiID0gMCwgXyA9IGg7IGIgPCBfLmxlbmd0aDsgYiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgayA9IHUucG9pbnRzW19bYl1dO1xuICAgICAgICAgICAgay56b29tIDw9IHQgfHwgKGsuem9vbSA9IHQsIHIucHVzaChrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIEoucHJvdG90eXBlLl9nZXRPcmlnaW5JZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZSAtIHRoaXMucG9pbnRzLmxlbmd0aCA+PiA1O1xuICAgIH0sIEoucHJvdG90eXBlLl9nZXRPcmlnaW5ab29tID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAoZSAtIHRoaXMucG9pbnRzLmxlbmd0aCkgJSAzMjtcbiAgICB9LCBKLnByb3RvdHlwZS5fbWFwID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIGlmIChlLm51bVBvaW50cykgcmV0dXJuIHQgPyBWKHt9LCBlLnByb3BlcnRpZXMpIDogZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIHIgPSB0aGlzLnBvaW50c1tlLmluZGV4XS5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGkgPSB0aGlzLm9wdGlvbnMubWFwKHIpO1xuICAgICAgcmV0dXJuIHQgJiYgaSA9PT0gciA/IFYoe30sIGkpIDogaTtcbiAgICB9LCBtZS5wcm90b3R5cGUub3B0aW9ucyA9IHtcbiAgICAgIG1heFpvb206IDE0LFxuICAgICAgaW5kZXhNYXhab29tOiA1LFxuICAgICAgaW5kZXhNYXhQb2ludHM6IDFlNSxcbiAgICAgIHRvbGVyYW5jZTogMyxcbiAgICAgIGV4dGVudDogNDA5NixcbiAgICAgIGJ1ZmZlcjogNjQsXG4gICAgICBsaW5lTWV0cmljczogITEsXG4gICAgICBwcm9tb3RlSWQ6IG51bGwsXG4gICAgICBnZW5lcmF0ZUlkOiAhMSxcbiAgICAgIGRlYnVnOiAwXG4gICAgfSwgbWUucHJvdG90eXBlLnNwbGl0VGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByLCBpLCBvLCBuLCBzKSB7XG4gICAgICBmb3IgKHZhciBhID0gW2UsIHQsIHIsIGldLCBsID0gdGhpcy5vcHRpb25zLCB1ID0gbC5kZWJ1ZzsgYS5sZW5ndGg7KSB7XG4gICAgICAgIGkgPSBhLnBvcCgpLCByID0gYS5wb3AoKSwgdCA9IGEucG9wKCksIGUgPSBhLnBvcCgpO1xuICAgICAgICB2YXIgaCA9IDEgPDwgdCxcbiAgICAgICAgICAgIGMgPSB5ZSh0LCByLCBpKSxcbiAgICAgICAgICAgIHAgPSB0aGlzLnRpbGVzW2NdO1xuXG4gICAgICAgIGlmICghcCAmJiAodSA+IDEgJiYgY29uc29sZS50aW1lKFwiY3JlYXRpb25cIiksIHAgPSB0aGlzLnRpbGVzW2NdID0gZGUoZSwgdCwgciwgaSwgbCksIHRoaXMudGlsZUNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICB6OiB0LFxuICAgICAgICAgIHg6IHIsXG4gICAgICAgICAgeTogaVxuICAgICAgICB9KSwgdSkpIHtcbiAgICAgICAgICB1ID4gMSAmJiAoY29uc29sZS5sb2coXCJ0aWxlIHolZC0lZC0lZCAoZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkLCBzaW1wbGlmaWVkOiAlZClcIiwgdCwgciwgaSwgcC5udW1GZWF0dXJlcywgcC5udW1Qb2ludHMsIHAubnVtU2ltcGxpZmllZCksIGNvbnNvbGUudGltZUVuZChcImNyZWF0aW9uXCIpKTtcbiAgICAgICAgICB2YXIgZiA9IFwielwiICsgdDtcbiAgICAgICAgICB0aGlzLnN0YXRzW2ZdID0gKHRoaXMuc3RhdHNbZl0gfHwgMCkgKyAxLCB0aGlzLnRvdGFsKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC5zb3VyY2UgPSBlLCBvKSB7XG4gICAgICAgICAgaWYgKHQgPT09IGwubWF4Wm9vbSB8fCB0ID09PSBvKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgZCA9IDEgPDwgbyAtIHQ7XG4gICAgICAgICAgaWYgKHIgIT09IE1hdGguZmxvb3IobiAvIGQpIHx8IGkgIT09IE1hdGguZmxvb3IocyAvIGQpKSBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSBsLmluZGV4TWF4Wm9vbSB8fCBwLm51bVBvaW50cyA8PSBsLmluZGV4TWF4UG9pbnRzKSBjb250aW51ZTtcblxuICAgICAgICBpZiAocC5zb3VyY2UgPSBudWxsLCAwICE9PSBlLmxlbmd0aCkge1xuICAgICAgICAgIHUgPiAxICYmIGNvbnNvbGUudGltZShcImNsaXBwaW5nXCIpO1xuICAgICAgICAgIHZhciBnLFxuICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB3LFxuICAgICAgICAgICAgICBTID0gLjUgKiBsLmJ1ZmZlciAvIGwuZXh0ZW50LFxuICAgICAgICAgICAgICBJID0gLjUgLSBTLFxuICAgICAgICAgICAgICBNID0gLjUgKyBTLFxuICAgICAgICAgICAgICBiID0gMSArIFM7XG4gICAgICAgICAgZyA9IHYgPSBtID0geSA9IG51bGwsIHggPSByZShlLCBoLCByIC0gUywgciArIE0sIDAsIHAubWluWCwgcC5tYXhYLCBsKSwgdyA9IHJlKGUsIGgsIHIgKyBJLCByICsgYiwgMCwgcC5taW5YLCBwLm1heFgsIGwpLCBlID0gbnVsbCwgeCAmJiAoZyA9IHJlKHgsIGgsIGkgLSBTLCBpICsgTSwgMSwgcC5taW5ZLCBwLm1heFksIGwpLCB2ID0gcmUoeCwgaCwgaSArIEksIGkgKyBiLCAxLCBwLm1pblksIHAubWF4WSwgbCksIHggPSBudWxsKSwgdyAmJiAobSA9IHJlKHcsIGgsIGkgLSBTLCBpICsgTSwgMSwgcC5taW5ZLCBwLm1heFksIGwpLCB5ID0gcmUodywgaCwgaSArIEksIGkgKyBiLCAxLCBwLm1pblksIHAubWF4WSwgbCksIHcgPSBudWxsKSwgdSA+IDEgJiYgY29uc29sZS50aW1lRW5kKFwiY2xpcHBpbmdcIiksIGEucHVzaChnIHx8IFtdLCB0ICsgMSwgMiAqIHIsIDIgKiBpKSwgYS5wdXNoKHYgfHwgW10sIHQgKyAxLCAyICogciwgMiAqIGkgKyAxKSwgYS5wdXNoKG0gfHwgW10sIHQgKyAxLCAyICogciArIDEsIDIgKiBpKSwgYS5wdXNoKHkgfHwgW10sIHQgKyAxLCAyICogciArIDEsIDIgKiBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBtZS5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB2YXIgaSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBvID0gaS5leHRlbnQsXG4gICAgICAgICAgbiA9IGkuZGVidWc7XG4gICAgICBpZiAoZSA8IDAgfHwgZSA+IDI0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzID0gMSA8PCBlLFxuICAgICAgICAgIGEgPSB5ZShlLCB0ID0gKHQgJSBzICsgcykgJSBzLCByKTtcbiAgICAgIGlmICh0aGlzLnRpbGVzW2FdKSByZXR1cm4gcGUodGhpcy50aWxlc1thXSwgbyk7XG4gICAgICBuID4gMSAmJiBjb25zb2xlLmxvZyhcImRyaWxsaW5nIGRvd24gdG8geiVkLSVkLSVkXCIsIGUsIHQsIHIpO1xuXG4gICAgICBmb3IgKHZhciBsLCB1ID0gZSwgaCA9IHQsIGMgPSByOyAhbCAmJiB1ID4gMDspIHtcbiAgICAgICAgdS0tLCBoID0gTWF0aC5mbG9vcihoIC8gMiksIGMgPSBNYXRoLmZsb29yKGMgLyAyKSwgbCA9IHRoaXMudGlsZXNbeWUodSwgaCwgYyldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbCAmJiBsLnNvdXJjZSA/IChuID4gMSAmJiBjb25zb2xlLmxvZyhcImZvdW5kIHBhcmVudCB0aWxlIHolZC0lZC0lZFwiLCB1LCBoLCBjKSwgbiA+IDEgJiYgY29uc29sZS50aW1lKFwiZHJpbGxpbmcgZG93blwiKSwgdGhpcy5zcGxpdFRpbGUobC5zb3VyY2UsIHUsIGgsIGMsIGUsIHQsIHIpLCBuID4gMSAmJiBjb25zb2xlLnRpbWVFbmQoXCJkcmlsbGluZyBkb3duXCIpLCB0aGlzLnRpbGVzW2FdID8gcGUodGhpcy50aWxlc1thXSwgbykgOiBudWxsKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB3ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiByKGUsIHIsIGksIG8pIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIsIGksIHhlKSwgbyAmJiAodGhpcy5sb2FkR2VvSlNPTiA9IG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoci5fX3Byb3RvX18gPSB0KSwgKHIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSByLCByLnByb3RvdHlwZS5sb2FkRGF0YSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFjayAmJiB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIGFiYW5kb25lZDogITBcbiAgICAgICAgfSksIHRoaXMuX3BlbmRpbmdDYWxsYmFjayA9IHQsIHRoaXMuX3BlbmRpbmdMb2FkRGF0YVBhcmFtcyA9IGUsIHRoaXMuX3N0YXRlICYmIFwiSWRsZVwiICE9PSB0aGlzLl9zdGF0ZSA/IHRoaXMuX3N0YXRlID0gXCJOZWVkc0xvYWREYXRhXCIgOiAodGhpcy5fc3RhdGUgPSBcIkNvYWxlc2NpbmdcIiwgdGhpcy5fbG9hZERhdGEoKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fbG9hZERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NhbGxiYWNrICYmIHRoaXMuX3BlbmRpbmdMb2FkRGF0YVBhcmFtcykge1xuICAgICAgICAgIHZhciByID0gdGhpcy5fcGVuZGluZ0NhbGxiYWNrLFxuICAgICAgICAgICAgICBpID0gdGhpcy5fcGVuZGluZ0xvYWREYXRhUGFyYW1zO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nQ2FsbGJhY2ssIGRlbGV0ZSB0aGlzLl9wZW5kaW5nTG9hZERhdGFQYXJhbXM7XG4gICAgICAgICAgdmFyIG8gPSAhIShpICYmIGkucmVxdWVzdCAmJiBpLnJlcXVlc3QuY29sbGVjdFJlc291cmNlVGltaW5nKSAmJiBuZXcgZS5SZXF1ZXN0UGVyZm9ybWFuY2UoaS5yZXF1ZXN0KTtcbiAgICAgICAgICB0aGlzLmxvYWRHZW9KU09OKGksIGZ1bmN0aW9uIChuLCBzKSB7XG4gICAgICAgICAgICBpZiAobiB8fCAhcykgcmV0dXJuIHIobik7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgcykgcmV0dXJuIHIobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBnaXZlbiB0byAnXCIgKyBpLnNvdXJjZSArIFwiJyBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgIWZ1bmN0aW9uIGUodCwgcikge1xuICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgIG8gPSB0ICYmIHQudHlwZTtcbiAgICAgICAgICAgICAgaWYgKFwiRmVhdHVyZUNvbGxlY3Rpb25cIiA9PT0gbykgZm9yIChpID0gMDsgaSA8IHQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlKHQuZmVhdHVyZXNbaV0sIHIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPT09IG8pIGZvciAoaSA9IDA7IGkgPCB0Lmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlKHQuZ2VvbWV0cmllc1tpXSwgcik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJGZWF0dXJlXCIgPT09IG8pIGUodC5nZW9tZXRyeSwgcik7ZWxzZSBpZiAoXCJQb2x5Z29uXCIgPT09IG8pIGModC5jb29yZGluYXRlcywgcik7ZWxzZSBpZiAoXCJNdWx0aVBvbHlnb25cIiA9PT0gbykgZm9yIChpID0gMDsgaSA8IHQuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjKHQuY29vcmRpbmF0ZXNbaV0sIHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfShzLCAhMCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChpLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHZhciBhID0gZS5jcmVhdGVFeHByZXNzaW9uKGkuZmlsdGVyLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG4gICAgICAgICAgICAgICAgICBvdmVycmlkYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAhMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgPT09IGEucmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYS52YWx1ZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLmtleSArIFwiOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgICAgIHZhciBsID0gcy5mZWF0dXJlcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhLnZhbHVlLmV2YWx1YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgem9vbTogMFxuICAgICAgICAgICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcyA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHQuX2dlb0pTT05JbmRleCA9IGkuY2x1c3RlciA/IG5ldyBKKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0LnN1cGVyY2x1c3Rlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0LmNsdXN0ZXJQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIGlmICghaSB8fCAhcikgcmV0dXJuIHI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0ge30sIG4gPSB7fSwgcyA9IHtcbiAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgem9vbTogMFxuICAgICAgICAgICAgICAgIH0sIGEgPSB7XG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgICAgICAgICAgfSwgbCA9IE9iamVjdC5rZXlzKGkpLCB1ID0gMCwgaCA9IGw7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYyA9IGhbdV0sXG4gICAgICAgICAgICAgICAgICAgICAgcCA9IGlbY10sXG4gICAgICAgICAgICAgICAgICAgICAgZiA9IHBbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgZCA9IGUuY3JlYXRlRXhwcmVzc2lvbihwWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICBnID0gZS5jcmVhdGVFeHByZXNzaW9uKFwic3RyaW5nXCIgPT0gdHlwZW9mIGYgPyBbZiwgW1wiYWNjdW11bGF0ZWRcIl0sIFtcImdldFwiLCBjXV0gOiBmKTtcbiAgICAgICAgICAgICAgICAgIG9bY10gPSBkLnZhbHVlLCBuW2NdID0gZy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gci5tYXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgYS5wcm9wZXJ0aWVzID0gZTtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IHt9LCByID0gMCwgaSA9IGw7IHIgPCBpLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gaVtyXTtcbiAgICAgICAgICAgICAgICAgICAgdFtuXSA9IG9bbl0uZXZhbHVhdGUocywgYSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH0sIHIucmVkdWNlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgIGEucHJvcGVydGllcyA9IHQ7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBpID0gbDsgciA8IGkubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBpW3JdO1xuICAgICAgICAgICAgICAgICAgICBzLmFjY3VtdWxhdGVkID0gZVtvXSwgZVtvXSA9IG5bb10uZXZhbHVhdGUocywgYSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcjtcbiAgICAgICAgICAgICAgfShpKSkubG9hZChzLmZlYXR1cmVzKSA6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtZShlLCB0KTtcbiAgICAgICAgICAgICAgfShzLCBpLmdlb2pzb25WdE9wdGlvbnMpO1xuICAgICAgICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICAgICAgICByZXR1cm4gcihuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdC5sb2FkZWQgPSB7fTtcbiAgICAgICAgICAgIHZhciB1ID0ge307XG5cbiAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgIHZhciBoID0gby5maW5pc2goKTtcbiAgICAgICAgICAgICAgaCAmJiAodS5yZXNvdXJjZVRpbWluZyA9IHt9LCB1LnJlc291cmNlVGltaW5nW2kuc291cmNlXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcihudWxsLCB1KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgci5wcm90b3R5cGUuY29hbGVzY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFwiQ29hbGVzY2luZ1wiID09PSB0aGlzLl9zdGF0ZSA/IHRoaXMuX3N0YXRlID0gXCJJZGxlXCIgOiBcIk5lZWRzTG9hZERhdGFcIiA9PT0gdGhpcy5fc3RhdGUgJiYgKHRoaXMuX3N0YXRlID0gXCJDb2FsZXNjaW5nXCIsIHRoaXMuX2xvYWREYXRhKCkpO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVsb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sb2FkZWQ7XG4gICAgICAgIHJldHVybiBpICYmIGlbZS51aWRdID8gdC5wcm90b3R5cGUucmVsb2FkVGlsZS5jYWxsKHRoaXMsIGUsIHIpIDogdGhpcy5sb2FkVGlsZShlLCByKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmxvYWRHZW9KU09OID0gZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgICAgaWYgKHQucmVxdWVzdCkgZS5nZXRKU09OKHQucmVxdWVzdCwgcik7ZWxzZSB7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHQuZGF0YSkgcmV0dXJuIHIobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBnaXZlbiB0byAnXCIgKyB0LnNvdXJjZSArIFwiJyBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiByKG51bGwsIEpTT04ucGFyc2UodC5kYXRhKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHIobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBnaXZlbiB0byAnXCIgKyB0LnNvdXJjZSArIFwiJyBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlU291cmNlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrICYmIHRoaXMuX3BlbmRpbmdDYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgYWJhbmRvbmVkOiAhMFxuICAgICAgICB9KSwgdCgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0Q2x1c3RlckV4cGFuc2lvblpvb20gPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHQobnVsbCwgdGhpcy5fZ2VvSlNPTkluZGV4LmdldENsdXN0ZXJFeHBhbnNpb25ab29tKGUuY2x1c3RlcklkKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0KGUpO1xuICAgICAgICB9XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDbHVzdGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHQobnVsbCwgdGhpcy5fZ2VvSlNPTkluZGV4LmdldENoaWxkcmVuKGUuY2x1c3RlcklkKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0KGUpO1xuICAgICAgICB9XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDbHVzdGVyTGVhdmVzID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0KG51bGwsIHRoaXMuX2dlb0pTT05JbmRleC5nZXRMZWF2ZXMoZS5jbHVzdGVySWQsIGUubGltaXQsIGUub2Zmc2V0KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0KGUpO1xuICAgICAgICB9XG4gICAgICB9LCByO1xuICAgIH0obCksXG4gICAgICAgIFNlID0gZnVuY3Rpb24gU2UodCkge1xuICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgdGhpcy5zZWxmID0gdCwgdGhpcy5hY3RvciA9IG5ldyBlLkFjdG9yKHQsIHRoaXMpLCB0aGlzLmxheWVySW5kZXhlcyA9IHt9LCB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IHt9LCB0aGlzLndvcmtlclNvdXJjZVR5cGVzID0ge1xuICAgICAgICB2ZWN0b3I6IGwsXG4gICAgICAgIGdlb2pzb246IHdlXG4gICAgICB9LCB0aGlzLndvcmtlclNvdXJjZXMgPSB7fSwgdGhpcy5kZW1Xb3JrZXJTb3VyY2VzID0ge30sIHRoaXMuc2VsZi5yZWdpc3RlcldvcmtlclNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGlmIChyLndvcmtlclNvdXJjZVR5cGVzW2VdKSB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBzb3VyY2Ugd2l0aCBuYW1lIFwiJyArIGUgKyAnXCIgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgICAgICByLndvcmtlclNvdXJjZVR5cGVzW2VdID0gdDtcbiAgICAgIH0sIHRoaXMuc2VsZi5yZWdpc3RlclJUTFRleHRQbHVnaW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAoZS5wbHVnaW4uaXNQYXJzZWQoKSkgdGhyb3cgbmV3IEVycm9yKFwiUlRMIHRleHQgcGx1Z2luIGFscmVhZHkgcmVnaXN0ZXJlZC5cIik7XG4gICAgICAgIGUucGx1Z2luLmFwcGx5QXJhYmljU2hhcGluZyA9IHQuYXBwbHlBcmFiaWNTaGFwaW5nLCBlLnBsdWdpbi5wcm9jZXNzQmlkaXJlY3Rpb25hbFRleHQgPSB0LnByb2Nlc3NCaWRpcmVjdGlvbmFsVGV4dCwgZS5wbHVnaW4ucHJvY2Vzc1N0eWxlZEJpZGlyZWN0aW9uYWxUZXh0ID0gdC5wcm9jZXNzU3R5bGVkQmlkaXJlY3Rpb25hbFRleHQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gU2UucHJvdG90eXBlLnNldFJlZmVycmVyID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHRoaXMucmVmZXJyZXIgPSB0O1xuICAgIH0sIFNlLnByb3RvdHlwZS5zZXRJbWFnZXMgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmF2YWlsYWJsZUltYWdlc1tlXSA9IHQsIHRoaXMud29ya2VyU291cmNlc1tlXSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMud29ya2VyU291cmNlc1tlXVtpXTtcblxuICAgICAgICBmb3IgKHZhciBuIGluIG8pIHtcbiAgICAgICAgICBvW25dLmF2YWlsYWJsZUltYWdlcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcigpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5zZXRMYXllcnMgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRMYXllckluZGV4KGUpLnJlcGxhY2UodCksIHIoKTtcbiAgICB9LCBTZS5wcm90b3R5cGUudXBkYXRlTGF5ZXJzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0TGF5ZXJJbmRleChlKS51cGRhdGUodC5sYXllcnMsIHQucmVtb3ZlZElkcyksIHIoKTtcbiAgICB9LCBTZS5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRXb3JrZXJTb3VyY2UoZSwgdC50eXBlLCB0LnNvdXJjZSkubG9hZFRpbGUodCwgcik7XG4gICAgfSwgU2UucHJvdG90eXBlLmxvYWRERU1UaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0REVNV29ya2VyU291cmNlKGUsIHQuc291cmNlKS5sb2FkVGlsZSh0LCByKTtcbiAgICB9LCBTZS5wcm90b3R5cGUucmVsb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB0aGlzLmdldFdvcmtlclNvdXJjZShlLCB0LnR5cGUsIHQuc291cmNlKS5yZWxvYWRUaWxlKHQsIHIpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5hYm9ydFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRXb3JrZXJTb3VyY2UoZSwgdC50eXBlLCB0LnNvdXJjZSkuYWJvcnRUaWxlKHQsIHIpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5yZW1vdmVUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0V29ya2VyU291cmNlKGUsIHQudHlwZSwgdC5zb3VyY2UpLnJlbW92ZVRpbGUodCwgcik7XG4gICAgfSwgU2UucHJvdG90eXBlLnJlbW92ZURFTVRpbGUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgdGhpcy5nZXRERU1Xb3JrZXJTb3VyY2UoZSwgdC5zb3VyY2UpLnJlbW92ZVRpbGUodCk7XG4gICAgfSwgU2UucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICBpZiAodGhpcy53b3JrZXJTb3VyY2VzW2VdICYmIHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdICYmIHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdW3Quc291cmNlXSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdW3Quc291cmNlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdW3Quc291cmNlXSwgdm9pZCAwICE9PSBpLnJlbW92ZVNvdXJjZSA/IGkucmVtb3ZlU291cmNlKHQsIHIpIDogcigpO1xuICAgICAgfVxuICAgIH0sIFNlLnByb3RvdHlwZS5sb2FkV29ya2VyU291cmNlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2VsZi5pbXBvcnRTY3JpcHRzKHQudXJsKSwgcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByKGUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSwgU2UucHJvdG90eXBlLnN5bmNSVExQbHVnaW5TdGF0ZSA9IGZ1bmN0aW9uICh0LCByLCBpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlLnBsdWdpbi5zZXRTdGF0ZShyKTtcbiAgICAgICAgdmFyIG8gPSBlLnBsdWdpbi5nZXRQbHVnaW5VUkwoKTtcblxuICAgICAgICBpZiAoZS5wbHVnaW4uaXNMb2FkZWQoKSAmJiAhZS5wbHVnaW4uaXNQYXJzZWQoKSAmJiBudWxsICE9IG8pIHtcbiAgICAgICAgICB0aGlzLnNlbGYuaW1wb3J0U2NyaXB0cyhvKTtcbiAgICAgICAgICB2YXIgbiA9IGUucGx1Z2luLmlzUGFyc2VkKCk7XG4gICAgICAgICAgaShuID8gdm9pZCAwIDogbmV3IEVycm9yKFwiUlRMIFRleHQgUGx1Z2luIGZhaWxlZCB0byBpbXBvcnQgc2NyaXB0cyBmcm9tIFwiICsgbyksIG4pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGkoZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9LCBTZS5wcm90b3R5cGUuZ2V0QXZhaWxhYmxlSW1hZ2VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5hdmFpbGFibGVJbWFnZXNbZV07XG4gICAgICByZXR1cm4gdCB8fCAodCA9IFtdKSwgdDtcbiAgICB9LCBTZS5wcm90b3R5cGUuZ2V0TGF5ZXJJbmRleCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubGF5ZXJJbmRleGVzW2VdO1xuICAgICAgcmV0dXJuIHQgfHwgKHQgPSB0aGlzLmxheWVySW5kZXhlc1tlXSA9IG5ldyBpKCkpLCB0O1xuICAgIH0sIFNlLnByb3RvdHlwZS5nZXRXb3JrZXJTb3VyY2UgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMud29ya2VyU291cmNlc1tlXSB8fCAodGhpcy53b3JrZXJTb3VyY2VzW2VdID0ge30pLCB0aGlzLndvcmtlclNvdXJjZXNbZV1bdF0gfHwgKHRoaXMud29ya2VyU291cmNlc1tlXVt0XSA9IHt9KSwgdGhpcy53b3JrZXJTb3VyY2VzW2VdW3RdW3JdIHx8ICh0aGlzLndvcmtlclNvdXJjZXNbZV1bdF1bcl0gPSBuZXcgdGhpcy53b3JrZXJTb3VyY2VUeXBlc1t0XSh7XG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQodCwgciwgbykge1xuICAgICAgICAgIGkuYWN0b3Iuc2VuZCh0LCByLCBvLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5nZXRMYXllckluZGV4KGUpLCB0aGlzLmdldEF2YWlsYWJsZUltYWdlcyhlKSkpLCB0aGlzLndvcmtlclNvdXJjZXNbZV1bdF1bcl07XG4gICAgfSwgU2UucHJvdG90eXBlLmdldERFTVdvcmtlclNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZW1Xb3JrZXJTb3VyY2VzW2VdIHx8ICh0aGlzLmRlbVdvcmtlclNvdXJjZXNbZV0gPSB7fSksIHRoaXMuZGVtV29ya2VyU291cmNlc1tlXVt0XSB8fCAodGhpcy5kZW1Xb3JrZXJTb3VyY2VzW2VdW3RdID0gbmV3IGgoKSksIHRoaXMuZGVtV29ya2VyU291cmNlc1tlXVt0XTtcbiAgICB9LCBTZS5wcm90b3R5cGUuZW5mb3JjZUNhY2hlU2l6ZUxpbWl0ID0gZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgIGUuZW5mb3JjZUNhY2hlU2l6ZUxpbWl0KHIpO1xuICAgIH0sIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIChzZWxmLndvcmtlciA9IG5ldyBTZShzZWxmKSksIFNlO1xuICB9KTtcbiAgZGVmaW5lKFtcIi4vc2hhcmVkXCJdLCBmdW5jdGlvbiAodCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGUgPSB0LmNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgICAgcmV0dXJuICFpKHQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHdpbmRvdyB8fCBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBkb2N1bWVudCA/IFwibm90IGEgYnJvd3NlclwiIDogQXJyYXkucHJvdG90eXBlICYmIEFycmF5LnByb3RvdHlwZS5ldmVyeSAmJiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICYmIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICYmIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmIEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiBBcnJheS5wcm90b3R5cGUubWFwICYmIEFycmF5LnByb3RvdHlwZS5zb21lICYmIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgJiYgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0ICYmIEFycmF5LmlzQXJyYXkgPyBGdW5jdGlvbi5wcm90b3R5cGUgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPyBPYmplY3Qua2V5cyAmJiBPYmplY3QuY3JlYXRlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAmJiBPYmplY3QuaXNTZWFsZWQgJiYgT2JqZWN0LmlzRnJvemVuICYmIE9iamVjdC5pc0V4dGVuc2libGUgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgJiYgT2JqZWN0LnNlYWwgJiYgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPyBcIkpTT05cIiBpbiB3aW5kb3cgJiYgXCJwYXJzZVwiIGluIEpTT04gJiYgXCJzdHJpbmdpZnlcIiBpbiBKU09OID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghKFwiV29ya2VyXCIgaW4gd2luZG93ICYmIFwiQmxvYlwiIGluIHdpbmRvdyAmJiBcIlVSTFwiIGluIHdpbmRvdykpIHJldHVybiAhMTtcbiAgICAgICAgICB2YXIgdCxcbiAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgaSA9IG5ldyBCbG9iKFtcIlwiXSwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBvID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlID0gbmV3IFdvcmtlcihvKSwgdCA9ICEwO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHQgPSAhMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZSAmJiBlLnRlcm1pbmF0ZSgpLCBVUkwucmV2b2tlT2JqZWN0VVJMKG8pLCB0O1xuICAgICAgICB9KCkgPyBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIgaW4gd2luZG93ID8gQXJyYXlCdWZmZXIuaXNWaWV3ID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICB0LndpZHRoID0gdC5oZWlnaHQgPSAxO1xuICAgICAgICAgIHZhciBlID0gdC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgaWYgKCFlKSByZXR1cm4gITE7XG4gICAgICAgICAgdmFyIGkgPSBlLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgICAgICByZXR1cm4gaSAmJiBpLndpZHRoID09PSB0LndpZHRoO1xuICAgICAgICB9KCkgPyAodm9pZCAwID09PSBvW2kgPSB0ICYmIHQuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdF0gJiYgKG9baV0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgICAgICBvID0gT2JqZWN0LmNyZWF0ZShlLndlYkdMQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG8uZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IHQsIGkucHJvYmFibHlTdXBwb3J0c0NvbnRleHQgPyBpLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KFwid2ViZ2xcIiwgbykgfHwgaS5wcm9iYWJseVN1cHBvcnRzQ29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBvKSA6IGkuc3VwcG9ydHNDb250ZXh0ID8gaS5zdXBwb3J0c0NvbnRleHQoXCJ3ZWJnbFwiLCBvKSB8fCBpLnN1cHBvcnRzQ29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBvKSA6IGkuZ2V0Q29udGV4dChcIndlYmdsXCIsIG8pIHx8IGkuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBvKTtcbiAgICAgICAgICB9KHQpO1xuXG4gICAgICAgICAgaWYgKCFpKSByZXR1cm4gITE7XG4gICAgICAgICAgdmFyIG8gPSBpLmNyZWF0ZVNoYWRlcihpLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICAgIHJldHVybiAhKCFvIHx8IGkuaXNDb250ZXh0TG9zdCgpKSAmJiAoaS5zaGFkZXJTb3VyY2UobywgXCJ2b2lkIG1haW4oKSB7fVwiKSwgaS5jb21waWxlU2hhZGVyKG8pLCAhMCA9PT0gaS5nZXRTaGFkZXJQYXJhbWV0ZXIobywgaS5DT01QSUxFX1NUQVRVUykpO1xuICAgICAgICB9KGkpKSwgb1tpXSA/IHZvaWQgMCA6IFwiaW5zdWZmaWNpZW50IFdlYkdMIHN1cHBvcnRcIikgOiBcImluc3VmZmljaWVudCBDYW52YXMvZ2V0SW1hZ2VEYXRhIHN1cHBvcnRcIiA6IFwiaW5zdWZmaWNpZW50IEFycmF5QnVmZmVyIHN1cHBvcnRcIiA6IFwiaW5zdWZmaWNpZW50IFVpbnQ4Q2xhbXBlZEFycmF5IHN1cHBvcnRcIiA6IFwiaW5zdWZmaWNpZW50IHdvcmtlciBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBKU09OIHN1cHBvcnRcIiA6IFwiaW5zdWZmaWNpZW50IE9iamVjdCBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBGdW5jdGlvbiBzdXBwb3J0XCIgOiBcImluc3VmZmljZW50IEFycmF5IHN1cHBvcnRcIjtcbiAgICAgICAgdmFyIGk7XG4gICAgICB9XG5cbiAgICAgIHQuZXhwb3J0cyA/IHQuZXhwb3J0cyA9IGUgOiB3aW5kb3cgJiYgKHdpbmRvdy5tYXBib3hnbCA9IHdpbmRvdy5tYXBib3hnbCB8fCB7fSwgd2luZG93Lm1hcGJveGdsLnN1cHBvcnRlZCA9IGUsIHdpbmRvdy5tYXBib3hnbC5ub3RTdXBwb3J0ZWRSZWFzb24gPSBpKTtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBlLndlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGFudGlhbGlhczogITEsXG4gICAgICAgIGFscGhhOiAhMCxcbiAgICAgICAgc3RlbmNpbDogITAsXG4gICAgICAgIGRlcHRoOiAhMFxuICAgICAgfTtcbiAgICB9KSxcbiAgICAgICAgaSA9IHtcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGUsIGksIG8pIHtcbiAgICAgICAgdmFyIHIgPSB0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO1xuICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBpICYmIChyLmNsYXNzTmFtZSA9IGkpLCBvICYmIG8uYXBwZW5kQ2hpbGQociksIHI7XG4gICAgICB9LFxuICAgICAgY3JlYXRlTlM6IGZ1bmN0aW9uIGNyZWF0ZU5TKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHQud2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhlLCBpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBvID0gdC53aW5kb3cuZG9jdW1lbnQgJiYgdC53aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG4gICAgZnVuY3Rpb24gcih0KSB7XG4gICAgICBpZiAoIW8pIHJldHVybiB0WzBdO1xuXG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgaWYgKHRbZV0gaW4gbykgcmV0dXJuIHRbZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0WzBdO1xuICAgIH1cblxuICAgIHZhciBhLFxuICAgICAgICBuID0gcihbXCJ1c2VyU2VsZWN0XCIsIFwiTW96VXNlclNlbGVjdFwiLCBcIldlYmtpdFVzZXJTZWxlY3RcIiwgXCJtc1VzZXJTZWxlY3RcIl0pO1xuICAgIGkuZGlzYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvICYmIG4gJiYgKGEgPSBvW25dLCBvW25dID0gXCJub25lXCIpO1xuICAgIH0sIGkuZW5hYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG8gJiYgbiAmJiAob1tuXSA9IGEpO1xuICAgIH07XG4gICAgdmFyIHMgPSByKFtcInRyYW5zZm9ybVwiLCBcIldlYmtpdFRyYW5zZm9ybVwiXSk7XG5cbiAgICBpLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0LnN0eWxlW3NdID0gZTtcbiAgICB9O1xuXG4gICAgdmFyIGwgPSAhMTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgbCA9ICEwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHQud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIGMsIGMpLCB0LndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBjLCBjKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBsID0gITE7XG4gICAgfVxuXG4gICAgaS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdC5hZGRFdmVudExpc3RlbmVyKGUsIGksIFwicGFzc2l2ZVwiIGluIG8gJiYgbCA/IG8gOiBvLmNhcHR1cmUpO1xuICAgIH0sIGkucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBpLCBcInBhc3NpdmVcIiBpbiBvICYmIGwgPyBvIDogby5jYXB0dXJlKTtcbiAgICB9O1xuXG4gICAgdmFyIHUgPSBmdW5jdGlvbiB1KGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHUsICEwKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaCh0KSB7XG4gICAgICB2YXIgZSA9IHQudXNlckltYWdlO1xuICAgICAgcmV0dXJuICEhKGUgJiYgZS5yZW5kZXIgJiYgZS5yZW5kZXIoKSkgJiYgKHQuZGF0YS5yZXBsYWNlKG5ldyBVaW50OEFycmF5KGUuZGF0YS5idWZmZXIpKSwgITApO1xuICAgIH1cblxuICAgIGkuc3VwcHJlc3NDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHQud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB1LCAhMCksIHQud2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0LndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdSwgITApO1xuICAgICAgfSwgMCk7XG4gICAgfSwgaS5tb3VzZVBvcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQoaS5jbGllbnRYIC0gby5sZWZ0IC0gZS5jbGllbnRMZWZ0LCBpLmNsaWVudFkgLSBvLnRvcCAtIGUuY2xpZW50VG9wKTtcbiAgICB9LCBpLnRvdWNoUG9zID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCByID0gW10sIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykge1xuICAgICAgICByLnB1c2gobmV3IHQuUG9pbnQoaVthXS5jbGllbnRYIC0gby5sZWZ0IC0gZS5jbGllbnRMZWZ0LCBpW2FdLmNsaWVudFkgLSBvLnRvcCAtIGUuY2xpZW50VG9wKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIGkubW91c2VCdXR0b24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdC53aW5kb3cuSW5zdGFsbFRyaWdnZXIgJiYgMiA9PT0gZS5idXR0b24gJiYgZS5jdHJsS2V5ICYmIHQud2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXCJNQUNcIikgPj0gMCA/IDAgOiBlLmJ1dHRvbjtcbiAgICB9LCBpLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuaW1hZ2VzID0ge30sIHRoaXMudXBkYXRlZEltYWdlcyA9IHt9LCB0aGlzLmNhbGxiYWNrRGlzcGF0Y2hlZFRoaXNGcmFtZSA9IHt9LCB0aGlzLmxvYWRlZCA9ICExLCB0aGlzLnJlcXVlc3RvcnMgPSBbXSwgdGhpcy5wYXR0ZXJucyA9IHt9LCB0aGlzLmF0bGFzSW1hZ2UgPSBuZXcgdC5SR0JBSW1hZ2Uoe1xuICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9KSwgdGhpcy5kaXJ0eSA9ICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0TG9hZGVkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkICE9PSB0ICYmICh0aGlzLmxvYWRlZCA9IHQsIHQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IDAsIGkgPSB0aGlzLnJlcXVlc3RvcnM7IGUgPCBpLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGlbZV07XG5cbiAgICAgICAgICAgIHRoaXMuX25vdGlmeShvLmlkcywgby5jYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZXF1ZXN0b3JzID0gW107XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzW3RdO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZSh0LCBlKSAmJiAodGhpcy5pbWFnZXNbdF0gPSBlKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gITA7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVN0cmV0Y2goaS5zdHJldGNoWCwgaS5kYXRhICYmIGkuZGF0YS53aWR0aCkgfHwgKHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignSW1hZ2UgXCInICsgZSArICdcIiBoYXMgaW52YWxpZCBcInN0cmV0Y2hYXCIgdmFsdWUnKSkpLCBvID0gITEpLCB0aGlzLl92YWxpZGF0ZVN0cmV0Y2goaS5zdHJldGNoWSwgaS5kYXRhICYmIGkuZGF0YS5oZWlnaHQpIHx8ICh0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ0ltYWdlIFwiJyArIGUgKyAnXCIgaGFzIGludmFsaWQgXCJzdHJldGNoWVwiIHZhbHVlJykpKSwgbyA9ICExKSwgdGhpcy5fdmFsaWRhdGVDb250ZW50KGkuY29udGVudCwgaSkgfHwgKHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignSW1hZ2UgXCInICsgZSArICdcIiBoYXMgaW52YWxpZCBcImNvbnRlbnRcIiB2YWx1ZScpKSksIG8gPSAhMSksIG87XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGVTdHJldGNoID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gITA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG8gPSAwLCByID0gdDsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHJbb107XG4gICAgICAgICAgaWYgKGFbMF0gPCBpIHx8IGFbMV0gPCBhWzBdIHx8IGUgPCBhWzFdKSByZXR1cm4gITE7XG4gICAgICAgICAgaSA9IGFbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGVDb250ZW50ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuICEodCAmJiAoNCAhPT0gdC5sZW5ndGggfHwgdFswXSA8IDAgfHwgZS5kYXRhLndpZHRoIDwgdFswXSB8fCB0WzFdIDwgMCB8fCBlLmRhdGEuaGVpZ2h0IDwgdFsxXSB8fCB0WzJdIDwgMCB8fCBlLmRhdGEud2lkdGggPCB0WzJdIHx8IHRbM10gPCAwIHx8IGUuZGF0YS5oZWlnaHQgPCB0WzNdIHx8IHRbMl0gPCB0WzBdIHx8IHRbM10gPCB0WzFdKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVJbWFnZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGUudmVyc2lvbiA9IHRoaXMuaW1hZ2VzW3RdLnZlcnNpb24gKyAxLCB0aGlzLmltYWdlc1t0XSA9IGUsIHRoaXMudXBkYXRlZEltYWdlc1t0XSA9ICEwO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlSW1hZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuaW1hZ2VzW3RdO1xuICAgICAgICBkZWxldGUgdGhpcy5pbWFnZXNbdF0sIGRlbGV0ZSB0aGlzLnBhdHRlcm5zW3RdLCBlLnVzZXJJbWFnZSAmJiBlLnVzZXJJbWFnZS5vblJlbW92ZSAmJiBlLnVzZXJJbWFnZS5vblJlbW92ZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUubGlzdEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaW1hZ2VzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gITA7XG4gICAgICAgIGlmICghdGhpcy5pc0xvYWRlZCgpKSBmb3IgKHZhciBvID0gMCwgciA9IHQ7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZXNbcltvXV0gfHwgKGkgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvYWRlZCgpIHx8IGkgPyB0aGlzLl9ub3RpZnkodCwgZSkgOiB0aGlzLnJlcXVlc3RvcnMucHVzaCh7XG4gICAgICAgICAgaWRzOiB0LFxuICAgICAgICAgIGNhbGxiYWNrOiBlXG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX25vdGlmeSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSB7fSwgciA9IDAsIGEgPSBlOyByIDwgYS5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIHZhciBuID0gYVtyXTtcbiAgICAgICAgICB0aGlzLmltYWdlc1tuXSB8fCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJzdHlsZWltYWdlbWlzc2luZ1wiLCB7XG4gICAgICAgICAgICBpZDogblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgcyA9IHRoaXMuaW1hZ2VzW25dO1xuICAgICAgICAgIHMgPyBvW25dID0ge1xuICAgICAgICAgICAgZGF0YTogcy5kYXRhLmNsb25lKCksXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgICBzZGY6IHMuc2RmLFxuICAgICAgICAgICAgdmVyc2lvbjogcy52ZXJzaW9uLFxuICAgICAgICAgICAgc3RyZXRjaFg6IHMuc3RyZXRjaFgsXG4gICAgICAgICAgICBzdHJldGNoWTogcy5zdHJldGNoWSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHMuY29udGVudCxcbiAgICAgICAgICAgIGhhc1JlbmRlckNhbGxiYWNrOiBCb29sZWFuKHMudXNlckltYWdlICYmIHMudXNlckltYWdlLnJlbmRlcilcbiAgICAgICAgICB9IDogdC53YXJuT25jZSgnSW1hZ2UgXCInICsgbiArICdcIiBjb3VsZCBub3QgYmUgbG9hZGVkLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGFkZGVkIHRoZSBpbWFnZSB3aXRoIG1hcC5hZGRJbWFnZSgpIG9yIGEgXCJzcHJpdGVcIiBwcm9wZXJ0eSBpbiB5b3VyIHN0eWxlLiBZb3UgY2FuIHByb3ZpZGUgbWlzc2luZyBpbWFnZXMgYnkgbGlzdGVuaW5nIGZvciB0aGUgXCJzdHlsZWltYWdlbWlzc2luZ1wiIG1hcCBldmVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkobnVsbCwgbyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRQaXhlbFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5hdGxhc0ltYWdlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFBhdHRlcm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMucGF0dGVybnNbZV0sXG4gICAgICAgICAgICBvID0gdGhpcy5nZXRJbWFnZShlKTtcbiAgICAgICAgaWYgKCFvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGkgJiYgaS5wb3NpdGlvbi52ZXJzaW9uID09PSBvLnZlcnNpb24pIHJldHVybiBpLnBvc2l0aW9uO1xuICAgICAgICBpZiAoaSkgaS5wb3NpdGlvbi52ZXJzaW9uID0gby52ZXJzaW9uO2Vsc2Uge1xuICAgICAgICAgIHZhciByID0ge1xuICAgICAgICAgICAgdzogby5kYXRhLndpZHRoICsgMixcbiAgICAgICAgICAgIGg6IG8uZGF0YS5oZWlnaHQgKyAyLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhID0gbmV3IHQuSW1hZ2VQb3NpdGlvbihyLCBvKTtcbiAgICAgICAgICB0aGlzLnBhdHRlcm5zW2VdID0ge1xuICAgICAgICAgICAgYmluOiByLFxuICAgICAgICAgICAgcG9zaXRpb246IGFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVQYXR0ZXJuQXRsYXMoKSwgdGhpcy5wYXR0ZXJuc1tlXS5wb3NpdGlvbjtcbiAgICAgIH0sIGkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IGUuZ2w7XG4gICAgICAgIHRoaXMuYXRsYXNUZXh0dXJlID8gdGhpcy5kaXJ0eSAmJiAodGhpcy5hdGxhc1RleHR1cmUudXBkYXRlKHRoaXMuYXRsYXNJbWFnZSksIHRoaXMuZGlydHkgPSAhMSkgOiB0aGlzLmF0bGFzVGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZSwgdGhpcy5hdGxhc0ltYWdlLCBpLlJHQkEpLCB0aGlzLmF0bGFzVGV4dHVyZS5iaW5kKGkuTElORUFSLCBpLkNMQU1QX1RPX0VER0UpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVBhdHRlcm5BdGxhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucGF0dGVybnMpIHtcbiAgICAgICAgICBlLnB1c2godGhpcy5wYXR0ZXJuc1tpXS5iaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG8gPSB0LnBvdHBhY2soZSksXG4gICAgICAgICAgICByID0gby53LFxuICAgICAgICAgICAgYSA9IG8uaCxcbiAgICAgICAgICAgIG4gPSB0aGlzLmF0bGFzSW1hZ2U7XG5cbiAgICAgICAgZm9yICh2YXIgcyBpbiBuLnJlc2l6ZSh7XG4gICAgICAgICAgd2lkdGg6IHIgfHwgMSxcbiAgICAgICAgICBoZWlnaHQ6IGEgfHwgMVxuICAgICAgICB9KSwgdGhpcy5wYXR0ZXJucykge1xuICAgICAgICAgIHZhciBsID0gdGhpcy5wYXR0ZXJuc1tzXS5iaW4sXG4gICAgICAgICAgICAgIGMgPSBsLnggKyAxLFxuICAgICAgICAgICAgICB1ID0gbC55ICsgMSxcbiAgICAgICAgICAgICAgaCA9IHRoaXMuaW1hZ2VzW3NdLmRhdGEsXG4gICAgICAgICAgICAgIHAgPSBoLndpZHRoLFxuICAgICAgICAgICAgICBkID0gaC5oZWlnaHQ7XG4gICAgICAgICAgdC5SR0JBSW1hZ2UuY29weShoLCBuLCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IGMsXG4gICAgICAgICAgICB5OiB1XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgd2lkdGg6IHAsXG4gICAgICAgICAgICBoZWlnaHQ6IGRcbiAgICAgICAgICB9KSwgdC5SR0JBSW1hZ2UuY29weShoLCBuLCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogZCAtIDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBjLFxuICAgICAgICAgICAgeTogdSAtIDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB3aWR0aDogcCxcbiAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICAgIH0pLCB0LlJHQkFJbWFnZS5jb3B5KGgsIG4sIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogYyxcbiAgICAgICAgICAgIHk6IHUgKyBkXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgd2lkdGg6IHAsXG4gICAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgICB9KSwgdC5SR0JBSW1hZ2UuY29weShoLCBuLCB7XG4gICAgICAgICAgICB4OiBwIC0gMSxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBjIC0gMSxcbiAgICAgICAgICAgIHk6IHVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIGhlaWdodDogZFxuICAgICAgICAgIH0pLCB0LlJHQkFJbWFnZS5jb3B5KGgsIG4sIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogYyArIHAsXG4gICAgICAgICAgICB5OiB1XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkgPSAhMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmJlZ2luRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tEaXNwYXRjaGVkVGhpc0ZyYW1lID0ge307XG4gICAgICB9LCBpLnByb3RvdHlwZS5kaXNwYXRjaFJlbmRlckNhbGxiYWNrcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBpID0gdDsgZSA8IGkubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICB2YXIgbyA9IGlbZV07XG5cbiAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tEaXNwYXRjaGVkVGhpc0ZyYW1lW29dKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrRGlzcGF0Y2hlZFRoaXNGcmFtZVtvXSA9ICEwO1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmltYWdlc1tvXTtcbiAgICAgICAgICAgIGgocikgJiYgdGhpcy51cGRhdGVJbWFnZShvLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGk7XG4gICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgICBkID0gbSxcbiAgICAgICAgXyA9IG0sXG4gICAgICAgIGYgPSAxZTIwO1xuXG4gICAgZnVuY3Rpb24gbSh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB0aGlzLmZvbnRTaXplID0gdCB8fCAyNCwgdGhpcy5idWZmZXIgPSB2b2lkIDAgPT09IGUgPyAzIDogZSwgdGhpcy5jdXRvZmYgPSBvIHx8IC4yNSwgdGhpcy5mb250RmFtaWx5ID0gciB8fCBcInNhbnMtc2VyaWZcIiwgdGhpcy5mb250V2VpZ2h0ID0gYSB8fCBcIm5vcm1hbFwiLCB0aGlzLnJhZGl1cyA9IGkgfHwgODtcbiAgICAgIHZhciBuID0gdGhpcy5zaXplID0gdGhpcy5mb250U2l6ZSArIDIgKiB0aGlzLmJ1ZmZlcjtcbiAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBuLCB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgdGhpcy5jdHguZm9udCA9IHRoaXMuZm9udFdlaWdodCArIFwiIFwiICsgdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnRGYW1pbHksIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIHRoaXMuY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIiwgdGhpcy5ncmlkT3V0ZXIgPSBuZXcgRmxvYXQ2NEFycmF5KG4gKiBuKSwgdGhpcy5ncmlkSW5uZXIgPSBuZXcgRmxvYXQ2NEFycmF5KG4gKiBuKSwgdGhpcy5mID0gbmV3IEZsb2F0NjRBcnJheShuKSwgdGhpcy5kID0gbmV3IEZsb2F0NjRBcnJheShuKSwgdGhpcy56ID0gbmV3IEZsb2F0NjRBcnJheShuICsgMSksIHRoaXMudiA9IG5ldyBJbnQxNkFycmF5KG4pLCB0aGlzLm1pZGRsZSA9IE1hdGgucm91bmQobiAvIDIgKiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiR2Vja28vXCIpID49IDAgPyAxLjIgOiAxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZyh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGU7IHMrKykge1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGk7IGwrKykge1xuICAgICAgICAgIG9bbF0gPSB0W2wgKiBlICsgc107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHYobywgciwgYSwgbiwgaSksIGwgPSAwOyBsIDwgaTsgbCsrKSB7XG4gICAgICAgICAgdFtsICogZSArIHNdID0gcltsXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGwgPSAwOyBsIDwgaTsgbCsrKSB7XG4gICAgICAgIGZvciAocyA9IDA7IHMgPCBlOyBzKyspIHtcbiAgICAgICAgICBvW3NdID0gdFtsICogZSArIHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2KG8sIHIsIGEsIG4sIGUpLCBzID0gMDsgcyA8IGU7IHMrKykge1xuICAgICAgICAgIHRbbCAqIGUgKyBzXSA9IE1hdGguc3FydChyW3NdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHYodCwgZSwgaSwgbywgcikge1xuICAgICAgaVswXSA9IDAsIG9bMF0gPSAtZiwgb1sxXSA9ICtmO1xuXG4gICAgICBmb3IgKHZhciBhID0gMSwgbiA9IDA7IGEgPCByOyBhKyspIHtcbiAgICAgICAgZm9yICh2YXIgcyA9ICh0W2FdICsgYSAqIGEgLSAodFtpW25dXSArIGlbbl0gKiBpW25dKSkgLyAoMiAqIGEgLSAyICogaVtuXSk7IHMgPD0gb1tuXTspIHtcbiAgICAgICAgICBuLS0sIHMgPSAodFthXSArIGEgKiBhIC0gKHRbaVtuXV0gKyBpW25dICogaVtuXSkpIC8gKDIgKiBhIC0gMiAqIGlbbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaVsrK25dID0gYSwgb1tuXSA9IHMsIG9bbiArIDFdID0gK2Y7XG4gICAgICB9XG5cbiAgICAgIGZvciAoYSA9IDAsIG4gPSAwOyBhIDwgcjsgYSsrKSB7XG4gICAgICAgIGZvciAoOyBvW24gKyAxXSA8IGE7KSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgZVthXSA9IChhIC0gaVtuXSkgKiAoYSAtIGlbbl0pICsgdFtpW25dXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSksIHRoaXMuY3R4LmZpbGxUZXh0KHQsIHRoaXMuYnVmZmVyLCB0aGlzLm1pZGRsZSk7XG5cbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5zaXplLCB0aGlzLnNpemUpLCBpID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZSksIG8gPSAwOyBvIDwgdGhpcy5zaXplICogdGhpcy5zaXplOyBvKyspIHtcbiAgICAgICAgdmFyIHIgPSBlLmRhdGFbNCAqIG8gKyAzXSAvIDI1NTtcbiAgICAgICAgdGhpcy5ncmlkT3V0ZXJbb10gPSAxID09PSByID8gMCA6IDAgPT09IHIgPyBmIDogTWF0aC5wb3coTWF0aC5tYXgoMCwgLjUgLSByKSwgMiksIHRoaXMuZ3JpZElubmVyW29dID0gMSA9PT0gciA/IGYgOiAwID09PSByID8gMCA6IE1hdGgucG93KE1hdGgubWF4KDAsIHIgLSAuNSksIDIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGcodGhpcy5ncmlkT3V0ZXIsIHRoaXMuc2l6ZSwgdGhpcy5zaXplLCB0aGlzLmYsIHRoaXMuZCwgdGhpcy52LCB0aGlzLnopLCBnKHRoaXMuZ3JpZElubmVyLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSwgdGhpcy5mLCB0aGlzLmQsIHRoaXMudiwgdGhpcy56KSwgbyA9IDA7IG8gPCB0aGlzLnNpemUgKiB0aGlzLnNpemU7IG8rKykge1xuICAgICAgICBpW29dID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKDI1NSAtIDI1NSAqICgodGhpcy5ncmlkT3V0ZXJbb10gLSB0aGlzLmdyaWRJbm5lcltvXSkgLyB0aGlzLnJhZGl1cyArIHRoaXMuY3V0b2ZmKSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgZC5kZWZhdWx0ID0gXztcblxuICAgIHZhciB5ID0gZnVuY3Rpb24geSh0LCBlKSB7XG4gICAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gdCwgdGhpcy5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPSBlLCB0aGlzLmVudHJpZXMgPSB7fTtcbiAgICB9O1xuXG4gICAgeS5wcm90b3R5cGUuc2V0VVJMID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudXJsID0gdDtcbiAgICB9LCB5LnByb3RvdHlwZS5nZXRHbHlwaHMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLFxuICAgICAgICAgIHIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgYSBpbiBlKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSAwLCBzID0gZVthXTsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICByLnB1c2goe1xuICAgICAgICAgICAgc3RhY2s6IGEsXG4gICAgICAgICAgICBpZDogc1tuXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHQuYXN5bmNBbGwociwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0LnN0YWNrLFxuICAgICAgICAgICAgciA9IHQuaWQsXG4gICAgICAgICAgICBhID0gby5lbnRyaWVzW2ldO1xuICAgICAgICBhIHx8IChhID0gby5lbnRyaWVzW2ldID0ge1xuICAgICAgICAgIGdseXBoczoge30sXG4gICAgICAgICAgcmVxdWVzdHM6IHt9LFxuICAgICAgICAgIHJhbmdlczoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuID0gYS5nbHlwaHNbcl07XG5cbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgICAgICAgIGlmIChuID0gby5fdGlueVNERihhLCBpLCByKSkgcmV0dXJuIGEuZ2x5cGhzW3JdID0gbiwgdm9pZCBlKG51bGwsIHtcbiAgICAgICAgICAgIHN0YWNrOiBpLFxuICAgICAgICAgICAgaWQ6IHIsXG4gICAgICAgICAgICBnbHlwaDogblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzID0gTWF0aC5mbG9vcihyIC8gMjU2KTtcbiAgICAgICAgICBpZiAoMjU2ICogcyA+IDY1NTM1KSBlKG5ldyBFcnJvcihcImdseXBocyA+IDY1NTM1IG5vdCBzdXBwb3J0ZWRcIikpO2Vsc2UgaWYgKGEucmFuZ2VzW3NdKSBlKG51bGwsIHtcbiAgICAgICAgICAgIHN0YWNrOiBpLFxuICAgICAgICAgICAgaWQ6IHIsXG4gICAgICAgICAgICBnbHlwaDogblxuICAgICAgICAgIH0pO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGwgPSBhLnJlcXVlc3RzW3NdO1xuICAgICAgICAgICAgbCB8fCAobCA9IGEucmVxdWVzdHNbc10gPSBbXSwgeS5sb2FkR2x5cGhSYW5nZShpLCBzLCBvLnVybCwgby5yZXF1ZXN0TWFuYWdlciwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGUpIHtcbiAgICAgICAgICAgICAgICAgIG8uX2RvZXNDaGFyU3VwcG9ydExvY2FsR2x5cGgoK2kpIHx8IChhLmdseXBoc1sraV0gPSBlWytpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYS5yYW5nZXNbc10gPSAhMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gbDsgciA8IG4ubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICAoMCwgbltyXSkodCwgZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgYS5yZXF1ZXN0c1tzXTtcbiAgICAgICAgICAgIH0pKSwgbC5wdXNoKGZ1bmN0aW9uICh0LCBvKSB7XG4gICAgICAgICAgICAgIHQgPyBlKHQpIDogbyAmJiBlKG51bGwsIHtcbiAgICAgICAgICAgICAgICBzdGFjazogaSxcbiAgICAgICAgICAgICAgICBpZDogcixcbiAgICAgICAgICAgICAgICBnbHlwaDogb1tyXSB8fCBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgZShudWxsLCB7XG4gICAgICAgICAgc3RhY2s6IGksXG4gICAgICAgICAgaWQ6IHIsXG4gICAgICAgICAgZ2x5cGg6IG5cbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpZiAodCkgaSh0KTtlbHNlIGlmIChlKSB7XG4gICAgICAgICAgZm9yICh2YXIgbyA9IHt9LCByID0gMCwgYSA9IGU7IHIgPCBhLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGFbcl0sXG4gICAgICAgICAgICAgICAgcyA9IG4uc3RhY2ssXG4gICAgICAgICAgICAgICAgbCA9IG4uaWQsXG4gICAgICAgICAgICAgICAgYyA9IG4uZ2x5cGg7XG4gICAgICAgICAgICAob1tzXSB8fCAob1tzXSA9IHt9KSlbbF0gPSBjICYmIHtcbiAgICAgICAgICAgICAgaWQ6IGMuaWQsXG4gICAgICAgICAgICAgIGJpdG1hcDogYy5iaXRtYXAuY2xvbmUoKSxcbiAgICAgICAgICAgICAgbWV0cmljczogYy5tZXRyaWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkobnVsbCwgbyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHkucHJvdG90eXBlLl9kb2VzQ2hhclN1cHBvcnRMb2NhbEdseXBoID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5ICYmICh0LmlzQ2hhcltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHNcIl0oZSkgfHwgdC5pc0NoYXJbXCJIYW5ndWwgU3lsbGFibGVzXCJdKGUpIHx8IHQuaXNDaGFyLkhpcmFnYW5hKGUpIHx8IHQuaXNDaGFyLkthdGFrYW5hKGUpKTtcbiAgICB9LCB5LnByb3RvdHlwZS5fdGlueVNERiA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5O1xuXG4gICAgICBpZiAociAmJiB0aGlzLl9kb2VzQ2hhclN1cHBvcnRMb2NhbEdseXBoKG8pKSB7XG4gICAgICAgIHZhciBhID0gZS50aW55U0RGO1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIHZhciBuID0gXCI0MDBcIjtcbiAgICAgICAgICAvYm9sZC9pLnRlc3QoaSkgPyBuID0gXCI5MDBcIiA6IC9tZWRpdW0vaS50ZXN0KGkpID8gbiA9IFwiNTAwXCIgOiAvbGlnaHQvaS50ZXN0KGkpICYmIChuID0gXCIyMDBcIiksIGEgPSBlLnRpbnlTREYgPSBuZXcgeS5UaW55U0RGKDI0LCAzLCA4LCAuMjUsIHIsIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogbyxcbiAgICAgICAgICBiaXRtYXA6IG5ldyB0LkFscGhhSW1hZ2Uoe1xuICAgICAgICAgICAgd2lkdGg6IDMwLFxuICAgICAgICAgICAgaGVpZ2h0OiAzMFxuICAgICAgICAgIH0sIGEuZHJhdyhTdHJpbmcuZnJvbUNoYXJDb2RlKG8pKSksXG4gICAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgICAgd2lkdGg6IDI0LFxuICAgICAgICAgICAgaGVpZ2h0OiAyNCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IC04LFxuICAgICAgICAgICAgYWR2YW5jZTogMjRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgeS5sb2FkR2x5cGhSYW5nZSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IDI1NiAqIGksXG4gICAgICAgICAgcyA9IG4gKyAyNTUsXG4gICAgICAgICAgbCA9IHIudHJhbnNmb3JtUmVxdWVzdChyLm5vcm1hbGl6ZUdseXBoc1VSTChvKS5yZXBsYWNlKFwie2ZvbnRzdGFja31cIiwgZSkucmVwbGFjZShcIntyYW5nZX1cIiwgbiArIFwiLVwiICsgcyksIHQuUmVzb3VyY2VUeXBlLkdseXBocyk7XG4gICAgICB0LmdldEFycmF5QnVmZmVyKGwsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGlmIChlKSBhKGUpO2Vsc2UgaWYgKGkpIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0ge30sIHIgPSAwLCBuID0gdC5wYXJzZUdseXBoUEJGKGkpOyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuW3JdO1xuICAgICAgICAgICAgb1tzLmlkXSA9IHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYShudWxsLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgeS5UaW55U0RGID0gZDtcblxuICAgIHZhciB4ID0gZnVuY3Rpb24geCgpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQuc3R5bGVTcGVjLmxpZ2h0LnBvc2l0aW9uO1xuICAgIH07XG5cbiAgICB4LnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHJldHVybiB0LnNwaGVyaWNhbFRvQ2FydGVzaWFuKGUuZXhwcmVzc2lvbi5ldmFsdWF0ZShpKSk7XG4gICAgfSwgeC5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdC5udW1iZXIoZS54LCBpLngsIG8pLFxuICAgICAgICB5OiB0Lm51bWJlcihlLnksIGkueSwgbyksXG4gICAgICAgIHo6IHQubnVtYmVyKGUueiwgaS56LCBvKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGIgPSBuZXcgdC5Qcm9wZXJ0aWVzKHtcbiAgICAgIGFuY2hvcjogbmV3IHQuRGF0YUNvbnN0YW50UHJvcGVydHkodC5zdHlsZVNwZWMubGlnaHQuYW5jaG9yKSxcbiAgICAgIHBvc2l0aW9uOiBuZXcgeCgpLFxuICAgICAgY29sb3I6IG5ldyB0LkRhdGFDb25zdGFudFByb3BlcnR5KHQuc3R5bGVTcGVjLmxpZ2h0LmNvbG9yKSxcbiAgICAgIGludGVuc2l0eTogbmV3IHQuRGF0YUNvbnN0YW50UHJvcGVydHkodC5zdHlsZVNwZWMubGlnaHQuaW50ZW5zaXR5KVxuICAgIH0pLFxuICAgICAgICB3ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoaSkge1xuICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuX3RyYW5zaXRpb25hYmxlID0gbmV3IHQuVHJhbnNpdGlvbmFibGUoYiksIHRoaXMuc2V0TGlnaHQoaSksIHRoaXMuX3RyYW5zaXRpb25pbmcgPSB0aGlzLl90cmFuc2l0aW9uYWJsZS51bnRyYW5zaXRpb25lZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5nZXRMaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25hYmxlLnNlcmlhbGl6ZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0TGlnaHQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBpICYmIChpID0ge30pLCAhdGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZUxpZ2h0LCBlLCBpKSkgZm9yICh2YXIgbyBpbiBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlW29dO1xuICAgICAgICAgIHQuZW5kc1dpdGgobywgXCItdHJhbnNpdGlvblwiKSA/IHRoaXMuX3RyYW5zaXRpb25hYmxlLnNldFRyYW5zaXRpb24oby5zbGljZSgwLCAtXCItdHJhbnNpdGlvblwiLmxlbmd0aCksIHIpIDogdGhpcy5fdHJhbnNpdGlvbmFibGUuc2V0VmFsdWUobywgcik7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmluZyA9IHRoaXMuX3RyYW5zaXRpb25hYmxlLnRyYW5zaXRpb25lZCh0LCB0aGlzLl90cmFuc2l0aW9uaW5nKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uaW5nLmhhc1RyYW5zaXRpb24oKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gdGhpcy5fdHJhbnNpdGlvbmluZy5wb3NzaWJseUV2YWx1YXRlKHQpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuICghbyB8fCAhMSAhPT0gby52YWxpZGF0ZSkgJiYgdC5lbWl0VmFsaWRhdGlvbkVycm9ycyh0aGlzLCBlLmNhbGwodC52YWxpZGF0ZVN0eWxlLCB0LmV4dGVuZCh7XG4gICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGdseXBoczogITAsXG4gICAgICAgICAgICBzcHJpdGU6ICEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjXG4gICAgICAgIH0pKSk7XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgVCA9IGZ1bmN0aW9uIFQodCwgZSkge1xuICAgICAgdGhpcy53aWR0aCA9IHQsIHRoaXMuaGVpZ2h0ID0gZSwgdGhpcy5uZXh0Um93ID0gMCwgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KSwgdGhpcy5kYXNoRW50cnkgPSB7fTtcbiAgICB9O1xuXG4gICAgVC5wcm90b3R5cGUuZ2V0RGFzaCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHQuam9pbihcIixcIikgKyBTdHJpbmcoZSk7XG4gICAgICByZXR1cm4gdGhpcy5kYXNoRW50cnlbaV0gfHwgKHRoaXMuZGFzaEVudHJ5W2ldID0gdGhpcy5hZGREYXNoKHQsIGUpKSwgdGhpcy5kYXNoRW50cnlbaV07XG4gICAgfSwgVC5wcm90b3R5cGUuZ2V0RGFzaFJhbmdlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IFtdLFxuICAgICAgICAgIHIgPSB0Lmxlbmd0aCAlIDIgPT0gMSA/IC10W3QubGVuZ3RoIC0gMV0gKiBpIDogMCxcbiAgICAgICAgICBhID0gdFswXSAqIGksXG4gICAgICAgICAgbiA9ICEwO1xuICAgICAgby5wdXNoKHtcbiAgICAgICAgbGVmdDogcixcbiAgICAgICAgcmlnaHQ6IGEsXG4gICAgICAgIGlzRGFzaDogbixcbiAgICAgICAgemVyb0xlbmd0aDogMCA9PT0gdFswXVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHMgPSB0WzBdLCBsID0gMTsgbCA8IHQubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGMgPSB0W2xdO1xuICAgICAgICBvLnB1c2goe1xuICAgICAgICAgIGxlZnQ6IHIgPSBzICogaSxcbiAgICAgICAgICByaWdodDogYSA9IChzICs9IGMpICogaSxcbiAgICAgICAgICBpc0Rhc2g6IG4gPSAhbixcbiAgICAgICAgICB6ZXJvTGVuZ3RoOiAwID09PSBjXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbztcbiAgICB9LCBULnByb3RvdHlwZS5hZGRSb3VuZERhc2ggPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IGUgLyAyLCByID0gLWk7IHIgPD0gaTsgcisrKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSB0aGlzLndpZHRoICogKHRoaXMubmV4dFJvdyArIGkgKyByKSwgbiA9IDAsIHMgPSB0W25dLCBsID0gMDsgbCA8IHRoaXMud2lkdGg7IGwrKykge1xuICAgICAgICAgIGwgLyBzLnJpZ2h0ID4gMSAmJiAocyA9IHRbKytuXSk7XG4gICAgICAgICAgdmFyIGMgPSBNYXRoLmFicyhsIC0gcy5sZWZ0KSxcbiAgICAgICAgICAgICAgdSA9IE1hdGguYWJzKGwgLSBzLnJpZ2h0KSxcbiAgICAgICAgICAgICAgaCA9IE1hdGgubWluKGMsIHUpLFxuICAgICAgICAgICAgICBwID0gdm9pZCAwLFxuICAgICAgICAgICAgICBkID0gciAvIGkgKiAobyArIDEpO1xuXG4gICAgICAgICAgaWYgKHMuaXNEYXNoKSB7XG4gICAgICAgICAgICB2YXIgXyA9IG8gLSBNYXRoLmFicyhkKTtcblxuICAgICAgICAgICAgcCA9IE1hdGguc3FydChoICogaCArIF8gKiBfKTtcbiAgICAgICAgICB9IGVsc2UgcCA9IG8gLSBNYXRoLnNxcnQoaCAqIGggKyBkICogZCk7XG5cbiAgICAgICAgICB0aGlzLmRhdGFbYSArIGxdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBwICsgMTI4KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBULnByb3RvdHlwZS5hZGRSZWd1bGFyRGFzaCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdC5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICB2YXIgaSA9IHRbZV0sXG4gICAgICAgICAgICBvID0gdFtlICsgMV07XG4gICAgICAgIGkuemVyb0xlbmd0aCA/IHQuc3BsaWNlKGUsIDEpIDogbyAmJiBvLmlzRGFzaCA9PT0gaS5pc0Rhc2ggJiYgKG8ubGVmdCA9IGkubGVmdCwgdC5zcGxpY2UoZSwgMSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IHRbMF0sXG4gICAgICAgICAgYSA9IHRbdC5sZW5ndGggLSAxXTtcbiAgICAgIHIuaXNEYXNoID09PSBhLmlzRGFzaCAmJiAoci5sZWZ0ID0gYS5sZWZ0IC0gdGhpcy53aWR0aCwgYS5yaWdodCA9IHIucmlnaHQgKyB0aGlzLndpZHRoKTtcblxuICAgICAgZm9yICh2YXIgbiA9IHRoaXMud2lkdGggKiB0aGlzLm5leHRSb3csIHMgPSAwLCBsID0gdFtzXSwgYyA9IDA7IGMgPCB0aGlzLndpZHRoOyBjKyspIHtcbiAgICAgICAgYyAvIGwucmlnaHQgPiAxICYmIChsID0gdFsrK3NdKTtcbiAgICAgICAgdmFyIHUgPSBNYXRoLmFicyhjIC0gbC5sZWZ0KSxcbiAgICAgICAgICAgIGggPSBNYXRoLmFicyhjIC0gbC5yaWdodCksXG4gICAgICAgICAgICBwID0gTWF0aC5taW4odSwgaCk7XG4gICAgICAgIHRoaXMuZGF0YVtuICsgY10gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIChsLmlzRGFzaCA/IHAgOiAtcCkgKyAxMjgpKTtcbiAgICAgIH1cbiAgICB9LCBULnByb3RvdHlwZS5hZGREYXNoID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZhciBvID0gaSA/IDcgOiAwLFxuICAgICAgICAgIHIgPSAyICogbyArIDE7XG4gICAgICBpZiAodGhpcy5uZXh0Um93ICsgciA+IHRoaXMuaGVpZ2h0KSByZXR1cm4gdC53YXJuT25jZShcIkxpbmVBdGxhcyBvdXQgb2Ygc3BhY2VcIiksIG51bGw7XG5cbiAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgYSArPSBlW25dO1xuICAgICAgfVxuXG4gICAgICBpZiAoMCAhPT0gYSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMud2lkdGggLyBhLFxuICAgICAgICAgICAgbCA9IHRoaXMuZ2V0RGFzaFJhbmdlcyhlLCB0aGlzLndpZHRoLCBzKTtcbiAgICAgICAgaSA/IHRoaXMuYWRkUm91bmREYXNoKGwsIHMsIG8pIDogdGhpcy5hZGRSZWd1bGFyRGFzaChsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGMgPSB7XG4gICAgICAgIHk6ICh0aGlzLm5leHRSb3cgKyBvICsgLjUpIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogMiAqIG8gLyB0aGlzLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5uZXh0Um93ICs9IHIsIHRoaXMuZGlydHkgPSAhMCwgYztcbiAgICB9LCBULnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdC5nbDtcbiAgICAgIHRoaXMudGV4dHVyZSA/IChlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKSwgdGhpcy5kaXJ0eSAmJiAodGhpcy5kaXJ0eSA9ICExLCBlLnRleFN1YkltYWdlMkQoZS5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZS5BTFBIQSwgZS5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpKSkgOiAodGhpcy50ZXh0dXJlID0gZS5jcmVhdGVUZXh0dXJlKCksIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpLCBlLnRleFBhcmFtZXRlcmkoZS5URVhUVVJFXzJELCBlLlRFWFRVUkVfV1JBUF9TLCBlLlJFUEVBVCksIGUudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsIGUuVEVYVFVSRV9XUkFQX1QsIGUuUkVQRUFUKSwgZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCwgZS5URVhUVVJFX01JTl9GSUxURVIsIGUuTElORUFSKSwgZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCwgZS5URVhUVVJFX01BR19GSUxURVIsIGUuTElORUFSKSwgZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwgMCwgZS5BTFBIQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGUuQUxQSEEsIGUuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKSk7XG4gICAgfTtcblxuICAgIHZhciBFID0gZnVuY3Rpb24gZShpLCBvKSB7XG4gICAgICB0aGlzLndvcmtlclBvb2wgPSBpLCB0aGlzLmFjdG9ycyA9IFtdLCB0aGlzLmN1cnJlbnRBY3RvciA9IDAsIHRoaXMuaWQgPSB0LnVuaXF1ZUlkKCk7XG5cbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLndvcmtlclBvb2wuYWNxdWlyZSh0aGlzLmlkKSwgYSA9IDA7IGEgPCByLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciBuID0gbmV3IGUuQWN0b3IoclthXSwgbywgdGhpcy5pZCk7XG4gICAgICAgIG4ubmFtZSA9IFwiV29ya2VyIFwiICsgYSwgdGhpcy5hY3RvcnMucHVzaChuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSShlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IGZ1bmN0aW9uIHIoX3IyLCBhKSB7XG4gICAgICAgIGlmIChfcjIpIHJldHVybiBvKF9yMik7XG5cbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICB2YXIgbiA9IHQucGljayh0LmV4dGVuZChhLCBlKSwgW1widGlsZXNcIiwgXCJtaW56b29tXCIsIFwibWF4em9vbVwiLCBcImF0dHJpYnV0aW9uXCIsIFwibWFwYm94X2xvZ29cIiwgXCJib3VuZHNcIiwgXCJzY2hlbWVcIiwgXCJ0aWxlU2l6ZVwiLCBcImVuY29kaW5nXCJdKTtcbiAgICAgICAgICBhLnZlY3Rvcl9sYXllcnMgJiYgKG4udmVjdG9yTGF5ZXJzID0gYS52ZWN0b3JfbGF5ZXJzLCBuLnZlY3RvckxheWVySWRzID0gbi52ZWN0b3JMYXllcnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgICAgICB9KSksIG4udGlsZXMgPSBpLmNhbm9uaWNhbGl6ZVRpbGVzZXQobiwgZS51cmwpLCBvKG51bGwsIG4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZS51cmwgPyB0LmdldEpTT04oaS50cmFuc2Zvcm1SZXF1ZXN0KGkubm9ybWFsaXplU291cmNlVVJMKGUudXJsKSwgdC5SZXNvdXJjZVR5cGUuU291cmNlKSwgcikgOiB0LmJyb3dzZXIuZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcihudWxsLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIEUucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICB0LmFzeW5jQWxsKHRoaXMuYWN0b3JzLCBmdW5jdGlvbiAodCwgbykge1xuICAgICAgICB0LnNlbmQoZSwgaSwgbyk7XG4gICAgICB9LCBvID0gbyB8fCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfSwgRS5wcm90b3R5cGUuZ2V0QWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50QWN0b3IgPSAodGhpcy5jdXJyZW50QWN0b3IgKyAxKSAlIHRoaXMuYWN0b3JzLmxlbmd0aCwgdGhpcy5hY3RvcnNbdGhpcy5jdXJyZW50QWN0b3JdO1xuICAgIH0sIEUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5yZW1vdmUoKTtcbiAgICAgIH0pLCB0aGlzLmFjdG9ycyA9IFtdLCB0aGlzLndvcmtlclBvb2wucmVsZWFzZSh0aGlzLmlkKTtcbiAgICB9LCBFLkFjdG9yID0gdC5BY3RvcjtcblxuICAgIHZhciBQID0gZnVuY3Rpb24gUChlLCBpLCBvKSB7XG4gICAgICB0aGlzLmJvdW5kcyA9IHQuTG5nTGF0Qm91bmRzLmNvbnZlcnQodGhpcy52YWxpZGF0ZUJvdW5kcyhlKSksIHRoaXMubWluem9vbSA9IGkgfHwgMCwgdGhpcy5tYXh6b29tID0gbyB8fCAyNDtcbiAgICB9O1xuXG4gICAgUC5wcm90b3R5cGUudmFsaWRhdGVCb3VuZHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgJiYgNCA9PT0gdC5sZW5ndGggPyBbTWF0aC5tYXgoLTE4MCwgdFswXSksIE1hdGgubWF4KC05MCwgdFsxXSksIE1hdGgubWluKDE4MCwgdFsyXSksIE1hdGgubWluKDkwLCB0WzNdKV0gOiBbLTE4MCwgLTkwLCAxODAsIDkwXTtcbiAgICB9LCBQLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IE1hdGgucG93KDIsIGUueiksXG4gICAgICAgICAgbyA9IE1hdGguZmxvb3IodC5tZXJjYXRvclhmcm9tTG5nKHRoaXMuYm91bmRzLmdldFdlc3QoKSkgKiBpKSxcbiAgICAgICAgICByID0gTWF0aC5mbG9vcih0Lm1lcmNhdG9yWWZyb21MYXQodGhpcy5ib3VuZHMuZ2V0Tm9ydGgoKSkgKiBpKSxcbiAgICAgICAgICBhID0gTWF0aC5jZWlsKHQubWVyY2F0b3JYZnJvbUxuZyh0aGlzLmJvdW5kcy5nZXRFYXN0KCkpICogaSksXG4gICAgICAgICAgbiA9IE1hdGguY2VpbCh0Lm1lcmNhdG9yWWZyb21MYXQodGhpcy5ib3VuZHMuZ2V0U291dGgoKSkgKiBpKTtcbiAgICAgIHJldHVybiBlLnggPj0gbyAmJiBlLnggPCBhICYmIGUueSA+PSByICYmIGUueSA8IG47XG4gICAgfTtcblxuICAgIHZhciBTID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoaSwgbywgciwgYSkge1xuICAgICAgICBpZiAoZS5jYWxsKHRoaXMpLCB0aGlzLmlkID0gaSwgdGhpcy5kaXNwYXRjaGVyID0gciwgdGhpcy50eXBlID0gXCJ2ZWN0b3JcIiwgdGhpcy5taW56b29tID0gMCwgdGhpcy5tYXh6b29tID0gMjIsIHRoaXMuc2NoZW1lID0gXCJ4eXpcIiwgdGhpcy50aWxlU2l6ZSA9IDUxMiwgdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCA9ICEwLCB0aGlzLmlzVGlsZUNsaXBwZWQgPSAhMCwgdGhpcy5fbG9hZGVkID0gITEsIHQuZXh0ZW5kKHRoaXMsIHQucGljayhvLCBbXCJ1cmxcIiwgXCJzY2hlbWVcIiwgXCJ0aWxlU2l6ZVwiLCBcInByb21vdGVJZFwiXSkpLCB0aGlzLl9vcHRpb25zID0gdC5leHRlbmQoe1xuICAgICAgICAgIHR5cGU6IFwidmVjdG9yXCJcbiAgICAgICAgfSwgbyksIHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyA9IG8uY29sbGVjdFJlc291cmNlVGltaW5nLCA1MTIgIT09IHRoaXMudGlsZVNpemUpIHRocm93IG5ldyBFcnJvcihcInZlY3RvciB0aWxlIHNvdXJjZXMgbXVzdCBoYXZlIGEgdGlsZVNpemUgb2YgNTEyXCIpO1xuICAgICAgICB0aGlzLnNldEV2ZW50ZWRQYXJlbnQoYSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9KSksIHRoaXMuX3RpbGVKU09OUmVxdWVzdCA9IEkodGhpcy5fb3B0aW9ucywgdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLCBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgIGUuX3RpbGVKU09OUmVxdWVzdCA9IG51bGwsIGUuX2xvYWRlZCA9ICEwLCBpID8gZS5maXJlKG5ldyB0LkVycm9yRXZlbnQoaSkpIDogbyAmJiAodC5leHRlbmQoZSwgbyksIG8uYm91bmRzICYmIChlLnRpbGVCb3VuZHMgPSBuZXcgUChvLmJvdW5kcywgZS5taW56b29tLCBlLm1heHpvb20pKSwgdC5wb3N0VHVybnN0aWxlRXZlbnQoby50aWxlcywgZS5tYXAuX3JlcXVlc3RNYW5hZ2VyLl9jdXN0b21BY2Nlc3NUb2tlbiksIHQucG9zdE1hcExvYWRFdmVudChvLnRpbGVzLCBlLm1hcC5fZ2V0TWFwSWQoKSwgZS5tYXAuX3JlcXVlc3RNYW5hZ2VyLl9za3VUb2tlbiwgZS5tYXAuX3JlcXVlc3RNYW5hZ2VyLl9jdXN0b21BY2Nlc3NUb2tlbiksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiXG4gICAgICAgICAgfSkpLCBlLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwiY29udGVudFwiXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZWQ7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnRpbGVCb3VuZHMgfHwgdGhpcy50aWxlQm91bmRzLmNvbnRhaW5zKHQuY2Fub25pY2FsKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldFNvdXJjZVByb3BlcnR5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdGlsZUpTT05SZXF1ZXN0ICYmIHRoaXMuX3RpbGVKU09OUmVxdWVzdC5jYW5jZWwoKSwgdCgpLCB0aGlzLm1hcC5zdHlsZS5zb3VyY2VDYWNoZXNbdGhpcy5pZF0uY2xlYXJUaWxlcygpLCB0aGlzLmxvYWQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldFRpbGVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3VyY2VQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS5fb3B0aW9ucy50aWxlcyA9IHQ7XG4gICAgICAgIH0pLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0VXJsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3VyY2VQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS51cmwgPSB0LCBlLl9vcHRpb25zLnVybCA9IHQ7XG4gICAgICAgIH0pLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RpbGVKU09OUmVxdWVzdCAmJiAodGhpcy5fdGlsZUpTT05SZXF1ZXN0LmNhbmNlbCgpLCB0aGlzLl90aWxlSlNPTlJlcXVlc3QgPSBudWxsKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplVGlsZVVSTChlLnRpbGVJRC5jYW5vbmljYWwudXJsKHRoaXMudGlsZXMsIHRoaXMuc2NoZW1lKSksXG4gICAgICAgICAgICByID0ge1xuICAgICAgICAgIHJlcXVlc3Q6IHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KG8sIHQuUmVzb3VyY2VUeXBlLlRpbGUpLFxuICAgICAgICAgIHVpZDogZS51aWQsXG4gICAgICAgICAgdGlsZUlEOiBlLnRpbGVJRCxcbiAgICAgICAgICB6b29tOiBlLnRpbGVJRC5vdmVyc2NhbGVkWixcbiAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSAqIGUudGlsZUlELm92ZXJzY2FsZUZhY3RvcigpLFxuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgcGl4ZWxSYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiB0aGlzLm1hcC5zaG93Q29sbGlzaW9uQm94ZXMsXG4gICAgICAgICAgcHJvbW90ZUlkOiB0aGlzLnByb21vdGVJZFxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGEobywgcikge1xuICAgICAgICAgIHJldHVybiBkZWxldGUgZS5yZXF1ZXN0LCBlLmFib3J0ZWQgPyBpKG51bGwpIDogbyAmJiA0MDQgIT09IG8uc3RhdHVzID8gaShvKSA6IChyICYmIHIucmVzb3VyY2VUaW1pbmcgJiYgKGUucmVzb3VyY2VUaW1pbmcgPSByLnJlc291cmNlVGltaW5nKSwgdGhpcy5tYXAuX3JlZnJlc2hFeHBpcmVkVGlsZXMgJiYgciAmJiBlLnNldEV4cGlyeURhdGEociksIGUubG9hZFZlY3RvckRhdGEociwgdGhpcy5tYXAucGFpbnRlciksIHQuY2FjaGVFbnRyeVBvc3NpYmx5QWRkZWQodGhpcy5kaXNwYXRjaGVyKSwgaShudWxsKSwgdm9pZCAoZS5yZWxvYWRDYWxsYmFjayAmJiAodGhpcy5sb2FkVGlsZShlLCBlLnJlbG9hZENhbGxiYWNrKSwgZS5yZWxvYWRDYWxsYmFjayA9IG51bGwpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByLnJlcXVlc3QuY29sbGVjdFJlc291cmNlVGltaW5nID0gdGhpcy5fY29sbGVjdFJlc291cmNlVGltaW5nLCBlLmFjdG9yICYmIFwiZXhwaXJlZFwiICE9PSBlLnN0YXRlID8gXCJsb2FkaW5nXCIgPT09IGUuc3RhdGUgPyBlLnJlbG9hZENhbGxiYWNrID0gaSA6IGUucmVxdWVzdCA9IGUuYWN0b3Iuc2VuZChcInJlbG9hZFRpbGVcIiwgciwgYS5iaW5kKHRoaXMpKSA6IChlLmFjdG9yID0gdGhpcy5kaXNwYXRjaGVyLmdldEFjdG9yKCksIGUucmVxdWVzdCA9IGUuYWN0b3Iuc2VuZChcImxvYWRUaWxlXCIsIHIsIGEuYmluZCh0aGlzKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWJvcnRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5yZXF1ZXN0ICYmICh0LnJlcXVlc3QuY2FuY2VsKCksIGRlbGV0ZSB0LnJlcXVlc3QpLCB0LmFjdG9yICYmIHQuYWN0b3Iuc2VuZChcImFib3J0VGlsZVwiLCB7XG4gICAgICAgICAgdWlkOiB0LnVpZCxcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51bmxvYWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC51bmxvYWRWZWN0b3JEYXRhKCksIHQuYWN0b3IgJiYgdC5hY3Rvci5zZW5kKFwicmVtb3ZlVGlsZVwiLCB7XG4gICAgICAgICAgdWlkOiB0LnVpZCxcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgQyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLmlkID0gaSwgdGhpcy5kaXNwYXRjaGVyID0gciwgdGhpcy5zZXRFdmVudGVkUGFyZW50KGEpLCB0aGlzLnR5cGUgPSBcInJhc3RlclwiLCB0aGlzLm1pbnpvb20gPSAwLCB0aGlzLm1heHpvb20gPSAyMiwgdGhpcy5yb3VuZFpvb20gPSAhMCwgdGhpcy5zY2hlbWUgPSBcInh5elwiLCB0aGlzLnRpbGVTaXplID0gNTEyLCB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5fb3B0aW9ucyA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInJhc3RlclwiXG4gICAgICAgIH0sIG8pLCB0LmV4dGVuZCh0aGlzLCB0LnBpY2sobywgW1widXJsXCIsIFwic2NoZW1lXCIsIFwidGlsZVNpemVcIl0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiXG4gICAgICAgIH0pKSwgdGhpcy5fdGlsZUpTT05SZXF1ZXN0ID0gSSh0aGlzLl9vcHRpb25zLCB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIsIGZ1bmN0aW9uIChpLCBvKSB7XG4gICAgICAgICAgZS5fdGlsZUpTT05SZXF1ZXN0ID0gbnVsbCwgZS5fbG9hZGVkID0gITAsIGkgPyBlLmZpcmUobmV3IHQuRXJyb3JFdmVudChpKSkgOiBvICYmICh0LmV4dGVuZChlLCBvKSwgby5ib3VuZHMgJiYgKGUudGlsZUJvdW5kcyA9IG5ldyBQKG8uYm91bmRzLCBlLm1pbnpvb20sIGUubWF4em9vbSkpLCB0LnBvc3RUdXJuc3RpbGVFdmVudChvLnRpbGVzKSwgdC5wb3N0TWFwTG9hZEV2ZW50KG8udGlsZXMsIGUubWFwLl9nZXRNYXBJZCgpLCBlLm1hcC5fcmVxdWVzdE1hbmFnZXIuX3NrdVRva2VuKSwgZS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcIm1ldGFkYXRhXCJcbiAgICAgICAgICB9KSksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJjb250ZW50XCJcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aWxlSlNPTlJlcXVlc3QgJiYgKHRoaXMuX3RpbGVKU09OUmVxdWVzdC5jYW5jZWwoKSwgdGhpcy5fdGlsZUpTT05SZXF1ZXN0ID0gbnVsbCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnRpbGVCb3VuZHMgfHwgdGhpcy50aWxlQm91bmRzLmNvbnRhaW5zKHQuY2Fub25pY2FsKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLFxuICAgICAgICAgICAgciA9IHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci5ub3JtYWxpemVUaWxlVVJMKGUudGlsZUlELmNhbm9uaWNhbC51cmwodGhpcy50aWxlcywgdGhpcy5zY2hlbWUpLCB0aGlzLnRpbGVTaXplKTtcblxuICAgICAgICBlLnJlcXVlc3QgPSB0LmdldEltYWdlKHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KHIsIHQuUmVzb3VyY2VUeXBlLlRpbGUpLCBmdW5jdGlvbiAociwgYSkge1xuICAgICAgICAgIGlmIChkZWxldGUgZS5yZXF1ZXN0LCBlLmFib3J0ZWQpIGUuc3RhdGUgPSBcInVubG9hZGVkXCIsIGkobnVsbCk7ZWxzZSBpZiAocikgZS5zdGF0ZSA9IFwiZXJyb3JlZFwiLCBpKHIpO2Vsc2UgaWYgKGEpIHtcbiAgICAgICAgICAgIG8ubWFwLl9yZWZyZXNoRXhwaXJlZFRpbGVzICYmIGUuc2V0RXhwaXJ5RGF0YShhKSwgZGVsZXRlIGEuY2FjaGVDb250cm9sLCBkZWxldGUgYS5leHBpcmVzO1xuICAgICAgICAgICAgdmFyIG4gPSBvLm1hcC5wYWludGVyLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgcyA9IG4uZ2w7XG4gICAgICAgICAgICBlLnRleHR1cmUgPSBvLm1hcC5wYWludGVyLmdldFRpbGVUZXh0dXJlKGEud2lkdGgpLCBlLnRleHR1cmUgPyBlLnRleHR1cmUudXBkYXRlKGEsIHtcbiAgICAgICAgICAgICAgdXNlTWlwbWFwOiAhMFxuICAgICAgICAgICAgfSkgOiAoZS50ZXh0dXJlID0gbmV3IHQuVGV4dHVyZShuLCBhLCBzLlJHQkEsIHtcbiAgICAgICAgICAgICAgdXNlTWlwbWFwOiAhMFxuICAgICAgICAgICAgfSksIGUudGV4dHVyZS5iaW5kKHMuTElORUFSLCBzLkNMQU1QX1RPX0VER0UsIHMuTElORUFSX01JUE1BUF9ORUFSRVNUKSwgbi5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMgJiYgcy50ZXhQYXJhbWV0ZXJmKHMuVEVYVFVSRV8yRCwgbi5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIG4uZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljTWF4KSksIGUuc3RhdGUgPSBcImxvYWRlZFwiLCB0LmNhY2hlRW50cnlQb3NzaWJseUFkZGVkKG8uZGlzcGF0Y2hlciksIGkobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFib3J0VGlsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHQucmVxdWVzdCAmJiAodC5yZXF1ZXN0LmNhbmNlbCgpLCBkZWxldGUgdC5yZXF1ZXN0KSwgZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudW5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHQudGV4dHVyZSAmJiB0aGlzLm1hcC5wYWludGVyLnNhdmVUaWxlVGV4dHVyZSh0LnRleHR1cmUpLCBlKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgeiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMsIGksIG8sIHIsIGEpLCB0aGlzLnR5cGUgPSBcInJhc3Rlci1kZW1cIiwgdGhpcy5tYXh6b29tID0gMjIsIHRoaXMuX29wdGlvbnMgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgdHlwZTogXCJyYXN0ZXItZGVtXCJcbiAgICAgICAgfSwgbyksIHRoaXMuZW5jb2RpbmcgPSBvLmVuY29kaW5nIHx8IFwibWFwYm94XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInJhc3Rlci1kZW1cIixcbiAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgIHRpbGVzOiB0aGlzLnRpbGVzLFxuICAgICAgICAgIGJvdW5kczogdGhpcy5ib3VuZHMsXG4gICAgICAgICAgZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmdcbiAgICAgICAgfTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplVGlsZVVSTChlLnRpbGVJRC5jYW5vbmljYWwudXJsKHRoaXMudGlsZXMsIHRoaXMuc2NoZW1lKSwgdGhpcy50aWxlU2l6ZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcih0LCBvKSB7XG4gICAgICAgICAgdCAmJiAoZS5zdGF0ZSA9IFwiZXJyb3JlZFwiLCBpKHQpKSwgbyAmJiAoZS5kZW0gPSBvLCBlLm5lZWRzSGlsbHNoYWRlUHJlcGFyZSA9ICEwLCBlLnN0YXRlID0gXCJsb2FkZWRcIiwgaShudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnJlcXVlc3QgPSB0LmdldEltYWdlKHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KG8sIHQuUmVzb3VyY2VUeXBlLlRpbGUpLCBmdW5jdGlvbiAobywgYSkge1xuICAgICAgICAgIGlmIChkZWxldGUgZS5yZXF1ZXN0LCBlLmFib3J0ZWQpIGUuc3RhdGUgPSBcInVubG9hZGVkXCIsIGkobnVsbCk7ZWxzZSBpZiAobykgZS5zdGF0ZSA9IFwiZXJyb3JlZFwiLCBpKG8pO2Vsc2UgaWYgKGEpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLl9yZWZyZXNoRXhwaXJlZFRpbGVzICYmIGUuc2V0RXhwaXJ5RGF0YShhKSwgZGVsZXRlIGEuY2FjaGVDb250cm9sLCBkZWxldGUgYS5leHBpcmVzO1xuICAgICAgICAgICAgdmFyIG4gPSB0LndpbmRvdy5JbWFnZUJpdG1hcCAmJiBhIGluc3RhbmNlb2YgdC53aW5kb3cuSW1hZ2VCaXRtYXAgJiYgdC5vZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSA/IGEgOiB0LmJyb3dzZXIuZ2V0SW1hZ2VEYXRhKGEsIDEpLFxuICAgICAgICAgICAgICAgIHMgPSB7XG4gICAgICAgICAgICAgIHVpZDogZS51aWQsXG4gICAgICAgICAgICAgIGNvb3JkOiBlLnRpbGVJRCxcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgICByYXdJbWFnZURhdGE6IG4sXG4gICAgICAgICAgICAgIGVuY29kaW5nOiB0aGlzLmVuY29kaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZS5hY3RvciAmJiBcImV4cGlyZWRcIiAhPT0gZS5zdGF0ZSB8fCAoZS5hY3RvciA9IHRoaXMuZGlzcGF0Y2hlci5nZXRBY3RvcigpLCBlLmFjdG9yLnNlbmQoXCJsb2FkREVNVGlsZVwiLCBzLCByLmJpbmQodGhpcykpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSksIGUubmVpZ2hib3JpbmdUaWxlcyA9IHRoaXMuX2dldE5laWdoYm9yaW5nVGlsZXMoZS50aWxlSUQpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2dldE5laWdoYm9yaW5nVGlsZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IGUuY2Fub25pY2FsLFxuICAgICAgICAgICAgbyA9IE1hdGgucG93KDIsIGkueiksXG4gICAgICAgICAgICByID0gKGkueCAtIDEgKyBvKSAlIG8sXG4gICAgICAgICAgICBhID0gMCA9PT0gaS54ID8gZS53cmFwIC0gMSA6IGUud3JhcCxcbiAgICAgICAgICAgIG4gPSAoaS54ICsgMSArIG8pICUgbyxcbiAgICAgICAgICAgIHMgPSBpLnggKyAxID09PSBvID8gZS53cmFwICsgMSA6IGUud3JhcCxcbiAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgcmV0dXJuIGxbbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLm92ZXJzY2FsZWRaLCBhLCBpLnosIHIsIGkueSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9LCBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgcywgaS56LCBuLCBpLnkpLmtleV0gPSB7XG4gICAgICAgICAgYmFja2ZpbGxlZDogITFcbiAgICAgICAgfSwgaS55ID4gMCAmJiAobFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGEsIGkueiwgciwgaS55IC0gMSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9LCBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgZS53cmFwLCBpLnosIGkueCwgaS55IC0gMSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9LCBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgcywgaS56LCBuLCBpLnkgLSAxKS5rZXldID0ge1xuICAgICAgICAgIGJhY2tmaWxsZWQ6ICExXG4gICAgICAgIH0pLCBpLnkgKyAxIDwgbyAmJiAobFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGEsIGkueiwgciwgaS55ICsgMSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9LCBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgZS53cmFwLCBpLnosIGkueCwgaS55ICsgMSkua2V5XSA9IHtcbiAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICB9LCBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgcywgaS56LCBuLCBpLnkgKyAxKS5rZXldID0ge1xuICAgICAgICAgIGJhY2tmaWxsZWQ6ICExXG4gICAgICAgIH0pLCBsO1xuICAgICAgfSwgaS5wcm90b3R5cGUudW5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQuZGVtVGV4dHVyZSAmJiB0aGlzLm1hcC5wYWludGVyLnNhdmVUaWxlVGV4dHVyZSh0LmRlbVRleHR1cmUpLCB0LmZibyAmJiAodC5mYm8uZGVzdHJveSgpLCBkZWxldGUgdC5mYm8pLCB0LmRlbSAmJiBkZWxldGUgdC5kZW0sIGRlbGV0ZSB0Lm5laWdoYm9yaW5nVGlsZXMsIHQuc3RhdGUgPSBcInVubG9hZGVkXCIsIHQuYWN0b3IgJiYgdC5hY3Rvci5zZW5kKFwicmVtb3ZlREVNVGlsZVwiLCB7XG4gICAgICAgICAgdWlkOiB0LnVpZCxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICB9LCBpO1xuICAgIH0oQyksXG4gICAgICAgIEQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaShpLCBvLCByLCBhKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGksIHRoaXMudHlwZSA9IFwiZ2VvanNvblwiLCB0aGlzLm1pbnpvb20gPSAwLCB0aGlzLm1heHpvb20gPSAxOCwgdGhpcy50aWxlU2l6ZSA9IDUxMiwgdGhpcy5pc1RpbGVDbGlwcGVkID0gITAsIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPSAhMCwgdGhpcy5fcmVtb3ZlZCA9ICExLCB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5hY3RvciA9IHIuZ2V0QWN0b3IoKSwgdGhpcy5zZXRFdmVudGVkUGFyZW50KGEpLCB0aGlzLl9kYXRhID0gby5kYXRhLCB0aGlzLl9vcHRpb25zID0gdC5leHRlbmQoe30sIG8pLCB0aGlzLl9jb2xsZWN0UmVzb3VyY2VUaW1pbmcgPSBvLmNvbGxlY3RSZXNvdXJjZVRpbWluZywgdGhpcy5fcmVzb3VyY2VUaW1pbmcgPSBbXSwgdm9pZCAwICE9PSBvLm1heHpvb20gJiYgKHRoaXMubWF4em9vbSA9IG8ubWF4em9vbSksIG8udHlwZSAmJiAodGhpcy50eXBlID0gby50eXBlKSwgby5hdHRyaWJ1dGlvbiAmJiAodGhpcy5hdHRyaWJ1dGlvbiA9IG8uYXR0cmlidXRpb24pLCB0aGlzLnByb21vdGVJZCA9IG8ucHJvbW90ZUlkO1xuICAgICAgICB2YXIgbiA9IHQuRVhURU5UIC8gdGhpcy50aWxlU2l6ZTtcbiAgICAgICAgdGhpcy53b3JrZXJPcHRpb25zID0gdC5leHRlbmQoe1xuICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICBjbHVzdGVyOiBvLmNsdXN0ZXIgfHwgITEsXG4gICAgICAgICAgZ2VvanNvblZ0T3B0aW9uczoge1xuICAgICAgICAgICAgYnVmZmVyOiAodm9pZCAwICE9PSBvLmJ1ZmZlciA/IG8uYnVmZmVyIDogMTI4KSAqIG4sXG4gICAgICAgICAgICB0b2xlcmFuY2U6ICh2b2lkIDAgIT09IG8udG9sZXJhbmNlID8gby50b2xlcmFuY2UgOiAuMzc1KSAqIG4sXG4gICAgICAgICAgICBleHRlbnQ6IHQuRVhURU5ULFxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgICAgbGluZU1ldHJpY3M6IG8ubGluZU1ldHJpY3MgfHwgITEsXG4gICAgICAgICAgICBnZW5lcmF0ZUlkOiBvLmdlbmVyYXRlSWQgfHwgITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN1cGVyY2x1c3Rlck9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1heFpvb206IHZvaWQgMCAhPT0gby5jbHVzdGVyTWF4Wm9vbSA/IE1hdGgubWluKG8uY2x1c3Rlck1heFpvb20sIHRoaXMubWF4em9vbSAtIDEpIDogdGhpcy5tYXh6b29tIC0gMSxcbiAgICAgICAgICAgIG1pblBvaW50czogTWF0aC5tYXgoMiwgby5jbHVzdGVyTWluUG9pbnRzIHx8IDIpLFxuICAgICAgICAgICAgZXh0ZW50OiB0LkVYVEVOVCxcbiAgICAgICAgICAgIHJhZGl1czogKG8uY2x1c3RlclJhZGl1cyB8fCA1MCkgKiBuLFxuICAgICAgICAgICAgbG9nOiAhMSxcbiAgICAgICAgICAgIGdlbmVyYXRlSWQ6IG8uZ2VuZXJhdGVJZCB8fCAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2x1c3RlclByb3BlcnRpZXM6IG8uY2x1c3RlclByb3BlcnRpZXMsXG4gICAgICAgICAgZmlsdGVyOiBvLmZpbHRlclxuICAgICAgICB9LCBvLndvcmtlck9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9KSksIHRoaXMuX3VwZGF0ZVdvcmtlckRhdGEoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBpZiAoaSkgZS5maXJlKG5ldyB0LkVycm9yRXZlbnQoaSkpO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZS5fY29sbGVjdFJlc291cmNlVGltaW5nICYmIGUuX3Jlc291cmNlVGltaW5nICYmIGUuX3Jlc291cmNlVGltaW5nLmxlbmd0aCA+IDAgJiYgKG8ucmVzb3VyY2VUaW1pbmcgPSBlLl9yZXNvdXJjZVRpbWluZywgZS5fcmVzb3VyY2VUaW1pbmcgPSBbXSksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwgbykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YSA9IGUsIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9KSksIHRoaXMuX3VwZGF0ZVdvcmtlckRhdGEoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZSkgaS5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJjb250ZW50XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpLl9jb2xsZWN0UmVzb3VyY2VUaW1pbmcgJiYgaS5fcmVzb3VyY2VUaW1pbmcgJiYgaS5fcmVzb3VyY2VUaW1pbmcubGVuZ3RoID4gMCAmJiAoby5yZXNvdXJjZVRpbWluZyA9IGkuX3Jlc291cmNlVGltaW5nLCBpLl9yZXNvdXJjZVRpbWluZyA9IFtdKSwgaS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCBvKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldENsdXN0ZXJFeHBhbnNpb25ab29tID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3Iuc2VuZChcImdlb2pzb24uZ2V0Q2x1c3RlckV4cGFuc2lvblpvb21cIiwge1xuICAgICAgICAgIGNsdXN0ZXJJZDogdCxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRDbHVzdGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rvci5zZW5kKFwiZ2VvanNvbi5nZXRDbHVzdGVyQ2hpbGRyZW5cIiwge1xuICAgICAgICAgIGNsdXN0ZXJJZDogdCxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRDbHVzdGVyTGVhdmVzID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3Iuc2VuZChcImdlb2pzb24uZ2V0Q2x1c3RlckxlYXZlc1wiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgIGNsdXN0ZXJJZDogdCxcbiAgICAgICAgICBsaW1pdDogZSxcbiAgICAgICAgICBvZmZzZXQ6IGlcbiAgICAgICAgfSwgbyksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdXBkYXRlV29ya2VyRGF0YSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gITE7XG4gICAgICAgIHZhciBvID0gdC5leHRlbmQoe30sIHRoaXMud29ya2VyT3B0aW9ucyksXG4gICAgICAgICAgICByID0gdGhpcy5fZGF0YTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgciA/IChvLnJlcXVlc3QgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdCh0LmJyb3dzZXIucmVzb2x2ZVVSTChyKSwgdC5SZXNvdXJjZVR5cGUuU291cmNlKSwgby5yZXF1ZXN0LmNvbGxlY3RSZXNvdXJjZVRpbWluZyA9IHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZykgOiBvLmRhdGEgPSBKU09OLnN0cmluZ2lmeShyKSwgdGhpcy5hY3Rvci5zZW5kKHRoaXMudHlwZSArIFwiLmxvYWREYXRhXCIsIG8sIGZ1bmN0aW9uICh0LCByKSB7XG4gICAgICAgICAgaS5fcmVtb3ZlZCB8fCByICYmIHIuYWJhbmRvbmVkIHx8IChpLl9sb2FkZWQgPSAhMCwgciAmJiByLnJlc291cmNlVGltaW5nICYmIHIucmVzb3VyY2VUaW1pbmdbaS5pZF0gJiYgKGkuX3Jlc291cmNlVGltaW5nID0gci5yZXNvdXJjZVRpbWluZ1tpLmlkXS5zbGljZSgwKSksIGkuYWN0b3Iuc2VuZChpLnR5cGUgKyBcIi5jb2FsZXNjZVwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IG8uc291cmNlXG4gICAgICAgICAgfSwgbnVsbCksIGUodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLFxuICAgICAgICAgICAgciA9IGUuYWN0b3IgPyBcInJlbG9hZFRpbGVcIiA6IFwibG9hZFRpbGVcIjtcbiAgICAgICAgZS5hY3RvciA9IHRoaXMuYWN0b3IsIGUucmVxdWVzdCA9IHRoaXMuYWN0b3Iuc2VuZChyLCB7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHVpZDogZS51aWQsXG4gICAgICAgICAgdGlsZUlEOiBlLnRpbGVJRCxcbiAgICAgICAgICB6b29tOiBlLnRpbGVJRC5vdmVyc2NhbGVkWixcbiAgICAgICAgICBtYXhab29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgIHBpeGVsUmF0aW86IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczogdGhpcy5tYXAuc2hvd0NvbGxpc2lvbkJveGVzLFxuICAgICAgICAgIHByb21vdGVJZDogdGhpcy5wcm9tb3RlSWRcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGEpIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlIGUucmVxdWVzdCwgZS51bmxvYWRWZWN0b3JEYXRhKCksIGUuYWJvcnRlZCA/IGkobnVsbCkgOiB0ID8gaSh0KSA6IChlLmxvYWRWZWN0b3JEYXRhKGEsIG8ubWFwLnBhaW50ZXIsIFwicmVsb2FkVGlsZVwiID09PSByKSwgaShudWxsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWJvcnRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5yZXF1ZXN0ICYmICh0LnJlcXVlc3QuY2FuY2VsKCksIGRlbGV0ZSB0LnJlcXVlc3QpLCB0LmFib3J0ZWQgPSAhMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVubG9hZFRpbGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnVubG9hZFZlY3RvckRhdGEoKSwgdGhpcy5hY3Rvci5zZW5kKFwicmVtb3ZlVGlsZVwiLCB7XG4gICAgICAgICAgdWlkOiB0LnVpZCxcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZWQgPSAhMCwgdGhpcy5hY3Rvci5zZW5kKFwicmVtb3ZlU291cmNlXCIsIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMsIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgZGF0YTogdGhpcy5fZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGk7XG4gICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgICBBID0gdC5jcmVhdGVMYXlvdXQoW3tcbiAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIGNvbXBvbmVudHM6IDJcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImFfdGV4dHVyZV9wb3NcIixcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIGNvbXBvbmVudHM6IDJcbiAgICB9XSksXG4gICAgICAgIE0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaSh0LCBpLCBvLCByKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IHQsIHRoaXMuZGlzcGF0Y2hlciA9IG8sIHRoaXMuY29vcmRpbmF0ZXMgPSBpLmNvb3JkaW5hdGVzLCB0aGlzLnR5cGUgPSBcImltYWdlXCIsIHRoaXMubWluem9vbSA9IDAsIHRoaXMubWF4em9vbSA9IDIyLCB0aGlzLnRpbGVTaXplID0gNTEyLCB0aGlzLnRpbGVzID0ge30sIHRoaXMuX2xvYWRlZCA9ICExLCB0aGlzLnNldEV2ZW50ZWRQYXJlbnQociksIHRoaXMub3B0aW9ucyA9IGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9ICExLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgfSkpLCB0aGlzLnVybCA9IHRoaXMub3B0aW9ucy51cmwsIHQuZ2V0SW1hZ2UodGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QodGhpcy51cmwsIHQuUmVzb3VyY2VUeXBlLkltYWdlKSwgZnVuY3Rpb24gKHIsIGEpIHtcbiAgICAgICAgICBvLl9sb2FkZWQgPSAhMCwgciA/IG8uZmlyZShuZXcgdC5FcnJvckV2ZW50KHIpKSA6IGEgJiYgKG8uaW1hZ2UgPSBhLCBlICYmIChvLmNvb3JkaW5hdGVzID0gZSksIGkgJiYgaSgpLCBvLl9maW5pc2hMb2FkaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZUltYWdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZSAmJiB0LnVybCA/ICh0aGlzLm9wdGlvbnMudXJsID0gdC51cmwsIHRoaXMubG9hZCh0LmNvb3JkaW5hdGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfSksIHRoaXMpIDogdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLl9maW5pc2hMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hcCAmJiAodGhpcy5zZXRDb29yZGluYXRlcyh0aGlzLmNvb3JkaW5hdGVzKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwibWV0YWRhdGFcIlxuICAgICAgICB9KSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm1hcCA9IHQsIHRoaXMubG9hZCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBlO1xuICAgICAgICB2YXIgbyA9IGUubWFwKHQuTWVyY2F0b3JDb29yZGluYXRlLmZyb21MbmdMYXQpO1xuICAgICAgICB0aGlzLnRpbGVJRCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEgLyAwLCBvID0gMSAvIDAsIHIgPSAtMSAvIDAsIGEgPSAtMSAvIDAsIG4gPSAwLCBzID0gZTsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsID0gc1tuXTtcbiAgICAgICAgICAgIGkgPSBNYXRoLm1pbihpLCBsLngpLCBvID0gTWF0aC5taW4obywgbC55KSwgciA9IE1hdGgubWF4KHIsIGwueCksIGEgPSBNYXRoLm1heChhLCBsLnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjID0gTWF0aC5tYXgociAtIGksIGEgLSBvKSxcbiAgICAgICAgICAgICAgdSA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoLU1hdGgubG9nKGMpIC8gTWF0aC5MTjIpKSxcbiAgICAgICAgICAgICAgaCA9IE1hdGgucG93KDIsIHUpO1xuICAgICAgICAgIHJldHVybiBuZXcgdC5DYW5vbmljYWxUaWxlSUQodSwgTWF0aC5mbG9vcigoaSArIHIpIC8gMiAqIGgpLCBNYXRoLmZsb29yKChvICsgYSkgLyAyICogaCkpO1xuICAgICAgICB9KG8pLCB0aGlzLm1pbnpvb20gPSB0aGlzLm1heHpvb20gPSB0aGlzLnRpbGVJRC56O1xuICAgICAgICB2YXIgciA9IG8ubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGkudGlsZUlELmdldFRpbGVQb2ludCh0KS5fcm91bmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHNBcnJheSA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0NGk4KCksIHRoaXMuX2JvdW5kc0FycmF5LmVtcGxhY2VCYWNrKHJbMF0ueCwgclswXS55LCAwLCAwKSwgdGhpcy5fYm91bmRzQXJyYXkuZW1wbGFjZUJhY2soclsxXS54LCByWzFdLnksIHQuRVhURU5ULCAwKSwgdGhpcy5fYm91bmRzQXJyYXkuZW1wbGFjZUJhY2soclszXS54LCByWzNdLnksIDAsIHQuRVhURU5UKSwgdGhpcy5fYm91bmRzQXJyYXkuZW1wbGFjZUJhY2soclsyXS54LCByWzJdLnksIHQuRVhURU5ULCB0LkVYVEVOVCksIHRoaXMuYm91bmRzQnVmZmVyICYmICh0aGlzLmJvdW5kc0J1ZmZlci5kZXN0cm95KCksIGRlbGV0ZSB0aGlzLmJvdW5kc0J1ZmZlciksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcImNvbnRlbnRcIlxuICAgICAgICB9KSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoMCAhPT0gT2JqZWN0LmtleXModGhpcy50aWxlcykubGVuZ3RoICYmIHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMubWFwLnBhaW50ZXIuY29udGV4dCxcbiAgICAgICAgICAgICAgaSA9IGUuZ2w7XG5cbiAgICAgICAgICBmb3IgKHZhciBvIGluIHRoaXMuYm91bmRzQnVmZmVyIHx8ICh0aGlzLmJvdW5kc0J1ZmZlciA9IGUuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuX2JvdW5kc0FycmF5LCBBLm1lbWJlcnMpKSwgdGhpcy5ib3VuZHNTZWdtZW50cyB8fCAodGhpcy5ib3VuZHNTZWdtZW50cyA9IHQuU2VnbWVudFZlY3Rvci5zaW1wbGVTZWdtZW50KDAsIDAsIDQsIDIpKSwgdGhpcy50ZXh0dXJlIHx8ICh0aGlzLnRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKGUsIHRoaXMuaW1hZ2UsIGkuUkdCQSksIHRoaXMudGV4dHVyZS5iaW5kKGkuTElORUFSLCBpLkNMQU1QX1RPX0VER0UpKSwgdGhpcy50aWxlcykge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnRpbGVzW29dO1xuICAgICAgICAgICAgXCJsb2FkZWRcIiAhPT0gci5zdGF0ZSAmJiAoci5zdGF0ZSA9IFwibG9hZGVkXCIsIHIudGV4dHVyZSA9IHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMudGlsZUlEICYmIHRoaXMudGlsZUlELmVxdWFscyh0LnRpbGVJRC5jYW5vbmljYWwpID8gKHRoaXMudGlsZXNbU3RyaW5nKHQudGlsZUlELndyYXApXSA9IHQsIHQuYnVja2V0cyA9IHt9LCBlKG51bGwpKSA6ICh0LnN0YXRlID0gXCJlcnJvcmVkXCIsIGUobnVsbCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy51cmwsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHRoaXMuY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGk7XG4gICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgICBMID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkodCwgaSwgbywgcikge1xuICAgICAgICBlLmNhbGwodGhpcywgdCwgaSwgbywgciksIHRoaXMucm91bmRab29tID0gITAsIHRoaXMudHlwZSA9IFwidmlkZW9cIiwgdGhpcy5vcHRpb25zID0gaTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudXJscyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIG8gPSAwLCByID0gaS51cmxzOyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgIHRoaXMudXJscy5wdXNoKHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KHJbb10sIHQuUmVzb3VyY2VUeXBlLlNvdXJjZSkudXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuZ2V0VmlkZW8odGhpcy51cmxzLCBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgIGUuX2xvYWRlZCA9ICEwLCBpID8gZS5maXJlKG5ldyB0LkVycm9yRXZlbnQoaSkpIDogbyAmJiAoZS52aWRlbyA9IG8sIGUudmlkZW8ubG9vcCA9ICEwLCBlLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGUubWFwLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgICAgICAgfSksIGUubWFwICYmIGUudmlkZW8ucGxheSgpLCBlLl9maW5pc2hMb2FkaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8ucGF1c2UoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMudmlkZW8uc2Vla2FibGU7XG4gICAgICAgICAgZSA8IGkuc3RhcnQoMCkgfHwgZSA+IGkuZW5kKDApID8gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IHQuVmFsaWRhdGlvbkVycm9yKFwic291cmNlcy5cIiArIHRoaXMuaWQsIG51bGwsIFwiUGxheWJhY2sgZm9yIHRoaXMgdmlkZW8gY2FuIGJlIHNldCBvbmx5IGJldHdlZW4gdGhlIFwiICsgaS5zdGFydCgwKSArIFwiIGFuZCBcIiArIGkuZW5kKDApICsgXCItc2Vjb25kIG1hcmsuXCIpKSkgOiB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lID0gZTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VmlkZW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm1hcCB8fCAodGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKSwgdGhpcy52aWRlbyAmJiAodGhpcy52aWRlby5wbGF5KCksIHRoaXMuc2V0Q29vcmRpbmF0ZXModGhpcy5jb29yZGluYXRlcykpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKDAgPT09IE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aCB8fCB0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPCAyKSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5tYXAucGFpbnRlci5jb250ZXh0LFxuICAgICAgICAgICAgICBpID0gZS5nbDtcblxuICAgICAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5ib3VuZHNCdWZmZXIgfHwgKHRoaXMuYm91bmRzQnVmZmVyID0gZS5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5fYm91bmRzQXJyYXksIEEubWVtYmVycykpLCB0aGlzLmJvdW5kc1NlZ21lbnRzIHx8ICh0aGlzLmJvdW5kc1NlZ21lbnRzID0gdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMCwgNCwgMikpLCB0aGlzLnRleHR1cmUgPyB0aGlzLnZpZGVvLnBhdXNlZCB8fCAodGhpcy50ZXh0dXJlLmJpbmQoaS5MSU5FQVIsIGkuQ0xBTVBfVE9fRURHRSksIGkudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGkuUkdCQSwgaS5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKSkgOiAodGhpcy50ZXh0dXJlID0gbmV3IHQuVGV4dHVyZShlLCB0aGlzLnZpZGVvLCBpLlJHQkEpLCB0aGlzLnRleHR1cmUuYmluZChpLkxJTkVBUiwgaS5DTEFNUF9UT19FREdFKSksIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy50aWxlc1tvXTtcbiAgICAgICAgICAgIFwibG9hZGVkXCIgIT09IHIuc3RhdGUgJiYgKHIuc3RhdGUgPSBcImxvYWRlZFwiLCByLnRleHR1cmUgPSB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgICAgICB1cmxzOiB0aGlzLnVybHMsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHRoaXMuY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvICYmICF0aGlzLnZpZGVvLnBhdXNlZDtcbiAgICAgIH0sIGk7XG4gICAgfShNKSxcbiAgICAgICAgUiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgZS5jYWxsKHRoaXMsIGksIG8sIHIsIGEpLCBvLmNvb3JkaW5hdGVzID8gQXJyYXkuaXNBcnJheShvLmNvb3JkaW5hdGVzKSAmJiA0ID09PSBvLmNvb3JkaW5hdGVzLmxlbmd0aCAmJiAhby5jb29yZGluYXRlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHQpIHx8IDIgIT09IHQubGVuZ3RoIHx8IHQuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pIHx8IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnXCJjb29yZGluYXRlc1wiIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXkgb2YgNCBsb25naXR1ZGUvbGF0aXR1ZGUgYXJyYXkgcGFpcnMnKSkpIDogdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IHQuVmFsaWRhdGlvbkVycm9yKFwic291cmNlcy5cIiArIGksIG51bGwsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwiY29vcmRpbmF0ZXNcIicpKSksIG8uYW5pbWF0ZSAmJiBcImJvb2xlYW5cIiAhPSB0eXBlb2Ygby5hbmltYXRlICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnb3B0aW9uYWwgXCJhbmltYXRlXCIgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWUnKSkpLCBvLmNhbnZhcyA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIG8uY2FudmFzIHx8IG8uY2FudmFzIGluc3RhbmNlb2YgdC53aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQgfHwgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IHQuVmFsaWRhdGlvbkVycm9yKFwic291cmNlcy5cIiArIGksIG51bGwsICdcImNhbnZhc1wiIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgSUQgb2YgdGhlIGNhbnZhcyBlbGVtZW50IGZyb20gd2hpY2ggdG8gcmVhZCwgb3IgYW4gSFRNTENhbnZhc0VsZW1lbnQgaW5zdGFuY2UnKSkpIDogdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IHQuVmFsaWRhdGlvbkVycm9yKFwic291cmNlcy5cIiArIGksIG51bGwsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwiY2FudmFzXCInKSkpLCB0aGlzLm9wdGlvbnMgPSBvLCB0aGlzLmFuaW1hdGUgPSB2b2lkIDAgPT09IG8uYW5pbWF0ZSB8fCBvLmFuaW1hdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9ICEwLCB0aGlzLmNhbnZhcyB8fCAodGhpcy5jYW52YXMgPSB0aGlzLm9wdGlvbnMuY2FudmFzIGluc3RhbmNlb2YgdC53aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQgPyB0aGlzLm9wdGlvbnMuY2FudmFzIDogdC53aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmNhbnZhcykpLCB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0LCB0aGlzLl9oYXNJbnZhbGlkRGltZW5zaW9ucygpID8gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiQ2FudmFzIGRpbWVuc2lvbnMgY2Fubm90IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvLlwiKSkpIDogKHRoaXMucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9wbGF5aW5nID0gITAsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgICAgIH0sIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fcGxheWluZyAmJiAodGhpcy5wcmVwYXJlKCksIHRoaXMuX3BsYXlpbmcgPSAhMSk7XG4gICAgICAgIH0sIHRoaXMuX2ZpbmlzaExvYWRpbmcoKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKSwgdGhpcy5jYW52YXMgJiYgdGhpcy5hbmltYXRlICYmIHRoaXMucGxheSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gITE7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLndpZHRoICE9PSB0aGlzLndpZHRoICYmICh0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGgsIGUgPSAhMCksIHRoaXMuY2FudmFzLmhlaWdodCAhPT0gdGhpcy5oZWlnaHQgJiYgKHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0LCBlID0gITApLCAhdGhpcy5faGFzSW52YWxpZERpbWVuc2lvbnMoKSAmJiAwICE9PSBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMubWFwLnBhaW50ZXIuY29udGV4dCxcbiAgICAgICAgICAgICAgbyA9IGkuZ2w7XG5cbiAgICAgICAgICBmb3IgKHZhciByIGluIHRoaXMuYm91bmRzQnVmZmVyIHx8ICh0aGlzLmJvdW5kc0J1ZmZlciA9IGkuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuX2JvdW5kc0FycmF5LCBBLm1lbWJlcnMpKSwgdGhpcy5ib3VuZHNTZWdtZW50cyB8fCAodGhpcy5ib3VuZHNTZWdtZW50cyA9IHQuU2VnbWVudFZlY3Rvci5zaW1wbGVTZWdtZW50KDAsIDAsIDQsIDIpKSwgdGhpcy50ZXh0dXJlID8gKGUgfHwgdGhpcy5fcGxheWluZykgJiYgdGhpcy50ZXh0dXJlLnVwZGF0ZSh0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgcHJlbXVsdGlwbHk6ICEwXG4gICAgICAgICAgfSkgOiB0aGlzLnRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKGksIHRoaXMuY2FudmFzLCBvLlJHQkEsIHtcbiAgICAgICAgICAgIHByZW11bHRpcGx5OiAhMFxuICAgICAgICAgIH0pLCB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMudGlsZXNbcl07XG4gICAgICAgICAgICBcImxvYWRlZFwiICE9PSBhLnN0YXRlICYmIChhLnN0YXRlID0gXCJsb2FkZWRcIiwgYS50ZXh0dXJlID0gdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImNhbnZhc1wiLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheWluZztcbiAgICAgIH0sIGkucHJvdG90eXBlLl9oYXNJbnZhbGlkRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IDAsIGUgPSBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF07IHQgPCBlLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgICAgdmFyIGkgPSBlW3RdO1xuICAgICAgICAgIGlmIChpc05hTihpKSB8fCBpIDw9IDApIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGk7XG4gICAgfShNKSxcbiAgICAgICAgayA9IHtcbiAgICAgIHZlY3RvcjogUyxcbiAgICAgIHJhc3RlcjogQyxcbiAgICAgIFwicmFzdGVyLWRlbVwiOiB6LFxuICAgICAgZ2VvanNvbjogRCxcbiAgICAgIHZpZGVvOiBMLFxuICAgICAgaW1hZ2U6IE0sXG4gICAgICBjYW52YXM6IFJcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQihlLCBpKSB7XG4gICAgICB2YXIgbyA9IHQuaWRlbnRpdHkoW10pO1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlKG8sIG8sIFsxLCAxLCAwXSksIHQuc2NhbGUobywgbywgWy41ICogZS53aWR0aCwgLjUgKiBlLmhlaWdodCwgMV0pLCB0Lm11bHRpcGx5KG8sIG8sIGUuY2FsY3VsYXRlUG9zTWF0cml4KGkudG9VbndyYXBwZWQoKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE8odCwgZSwgaSwgbywgciwgYSkge1xuICAgICAgdmFyIG4gPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICBpZiAodCkgZm9yICh2YXIgbyA9IDAsIHIgPSB0OyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgIHZhciBhID0gZVtyW29dXTtcbiAgICAgICAgICBpZiAoYSAmJiBhLnNvdXJjZSA9PT0gaSAmJiBcImZpbGwtZXh0cnVzaW9uXCIgPT09IGEudHlwZSkgcmV0dXJuICEwO1xuICAgICAgICB9IGVsc2UgZm9yICh2YXIgbiBpbiBlKSB7XG4gICAgICAgICAgdmFyIHMgPSBlW25dO1xuICAgICAgICAgIGlmIChzLnNvdXJjZSA9PT0gaSAmJiBcImZpbGwtZXh0cnVzaW9uXCIgPT09IHMudHlwZSkgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0ociAmJiByLmxheWVycywgZSwgdC5pZCksXG4gICAgICAgICAgcyA9IGEubWF4UGl0Y2hTY2FsZUZhY3RvcigpLFxuICAgICAgICAgIGwgPSB0LnRpbGVzSW4obywgcywgbik7XG5cbiAgICAgIGwuc29ydChGKTtcblxuICAgICAgZm9yICh2YXIgYyA9IFtdLCB1ID0gMCwgaCA9IGw7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIHZhciBwID0gaFt1XTtcbiAgICAgICAgYy5wdXNoKHtcbiAgICAgICAgICB3cmFwcGVkVGlsZUlEOiBwLnRpbGVJRC53cmFwcGVkKCkua2V5LFxuICAgICAgICAgIHF1ZXJ5UmVzdWx0czogcC50aWxlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhlLCBpLCB0Ll9zdGF0ZSwgcC5xdWVyeUdlb21ldHJ5LCBwLmNhbWVyYVF1ZXJ5R2VvbWV0cnksIHAuc2NhbGUsIHIsIGEsIHMsIEIodC50cmFuc2Zvcm0sIHAudGlsZUlEKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHt9LCBpID0ge30sIG8gPSAwLCByID0gdDsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHJbb10sXG4gICAgICAgICAgICAgIG4gPSBhLnF1ZXJ5UmVzdWx0cyxcbiAgICAgICAgICAgICAgcyA9IGEud3JhcHBlZFRpbGVJRCxcbiAgICAgICAgICAgICAgbCA9IGlbc10gPSBpW3NdIHx8IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgYyBpbiBuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gbltjXSwgaCA9IGxbY10gPSBsW2NdIHx8IHt9LCBwID0gZVtjXSA9IGVbY10gfHwgW10sIGQgPSAwLCBfID0gdTsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSBfW2RdO1xuICAgICAgICAgICAgICBoW2YuZmVhdHVyZUluZGV4XSB8fCAoaFtmLmZlYXR1cmVJbmRleF0gPSAhMCwgcC5wdXNoKGYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oYyk7XG5cbiAgICAgIGZvciAodmFyIF8gaW4gZCkge1xuICAgICAgICBkW19dLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgaSA9IGUuZmVhdHVyZSxcbiAgICAgICAgICAgICAgbyA9IHQuZ2V0RmVhdHVyZVN0YXRlKGkubGF5ZXJbXCJzb3VyY2UtbGF5ZXJcIl0sIGkuaWQpO1xuICAgICAgICAgIGkuc291cmNlID0gaS5sYXllci5zb3VyY2UsIGkubGF5ZXJbXCJzb3VyY2UtbGF5ZXJcIl0gJiYgKGkuc291cmNlTGF5ZXIgPSBpLmxheWVyW1wic291cmNlLWxheWVyXCJdKSwgaS5zdGF0ZSA9IG87XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGKHQsIGUpIHtcbiAgICAgIHZhciBpID0gdC50aWxlSUQsXG4gICAgICAgICAgbyA9IGUudGlsZUlEO1xuICAgICAgcmV0dXJuIGkub3ZlcnNjYWxlZFogLSBvLm92ZXJzY2FsZWRaIHx8IGkuY2Fub25pY2FsLnkgLSBvLmNhbm9uaWNhbC55IHx8IGkud3JhcCAtIG8ud3JhcCB8fCBpLmNhbm9uaWNhbC54IC0gby5jYW5vbmljYWwueDtcbiAgICB9XG5cbiAgICB2YXIgVSA9IGZ1bmN0aW9uIFUodCwgZSkge1xuICAgICAgdGhpcy5tYXggPSB0LCB0aGlzLm9uUmVtb3ZlID0gZSwgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICBVLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBpID0gdGhpcy5kYXRhW3RdOyBlIDwgaS5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgIHZhciBvID0gaVtlXTtcbiAgICAgICAgICBvLnRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KG8udGltZW91dCksIHRoaXMub25SZW1vdmUoby52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZGF0YSA9IHt9LCB0aGlzLm9yZGVyID0gW10sIHRoaXM7XG4gICAgfSwgVS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgICByID0gdC53cmFwcGVkKCkua2V5O1xuICAgICAgdm9pZCAwID09PSB0aGlzLmRhdGFbcl0gJiYgKHRoaXMuZGF0YVtyXSA9IFtdKTtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgdGltZW91dDogdm9pZCAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodm9pZCAwICE9PSBpICYmIChhLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgby5yZW1vdmUodCwgYSk7XG4gICAgICB9LCBpKSksIHRoaXMuZGF0YVtyXS5wdXNoKGEpLCB0aGlzLm9yZGVyLnB1c2gociksIHRoaXMub3JkZXIubGVuZ3RoID4gdGhpcy5tYXgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9nZXRBbmRSZW1vdmVCeUtleSh0aGlzLm9yZGVyWzBdKTtcblxuICAgICAgICBuICYmIHRoaXMub25SZW1vdmUobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIFUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC53cmFwcGVkKCkua2V5IGluIHRoaXMuZGF0YTtcbiAgICB9LCBVLnByb3RvdHlwZS5nZXRBbmRSZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHQpID8gdGhpcy5fZ2V0QW5kUmVtb3ZlQnlLZXkodC53cmFwcGVkKCkua2V5KSA6IG51bGw7XG4gICAgfSwgVS5wcm90b3R5cGUuX2dldEFuZFJlbW92ZUJ5S2V5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5kYXRhW3RdLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gZS50aW1lb3V0ICYmIGNsZWFyVGltZW91dChlLnRpbWVvdXQpLCAwID09PSB0aGlzLmRhdGFbdF0ubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmRhdGFbdF0sIHRoaXMub3JkZXIuc3BsaWNlKHRoaXMub3JkZXIuaW5kZXhPZih0KSwgMSksIGUudmFsdWU7XG4gICAgfSwgVS5wcm90b3R5cGUuZ2V0QnlLZXkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmRhdGFbdF07XG4gICAgICByZXR1cm4gZSA/IGVbMF0udmFsdWUgOiBudWxsO1xuICAgIH0sIFUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModCkgPyB0aGlzLmRhdGFbdC53cmFwcGVkKCkua2V5XVswXS52YWx1ZSA6IG51bGw7XG4gICAgfSwgVS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModCkpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGkgPSB0LndyYXBwZWQoKS5rZXksXG4gICAgICAgICAgbyA9IHZvaWQgMCA9PT0gZSA/IDAgOiB0aGlzLmRhdGFbaV0uaW5kZXhPZihlKSxcbiAgICAgICAgICByID0gdGhpcy5kYXRhW2ldW29dO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpXS5zcGxpY2UobywgMSksIHIudGltZW91dCAmJiBjbGVhclRpbWVvdXQoci50aW1lb3V0KSwgMCA9PT0gdGhpcy5kYXRhW2ldLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5kYXRhW2ldLCB0aGlzLm9uUmVtb3ZlKHIudmFsdWUpLCB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2YoaSksIDEpLCB0aGlzO1xuICAgIH0sIFUucHJvdG90eXBlLnNldE1heFNpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh0aGlzLm1heCA9IHQ7IHRoaXMub3JkZXIubGVuZ3RoID4gdGhpcy5tYXg7KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fZ2V0QW5kUmVtb3ZlQnlLZXkodGhpcy5vcmRlclswXSk7XG5cbiAgICAgICAgZSAmJiB0aGlzLm9uUmVtb3ZlKGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBVLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IDAsIHIgPSB0aGlzLmRhdGFbaV07IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSByW29dO1xuICAgICAgICAgIHQoYS52YWx1ZSkgfHwgZS5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwLCBzID0gZTsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGwgPSBzW25dO1xuICAgICAgICB0aGlzLnJlbW92ZShsLnZhbHVlLnRpbGVJRCwgbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBOID0gZnVuY3Rpb24gTih0LCBlLCBpKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSB0O1xuICAgICAgdmFyIG8gPSB0LmdsO1xuICAgICAgdGhpcy5idWZmZXIgPSBvLmNyZWF0ZUJ1ZmZlcigpLCB0aGlzLmR5bmFtaWNEcmF3ID0gQm9vbGVhbihpKSwgdGhpcy5jb250ZXh0LnVuYmluZFZBTygpLCB0LmJpbmRFbGVtZW50QnVmZmVyLnNldCh0aGlzLmJ1ZmZlciksIG8uYnVmZmVyRGF0YShvLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlLmFycmF5QnVmZmVyLCB0aGlzLmR5bmFtaWNEcmF3ID8gby5EWU5BTUlDX0RSQVcgOiBvLlNUQVRJQ19EUkFXKSwgdGhpcy5keW5hbWljRHJhdyB8fCBkZWxldGUgZS5hcnJheUJ1ZmZlcjtcbiAgICB9O1xuXG4gICAgTi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29udGV4dC5iaW5kRWxlbWVudEJ1ZmZlci5zZXQodGhpcy5idWZmZXIpO1xuICAgIH0sIE4ucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICB0aGlzLmNvbnRleHQudW5iaW5kVkFPKCksIHRoaXMuYmluZCgpLCBlLmJ1ZmZlclN1YkRhdGEoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgdC5hcnJheUJ1ZmZlcik7XG4gICAgfSwgTi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYnVmZmVyICYmICh0aGlzLmNvbnRleHQuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKSwgZGVsZXRlIHRoaXMuYnVmZmVyKTtcbiAgICB9O1xuXG4gICAgdmFyIFogPSB7XG4gICAgICBJbnQ4OiBcIkJZVEVcIixcbiAgICAgIFVpbnQ4OiBcIlVOU0lHTkVEX0JZVEVcIixcbiAgICAgIEludDE2OiBcIlNIT1JUXCIsXG4gICAgICBVaW50MTY6IFwiVU5TSUdORURfU0hPUlRcIixcbiAgICAgIEludDMyOiBcIklOVFwiLFxuICAgICAgVWludDMyOiBcIlVOU0lHTkVEX0lOVFwiLFxuICAgICAgRmxvYXQzMjogXCJGTE9BVFwiXG4gICAgfSxcbiAgICAgICAgcSA9IGZ1bmN0aW9uIHEodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy5sZW5ndGggPSBlLmxlbmd0aCwgdGhpcy5hdHRyaWJ1dGVzID0gaSwgdGhpcy5pdGVtU2l6ZSA9IGUuYnl0ZXNQZXJFbGVtZW50LCB0aGlzLmR5bmFtaWNEcmF3ID0gbywgdGhpcy5jb250ZXh0ID0gdDtcbiAgICAgIHZhciByID0gdC5nbDtcbiAgICAgIHRoaXMuYnVmZmVyID0gci5jcmVhdGVCdWZmZXIoKSwgdC5iaW5kVmVydGV4QnVmZmVyLnNldCh0aGlzLmJ1ZmZlciksIHIuYnVmZmVyRGF0YShyLkFSUkFZX0JVRkZFUiwgZS5hcnJheUJ1ZmZlciwgdGhpcy5keW5hbWljRHJhdyA/IHIuRFlOQU1JQ19EUkFXIDogci5TVEFUSUNfRFJBVyksIHRoaXMuZHluYW1pY0RyYXcgfHwgZGVsZXRlIGUuYXJyYXlCdWZmZXI7XG4gICAgfTtcblxuICAgIHEucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnRleHQuYmluZFZlcnRleEJ1ZmZlci5zZXQodGhpcy5idWZmZXIpO1xuICAgIH0sIHEucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICB0aGlzLmJpbmQoKSwgZS5idWZmZXJTdWJEYXRhKGUuQVJSQVlfQlVGRkVSLCAwLCB0LmFycmF5QnVmZmVyKTtcbiAgICB9LCBxLnByb3RvdHlwZS5lbmFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvID0gZS5hdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlc1tpXS5uYW1lXTtcbiAgICAgICAgdm9pZCAwICE9PSBvICYmIHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobyk7XG4gICAgICB9XG4gICAgfSwgcS5wcm90b3R5cGUuc2V0VmVydGV4QXR0cmliUG9pbnRlcnMgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmF0dHJpYnV0ZXNbb10sXG4gICAgICAgICAgICBhID0gZS5hdHRyaWJ1dGVzW3IubmFtZV07XG4gICAgICAgIHZvaWQgMCAhPT0gYSAmJiB0LnZlcnRleEF0dHJpYlBvaW50ZXIoYSwgci5jb21wb25lbnRzLCB0W1pbci50eXBlXV0sICExLCB0aGlzLml0ZW1TaXplLCByLm9mZnNldCArIHRoaXMuaXRlbVNpemUgKiAoaSB8fCAwKSk7XG4gICAgICB9XG4gICAgfSwgcS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYnVmZmVyICYmICh0aGlzLmNvbnRleHQuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKSwgZGVsZXRlIHRoaXMuYnVmZmVyKTtcbiAgICB9O1xuXG4gICAgdmFyIGogPSBmdW5jdGlvbiBqKHQpIHtcbiAgICAgIHRoaXMuZ2wgPSB0LmdsLCB0aGlzLmRlZmF1bHQgPSB0aGlzLmdldERlZmF1bHQoKSwgdGhpcy5jdXJyZW50ID0gdGhpcy5kZWZhdWx0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgfTtcblxuICAgIGoucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfSwgai5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHt9LCBqLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdDtcbiAgICB9LCBqLnByb3RvdHlwZS5zZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5kZWZhdWx0KTtcbiAgICB9O1xuXG4gICAgdmFyIFYgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdC5Db2xvci50cmFuc3BhcmVudDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAodC5yICE9PSBlLnIgfHwgdC5nICE9PSBlLmcgfHwgdC5iICE9PSBlLmIgfHwgdC5hICE9PSBlLmEgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY2xlYXJDb2xvcih0LnIsIHQuZywgdC5iLCB0LmEpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgaTtcbiAgICB9KGopLFxuICAgICAgICBHID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmNsZWFyRGVwdGgodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIFcgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY2xlYXJTdGVuY2lsKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBYID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFshMCwgITAsICEwLCAhMF07XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgKHRbMF0gIT09IGVbMF0gfHwgdFsxXSAhPT0gZVsxXSB8fCB0WzJdICE9PSBlWzJdIHx8IHRbM10gIT09IGVbM10gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY29sb3JNYXNrKHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBIID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5kZXB0aE1hc2sodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIEsgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5zdGVuY2lsTWFzayh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgWSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnVuYzogdGhpcy5nbC5BTFdBWVMsXG4gICAgICAgICAgcmVmOiAwLFxuICAgICAgICAgIG1hc2s6IDI1NVxuICAgICAgICB9O1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICh0LmZ1bmMgIT09IGUuZnVuYyB8fCB0LnJlZiAhPT0gZS5yZWYgfHwgdC5tYXNrICE9PSBlLm1hc2sgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuc3RlbmNpbEZ1bmModC5mdW5jLCB0LnJlZiwgdC5tYXNrKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgSiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5nbDtcbiAgICAgICAgcmV0dXJuIFt0LktFRVAsIHQuS0VFUCwgdC5LRUVQXTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAodFswXSAhPT0gZVswXSB8fCB0WzFdICE9PSBlWzFdIHx8IHRbMl0gIT09IGVbMl0gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuc3RlbmNpbE9wKHRbMF0sIHRbMV0sIHRbMl0pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBRID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIHQgPyBlLmVuYWJsZShlLlNURU5DSUxfVEVTVCkgOiBlLmRpc2FibGUoZS5TVEVOQ0lMX1RFU1QpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgJCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgKHRbMF0gIT09IGVbMF0gfHwgdFsxXSAhPT0gZVsxXSB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5kZXB0aFJhbmdlKHRbMF0sIHRbMV0pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICB0dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICB0ID8gZS5lbmFibGUoZS5ERVBUSF9URVNUKSA6IGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5MRVNTO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5kZXB0aEZ1bmModCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIHQgPyBlLmVuYWJsZShlLkJMRU5EKSA6IGUuZGlzYWJsZShlLkJMRU5EKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIG90ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmdsO1xuICAgICAgICByZXR1cm4gW3QuT05FLCB0LlpFUk9dO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICh0WzBdICE9PSBlWzBdIHx8IHRbMV0gIT09IGVbMV0gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuYmxlbmRGdW5jKHRbMF0sIHRbMV0pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgICBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LkNvbG9yLnRyYW5zcGFyZW50O1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICh0LnIgIT09IGUuciB8fCB0LmcgIT09IGUuZyB8fCB0LmIgIT09IGUuYiB8fCB0LmEgIT09IGUuYSB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5ibGVuZENvbG9yKHQuciwgdC5nLCB0LmIsIHQuYSksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBpO1xuICAgIH0oaiksXG4gICAgICAgIGF0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuRlVOQ19BREQ7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmJsZW5kRXF1YXRpb24odCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIG50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIHQgPyBlLmVuYWJsZShlLkNVTExfRkFDRSkgOiBlLmRpc2FibGUoZS5DVUxMX0ZBQ0UpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgc3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5CQUNLO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5jdWxsRmFjZSh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgbHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5DQ1c7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmZyb250RmFjZSh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgY3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wudXNlUHJvZ3JhbSh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgdXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5URVhUVVJFMDtcbiAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgaHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZ2w7XG4gICAgICAgIHJldHVybiBbMCwgMCwgdC5kcmF3aW5nQnVmZmVyV2lkdGgsIHQuZHJhd2luZ0J1ZmZlckhlaWdodF07XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgKHRbMF0gIT09IGVbMF0gfHwgdFsxXSAhPT0gZVsxXSB8fCB0WzJdICE9PSBlWzJdIHx8IHRbM10gIT09IGVbM10gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wudmlld3BvcnQodFswXSwgdFsxXSwgdFsyXSwgdFszXSksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIHB0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBkdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUuYmluZFJlbmRlcmJ1ZmZlcihlLlJFTkRFUkJVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBfdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIGZ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIG10ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgIGUuYmluZEJ1ZmZlcihlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICBndCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUpLCB0aGlzLnZhbyA9IGUuZXh0VmVydGV4QXJyYXlPYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy52YW8gJiYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy52YW8uYmluZFZlcnRleEFycmF5T0VTKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgfSwgZTtcbiAgICB9KGopLFxuICAgICAgICB2dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUucGl4ZWxTdG9yZWkoZS5VTlBBQ0tfQUxJR05NRU5ULCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBlO1xuICAgIH0oaiksXG4gICAgICAgIHl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUucGl4ZWxTdG9yZWkoZS5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgeHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgZS5waXhlbFN0b3JlaShlLlVOUEFDS19GTElQX1lfV0VCR0wsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgYnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlLCBpKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlKSwgdGhpcy5jb250ZXh0ID0gZSwgdGhpcy5wYXJlbnQgPSBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIGU7XG4gICAgfShqKSxcbiAgICAgICAgd3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICEwO1xuICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmJpbmRGcmFtZWJ1ZmZlci5zZXQodGhpcy5wYXJlbnQpO1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsIGUuQ09MT1JfQVRUQUNITUVOVDAsIGUuVEVYVFVSRV8yRCwgdCwgMCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGJ0KSxcbiAgICAgICAgVHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmluZEZyYW1lYnVmZmVyLnNldCh0aGlzLnBhcmVudCk7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgIGUuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZS5GUkFNRUJVRkZFUiwgZS5ERVBUSF9BVFRBQ0hNRU5ULCBlLlJFTkRFUkJVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KGJ0KSxcbiAgICAgICAgRXQgPSBmdW5jdGlvbiBFdCh0LCBlLCBpLCBvKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSB0LCB0aGlzLndpZHRoID0gZSwgdGhpcy5oZWlnaHQgPSBpO1xuICAgICAgdmFyIHIgPSB0aGlzLmZyYW1lYnVmZmVyID0gdC5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgdGhpcy5jb2xvckF0dGFjaG1lbnQgPSBuZXcgd3QodCwgciksIG8gJiYgKHRoaXMuZGVwdGhBdHRhY2htZW50ID0gbmV3IFR0KHQsIHIpKTtcbiAgICB9O1xuXG4gICAgRXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY29udGV4dC5nbCxcbiAgICAgICAgICBlID0gdGhpcy5jb2xvckF0dGFjaG1lbnQuZ2V0KCk7XG5cbiAgICAgIGlmIChlICYmIHQuZGVsZXRlVGV4dHVyZShlKSwgdGhpcy5kZXB0aEF0dGFjaG1lbnQpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmRlcHRoQXR0YWNobWVudC5nZXQoKTtcbiAgICAgICAgaSAmJiB0LmRlbGV0ZVJlbmRlcmJ1ZmZlcihpKTtcbiAgICAgIH1cblxuICAgICAgdC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICB9O1xuXG4gICAgdmFyIEl0ID0gZnVuY3Rpb24gSXQodCwgZSwgaSkge1xuICAgICAgdGhpcy5mdW5jID0gdCwgdGhpcy5tYXNrID0gZSwgdGhpcy5yYW5nZSA9IGk7XG4gICAgfTtcblxuICAgIEl0LlJlYWRPbmx5ID0gITEsIEl0LlJlYWRXcml0ZSA9ICEwLCBJdC5kaXNhYmxlZCA9IG5ldyBJdCg1MTksIEl0LlJlYWRPbmx5LCBbMCwgMV0pO1xuXG4gICAgdmFyIFB0ID0gZnVuY3Rpb24gUHQodCwgZSwgaSwgbywgciwgYSkge1xuICAgICAgdGhpcy50ZXN0ID0gdCwgdGhpcy5yZWYgPSBlLCB0aGlzLm1hc2sgPSBpLCB0aGlzLmZhaWwgPSBvLCB0aGlzLmRlcHRoRmFpbCA9IHIsIHRoaXMucGFzcyA9IGE7XG4gICAgfTtcblxuICAgIFB0LmRpc2FibGVkID0gbmV3IFB0KHtcbiAgICAgIGZ1bmM6IDUxOSxcbiAgICAgIG1hc2s6IDBcbiAgICB9LCAwLCAwLCA3NjgwLCA3NjgwLCA3NjgwKTtcblxuICAgIHZhciBTdCA9IGZ1bmN0aW9uIFN0KHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuYmxlbmRGdW5jdGlvbiA9IHQsIHRoaXMuYmxlbmRDb2xvciA9IGUsIHRoaXMubWFzayA9IGk7XG4gICAgfTtcblxuICAgIFN0LmRpc2FibGVkID0gbmV3IFN0KFN0LlJlcGxhY2UgPSBbMSwgMF0sIHQuQ29sb3IudHJhbnNwYXJlbnQsIFshMSwgITEsICExLCAhMV0pLCBTdC51bmJsZW5kZWQgPSBuZXcgU3QoU3QuUmVwbGFjZSwgdC5Db2xvci50cmFuc3BhcmVudCwgWyEwLCAhMCwgITAsICEwXSksIFN0LmFscGhhQmxlbmRlZCA9IG5ldyBTdChbMSwgNzcxXSwgdC5Db2xvci50cmFuc3BhcmVudCwgWyEwLCAhMCwgITAsICEwXSk7XG5cbiAgICB2YXIgQ3QgPSBmdW5jdGlvbiBDdCh0LCBlLCBpKSB7XG4gICAgICB0aGlzLmVuYWJsZSA9IHQsIHRoaXMubW9kZSA9IGUsIHRoaXMuZnJvbnRGYWNlID0gaTtcbiAgICB9O1xuXG4gICAgQ3QuZGlzYWJsZWQgPSBuZXcgQ3QoITEsIDEwMjksIDIzMDUpLCBDdC5iYWNrQ0NXID0gbmV3IEN0KCEwLCAxMDI5LCAyMzA1KTtcblxuICAgIHZhciB6dCA9IGZ1bmN0aW9uIHp0KHQpIHtcbiAgICAgIHRoaXMuZ2wgPSB0LCB0aGlzLmV4dFZlcnRleEFycmF5T2JqZWN0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSwgdGhpcy5jbGVhckNvbG9yID0gbmV3IFYodGhpcyksIHRoaXMuY2xlYXJEZXB0aCA9IG5ldyBHKHRoaXMpLCB0aGlzLmNsZWFyU3RlbmNpbCA9IG5ldyBXKHRoaXMpLCB0aGlzLmNvbG9yTWFzayA9IG5ldyBYKHRoaXMpLCB0aGlzLmRlcHRoTWFzayA9IG5ldyBIKHRoaXMpLCB0aGlzLnN0ZW5jaWxNYXNrID0gbmV3IEsodGhpcyksIHRoaXMuc3RlbmNpbEZ1bmMgPSBuZXcgWSh0aGlzKSwgdGhpcy5zdGVuY2lsT3AgPSBuZXcgSih0aGlzKSwgdGhpcy5zdGVuY2lsVGVzdCA9IG5ldyBRKHRoaXMpLCB0aGlzLmRlcHRoUmFuZ2UgPSBuZXcgJCh0aGlzKSwgdGhpcy5kZXB0aFRlc3QgPSBuZXcgdHQodGhpcyksIHRoaXMuZGVwdGhGdW5jID0gbmV3IGV0KHRoaXMpLCB0aGlzLmJsZW5kID0gbmV3IGl0KHRoaXMpLCB0aGlzLmJsZW5kRnVuYyA9IG5ldyBvdCh0aGlzKSwgdGhpcy5ibGVuZENvbG9yID0gbmV3IHJ0KHRoaXMpLCB0aGlzLmJsZW5kRXF1YXRpb24gPSBuZXcgYXQodGhpcyksIHRoaXMuY3VsbEZhY2UgPSBuZXcgbnQodGhpcyksIHRoaXMuY3VsbEZhY2VTaWRlID0gbmV3IHN0KHRoaXMpLCB0aGlzLmZyb250RmFjZSA9IG5ldyBsdCh0aGlzKSwgdGhpcy5wcm9ncmFtID0gbmV3IGN0KHRoaXMpLCB0aGlzLmFjdGl2ZVRleHR1cmUgPSBuZXcgdXQodGhpcyksIHRoaXMudmlld3BvcnQgPSBuZXcgaHQodGhpcyksIHRoaXMuYmluZEZyYW1lYnVmZmVyID0gbmV3IHB0KHRoaXMpLCB0aGlzLmJpbmRSZW5kZXJidWZmZXIgPSBuZXcgZHQodGhpcyksIHRoaXMuYmluZFRleHR1cmUgPSBuZXcgX3QodGhpcyksIHRoaXMuYmluZFZlcnRleEJ1ZmZlciA9IG5ldyBmdCh0aGlzKSwgdGhpcy5iaW5kRWxlbWVudEJ1ZmZlciA9IG5ldyBtdCh0aGlzKSwgdGhpcy5iaW5kVmVydGV4QXJyYXlPRVMgPSB0aGlzLmV4dFZlcnRleEFycmF5T2JqZWN0ICYmIG5ldyBndCh0aGlzKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrID0gbmV3IHZ0KHRoaXMpLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhID0gbmV3IHl0KHRoaXMpLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2tGbGlwWSA9IG5ldyB4dCh0aGlzKSwgdGhpcy5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMgPSB0LmdldEV4dGVuc2lvbihcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSB8fCB0LmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikgfHwgdC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpLCB0aGlzLmV4dFRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYyAmJiAodGhpcy5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWNNYXggPSB0LmdldFBhcmFtZXRlcih0aGlzLmV4dFRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYy5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpKSwgdGhpcy5leHRUZXh0dXJlSGFsZkZsb2F0ID0gdC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLCB0aGlzLmV4dFRleHR1cmVIYWxmRmxvYXQgJiYgKHQuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcIiksIHRoaXMuZXh0UmVuZGVyVG9UZXh0dXJlSGFsZkZsb2F0ID0gdC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikpLCB0aGlzLmV4dFRpbWVyUXVlcnkgPSB0LmdldEV4dGVuc2lvbihcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSwgdGhpcy5tYXhUZXh0dXJlU2l6ZSA9IHQuZ2V0UGFyYW1ldGVyKHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgfTtcblxuICAgIHp0LnByb3RvdHlwZS5zZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy51bmJpbmRWQU8oKSwgdGhpcy5jbGVhckNvbG9yLnNldERlZmF1bHQoKSwgdGhpcy5jbGVhckRlcHRoLnNldERlZmF1bHQoKSwgdGhpcy5jbGVhclN0ZW5jaWwuc2V0RGVmYXVsdCgpLCB0aGlzLmNvbG9yTWFzay5zZXREZWZhdWx0KCksIHRoaXMuZGVwdGhNYXNrLnNldERlZmF1bHQoKSwgdGhpcy5zdGVuY2lsTWFzay5zZXREZWZhdWx0KCksIHRoaXMuc3RlbmNpbEZ1bmMuc2V0RGVmYXVsdCgpLCB0aGlzLnN0ZW5jaWxPcC5zZXREZWZhdWx0KCksIHRoaXMuc3RlbmNpbFRlc3Quc2V0RGVmYXVsdCgpLCB0aGlzLmRlcHRoUmFuZ2Uuc2V0RGVmYXVsdCgpLCB0aGlzLmRlcHRoVGVzdC5zZXREZWZhdWx0KCksIHRoaXMuZGVwdGhGdW5jLnNldERlZmF1bHQoKSwgdGhpcy5ibGVuZC5zZXREZWZhdWx0KCksIHRoaXMuYmxlbmRGdW5jLnNldERlZmF1bHQoKSwgdGhpcy5ibGVuZENvbG9yLnNldERlZmF1bHQoKSwgdGhpcy5ibGVuZEVxdWF0aW9uLnNldERlZmF1bHQoKSwgdGhpcy5jdWxsRmFjZS5zZXREZWZhdWx0KCksIHRoaXMuY3VsbEZhY2VTaWRlLnNldERlZmF1bHQoKSwgdGhpcy5mcm9udEZhY2Uuc2V0RGVmYXVsdCgpLCB0aGlzLnByb2dyYW0uc2V0RGVmYXVsdCgpLCB0aGlzLmFjdGl2ZVRleHR1cmUuc2V0RGVmYXVsdCgpLCB0aGlzLmJpbmRGcmFtZWJ1ZmZlci5zZXREZWZhdWx0KCksIHRoaXMucGl4ZWxTdG9yZVVucGFjay5zZXREZWZhdWx0KCksIHRoaXMucGl4ZWxTdG9yZVVucGFja1ByZW11bHRpcGx5QWxwaGEuc2V0RGVmYXVsdCgpLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2tGbGlwWS5zZXREZWZhdWx0KCk7XG4gICAgfSwgenQucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jbGVhckNvbG9yLmRpcnR5ID0gITAsIHRoaXMuY2xlYXJEZXB0aC5kaXJ0eSA9ICEwLCB0aGlzLmNsZWFyU3RlbmNpbC5kaXJ0eSA9ICEwLCB0aGlzLmNvbG9yTWFzay5kaXJ0eSA9ICEwLCB0aGlzLmRlcHRoTWFzay5kaXJ0eSA9ICEwLCB0aGlzLnN0ZW5jaWxNYXNrLmRpcnR5ID0gITAsIHRoaXMuc3RlbmNpbEZ1bmMuZGlydHkgPSAhMCwgdGhpcy5zdGVuY2lsT3AuZGlydHkgPSAhMCwgdGhpcy5zdGVuY2lsVGVzdC5kaXJ0eSA9ICEwLCB0aGlzLmRlcHRoUmFuZ2UuZGlydHkgPSAhMCwgdGhpcy5kZXB0aFRlc3QuZGlydHkgPSAhMCwgdGhpcy5kZXB0aEZ1bmMuZGlydHkgPSAhMCwgdGhpcy5ibGVuZC5kaXJ0eSA9ICEwLCB0aGlzLmJsZW5kRnVuYy5kaXJ0eSA9ICEwLCB0aGlzLmJsZW5kQ29sb3IuZGlydHkgPSAhMCwgdGhpcy5ibGVuZEVxdWF0aW9uLmRpcnR5ID0gITAsIHRoaXMuY3VsbEZhY2UuZGlydHkgPSAhMCwgdGhpcy5jdWxsRmFjZVNpZGUuZGlydHkgPSAhMCwgdGhpcy5mcm9udEZhY2UuZGlydHkgPSAhMCwgdGhpcy5wcm9ncmFtLmRpcnR5ID0gITAsIHRoaXMuYWN0aXZlVGV4dHVyZS5kaXJ0eSA9ICEwLCB0aGlzLnZpZXdwb3J0LmRpcnR5ID0gITAsIHRoaXMuYmluZEZyYW1lYnVmZmVyLmRpcnR5ID0gITAsIHRoaXMuYmluZFJlbmRlcmJ1ZmZlci5kaXJ0eSA9ICEwLCB0aGlzLmJpbmRUZXh0dXJlLmRpcnR5ID0gITAsIHRoaXMuYmluZFZlcnRleEJ1ZmZlci5kaXJ0eSA9ICEwLCB0aGlzLmJpbmRFbGVtZW50QnVmZmVyLmRpcnR5ID0gITAsIHRoaXMuZXh0VmVydGV4QXJyYXlPYmplY3QgJiYgKHRoaXMuYmluZFZlcnRleEFycmF5T0VTLmRpcnR5ID0gITApLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2suZGlydHkgPSAhMCwgdGhpcy5waXhlbFN0b3JlVW5wYWNrUHJlbXVsdGlwbHlBbHBoYS5kaXJ0eSA9ICEwLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2tGbGlwWS5kaXJ0eSA9ICEwO1xuICAgIH0sIHp0LnByb3RvdHlwZS5jcmVhdGVJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gbmV3IE4odGhpcywgdCwgZSk7XG4gICAgfSwgenQucHJvdG90eXBlLmNyZWF0ZVZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICByZXR1cm4gbmV3IHEodGhpcywgdCwgZSwgaSk7XG4gICAgfSwgenQucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmJ1ZmZlciA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuZ2wsXG4gICAgICAgICAgciA9IG8uY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5iaW5kUmVuZGVyYnVmZmVyLnNldChyKSwgby5yZW5kZXJidWZmZXJTdG9yYWdlKG8uUkVOREVSQlVGRkVSLCB0LCBlLCBpKSwgdGhpcy5iaW5kUmVuZGVyYnVmZmVyLnNldChudWxsKSwgcjtcbiAgICB9LCB6dC5wcm90b3R5cGUuY3JlYXRlRnJhbWVidWZmZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIG5ldyBFdCh0aGlzLCB0LCBlLCBpKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmNvbG9yLFxuICAgICAgICAgIGkgPSB0LmRlcHRoLFxuICAgICAgICAgIG8gPSB0aGlzLmdsLFxuICAgICAgICAgIHIgPSAwO1xuICAgICAgZSAmJiAociB8PSBvLkNPTE9SX0JVRkZFUl9CSVQsIHRoaXMuY2xlYXJDb2xvci5zZXQoZSksIHRoaXMuY29sb3JNYXNrLnNldChbITAsICEwLCAhMCwgITBdKSksIHZvaWQgMCAhPT0gaSAmJiAociB8PSBvLkRFUFRIX0JVRkZFUl9CSVQsIHRoaXMuZGVwdGhSYW5nZS5zZXQoWzAsIDFdKSwgdGhpcy5jbGVhckRlcHRoLnNldChpKSwgdGhpcy5kZXB0aE1hc2suc2V0KCEwKSksIG8uY2xlYXIocik7XG4gICAgfSwgenQucHJvdG90eXBlLnNldEN1bGxGYWNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICExID09PSB0LmVuYWJsZSA/IHRoaXMuY3VsbEZhY2Uuc2V0KCExKSA6ICh0aGlzLmN1bGxGYWNlLnNldCghMCksIHRoaXMuY3VsbEZhY2VTaWRlLnNldCh0Lm1vZGUpLCB0aGlzLmZyb250RmFjZS5zZXQodC5mcm9udEZhY2UpKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuc2V0RGVwdGhNb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQuZnVuYyAhPT0gdGhpcy5nbC5BTFdBWVMgfHwgdC5tYXNrID8gKHRoaXMuZGVwdGhUZXN0LnNldCghMCksIHRoaXMuZGVwdGhGdW5jLnNldCh0LmZ1bmMpLCB0aGlzLmRlcHRoTWFzay5zZXQodC5tYXNrKSwgdGhpcy5kZXB0aFJhbmdlLnNldCh0LnJhbmdlKSkgOiB0aGlzLmRlcHRoVGVzdC5zZXQoITEpO1xuICAgIH0sIHp0LnByb3RvdHlwZS5zZXRTdGVuY2lsTW9kZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnRlc3QuZnVuYyAhPT0gdGhpcy5nbC5BTFdBWVMgfHwgdC5tYXNrID8gKHRoaXMuc3RlbmNpbFRlc3Quc2V0KCEwKSwgdGhpcy5zdGVuY2lsTWFzay5zZXQodC5tYXNrKSwgdGhpcy5zdGVuY2lsT3Auc2V0KFt0LmZhaWwsIHQuZGVwdGhGYWlsLCB0LnBhc3NdKSwgdGhpcy5zdGVuY2lsRnVuYy5zZXQoe1xuICAgICAgICBmdW5jOiB0LnRlc3QuZnVuYyxcbiAgICAgICAgcmVmOiB0LnJlZixcbiAgICAgICAgbWFzazogdC50ZXN0Lm1hc2tcbiAgICAgIH0pKSA6IHRoaXMuc3RlbmNpbFRlc3Quc2V0KCExKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuc2V0Q29sb3JNb2RlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHQuZGVlcEVxdWFsKGUuYmxlbmRGdW5jdGlvbiwgU3QuUmVwbGFjZSkgPyB0aGlzLmJsZW5kLnNldCghMSkgOiAodGhpcy5ibGVuZC5zZXQoITApLCB0aGlzLmJsZW5kRnVuYy5zZXQoZS5ibGVuZEZ1bmN0aW9uKSwgdGhpcy5ibGVuZENvbG9yLnNldChlLmJsZW5kQ29sb3IpKSwgdGhpcy5jb2xvck1hc2suc2V0KGUubWFzayk7XG4gICAgfSwgenQucHJvdG90eXBlLnVuYmluZFZBTyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZXh0VmVydGV4QXJyYXlPYmplY3QgJiYgdGhpcy5iaW5kVmVydGV4QXJyYXlPRVMuc2V0KG51bGwpO1xuICAgIH07XG5cbiAgICB2YXIgRHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gaShpLCBvLCByKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLmlkID0gaSwgdGhpcy5kaXNwYXRjaGVyID0gciwgdGhpcy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBcInNvdXJjZVwiID09PSB0LmRhdGFUeXBlICYmIFwibWV0YWRhdGFcIiA9PT0gdC5zb3VyY2VEYXRhVHlwZSAmJiAoYS5fc291cmNlTG9hZGVkID0gITApLCBhLl9zb3VyY2VMb2FkZWQgJiYgIWEuX3BhdXNlZCAmJiBcInNvdXJjZVwiID09PSB0LmRhdGFUeXBlICYmIFwiY29udGVudFwiID09PSB0LnNvdXJjZURhdGFUeXBlICYmIChhLnJlbG9hZCgpLCBhLnRyYW5zZm9ybSAmJiBhLnVwZGF0ZShhLnRyYW5zZm9ybSkpO1xuICAgICAgICB9KSwgdGhpcy5vbihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhLl9zb3VyY2VFcnJvcmVkID0gITA7XG4gICAgICAgIH0pLCB0aGlzLl9zb3VyY2UgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICAgIHZhciBhID0gbmV3IGtbaS50eXBlXShlLCBpLCBvLCByKTtcbiAgICAgICAgICBpZiAoYS5pZCAhPT0gZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgU291cmNlIGlkIHRvIGJlIFwiICsgZSArIFwiIGluc3RlYWQgb2YgXCIgKyBhLmlkKTtcbiAgICAgICAgICByZXR1cm4gdC5iaW5kQWxsKFtcImxvYWRcIiwgXCJhYm9ydFwiLCBcInVubG9hZFwiLCBcInNlcmlhbGl6ZVwiLCBcInByZXBhcmVcIl0sIGEpLCBhO1xuICAgICAgICB9KGksIG8sIHIsIHRoaXMpLCB0aGlzLl90aWxlcyA9IHt9LCB0aGlzLl9jYWNoZSA9IG5ldyBVKDAsIHRoaXMuX3VubG9hZFRpbGUuYmluZCh0aGlzKSksIHRoaXMuX3RpbWVycyA9IHt9LCB0aGlzLl9jYWNoZVRpbWVycyA9IHt9LCB0aGlzLl9tYXhUaWxlQ2FjaGVTaXplID0gbnVsbCwgdGhpcy5fbG9hZGVkUGFyZW50VGlsZXMgPSB7fSwgdGhpcy5fY292ZXJlZFRpbGVzID0ge30sIHRoaXMuX3N0YXRlID0gbmV3IHQuU291cmNlRmVhdHVyZVN0YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLl9tYXhUaWxlQ2FjaGVTaXplID0gdCA/IHQuX21heFRpbGVDYWNoZVNpemUgOiBudWxsLCB0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLm9uQWRkICYmIHRoaXMuX3NvdXJjZS5vbkFkZCh0KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5vblJlbW92ZSAmJiB0aGlzLl9zb3VyY2Uub25SZW1vdmUodCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VFcnJvcmVkKSByZXR1cm4gITA7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlTG9hZGVkKSByZXR1cm4gITE7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlLmxvYWRlZCgpKSByZXR1cm4gITE7XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgICAgaWYgKFwibG9hZGVkXCIgIT09IGUuc3RhdGUgJiYgXCJlcnJvcmVkXCIgIT09IGUuc3RhdGUpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSAhMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5fc2hvdWxkUmVsb2FkT25SZXN1bWU7XG4gICAgICAgICAgdGhpcy5fcGF1c2VkID0gITEsIHRoaXMuX3Nob3VsZFJlbG9hZE9uUmVzdW1lID0gITEsIHQgJiYgdGhpcy5yZWxvYWQoKSwgdGhpcy50cmFuc2Zvcm0gJiYgdGhpcy51cGRhdGUodGhpcy50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5fbG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvYWRUaWxlKHQsIGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3VubG9hZFRpbGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy5fc291cmNlLnVubG9hZFRpbGUpIHJldHVybiB0aGlzLl9zb3VyY2UudW5sb2FkVGlsZSh0LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fYWJvcnRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZS5hYm9ydFRpbGUpIHJldHVybiB0aGlzLl9zb3VyY2UuYWJvcnRUaWxlKHQsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5zZXJpYWxpemUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlIGluIHRoaXMuX3NvdXJjZS5wcmVwYXJlICYmIHRoaXMuX3NvdXJjZS5wcmVwYXJlKCksIHRoaXMuX3N0YXRlLmNvYWxlc2NlQ2hhbmdlcyh0aGlzLl90aWxlcywgdGhpcy5tYXAgPyB0aGlzLm1hcC5wYWludGVyIDogbnVsbCksIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl90aWxlc1tlXTtcbiAgICAgICAgICBpLnVwbG9hZCh0KSwgaS5wcmVwYXJlKHRoaXMubWFwLnN0eWxlLmltYWdlTWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmdldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWVzKHRoaXMuX3RpbGVzKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC50aWxlSUQ7XG4gICAgICAgIH0pLnNvcnQoQXQpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LmtleTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRSZW5kZXJhYmxlSWRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgICAgbyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIHIgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB0aGlzLl9pc0lkUmVuZGVyYWJsZShyLCBlKSAmJiBvLnB1c2godGhpcy5fdGlsZXNbcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGUgPyBvLnNvcnQoZnVuY3Rpb24gKGUsIG8pIHtcbiAgICAgICAgICB2YXIgciA9IGUudGlsZUlELFxuICAgICAgICAgICAgICBhID0gby50aWxlSUQsXG4gICAgICAgICAgICAgIG4gPSBuZXcgdC5Qb2ludChyLmNhbm9uaWNhbC54LCByLmNhbm9uaWNhbC55KS5fcm90YXRlKGkudHJhbnNmb3JtLmFuZ2xlKSxcbiAgICAgICAgICAgICAgcyA9IG5ldyB0LlBvaW50KGEuY2Fub25pY2FsLngsIGEuY2Fub25pY2FsLnkpLl9yb3RhdGUoaS50cmFuc2Zvcm0uYW5nbGUpO1xuXG4gICAgICAgICAgcmV0dXJuIHIub3ZlcnNjYWxlZFogLSBhLm92ZXJzY2FsZWRaIHx8IHMueSAtIG4ueSB8fCBzLnggLSBuLng7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnRpbGVJRC5rZXk7XG4gICAgICAgIH0pIDogby5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC50aWxlSUQ7XG4gICAgICAgIH0pLnNvcnQoQXQpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LmtleTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5oYXNSZW5kZXJhYmxlUGFyZW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmZpbmRMb2FkZWRQYXJlbnQodCwgMCk7XG4gICAgICAgIHJldHVybiAhIWUgJiYgdGhpcy5faXNJZFJlbmRlcmFibGUoZS50aWxlSUQua2V5KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9pc0lkUmVuZGVyYWJsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlc1t0XSAmJiB0aGlzLl90aWxlc1t0XS5oYXNEYXRhKCkgJiYgIXRoaXMuX2NvdmVyZWRUaWxlc1t0XSAmJiAoZSB8fCAhdGhpcy5fdGlsZXNbdF0uaG9sZGluZ0ZvckZhZGUoKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHRoaXMuX3Nob3VsZFJlbG9hZE9uUmVzdW1lID0gITA7ZWxzZSBmb3IgKHZhciB0IGluIHRoaXMuX2NhY2hlLnJlc2V0KCksIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgXCJlcnJvcmVkXCIgIT09IHRoaXMuX3RpbGVzW3RdLnN0YXRlICYmIHRoaXMuX3JlbG9hZFRpbGUodCwgXCJyZWxvYWRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl9yZWxvYWRUaWxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgICAgaSAmJiAoXCJsb2FkaW5nXCIgIT09IGkuc3RhdGUgJiYgKGkuc3RhdGUgPSBlKSwgdGhpcy5fbG9hZFRpbGUoaSwgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIGksIHQsIGUpKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdGlsZUxvYWRlZCA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIGlmIChyKSByZXR1cm4gZS5zdGF0ZSA9IFwiZXJyb3JlZFwiLCB2b2lkICg0MDQgIT09IHIuc3RhdHVzID8gdGhpcy5fc291cmNlLmZpcmUobmV3IHQuRXJyb3JFdmVudChyLCB7XG4gICAgICAgICAgdGlsZTogZVxuICAgICAgICB9KSkgOiB0aGlzLnVwZGF0ZSh0aGlzLnRyYW5zZm9ybSkpO1xuICAgICAgICBlLnRpbWVBZGRlZCA9IHQuYnJvd3Nlci5ub3coKSwgXCJleHBpcmVkXCIgPT09IG8gJiYgKGUucmVmcmVzaGVkVXBvbkV4cGlyYXRpb24gPSAhMCksIHRoaXMuX3NldFRpbGVSZWxvYWRUaW1lcihpLCBlKSwgXCJyYXN0ZXItZGVtXCIgPT09IHRoaXMuZ2V0U291cmNlKCkudHlwZSAmJiBlLmRlbSAmJiB0aGlzLl9iYWNrZmlsbERFTShlKSwgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZVRpbGVTdGF0ZShlLCB0aGlzLm1hcCA/IHRoaXMubWFwLnBhaW50ZXIgOiBudWxsKSwgdGhpcy5fc291cmNlLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICB0aWxlOiBlLFxuICAgICAgICAgIGNvb3JkOiBlLnRpbGVJRFxuICAgICAgICB9KSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fYmFja2ZpbGxERU0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5nZXRSZW5kZXJhYmxlSWRzKCksIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvID0gZVtpXTtcblxuICAgICAgICAgIGlmICh0Lm5laWdoYm9yaW5nVGlsZXMgJiYgdC5uZWlnaGJvcmluZ1RpbGVzW29dKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0VGlsZUJ5SUQobyk7XG4gICAgICAgICAgICBhKHQsIHIpLCBhKHIsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGEodCwgZSkge1xuICAgICAgICAgIHQubmVlZHNIaWxsc2hhZGVQcmVwYXJlID0gITA7XG4gICAgICAgICAgdmFyIGkgPSBlLnRpbGVJRC5jYW5vbmljYWwueCAtIHQudGlsZUlELmNhbm9uaWNhbC54LFxuICAgICAgICAgICAgICBvID0gZS50aWxlSUQuY2Fub25pY2FsLnkgLSB0LnRpbGVJRC5jYW5vbmljYWwueSxcbiAgICAgICAgICAgICAgciA9IE1hdGgucG93KDIsIHQudGlsZUlELmNhbm9uaWNhbC56KSxcbiAgICAgICAgICAgICAgYSA9IGUudGlsZUlELmtleTtcbiAgICAgICAgICAwID09PSBpICYmIDAgPT09IG8gfHwgTWF0aC5hYnMobykgPiAxIHx8IChNYXRoLmFicyhpKSA+IDEgJiYgKDEgPT09IE1hdGguYWJzKGkgKyByKSA/IGkgKz0gciA6IDEgPT09IE1hdGguYWJzKGkgLSByKSAmJiAoaSAtPSByKSksIGUuZGVtICYmIHQuZGVtICYmICh0LmRlbS5iYWNrZmlsbEJvcmRlcihlLmRlbSwgaSwgbyksIHQubmVpZ2hib3JpbmdUaWxlcyAmJiB0Lm5laWdoYm9yaW5nVGlsZXNbYV0gJiYgKHQubmVpZ2hib3JpbmdUaWxlc1thXS5iYWNrZmlsbGVkID0gITApKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlQnlJRCh0LmtleSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRUaWxlQnlJRCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlc1t0XTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9yZXRhaW5Mb2FkZWRDaGlsZHJlbiA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgIGZvciAodmFyIHIgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuX3RpbGVzW3JdO1xuXG4gICAgICAgICAgaWYgKCEob1tyXSB8fCAhYS5oYXNEYXRhKCkgfHwgYS50aWxlSUQub3ZlcnNjYWxlZFogPD0gZSB8fCBhLnRpbGVJRC5vdmVyc2NhbGVkWiA+IGkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gYS50aWxlSUQ7IGEgJiYgYS50aWxlSUQub3ZlcnNjYWxlZFogPiBlICsgMTspIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSBhLnRpbGVJRC5zY2FsZWRUbyhhLnRpbGVJRC5vdmVyc2NhbGVkWiAtIDEpO1xuICAgICAgICAgICAgICAoYSA9IHRoaXMuX3RpbGVzW3Mua2V5XSkgJiYgYS5oYXNEYXRhKCkgJiYgKG4gPSBzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IG47IGwub3ZlcnNjYWxlZFogPiBlOykge1xuICAgICAgICAgICAgICBpZiAodFsobCA9IGwuc2NhbGVkVG8obC5vdmVyc2NhbGVkWiAtIDEpKS5rZXldKSB7XG4gICAgICAgICAgICAgICAgb1tuLmtleV0gPSBuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5maW5kTG9hZGVkUGFyZW50ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKHQua2V5IGluIHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlc1t0LmtleV07XG4gICAgICAgICAgcmV0dXJuIGkgJiYgaS50aWxlSUQub3ZlcnNjYWxlZFogPj0gZSA/IGkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbyA9IHQub3ZlcnNjYWxlZFogLSAxOyBvID49IGU7IG8tLSkge1xuICAgICAgICAgIHZhciByID0gdC5zY2FsZWRUbyhvKSxcbiAgICAgICAgICAgICAgYSA9IHRoaXMuX2dldExvYWRlZFRpbGUocik7XG5cbiAgICAgICAgICBpZiAoYSkgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl9nZXRMb2FkZWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl90aWxlc1t0LmtleV07XG4gICAgICAgIHJldHVybiBlICYmIGUuaGFzRGF0YSgpID8gZSA6IHRoaXMuX2NhY2hlLmdldEJ5S2V5KHQud3JhcHBlZCgpLmtleSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVDYWNoZVNpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IE1hdGguY2VpbCh0LndpZHRoIC8gdGhpcy5fc291cmNlLnRpbGVTaXplKSArIDEsXG4gICAgICAgICAgICBpID0gTWF0aC5jZWlsKHQuaGVpZ2h0IC8gdGhpcy5fc291cmNlLnRpbGVTaXplKSArIDEsXG4gICAgICAgICAgICBvID0gTWF0aC5mbG9vcihlICogaSAqIDUpLFxuICAgICAgICAgICAgciA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIHRoaXMuX21heFRpbGVDYWNoZVNpemUgPyBNYXRoLm1pbih0aGlzLl9tYXhUaWxlQ2FjaGVTaXplLCBvKSA6IG87XG5cbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0TWF4U2l6ZShyKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhbmRsZVdyYXBKdW1wID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLnJvdW5kKCh0IC0gKHZvaWQgMCA9PT0gdGhpcy5fcHJldkxuZyA/IHQgOiB0aGlzLl9wcmV2TG5nKSkgLyAzNjApO1xuXG4gICAgICAgIGlmICh0aGlzLl9wcmV2TG5nID0gdCwgZSkge1xuICAgICAgICAgIHZhciBpID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBvIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuX3RpbGVzW29dO1xuICAgICAgICAgICAgci50aWxlSUQgPSByLnRpbGVJRC51bndyYXBUbyhyLnRpbGVJRC53cmFwICsgZSksIGlbci50aWxlSUQua2V5XSA9IHI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLl90aWxlcyA9IGksIHRoaXMuX3RpbWVycykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyc1thXSksIGRlbGV0ZSB0aGlzLl90aW1lcnNbYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGlsZVJlbG9hZFRpbWVyKG4sIHRoaXMuX3RpbGVzW25dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0gPSBlLCB0aGlzLl9zb3VyY2VMb2FkZWQgJiYgIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgIHZhciByO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVTaXplKGUpLCB0aGlzLmhhbmRsZVdyYXBKdW1wKHRoaXMudHJhbnNmb3JtLmNlbnRlci5sbmcpLCB0aGlzLl9jb3ZlcmVkVGlsZXMgPSB7fSwgdGhpcy51c2VkID8gdGhpcy5fc291cmNlLnRpbGVJRCA/IHIgPSBlLmdldFZpc2libGVVbndyYXBwZWRDb29yZGluYXRlcyh0aGlzLl9zb3VyY2UudGlsZUlEKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUuY2Fub25pY2FsLnosIGUud3JhcCwgZS5jYW5vbmljYWwueiwgZS5jYW5vbmljYWwueCwgZS5jYW5vbmljYWwueSk7XG4gICAgICAgICAgfSkgOiAociA9IGUuY292ZXJpbmdUaWxlcyh7XG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy5fc291cmNlLnRpbGVTaXplLFxuICAgICAgICAgICAgbWluem9vbTogdGhpcy5fc291cmNlLm1pbnpvb20sXG4gICAgICAgICAgICBtYXh6b29tOiB0aGlzLl9zb3VyY2UubWF4em9vbSxcbiAgICAgICAgICAgIHJvdW5kWm9vbTogdGhpcy5fc291cmNlLnJvdW5kWm9vbSxcbiAgICAgICAgICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0aGlzLl9zb3VyY2UucmVwYXJzZU92ZXJzY2FsZWRcbiAgICAgICAgICB9KSwgdGhpcy5fc291cmNlLmhhc1RpbGUgJiYgKHIgPSByLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIG8uX3NvdXJjZS5oYXNUaWxlKHQpO1xuICAgICAgICAgIH0pKSkgOiByID0gW107XG5cbiAgICAgICAgICB2YXIgYSA9IGUuY292ZXJpbmdab29tTGV2ZWwodGhpcy5fc291cmNlKSxcbiAgICAgICAgICAgICAgbiA9IE1hdGgubWF4KGEgLSBpLm1heE92ZXJ6b29taW5nLCB0aGlzLl9zb3VyY2UubWluem9vbSksXG4gICAgICAgICAgICAgIHMgPSBNYXRoLm1heChhICsgaS5tYXhVbmRlcnpvb21pbmcsIHRoaXMuX3NvdXJjZS5taW56b29tKSxcbiAgICAgICAgICAgICAgbCA9IHRoaXMuX3VwZGF0ZVJldGFpbmVkVGlsZXMociwgYSk7XG5cbiAgICAgICAgICBpZiAoTXQodGhpcy5fc291cmNlLnR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0ge30sIHUgPSB7fSwgaCA9IDAsIHAgPSBPYmplY3Qua2V5cyhsKTsgaCA8IHAubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBwW2hdLFxuICAgICAgICAgICAgICAgICAgXyA9IGxbZF0sXG4gICAgICAgICAgICAgICAgICBmID0gdGhpcy5fdGlsZXNbZF07XG5cbiAgICAgICAgICAgICAgaWYgKGYgJiYgIShmLmZhZGVFbmRUaW1lICYmIGYuZmFkZUVuZFRpbWUgPD0gdC5icm93c2VyLm5vdygpKSkge1xuICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5maW5kTG9hZGVkUGFyZW50KF8sIG4pO1xuICAgICAgICAgICAgICAgIG0gJiYgKHRoaXMuX2FkZFRpbGUobS50aWxlSUQpLCBjW20udGlsZUlELmtleV0gPSBtLnRpbGVJRCksIHVbZF0gPSBfO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGcgaW4gdGhpcy5fcmV0YWluTG9hZGVkQ2hpbGRyZW4odSwgYSwgcywgbCksIGMpIHtcbiAgICAgICAgICAgICAgbFtnXSB8fCAodGhpcy5fY292ZXJlZFRpbGVzW2ddID0gITAsIGxbZ10gPSBjW2ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB2IGluIGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzW3ZdLmNsZWFyRmFkZUhvbGQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB5ID0gMCwgeCA9IHQua2V5c0RpZmZlcmVuY2UodGhpcy5fdGlsZXMsIGwpOyB5IDwgeC5sZW5ndGg7IHkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGIgPSB4W3ldLFxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLl90aWxlc1tiXTtcbiAgICAgICAgICAgIHcuaGFzU3ltYm9sQnVja2V0cyAmJiAhdy5ob2xkaW5nRm9yRmFkZSgpID8gdy5zZXRIb2xkRHVyYXRpb24odGhpcy5tYXAuX2ZhZGVEdXJhdGlvbikgOiB3Lmhhc1N5bWJvbEJ1Y2tldHMgJiYgIXcuc3ltYm9sRmFkZUZpbmlzaGVkKCkgfHwgdGhpcy5fcmVtb3ZlVGlsZShiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVMb2FkZWRQYXJlbnRUaWxlQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUucmVsZWFzZVN5bWJvbEZhZGVUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHRoaXMuX3RpbGVzW3RdLmhvbGRpbmdGb3JGYWRlKCkgJiYgdGhpcy5fcmVtb3ZlVGlsZSh0KTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVJldGFpbmVkVGlsZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciBvID0ge30sIHIgPSB7fSwgYSA9IE1hdGgubWF4KGUgLSBpLm1heE92ZXJ6b29taW5nLCB0aGlzLl9zb3VyY2UubWluem9vbSksIG4gPSBNYXRoLm1heChlICsgaS5tYXhVbmRlcnpvb21pbmcsIHRoaXMuX3NvdXJjZS5taW56b29tKSwgcyA9IHt9LCBsID0gMCwgYyA9IHQ7IGwgPCBjLmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgICAgdmFyIHUgPSBjW2xdLFxuICAgICAgICAgICAgICBoID0gdGhpcy5fYWRkVGlsZSh1KTtcblxuICAgICAgICAgIG9bdS5rZXldID0gdSwgaC5oYXNEYXRhKCkgfHwgZSA8IHRoaXMuX3NvdXJjZS5tYXh6b29tICYmIChzW3Uua2V5XSA9IHUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmV0YWluTG9hZGVkQ2hpbGRyZW4ocywgZSwgbiwgbyk7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IDAsIGQgPSB0OyBwIDwgZC5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgICAgIHZhciBfID0gZFtwXSxcbiAgICAgICAgICAgICAgZiA9IHRoaXMuX3RpbGVzW18ua2V5XTtcblxuICAgICAgICAgIGlmICghZi5oYXNEYXRhKCkpIHtcbiAgICAgICAgICAgIGlmIChlICsgMSA+IHRoaXMuX3NvdXJjZS5tYXh6b29tKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gXy5jaGlsZHJlbih0aGlzLl9zb3VyY2UubWF4em9vbSlbMF0sXG4gICAgICAgICAgICAgICAgICBnID0gdGhpcy5nZXRUaWxlKG0pO1xuXG4gICAgICAgICAgICAgIGlmIChnICYmIGcuaGFzRGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgb1ttLmtleV0gPSBtO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdiA9IF8uY2hpbGRyZW4odGhpcy5fc291cmNlLm1heHpvb20pO1xuXG4gICAgICAgICAgICAgIGlmIChvW3ZbMF0ua2V5XSAmJiBvW3ZbMV0ua2V5XSAmJiBvW3ZbMl0ua2V5XSAmJiBvW3ZbM10ua2V5XSkgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIHkgPSBmLndhc1JlcXVlc3RlZCgpLCB4ID0gXy5vdmVyc2NhbGVkWiAtIDE7IHggPj0gYTsgLS14KSB7XG4gICAgICAgICAgICAgIHZhciBiID0gXy5zY2FsZWRUbyh4KTtcblxuICAgICAgICAgICAgICBpZiAocltiLmtleV0pIGJyZWFrO1xuICAgICAgICAgICAgICBpZiAocltiLmtleV0gPSAhMCwgIShmID0gdGhpcy5nZXRUaWxlKGIpKSAmJiB5ICYmIChmID0gdGhpcy5fYWRkVGlsZShiKSksIGYgJiYgKG9bYi5rZXldID0gYiwgeSA9IGYud2FzUmVxdWVzdGVkKCksIGYuaGFzRGF0YSgpKSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdXBkYXRlTG9hZGVkUGFyZW50VGlsZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzID0ge30sIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IFtdLCBpID0gdm9pZCAwLCBvID0gdGhpcy5fdGlsZXNbdF0udGlsZUlEOyBvLm92ZXJzY2FsZWRaID4gMDspIHtcbiAgICAgICAgICAgIGlmIChvLmtleSBpbiB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlcykge1xuICAgICAgICAgICAgICBpID0gdGhpcy5fbG9hZGVkUGFyZW50VGlsZXNbby5rZXldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wdXNoKG8ua2V5KTtcbiAgICAgICAgICAgIHZhciByID0gby5zY2FsZWRUbyhvLm92ZXJzY2FsZWRaIC0gMSk7XG4gICAgICAgICAgICBpZiAoaSA9IHRoaXMuX2dldExvYWRlZFRpbGUocikpIGJyZWFrO1xuICAgICAgICAgICAgbyA9IHI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgYSA9IDAsIG4gPSBlOyBhIDwgbi5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkUGFyZW50VGlsZXNbblthXV0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX2FkZFRpbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX3RpbGVzW2Uua2V5XTtcbiAgICAgICAgaWYgKGkpIHJldHVybiBpO1xuICAgICAgICAoaSA9IHRoaXMuX2NhY2hlLmdldEFuZFJlbW92ZShlKSkgJiYgKHRoaXMuX3NldFRpbGVSZWxvYWRUaW1lcihlLmtleSwgaSksIGkudGlsZUlEID0gZSwgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZVRpbGVTdGF0ZShpLCB0aGlzLm1hcCA/IHRoaXMubWFwLnBhaW50ZXIgOiBudWxsKSwgdGhpcy5fY2FjaGVUaW1lcnNbZS5rZXldICYmIChjbGVhclRpbWVvdXQodGhpcy5fY2FjaGVUaW1lcnNbZS5rZXldKSwgZGVsZXRlIHRoaXMuX2NhY2hlVGltZXJzW2Uua2V5XSwgdGhpcy5fc2V0VGlsZVJlbG9hZFRpbWVyKGUua2V5LCBpKSkpO1xuICAgICAgICB2YXIgbyA9IEJvb2xlYW4oaSk7XG4gICAgICAgIHJldHVybiBvIHx8IChpID0gbmV3IHQuVGlsZShlLCB0aGlzLl9zb3VyY2UudGlsZVNpemUgKiBlLm92ZXJzY2FsZUZhY3RvcigpKSwgdGhpcy5fbG9hZFRpbGUoaSwgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIGksIGUua2V5LCBpLnN0YXRlKSkpLCBpID8gKGkudXNlcysrLCB0aGlzLl90aWxlc1tlLmtleV0gPSBpLCBvIHx8IHRoaXMuX3NvdXJjZS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgIHRpbGU6IGksXG4gICAgICAgICAgY29vcmQ6IGkudGlsZUlELFxuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiXG4gICAgICAgIH0pKSwgaSkgOiBudWxsO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3NldFRpbGVSZWxvYWRUaW1lciA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgdCBpbiB0aGlzLl90aW1lcnMgJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lcnNbdF0pLCBkZWxldGUgdGhpcy5fdGltZXJzW3RdKTtcbiAgICAgICAgdmFyIG8gPSBlLmdldEV4cGlyeVRpbWVvdXQoKTtcbiAgICAgICAgbyAmJiAodGhpcy5fdGltZXJzW3RdID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaS5fcmVsb2FkVGlsZSh0LCBcImV4cGlyZWRcIiksIGRlbGV0ZSBpLl90aW1lcnNbdF07XG4gICAgICAgIH0sIG8pKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9yZW1vdmVUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgICAgZSAmJiAoZS51c2VzLS0sIGRlbGV0ZSB0aGlzLl90aWxlc1t0XSwgdGhpcy5fdGltZXJzW3RdICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZXJzW3RdKSwgZGVsZXRlIHRoaXMuX3RpbWVyc1t0XSksIGUudXNlcyA+IDAgfHwgKGUuaGFzRGF0YSgpICYmIFwicmVsb2FkaW5nXCIgIT09IGUuc3RhdGUgPyB0aGlzLl9jYWNoZS5hZGQoZS50aWxlSUQsIGUsIGUuZ2V0RXhwaXJ5VGltZW91dCgpKSA6IChlLmFib3J0ZWQgPSAhMCwgdGhpcy5fYWJvcnRUaWxlKGUpLCB0aGlzLl91bmxvYWRUaWxlKGUpKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY2xlYXJUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl9zaG91bGRSZWxvYWRPblJlc3VtZSA9ICExLCB0aGlzLl9wYXVzZWQgPSAhMSwgdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGUucmVzZXQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnRpbGVzSW4gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2YXIgciA9IHRoaXMsXG4gICAgICAgICAgICBhID0gW10sXG4gICAgICAgICAgICBuID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghbikgcmV0dXJuIGE7XG5cbiAgICAgICAgZm9yICh2YXIgcyA9IG8gPyBuLmdldENhbWVyYVF1ZXJ5R2VvbWV0cnkoZSkgOiBlLCBsID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbi5wb2ludENvb3JkaW5hdGUodCk7XG4gICAgICAgIH0pLCBjID0gcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbi5wb2ludENvb3JkaW5hdGUodCk7XG4gICAgICAgIH0pLCB1ID0gdGhpcy5nZXRJZHMoKSwgaCA9IDEgLyAwLCBwID0gMSAvIDAsIGQgPSAtMSAvIDAsIF8gPSAtMSAvIDAsIGYgPSAwLCBtID0gYzsgZiA8IG0ubGVuZ3RoOyBmICs9IDEpIHtcbiAgICAgICAgICB2YXIgZyA9IG1bZl07XG4gICAgICAgICAgaCA9IE1hdGgubWluKGgsIGcueCksIHAgPSBNYXRoLm1pbihwLCBnLnkpLCBkID0gTWF0aC5tYXgoZCwgZy54KSwgXyA9IE1hdGgubWF4KF8sIGcueSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB2ID0gZnVuY3Rpb24gdihlKSB7XG4gICAgICAgICAgdmFyIG8gPSByLl90aWxlc1t1W2VdXTtcblxuICAgICAgICAgIGlmICghby5ob2xkaW5nRm9yRmFkZSgpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG8udGlsZUlELFxuICAgICAgICAgICAgICAgIGYgPSBNYXRoLnBvdygyLCBuLnpvb20gLSBvLnRpbGVJRC5vdmVyc2NhbGVkWiksXG4gICAgICAgICAgICAgICAgbSA9IGkgKiBvLnF1ZXJ5UGFkZGluZyAqIHQuRVhURU5UIC8gby50aWxlU2l6ZSAvIGYsXG4gICAgICAgICAgICAgICAgZyA9IFtzLmdldFRpbGVQb2ludChuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoaCwgcCkpLCBzLmdldFRpbGVQb2ludChuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoZCwgXykpXTtcblxuICAgICAgICAgICAgaWYgKGdbMF0ueCAtIG0gPCB0LkVYVEVOVCAmJiBnWzBdLnkgLSBtIDwgdC5FWFRFTlQgJiYgZ1sxXS54ICsgbSA+PSAwICYmIGdbMV0ueSArIG0gPj0gMCkge1xuICAgICAgICAgICAgICB2YXIgdiA9IGwubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuZ2V0VGlsZVBvaW50KHQpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHkgPSBjLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLmdldFRpbGVQb2ludCh0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGEucHVzaCh7XG4gICAgICAgICAgICAgICAgdGlsZTogbyxcbiAgICAgICAgICAgICAgICB0aWxlSUQ6IHMsXG4gICAgICAgICAgICAgICAgcXVlcnlHZW9tZXRyeTogdixcbiAgICAgICAgICAgICAgICBjYW1lcmFRdWVyeUdlb21ldHJ5OiB5LFxuICAgICAgICAgICAgICAgIHNjYWxlOiBmXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgeSA9IDA7IHkgPCB1Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdih5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VmlzaWJsZUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMsIGkgPSB0aGlzLmdldFJlbmRlcmFibGVJZHModCkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGUuX3RpbGVzW3RdLnRpbGVJRDtcbiAgICAgICAgfSksIG8gPSAwLCByID0gaTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHJbb107XG4gICAgICAgICAgYS5wb3NNYXRyaXggPSB0aGlzLnRyYW5zZm9ybS5jYWxjdWxhdGVQb3NNYXRyaXgoYS50b1Vud3JhcHBlZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZS5oYXNUcmFuc2l0aW9uKCkpIHJldHVybiAhMDtcbiAgICAgICAgaWYgKE10KHRoaXMuX3NvdXJjZS50eXBlKSkgZm9yICh2YXIgZSBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fdGlsZXNbZV07XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaS5mYWRlRW5kVGltZSAmJiBpLmZhZGVFbmRUaW1lID49IHQuYnJvd3Nlci5ub3coKSkgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldEZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlLnVwZGF0ZVN0YXRlKHQgPSB0IHx8IFwiX2dlb2pzb25UaWxlTGF5ZXJcIiwgZSwgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB0aGlzLl9zdGF0ZS5yZW1vdmVGZWF0dXJlU3RhdGUodCA9IHQgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLCBlLCBpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRTdGF0ZSh0ID0gdCB8fCBcIl9nZW9qc29uVGlsZUxheWVyXCIsIGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgICAgbyAmJiBvLnNldERlcGVuZGVuY2llcyhlLCBpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbG9hZFRpbGVzRm9yRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHRoaXMuX3RpbGVzW2ldLmhhc0RlcGVuZGVuY3kodCwgZSkgJiYgdGhpcy5fcmVsb2FkVGlsZShpLCBcInJlbG9hZGluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiAhaS5oYXNEZXBlbmRlbmN5KHQsIGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGk7XG4gICAgfSh0LkV2ZW50ZWQpO1xuXG4gICAgZnVuY3Rpb24gQXQodCwgZSkge1xuICAgICAgdmFyIGkgPSBNYXRoLmFicygyICogdC53cmFwKSAtICsodC53cmFwIDwgMCksXG4gICAgICAgICAgbyA9IE1hdGguYWJzKDIgKiBlLndyYXApIC0gKyhlLndyYXAgPCAwKTtcbiAgICAgIHJldHVybiB0Lm92ZXJzY2FsZWRaIC0gZS5vdmVyc2NhbGVkWiB8fCBvIC0gaSB8fCBlLmNhbm9uaWNhbC55IC0gdC5jYW5vbmljYWwueSB8fCBlLmNhbm9uaWNhbC54IC0gdC5jYW5vbmljYWwueDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNdCh0KSB7XG4gICAgICByZXR1cm4gXCJyYXN0ZXJcIiA9PT0gdCB8fCBcImltYWdlXCIgPT09IHQgfHwgXCJ2aWRlb1wiID09PSB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEx0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0LndpbmRvdy5Xb3JrZXIoS3Iud29ya2VyVXJsKTtcbiAgICB9XG5cbiAgICBEdC5tYXhPdmVyem9vbWluZyA9IDEwLCBEdC5tYXhVbmRlcnpvb21pbmcgPSAzO1xuXG4gICAgdmFyIFJ0ID0gXCJtYXBib3hnbF9wcmVsb2FkZWRfd29ya2VyX3Bvb2xcIixcbiAgICAgICAga3QgPSBmdW5jdGlvbiBrdCgpIHtcbiAgICAgIHRoaXMuYWN0aXZlID0ge307XG4gICAgfTtcblxuICAgIGt0LnByb3RvdHlwZS5hY3F1aXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICghdGhpcy53b3JrZXJzKSBmb3IgKHRoaXMud29ya2VycyA9IFtdOyB0aGlzLndvcmtlcnMubGVuZ3RoIDwga3Qud29ya2VyQ291bnQ7KSB7XG4gICAgICAgIHRoaXMud29ya2Vycy5wdXNoKG5ldyBMdCgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVt0XSA9ICEwLCB0aGlzLndvcmtlcnMuc2xpY2UoKTtcbiAgICB9LCBrdC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBkZWxldGUgdGhpcy5hY3RpdmVbdF0sIDAgPT09IHRoaXMubnVtQWN0aXZlKCkgJiYgKHRoaXMud29ya2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQudGVybWluYXRlKCk7XG4gICAgICB9KSwgdGhpcy53b3JrZXJzID0gbnVsbCk7XG4gICAgfSwga3QucHJvdG90eXBlLmlzUHJlbG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5hY3RpdmVbUnRdO1xuICAgIH0sIGt0LnByb3RvdHlwZS5udW1BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hY3RpdmUpLmxlbmd0aDtcbiAgICB9O1xuICAgIHZhciBCdCxcbiAgICAgICAgT3QgPSBNYXRoLmZsb29yKHQuYnJvd3Nlci5oYXJkd2FyZUNvbmN1cnJlbmN5IC8gMik7XG5cbiAgICBmdW5jdGlvbiBGdCgpIHtcbiAgICAgIHJldHVybiBCdCB8fCAoQnQgPSBuZXcga3QoKSksIEJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFV0KGUsIGkpIHtcbiAgICAgIHZhciBvID0ge307XG5cbiAgICAgIGZvciAodmFyIHIgaW4gZSkge1xuICAgICAgICBcInJlZlwiICE9PSByICYmIChvW3JdID0gZVtyXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LnJlZlByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0IGluIGkgJiYgKG9bdF0gPSBpW3RdKTtcbiAgICAgIH0pLCBvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE50KHQpIHtcbiAgICAgIHQgPSB0LnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGUgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZVt0W2ldLmlkXSA9IHRbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdC5sZW5ndGg7IG8rKykge1xuICAgICAgICBcInJlZlwiIGluIHRbb10gJiYgKHRbb10gPSBVdCh0W29dLCBlW3Rbb10ucmVmXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBrdC53b3JrZXJDb3VudCA9IE1hdGgubWF4KE1hdGgubWluKE90LCA2KSwgMSk7XG4gICAgdmFyIFp0ID0ge1xuICAgICAgc2V0U3R5bGU6IFwic2V0U3R5bGVcIixcbiAgICAgIGFkZExheWVyOiBcImFkZExheWVyXCIsXG4gICAgICByZW1vdmVMYXllcjogXCJyZW1vdmVMYXllclwiLFxuICAgICAgc2V0UGFpbnRQcm9wZXJ0eTogXCJzZXRQYWludFByb3BlcnR5XCIsXG4gICAgICBzZXRMYXlvdXRQcm9wZXJ0eTogXCJzZXRMYXlvdXRQcm9wZXJ0eVwiLFxuICAgICAgc2V0RmlsdGVyOiBcInNldEZpbHRlclwiLFxuICAgICAgYWRkU291cmNlOiBcImFkZFNvdXJjZVwiLFxuICAgICAgcmVtb3ZlU291cmNlOiBcInJlbW92ZVNvdXJjZVwiLFxuICAgICAgc2V0R2VvSlNPTlNvdXJjZURhdGE6IFwic2V0R2VvSlNPTlNvdXJjZURhdGFcIixcbiAgICAgIHNldExheWVyWm9vbVJhbmdlOiBcInNldExheWVyWm9vbVJhbmdlXCIsXG4gICAgICBzZXRMYXllclByb3BlcnR5OiBcInNldExheWVyUHJvcGVydHlcIixcbiAgICAgIHNldENlbnRlcjogXCJzZXRDZW50ZXJcIixcbiAgICAgIHNldFpvb206IFwic2V0Wm9vbVwiLFxuICAgICAgc2V0QmVhcmluZzogXCJzZXRCZWFyaW5nXCIsXG4gICAgICBzZXRQaXRjaDogXCJzZXRQaXRjaFwiLFxuICAgICAgc2V0U3ByaXRlOiBcInNldFNwcml0ZVwiLFxuICAgICAgc2V0R2x5cGhzOiBcInNldEdseXBoc1wiLFxuICAgICAgc2V0VHJhbnNpdGlvbjogXCJzZXRUcmFuc2l0aW9uXCIsXG4gICAgICBzZXRMaWdodDogXCJzZXRMaWdodFwiXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHF0KHQsIGUsIGkpIHtcbiAgICAgIGkucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IFp0LmFkZFNvdXJjZSxcbiAgICAgICAgYXJnczogW3QsIGVbdF1dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqdCh0LCBlLCBpKSB7XG4gICAgICBlLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVTb3VyY2UsXG4gICAgICAgIGFyZ3M6IFt0XVxuICAgICAgfSksIGlbdF0gPSAhMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBWdCh0LCBlLCBpLCBvKSB7XG4gICAgICBqdCh0LCBpLCBvKSwgcXQodCwgZSwgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR3QoZSwgaSwgbykge1xuICAgICAgdmFyIHI7XG5cbiAgICAgIGZvciAociBpbiBlW29dKSB7XG4gICAgICAgIGlmIChlW29dLmhhc093blByb3BlcnR5KHIpICYmIFwiZGF0YVwiICE9PSByICYmICF0LmRlZXBFcXVhbChlW29dW3JdLCBpW29dW3JdKSkgcmV0dXJuICExO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHIgaW4gaVtvXSkge1xuICAgICAgICBpZiAoaVtvXS5oYXNPd25Qcm9wZXJ0eShyKSAmJiBcImRhdGFcIiAhPT0gciAmJiAhdC5kZWVwRXF1YWwoZVtvXVtyXSwgaVtvXVtyXSkpIHJldHVybiAhMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFd0KGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzO1xuXG4gICAgICBmb3IgKHMgaW4gaSA9IGkgfHwge30sIGUgPSBlIHx8IHt9KSB7XG4gICAgICAgIGUuaGFzT3duUHJvcGVydHkocykgJiYgKHQuZGVlcEVxdWFsKGVbc10sIGlbc10pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgY29tbWFuZDogbixcbiAgICAgICAgICBhcmdzOiBbciwgcywgaVtzXSwgYV1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHMgaW4gaSkge1xuICAgICAgICBpLmhhc093blByb3BlcnR5KHMpICYmICFlLmhhc093blByb3BlcnR5KHMpICYmICh0LmRlZXBFcXVhbChlW3NdLCBpW3NdKSB8fCBvLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6IG4sXG4gICAgICAgICAgYXJnczogW3IsIHMsIGlbc10sIGFdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBYdCh0KSB7XG4gICAgICByZXR1cm4gdC5pZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIdCh0LCBlKSB7XG4gICAgICByZXR1cm4gdFtlLmlkXSA9IGUsIHQ7XG4gICAgfVxuXG4gICAgdmFyIEt0ID0gZnVuY3Rpb24gS3QodCwgZSkge1xuICAgICAgdGhpcy5yZXNldCh0LCBlKTtcbiAgICB9O1xuXG4gICAgS3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucG9pbnRzID0gdCB8fCBbXSwgdGhpcy5fZGlzdGFuY2VzID0gWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlc1tpXSA9IHRoaXMuX2Rpc3RhbmNlc1tpIC0gMV0gKyB0aGlzLnBvaW50c1tpXS5kaXN0KHRoaXMucG9pbnRzW2kgLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZGlzdGFuY2VzW3RoaXMuX2Rpc3RhbmNlcy5sZW5ndGggLSAxXSwgdGhpcy5wYWRkaW5nID0gTWF0aC5taW4oZSB8fCAwLCAuNSAqIHRoaXMubGVuZ3RoKSwgdGhpcy5wYWRkZWRMZW5ndGggPSB0aGlzLmxlbmd0aCAtIDIgKiB0aGlzLnBhZGRpbmc7XG4gICAgfSwgS3QucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKDEgPT09IHRoaXMucG9pbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMucG9pbnRzWzBdO1xuICAgICAgZSA9IHQuY2xhbXAoZSwgMCwgMSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBvID0gdGhpcy5fZGlzdGFuY2VzW2ldLCByID0gZSAqIHRoaXMucGFkZGVkTGVuZ3RoICsgdGhpcy5wYWRkaW5nOyBvIDwgciAmJiBpIDwgdGhpcy5fZGlzdGFuY2VzLmxlbmd0aDspIHtcbiAgICAgICAgbyA9IHRoaXMuX2Rpc3RhbmNlc1srK2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYSA9IGkgLSAxLFxuICAgICAgICAgIG4gPSB0aGlzLl9kaXN0YW5jZXNbYV0sXG4gICAgICAgICAgcyA9IG8gLSBuLFxuICAgICAgICAgIGwgPSBzID4gMCA/IChyIC0gbikgLyBzIDogMDtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50c1thXS5tdWx0KDEgLSBsKS5hZGQodGhpcy5wb2ludHNbaV0ubXVsdChsKSk7XG4gICAgfTtcblxuICAgIHZhciBZdCA9IGZ1bmN0aW9uIFl0KHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5ib3hDZWxscyA9IFtdLFxuICAgICAgICAgIHIgPSB0aGlzLmNpcmNsZUNlbGxzID0gW107XG4gICAgICB0aGlzLnhDZWxsQ291bnQgPSBNYXRoLmNlaWwodCAvIGkpLCB0aGlzLnlDZWxsQ291bnQgPSBNYXRoLmNlaWwoZSAvIGkpO1xuXG4gICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMueENlbGxDb3VudCAqIHRoaXMueUNlbGxDb3VudDsgYSsrKSB7XG4gICAgICAgIG8ucHVzaChbXSksIHIucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2lyY2xlS2V5cyA9IFtdLCB0aGlzLmJveEtleXMgPSBbXSwgdGhpcy5iYm94ZXMgPSBbXSwgdGhpcy5jaXJjbGVzID0gW10sIHRoaXMud2lkdGggPSB0LCB0aGlzLmhlaWdodCA9IGUsIHRoaXMueFNjYWxlID0gdGhpcy54Q2VsbENvdW50IC8gdCwgdGhpcy55U2NhbGUgPSB0aGlzLnlDZWxsQ291bnQgLyBlLCB0aGlzLmJveFVpZCA9IDAsIHRoaXMuY2lyY2xlVWlkID0gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSnQoZSwgaSwgbywgciwgYSkge1xuICAgICAgdmFyIG4gPSB0LmNyZWF0ZSgpO1xuICAgICAgcmV0dXJuIGkgPyAodC5zY2FsZShuLCBuLCBbMSAvIGEsIDEgLyBhLCAxXSksIG8gfHwgdC5yb3RhdGVaKG4sIG4sIHIuYW5nbGUpKSA6IHQubXVsdGlwbHkobiwgci5sYWJlbFBsYW5lTWF0cml4LCBlKSwgbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBRdChlLCBpLCBvLCByLCBhKSB7XG4gICAgICBpZiAoaSkge1xuICAgICAgICB2YXIgbiA9IHQuY2xvbmUoZSk7XG4gICAgICAgIHJldHVybiB0LnNjYWxlKG4sIG4sIFthLCBhLCAxXSksIG8gfHwgdC5yb3RhdGVaKG4sIG4sIC1yLmFuZ2xlKSwgbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHIuZ2xDb29yZE1hdHJpeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkdChlLCBpKSB7XG4gICAgICB2YXIgbyA9IFtlLngsIGUueSwgMCwgMV07XG4gICAgICB1ZShvLCBvLCBpKTtcbiAgICAgIHZhciByID0gb1szXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBuZXcgdC5Qb2ludChvWzBdIC8gciwgb1sxXSAvIHIpLFxuICAgICAgICBzaWduZWREaXN0YW5jZUZyb21DYW1lcmE6IHJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGUodCwgZSkge1xuICAgICAgcmV0dXJuIC41ICsgdCAvIGUgKiAuNTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlZSh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHRbMF0gLyB0WzNdLFxuICAgICAgICAgIG8gPSB0WzFdIC8gdFszXTtcbiAgICAgIHJldHVybiBpID49IC1lWzBdICYmIGkgPD0gZVswXSAmJiBvID49IC1lWzFdICYmIG8gPD0gZVsxXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZShlLCBpLCBvLCByLCBhLCBuLCBzLCBsKSB7XG4gICAgICB2YXIgYyA9IHIgPyBlLnRleHRTaXplRGF0YSA6IGUuaWNvblNpemVEYXRhLFxuICAgICAgICAgIHUgPSB0LmV2YWx1YXRlU2l6ZUZvclpvb20oYywgby50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgICAgaCA9IFsyNTYgLyBvLndpZHRoICogMiArIDEsIDI1NiAvIG8uaGVpZ2h0ICogMiArIDFdLFxuICAgICAgICAgIHAgPSByID8gZS50ZXh0LmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheSA6IGUuaWNvbi5keW5hbWljTGF5b3V0VmVydGV4QXJyYXk7XG4gICAgICBwLmNsZWFyKCk7XG5cbiAgICAgIGZvciAodmFyIGQgPSBlLmxpbmVWZXJ0ZXhBcnJheSwgXyA9IHIgPyBlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkgOiBlLmljb24ucGxhY2VkU3ltYm9sQXJyYXksIGYgPSBvLnRyYW5zZm9ybS53aWR0aCAvIG8udHJhbnNmb3JtLmhlaWdodCwgbSA9ICExLCBnID0gMDsgZyA8IF8ubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgdmFyIHYgPSBfLmdldChnKTtcblxuICAgICAgICBpZiAodi5oaWRkZW4gfHwgdi53cml0aW5nTW9kZSA9PT0gdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCAmJiAhbSkgY2Uodi5udW1HbHlwaHMsIHApO2Vsc2Uge1xuICAgICAgICAgIG0gPSAhMTtcbiAgICAgICAgICB2YXIgeSA9IFt2LmFuY2hvclgsIHYuYW5jaG9yWSwgMCwgMV07XG5cbiAgICAgICAgICBpZiAodC50cmFuc2Zvcm1NYXQ0KHksIHksIGkpLCBlZSh5LCBoKSkge1xuICAgICAgICAgICAgdmFyIHggPSB0ZShvLnRyYW5zZm9ybS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlLCB5WzNdKSxcbiAgICAgICAgICAgICAgICBiID0gdC5ldmFsdWF0ZVNpemVGb3JGZWF0dXJlKGMsIHUsIHYpLFxuICAgICAgICAgICAgICAgIHcgPSBzID8gYiAvIHggOiBiICogeCxcbiAgICAgICAgICAgICAgICBUID0gbmV3IHQuUG9pbnQodi5hbmNob3JYLCB2LmFuY2hvclkpLFxuICAgICAgICAgICAgICAgIEUgPSAkdChULCBhKS5wb2ludCxcbiAgICAgICAgICAgICAgICBJID0ge30sXG4gICAgICAgICAgICAgICAgUCA9IGFlKHYsIHcsICExLCBsLCBpLCBhLCBuLCBlLmdseXBoT2Zmc2V0QXJyYXksIGQsIHAsIEUsIFQsIEksIGYpO1xuICAgICAgICAgICAgbSA9IFAudXNlVmVydGljYWwsIChQLm5vdEVub3VnaFJvb20gfHwgbSB8fCBQLm5lZWRzRmxpcHBpbmcgJiYgYWUodiwgdywgITAsIGwsIGksIGEsIG4sIGUuZ2x5cGhPZmZzZXRBcnJheSwgZCwgcCwgRSwgVCwgSSwgZikubm90RW5vdWdoUm9vbSkgJiYgY2Uodi5udW1HbHlwaHMsIHApO1xuICAgICAgICAgIH0gZWxzZSBjZSh2Lm51bUdseXBocywgcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgciA/IGUudGV4dC5keW5hbWljTGF5b3V0VmVydGV4QnVmZmVyLnVwZGF0ZURhdGEocCkgOiBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9lKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUpIHtcbiAgICAgIHZhciBoID0gcy5nbHlwaFN0YXJ0SW5kZXggKyBzLm51bUdseXBocyxcbiAgICAgICAgICBwID0gcy5saW5lU3RhcnRJbmRleCxcbiAgICAgICAgICBkID0gcy5saW5lU3RhcnRJbmRleCArIHMubGluZUxlbmd0aCxcbiAgICAgICAgICBfID0gZS5nZXRvZmZzZXRYKHMuZ2x5cGhTdGFydEluZGV4KSxcbiAgICAgICAgICBmID0gZS5nZXRvZmZzZXRYKGggLSAxKSxcbiAgICAgICAgICBtID0gc2UodCAqIF8sIGksIG8sIHIsIGEsIG4sIHMuc2VnbWVudCwgcCwgZCwgbCwgYywgdSk7XG5cbiAgICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZyA9IHNlKHQgKiBmLCBpLCBvLCByLCBhLCBuLCBzLnNlZ21lbnQsIHAsIGQsIGwsIGMsIHUpO1xuICAgICAgcmV0dXJuIGcgPyB7XG4gICAgICAgIGZpcnN0OiBtLFxuICAgICAgICBsYXN0OiBnXG4gICAgICB9IDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZShlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4gZSA9PT0gdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsICYmIE1hdGguYWJzKG8ueSAtIGkueSkgPiBNYXRoLmFicyhvLnggLSBpLngpICogciA/IHtcbiAgICAgICAgdXNlVmVydGljYWw6ICEwXG4gICAgICB9IDogKGUgPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgPyBpLnkgPCBvLnkgOiBpLnggPiBvLngpID8ge1xuICAgICAgICBuZWVkc0ZsaXBwaW5nOiAhMFxuICAgICAgfSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWUoZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSwgaCwgcCwgZCwgXykge1xuICAgICAgdmFyIGYsXG4gICAgICAgICAgbSA9IGkgLyAyNCxcbiAgICAgICAgICBnID0gZS5saW5lT2Zmc2V0WCAqIG0sXG4gICAgICAgICAgdiA9IGUubGluZU9mZnNldFkgKiBtO1xuXG4gICAgICBpZiAoZS5udW1HbHlwaHMgPiAxKSB7XG4gICAgICAgIHZhciB5ID0gZS5nbHlwaFN0YXJ0SW5kZXggKyBlLm51bUdseXBocyxcbiAgICAgICAgICAgIHggPSBlLmxpbmVTdGFydEluZGV4LFxuICAgICAgICAgICAgYiA9IGUubGluZVN0YXJ0SW5kZXggKyBlLmxpbmVMZW5ndGgsXG4gICAgICAgICAgICB3ID0gb2UobSwgbCwgZywgdiwgbywgaCwgcCwgZSwgYywgbiwgZCk7XG4gICAgICAgIGlmICghdykgcmV0dXJuIHtcbiAgICAgICAgICBub3RFbm91Z2hSb29tOiAhMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgVCA9ICR0KHcuZmlyc3QucG9pbnQsIHMpLnBvaW50LFxuICAgICAgICAgICAgRSA9ICR0KHcubGFzdC5wb2ludCwgcykucG9pbnQ7XG5cbiAgICAgICAgaWYgKHIgJiYgIW8pIHtcbiAgICAgICAgICB2YXIgSSA9IHJlKGUud3JpdGluZ01vZGUsIFQsIEUsIF8pO1xuICAgICAgICAgIGlmIChJKSByZXR1cm4gSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYgPSBbdy5maXJzdF07XG5cbiAgICAgICAgZm9yICh2YXIgUCA9IGUuZ2x5cGhTdGFydEluZGV4ICsgMTsgUCA8IHkgLSAxOyBQKyspIHtcbiAgICAgICAgICBmLnB1c2goc2UobSAqIGwuZ2V0b2Zmc2V0WChQKSwgZywgdiwgbywgaCwgcCwgZS5zZWdtZW50LCB4LCBiLCBjLCBuLCBkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmLnB1c2gody5sYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyICYmICFvKSB7XG4gICAgICAgICAgdmFyIFMgPSAkdChwLCBhKS5wb2ludCxcbiAgICAgICAgICAgICAgQyA9IGUubGluZVN0YXJ0SW5kZXggKyBlLnNlZ21lbnQgKyAxLFxuICAgICAgICAgICAgICB6ID0gbmV3IHQuUG9pbnQoYy5nZXR4KEMpLCBjLmdldHkoQykpLFxuICAgICAgICAgICAgICBEID0gJHQoeiwgYSksXG4gICAgICAgICAgICAgIEEgPSBELnNpZ25lZERpc3RhbmNlRnJvbUNhbWVyYSA+IDAgPyBELnBvaW50IDogbmUocCwgeiwgUywgMSwgYSksXG4gICAgICAgICAgICAgIE0gPSByZShlLndyaXRpbmdNb2RlLCBTLCBBLCBfKTtcbiAgICAgICAgICBpZiAoTSkgcmV0dXJuIE07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgTCA9IHNlKG0gKiBsLmdldG9mZnNldFgoZS5nbHlwaFN0YXJ0SW5kZXgpLCBnLCB2LCBvLCBoLCBwLCBlLnNlZ21lbnQsIGUubGluZVN0YXJ0SW5kZXgsIGUubGluZVN0YXJ0SW5kZXggKyBlLmxpbmVMZW5ndGgsIGMsIG4sIGQpO1xuICAgICAgICBpZiAoIUwpIHJldHVybiB7XG4gICAgICAgICAgbm90RW5vdWdoUm9vbTogITBcbiAgICAgICAgfTtcbiAgICAgICAgZiA9IFtMXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgUiA9IDAsIGsgPSBmOyBSIDwgay5sZW5ndGg7IFIgKz0gMSkge1xuICAgICAgICB2YXIgQiA9IGtbUl07XG4gICAgICAgIHQuYWRkRHluYW1pY0F0dHJpYnV0ZXModSwgQi5wb2ludCwgQi5hbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSA9ICR0KHQuYWRkKHQuc3ViKGUpLl91bml0KCkpLCByKS5wb2ludCxcbiAgICAgICAgICBuID0gaS5zdWIoYSk7XG4gICAgICByZXR1cm4gaS5hZGQobi5fbXVsdChvIC8gbi5tYWcoKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgsIHApIHtcbiAgICAgIHZhciBkID0gciA/IGUgLSBpIDogZSArIGksXG4gICAgICAgICAgXyA9IGQgPiAwID8gMSA6IC0xLFxuICAgICAgICAgIGYgPSAwO1xuXG4gICAgICByICYmIChfICo9IC0xLCBmID0gTWF0aC5QSSksIF8gPCAwICYmIChmICs9IE1hdGguUEkpO1xuXG4gICAgICBmb3IgKHZhciBtID0gXyA+IDAgPyBsICsgcyA6IGwgKyBzICsgMSwgZyA9IGEsIHYgPSBhLCB5ID0gMCwgeCA9IDAsIGIgPSBNYXRoLmFicyhkKSwgdyA9IFtdOyB5ICsgeCA8PSBiOykge1xuICAgICAgICBpZiAoKG0gKz0gXykgPCBsIHx8IG0gPj0gYykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKHYgPSBnLCB3LnB1c2goZyksIHZvaWQgMCA9PT0gKGcgPSBwW21dKSkge1xuICAgICAgICAgIHZhciBUID0gbmV3IHQuUG9pbnQodS5nZXR4KG0pLCB1LmdldHkobSkpLFxuICAgICAgICAgICAgICBFID0gJHQoVCwgaCk7XG4gICAgICAgICAgaWYgKEUuc2lnbmVkRGlzdGFuY2VGcm9tQ2FtZXJhID4gMCkgZyA9IHBbbV0gPSBFLnBvaW50O2Vsc2Uge1xuICAgICAgICAgICAgdmFyIEkgPSBtIC0gXztcbiAgICAgICAgICAgIGcgPSBuZSgwID09PSB5ID8gbiA6IG5ldyB0LlBvaW50KHUuZ2V0eChJKSwgdS5nZXR5KEkpKSwgVCwgdiwgYiAtIHkgKyAxLCBoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB5ICs9IHgsIHggPSB2LmRpc3QoZyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBQID0gKGIgLSB5KSAvIHgsXG4gICAgICAgICAgUyA9IGcuc3ViKHYpLFxuICAgICAgICAgIEMgPSBTLm11bHQoUCkuX2FkZCh2KTtcblxuICAgICAgQy5fYWRkKFMuX3VuaXQoKS5fcGVycCgpLl9tdWx0KG8gKiBfKSk7XG5cbiAgICAgIHZhciB6ID0gZiArIE1hdGguYXRhbjIoZy55IC0gdi55LCBnLnggLSB2LngpO1xuICAgICAgcmV0dXJuIHcucHVzaChDKSwge1xuICAgICAgICBwb2ludDogQyxcbiAgICAgICAgYW5nbGU6IHosXG4gICAgICAgIHBhdGg6IHdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgWXQucHJvdG90eXBlLmtleXNMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3hLZXlzLmxlbmd0aCArIHRoaXMuY2lyY2xlS2V5cy5sZW5ndGg7XG4gICAgfSwgWXQucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB0aGlzLl9mb3JFYWNoQ2VsbChlLCBpLCBvLCByLCB0aGlzLl9pbnNlcnRCb3hDZWxsLCB0aGlzLmJveFVpZCsrKSwgdGhpcy5ib3hLZXlzLnB1c2godCksIHRoaXMuYmJveGVzLnB1c2goZSksIHRoaXMuYmJveGVzLnB1c2goaSksIHRoaXMuYmJveGVzLnB1c2gobyksIHRoaXMuYmJveGVzLnB1c2gocik7XG4gICAgfSwgWXQucHJvdG90eXBlLmluc2VydENpcmNsZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICB0aGlzLl9mb3JFYWNoQ2VsbChlIC0gbywgaSAtIG8sIGUgKyBvLCBpICsgbywgdGhpcy5faW5zZXJ0Q2lyY2xlQ2VsbCwgdGhpcy5jaXJjbGVVaWQrKyksIHRoaXMuY2lyY2xlS2V5cy5wdXNoKHQpLCB0aGlzLmNpcmNsZXMucHVzaChlKSwgdGhpcy5jaXJjbGVzLnB1c2goaSksIHRoaXMuY2lyY2xlcy5wdXNoKG8pO1xuICAgIH0sIFl0LnByb3RvdHlwZS5faW5zZXJ0Qm94Q2VsbCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB0aGlzLmJveENlbGxzW3JdLnB1c2goYSk7XG4gICAgfSwgWXQucHJvdG90eXBlLl9pbnNlcnRDaXJjbGVDZWxsID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHRoaXMuY2lyY2xlQ2VsbHNbcl0ucHVzaChhKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX3F1ZXJ5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIGlmIChpIDwgMCB8fCB0ID4gdGhpcy53aWR0aCB8fCBvIDwgMCB8fCBlID4gdGhpcy5oZWlnaHQpIHJldHVybiAhciAmJiBbXTtcbiAgICAgIHZhciBuID0gW107XG5cbiAgICAgIGlmICh0IDw9IDAgJiYgZSA8PSAwICYmIHRoaXMud2lkdGggPD0gaSAmJiB0aGlzLmhlaWdodCA8PSBvKSB7XG4gICAgICAgIGlmIChyKSByZXR1cm4gITA7XG5cbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0aGlzLmJveEtleXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICBuLnB1c2goe1xuICAgICAgICAgICAga2V5OiB0aGlzLmJveEtleXNbc10sXG4gICAgICAgICAgICB4MTogdGhpcy5iYm94ZXNbNCAqIHNdLFxuICAgICAgICAgICAgeTE6IHRoaXMuYmJveGVzWzQgKiBzICsgMV0sXG4gICAgICAgICAgICB4MjogdGhpcy5iYm94ZXNbNCAqIHMgKyAyXSxcbiAgICAgICAgICAgIHkyOiB0aGlzLmJib3hlc1s0ICogcyArIDNdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoaXMuY2lyY2xlS2V5cy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5jaXJjbGVzWzMgKiBsXSxcbiAgICAgICAgICAgICAgdSA9IHRoaXMuY2lyY2xlc1szICogbCArIDFdLFxuICAgICAgICAgICAgICBoID0gdGhpcy5jaXJjbGVzWzMgKiBsICsgMl07XG4gICAgICAgICAgbi5wdXNoKHtcbiAgICAgICAgICAgIGtleTogdGhpcy5jaXJjbGVLZXlzW2xdLFxuICAgICAgICAgICAgeDE6IGMgLSBoLFxuICAgICAgICAgICAgeTE6IHUgLSBoLFxuICAgICAgICAgICAgeDI6IGMgKyBoLFxuICAgICAgICAgICAgeTI6IHUgKyBoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSA/IG4uZmlsdGVyKGEpIDogbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2ZvckVhY2hDZWxsKHQsIGUsIGksIG8sIHRoaXMuX3F1ZXJ5Q2VsbCwgbiwge1xuICAgICAgICBoaXRUZXN0OiByLFxuICAgICAgICBzZWVuVWlkczoge1xuICAgICAgICAgIGJveDoge30sXG4gICAgICAgICAgY2lyY2xlOiB7fVxuICAgICAgICB9XG4gICAgICB9LCBhKSwgciA/IG4ubGVuZ3RoID4gMCA6IG47XG4gICAgfSwgWXQucHJvdG90eXBlLl9xdWVyeUNpcmNsZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSA9IHQgLSBpLFxuICAgICAgICAgIG4gPSB0ICsgaSxcbiAgICAgICAgICBzID0gZSAtIGksXG4gICAgICAgICAgbCA9IGUgKyBpO1xuICAgICAgaWYgKG4gPCAwIHx8IGEgPiB0aGlzLndpZHRoIHx8IGwgPCAwIHx8IHMgPiB0aGlzLmhlaWdodCkgcmV0dXJuICFvICYmIFtdO1xuICAgICAgdmFyIGMgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JFYWNoQ2VsbChhLCBzLCBuLCBsLCB0aGlzLl9xdWVyeUNlbGxDaXJjbGUsIGMsIHtcbiAgICAgICAgaGl0VGVzdDogbyxcbiAgICAgICAgY2lyY2xlOiB7XG4gICAgICAgICAgeDogdCxcbiAgICAgICAgICB5OiBlLFxuICAgICAgICAgIHJhZGl1czogaVxuICAgICAgICB9LFxuICAgICAgICBzZWVuVWlkczoge1xuICAgICAgICAgIGJveDoge30sXG4gICAgICAgICAgY2lyY2xlOiB7fVxuICAgICAgICB9XG4gICAgICB9LCByKSwgbyA/IGMubGVuZ3RoID4gMCA6IGM7XG4gICAgfSwgWXQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWVyeSh0LCBlLCBpLCBvLCAhMSwgcik7XG4gICAgfSwgWXQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5KHQsIGUsIGksIG8sICEwLCByKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuaGl0VGVzdENpcmNsZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVlcnlDaXJjbGUodCwgZSwgaSwgITAsIG8pO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fcXVlcnlDZWxsID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIHZhciBsID0gbi5zZWVuVWlkcyxcbiAgICAgICAgICBjID0gdGhpcy5ib3hDZWxsc1tyXTtcbiAgICAgIGlmIChudWxsICE9PSBjKSBmb3IgKHZhciB1ID0gdGhpcy5iYm94ZXMsIGggPSAwLCBwID0gYzsgaCA8IHAubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgdmFyIGQgPSBwW2hdO1xuXG4gICAgICAgIGlmICghbC5ib3hbZF0pIHtcbiAgICAgICAgICBsLmJveFtkXSA9ICEwO1xuXG4gICAgICAgICAgdmFyIF8gPSA0ICogZDtcblxuICAgICAgICAgIGlmICh0IDw9IHVbXyArIDJdICYmIGUgPD0gdVtfICsgM10gJiYgaSA+PSB1W18gKyAwXSAmJiBvID49IHVbXyArIDFdICYmICghcyB8fCBzKHRoaXMuYm94S2V5c1tkXSkpKSB7XG4gICAgICAgICAgICBpZiAobi5oaXRUZXN0KSByZXR1cm4gYS5wdXNoKCEwKSwgITA7XG4gICAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IHRoaXMuYm94S2V5c1tkXSxcbiAgICAgICAgICAgICAgeDE6IHVbX10sXG4gICAgICAgICAgICAgIHkxOiB1W18gKyAxXSxcbiAgICAgICAgICAgICAgeDI6IHVbXyArIDJdLFxuICAgICAgICAgICAgICB5MjogdVtfICsgM11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGYgPSB0aGlzLmNpcmNsZUNlbGxzW3JdO1xuICAgICAgaWYgKG51bGwgIT09IGYpIGZvciAodmFyIG0gPSB0aGlzLmNpcmNsZXMsIGcgPSAwLCB2ID0gZjsgZyA8IHYubGVuZ3RoOyBnICs9IDEpIHtcbiAgICAgICAgdmFyIHkgPSB2W2ddO1xuXG4gICAgICAgIGlmICghbC5jaXJjbGVbeV0pIHtcbiAgICAgICAgICBsLmNpcmNsZVt5XSA9ICEwO1xuICAgICAgICAgIHZhciB4ID0gMyAqIHk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fY2lyY2xlQW5kUmVjdENvbGxpZGUobVt4XSwgbVt4ICsgMV0sIG1beCArIDJdLCB0LCBlLCBpLCBvKSAmJiAoIXMgfHwgcyh0aGlzLmNpcmNsZUtleXNbeV0pKSkge1xuICAgICAgICAgICAgaWYgKG4uaGl0VGVzdCkgcmV0dXJuIGEucHVzaCghMCksICEwO1xuICAgICAgICAgICAgdmFyIGIgPSBtW3hdLFxuICAgICAgICAgICAgICAgIHcgPSBtW3ggKyAxXSxcbiAgICAgICAgICAgICAgICBUID0gbVt4ICsgMl07XG4gICAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IHRoaXMuY2lyY2xlS2V5c1t5XSxcbiAgICAgICAgICAgICAgeDE6IGIgLSBULFxuICAgICAgICAgICAgICB5MTogdyAtIFQsXG4gICAgICAgICAgICAgIHgyOiBiICsgVCxcbiAgICAgICAgICAgICAgeTI6IHcgKyBUXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBZdC5wcm90b3R5cGUuX3F1ZXJ5Q2VsbENpcmNsZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzKSB7XG4gICAgICB2YXIgbCA9IG4uY2lyY2xlLFxuICAgICAgICAgIGMgPSBuLnNlZW5VaWRzLFxuICAgICAgICAgIHUgPSB0aGlzLmJveENlbGxzW3JdO1xuICAgICAgaWYgKG51bGwgIT09IHUpIGZvciAodmFyIGggPSB0aGlzLmJib3hlcywgcCA9IDAsIGQgPSB1OyBwIDwgZC5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgICB2YXIgXyA9IGRbcF07XG5cbiAgICAgICAgaWYgKCFjLmJveFtfXSkge1xuICAgICAgICAgIGMuYm94W19dID0gITA7XG4gICAgICAgICAgdmFyIGYgPSA0ICogXztcbiAgICAgICAgICBpZiAodGhpcy5fY2lyY2xlQW5kUmVjdENvbGxpZGUobC54LCBsLnksIGwucmFkaXVzLCBoW2YgKyAwXSwgaFtmICsgMV0sIGhbZiArIDJdLCBoW2YgKyAzXSkgJiYgKCFzIHx8IHModGhpcy5ib3hLZXlzW19dKSkpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG0gPSB0aGlzLmNpcmNsZUNlbGxzW3JdO1xuICAgICAgaWYgKG51bGwgIT09IG0pIGZvciAodmFyIGcgPSB0aGlzLmNpcmNsZXMsIHYgPSAwLCB5ID0gbTsgdiA8IHkubGVuZ3RoOyB2ICs9IDEpIHtcbiAgICAgICAgdmFyIHggPSB5W3ZdO1xuXG4gICAgICAgIGlmICghYy5jaXJjbGVbeF0pIHtcbiAgICAgICAgICBjLmNpcmNsZVt4XSA9ICEwO1xuICAgICAgICAgIHZhciBiID0gMyAqIHg7XG4gICAgICAgICAgaWYgKHRoaXMuX2NpcmNsZXNDb2xsaWRlKGdbYl0sIGdbYiArIDFdLCBnW2IgKyAyXSwgbC54LCBsLnksIGwucmFkaXVzKSAmJiAoIXMgfHwgcyh0aGlzLmNpcmNsZUtleXNbeF0pKSkgcmV0dXJuIGEucHVzaCghMCksICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgWXQucHJvdG90eXBlLl9mb3JFYWNoQ2VsbCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzKSB7XG4gICAgICBmb3IgKHZhciBsID0gdGhpcy5fY29udmVydFRvWENlbGxDb29yZCh0KSwgYyA9IHRoaXMuX2NvbnZlcnRUb1lDZWxsQ29vcmQoZSksIHUgPSB0aGlzLl9jb252ZXJ0VG9YQ2VsbENvb3JkKGkpLCBoID0gdGhpcy5fY29udmVydFRvWUNlbGxDb29yZChvKSwgcCA9IGw7IHAgPD0gdTsgcCsrKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSBjOyBkIDw9IGg7IGQrKykge1xuICAgICAgICAgIGlmIChyLmNhbGwodGhpcywgdCwgZSwgaSwgbywgdGhpcy54Q2VsbENvdW50ICogZCArIHAsIGEsIG4sIHMpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBZdC5wcm90b3R5cGUuX2NvbnZlcnRUb1hDZWxsQ29vcmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMueENlbGxDb3VudCAtIDEsIE1hdGguZmxvb3IodCAqIHRoaXMueFNjYWxlKSkpO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fY29udmVydFRvWUNlbGxDb29yZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy55Q2VsbENvdW50IC0gMSwgTWF0aC5mbG9vcih0ICogdGhpcy55U2NhbGUpKSk7XG4gICAgfSwgWXQucHJvdG90eXBlLl9jaXJjbGVzQ29sbGlkZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IG8gLSB0LFxuICAgICAgICAgIHMgPSByIC0gZSxcbiAgICAgICAgICBsID0gaSArIGE7XG4gICAgICByZXR1cm4gbCAqIGwgPiBuICogbiArIHMgKiBzO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fY2lyY2xlQW5kUmVjdENvbGxpZGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMgPSAoYSAtIG8pIC8gMixcbiAgICAgICAgICBsID0gTWF0aC5hYnModCAtIChvICsgcykpO1xuICAgICAgaWYgKGwgPiBzICsgaSkgcmV0dXJuICExO1xuICAgICAgdmFyIGMgPSAobiAtIHIpIC8gMixcbiAgICAgICAgICB1ID0gTWF0aC5hYnMoZSAtIChyICsgYykpO1xuICAgICAgaWYgKHUgPiBjICsgaSkgcmV0dXJuICExO1xuICAgICAgaWYgKGwgPD0gcyB8fCB1IDw9IGMpIHJldHVybiAhMDtcbiAgICAgIHZhciBoID0gbCAtIHMsXG4gICAgICAgICAgcCA9IHUgLSBjO1xuICAgICAgcmV0dXJuIGggKiBoICsgcCAqIHAgPD0gaSAqIGk7XG4gICAgfTtcbiAgICB2YXIgbGUgPSBuZXcgRmxvYXQzMkFycmF5KFstMSAvIDAsIC0xIC8gMCwgMCwgLTEgLyAwLCAtMSAvIDAsIDAsIC0xIC8gMCwgLTEgLyAwLCAwLCAtMSAvIDAsIC0xIC8gMCwgMF0pO1xuXG4gICAgZnVuY3Rpb24gY2UodCwgZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyBpKyspIHtcbiAgICAgICAgdmFyIG8gPSBlLmxlbmd0aDtcbiAgICAgICAgZS5yZXNpemUobyArIDQpLCBlLmZsb2F0MzIuc2V0KGxlLCAzICogbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdWUodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSBlWzBdLFxuICAgICAgICAgIHIgPSBlWzFdO1xuICAgICAgcmV0dXJuIHRbMF0gPSBpWzBdICogbyArIGlbNF0gKiByICsgaVsxMl0sIHRbMV0gPSBpWzFdICogbyArIGlbNV0gKiByICsgaVsxM10sIHRbM10gPSBpWzNdICogbyArIGlbN10gKiByICsgaVsxNV0sIHQ7XG4gICAgfVxuXG4gICAgdmFyIGhlID0gZnVuY3Rpb24gaGUodCwgZSwgaSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gbmV3IFl0KHQud2lkdGggKyAyMDAsIHQuaGVpZ2h0ICsgMjAwLCAyNSkpLCB2b2lkIDAgPT09IGkgJiYgKGkgPSBuZXcgWXQodC53aWR0aCArIDIwMCwgdC5oZWlnaHQgKyAyMDAsIDI1KSksIHRoaXMudHJhbnNmb3JtID0gdCwgdGhpcy5ncmlkID0gZSwgdGhpcy5pZ25vcmVkR3JpZCA9IGksIHRoaXMucGl0Y2hmYWN0b3IgPSBNYXRoLmNvcyh0Ll9waXRjaCkgKiB0LmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsIHRoaXMuc2NyZWVuUmlnaHRCb3VuZGFyeSA9IHQud2lkdGggKyAxMDAsIHRoaXMuc2NyZWVuQm90dG9tQm91bmRhcnkgPSB0LmhlaWdodCArIDEwMCwgdGhpcy5ncmlkUmlnaHRCb3VuZGFyeSA9IHQud2lkdGggKyAyMDAsIHRoaXMuZ3JpZEJvdHRvbUJvdW5kYXJ5ID0gdC5oZWlnaHQgKyAyMDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBlKGUsIGksIG8pIHtcbiAgICAgIHJldHVybiBpICogKHQuRVhURU5UIC8gKGUudGlsZVNpemUgKiBNYXRoLnBvdygyLCBvIC0gZS50aWxlSUQub3ZlcnNjYWxlZFopKSk7XG4gICAgfVxuXG4gICAgaGUucHJvdG90eXBlLnBsYWNlQ29sbGlzaW9uQm94ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIHZhciBhID0gdGhpcy5wcm9qZWN0QW5kR2V0UGVyc3BlY3RpdmVSYXRpbyhvLCB0LmFuY2hvclBvaW50WCwgdC5hbmNob3JQb2ludFkpLFxuICAgICAgICAgIG4gPSBpICogYS5wZXJzcGVjdGl2ZVJhdGlvLFxuICAgICAgICAgIHMgPSB0LngxICogbiArIGEucG9pbnQueCxcbiAgICAgICAgICBsID0gdC55MSAqIG4gKyBhLnBvaW50LnksXG4gICAgICAgICAgYyA9IHQueDIgKiBuICsgYS5wb2ludC54LFxuICAgICAgICAgIHUgPSB0LnkyICogbiArIGEucG9pbnQueTtcbiAgICAgIHJldHVybiAhdGhpcy5pc0luc2lkZUdyaWQocywgbCwgYywgdSkgfHwgIWUgJiYgdGhpcy5ncmlkLmhpdFRlc3QocywgbCwgYywgdSwgcikgPyB7XG4gICAgICAgIGJveDogW10sXG4gICAgICAgIG9mZnNjcmVlbjogITFcbiAgICAgIH0gOiB7XG4gICAgICAgIGJveDogW3MsIGwsIGMsIHVdLFxuICAgICAgICBvZmZzY3JlZW46IHRoaXMuaXNPZmZzY3JlZW4ocywgbCwgYywgdSlcbiAgICAgIH07XG4gICAgfSwgaGUucHJvdG90eXBlLnBsYWNlQ29sbGlzaW9uQ2lyY2xlcyA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoLCBwLCBkKSB7XG4gICAgICB2YXIgXyA9IFtdLFxuICAgICAgICAgIGYgPSBuZXcgdC5Qb2ludChpLmFuY2hvclgsIGkuYW5jaG9yWSksXG4gICAgICAgICAgbSA9ICR0KGYsIG4pLFxuICAgICAgICAgIGcgPSB0ZSh0aGlzLnRyYW5zZm9ybS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlLCBtLnNpZ25lZERpc3RhbmNlRnJvbUNhbWVyYSksXG4gICAgICAgICAgdiA9ICh1ID8gYSAvIGcgOiBhICogZykgLyB0Lk9ORV9FTSxcbiAgICAgICAgICB5ID0gJHQoZiwgcykucG9pbnQsXG4gICAgICAgICAgeCA9IG9lKHYsIHIsIGkubGluZU9mZnNldFggKiB2LCBpLmxpbmVPZmZzZXRZICogdiwgITEsIHksIGYsIGksIG8sIHMsIHt9KSxcbiAgICAgICAgICBiID0gITEsXG4gICAgICAgICAgdyA9ICExLFxuICAgICAgICAgIFQgPSAhMDtcblxuICAgICAgaWYgKHgpIHtcbiAgICAgICAgZm9yICh2YXIgRSA9IC41ICogcCAqIGcgKyBkLCBJID0gbmV3IHQuUG9pbnQoLTEwMCwgLTEwMCksIFAgPSBuZXcgdC5Qb2ludCh0aGlzLnNjcmVlblJpZ2h0Qm91bmRhcnksIHRoaXMuc2NyZWVuQm90dG9tQm91bmRhcnkpLCBTID0gbmV3IEt0KCksIEMgPSB4LmZpcnN0LCB6ID0geC5sYXN0LCBEID0gW10sIEEgPSBDLnBhdGgubGVuZ3RoIC0gMTsgQSA+PSAxOyBBLS0pIHtcbiAgICAgICAgICBELnB1c2goQy5wYXRoW0FdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIE0gPSAxOyBNIDwgei5wYXRoLmxlbmd0aDsgTSsrKSB7XG4gICAgICAgICAgRC5wdXNoKHoucGF0aFtNXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgTCA9IDIuNSAqIEU7XG5cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgUiA9IEQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gJHQodCwgbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgRCA9IFIuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuc2lnbmVkRGlzdGFuY2VGcm9tQ2FtZXJhIDw9IDA7XG4gICAgICAgICAgfSkgPyBbXSA6IFIubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5wb2ludDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrID0gW107XG5cbiAgICAgICAgaWYgKEQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIEIgPSBEWzBdLmNsb25lKCksIE8gPSBEWzBdLmNsb25lKCksIEYgPSAxOyBGIDwgRC5sZW5ndGg7IEYrKykge1xuICAgICAgICAgICAgQi54ID0gTWF0aC5taW4oQi54LCBEW0ZdLngpLCBCLnkgPSBNYXRoLm1pbihCLnksIERbRl0ueSksIE8ueCA9IE1hdGgubWF4KE8ueCwgRFtGXS54KSwgTy55ID0gTWF0aC5tYXgoTy55LCBEW0ZdLnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGsgPSBCLnggPj0gSS54ICYmIE8ueCA8PSBQLnggJiYgQi55ID49IEkueSAmJiBPLnkgPD0gUC55ID8gW0RdIDogTy54IDwgSS54IHx8IEIueCA+IFAueCB8fCBPLnkgPCBJLnkgfHwgQi55ID4gUC55ID8gW10gOiB0LmNsaXBMaW5lKFtEXSwgSS54LCBJLnksIFAueCwgUC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIFUgPSAwLCBOID0gazsgVSA8IE4ubGVuZ3RoOyBVICs9IDEpIHtcbiAgICAgICAgICB2YXIgWjtcbiAgICAgICAgICBTLnJlc2V0KE5bVV0sIC4yNSAqIEUpLCBaID0gUy5sZW5ndGggPD0gLjUgKiBFID8gMSA6IE1hdGguY2VpbChTLnBhZGRlZExlbmd0aCAvIEwpICsgMTtcblxuICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgWjsgcSsrKSB7XG4gICAgICAgICAgICB2YXIgaiA9IHEgLyBNYXRoLm1heChaIC0gMSwgMSksXG4gICAgICAgICAgICAgICAgViA9IFMubGVycChqKSxcbiAgICAgICAgICAgICAgICBHID0gVi54ICsgMTAwLFxuICAgICAgICAgICAgICAgIFcgPSBWLnkgKyAxMDA7XG5cbiAgICAgICAgICAgIF8ucHVzaChHLCBXLCBFLCAwKTtcblxuICAgICAgICAgICAgdmFyIFggPSBHIC0gRSxcbiAgICAgICAgICAgICAgICBIID0gVyAtIEUsXG4gICAgICAgICAgICAgICAgSyA9IEcgKyBFLFxuICAgICAgICAgICAgICAgIFkgPSBXICsgRTtcbiAgICAgICAgICAgIGlmIChUID0gVCAmJiB0aGlzLmlzT2Zmc2NyZWVuKFgsIEgsIEssIFkpLCB3ID0gdyB8fCB0aGlzLmlzSW5zaWRlR3JpZChYLCBILCBLLCBZKSwgIWUgJiYgdGhpcy5ncmlkLmhpdFRlc3RDaXJjbGUoRywgVywgRSwgaCkgJiYgKGIgPSAhMCwgIWMpKSByZXR1cm4ge1xuICAgICAgICAgICAgICBjaXJjbGVzOiBbXSxcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuOiAhMSxcbiAgICAgICAgICAgICAgY29sbGlzaW9uRGV0ZWN0ZWQ6IGJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpcmNsZXM6ICFjICYmIGIgfHwgIXcgPyBbXSA6IF8sXG4gICAgICAgIG9mZnNjcmVlbjogVCxcbiAgICAgICAgY29sbGlzaW9uRGV0ZWN0ZWQ6IGJcbiAgICAgIH07XG4gICAgfSwgaGUucHJvdG90eXBlLnF1ZXJ5UmVuZGVyZWRTeW1ib2xzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICgwID09PSBlLmxlbmd0aCB8fCAwID09PSB0aGlzLmdyaWQua2V5c0xlbmd0aCgpICYmIDAgPT09IHRoaXMuaWdub3JlZEdyaWQua2V5c0xlbmd0aCgpKSByZXR1cm4ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSBbXSwgbyA9IDEgLyAwLCByID0gMSAvIDAsIGEgPSAtMSAvIDAsIG4gPSAtMSAvIDAsIHMgPSAwLCBsID0gZTsgcyA8IGwubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBsW3NdLFxuICAgICAgICAgICAgdSA9IG5ldyB0LlBvaW50KGMueCArIDEwMCwgYy55ICsgMTAwKTtcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIHUueCksIHIgPSBNYXRoLm1pbihyLCB1LnkpLCBhID0gTWF0aC5tYXgoYSwgdS54KSwgbiA9IE1hdGgubWF4KG4sIHUueSksIGkucHVzaCh1KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaCA9IHt9LCBwID0ge30sIGQgPSAwLCBfID0gdGhpcy5ncmlkLnF1ZXJ5KG8sIHIsIGEsIG4pLmNvbmNhdCh0aGlzLmlnbm9yZWRHcmlkLnF1ZXJ5KG8sIHIsIGEsIG4pKTsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgdmFyIGYgPSBfW2RdLFxuICAgICAgICAgICAgbSA9IGYua2V5O1xuXG4gICAgICAgIGlmICh2b2lkIDAgPT09IGhbbS5idWNrZXRJbnN0YW5jZUlkXSAmJiAoaFttLmJ1Y2tldEluc3RhbmNlSWRdID0ge30pLCAhaFttLmJ1Y2tldEluc3RhbmNlSWRdW20uZmVhdHVyZUluZGV4XSkge1xuICAgICAgICAgIHZhciBnID0gW25ldyB0LlBvaW50KGYueDEsIGYueTEpLCBuZXcgdC5Qb2ludChmLngyLCBmLnkxKSwgbmV3IHQuUG9pbnQoZi54MiwgZi55MiksIG5ldyB0LlBvaW50KGYueDEsIGYueTIpXTtcbiAgICAgICAgICB0LnBvbHlnb25JbnRlcnNlY3RzUG9seWdvbihpLCBnKSAmJiAoaFttLmJ1Y2tldEluc3RhbmNlSWRdW20uZmVhdHVyZUluZGV4XSA9ICEwLCB2b2lkIDAgPT09IHBbbS5idWNrZXRJbnN0YW5jZUlkXSAmJiAocFttLmJ1Y2tldEluc3RhbmNlSWRdID0gW10pLCBwW20uYnVja2V0SW5zdGFuY2VJZF0ucHVzaChtLmZlYXR1cmVJbmRleCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwO1xuICAgIH0sIGhlLnByb3RvdHlwZS5pbnNlcnRDb2xsaXNpb25Cb3ggPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgKGUgPyB0aGlzLmlnbm9yZWRHcmlkIDogdGhpcy5ncmlkKS5pbnNlcnQoe1xuICAgICAgICBidWNrZXRJbnN0YW5jZUlkOiBpLFxuICAgICAgICBmZWF0dXJlSW5kZXg6IG8sXG4gICAgICAgIGNvbGxpc2lvbkdyb3VwSUQ6IHJcbiAgICAgIH0sIHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pO1xuICAgIH0sIGhlLnByb3RvdHlwZS5pbnNlcnRDb2xsaXNpb25DaXJjbGVzID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIGZvciAodmFyIGEgPSBlID8gdGhpcy5pZ25vcmVkR3JpZCA6IHRoaXMuZ3JpZCwgbiA9IHtcbiAgICAgICAgYnVja2V0SW5zdGFuY2VJZDogaSxcbiAgICAgICAgZmVhdHVyZUluZGV4OiBvLFxuICAgICAgICBjb2xsaXNpb25Hcm91cElEOiByXG4gICAgICB9LCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzICs9IDQpIHtcbiAgICAgICAgYS5pbnNlcnRDaXJjbGUobiwgdFtzXSwgdFtzICsgMV0sIHRbcyArIDJdKTtcbiAgICAgIH1cbiAgICB9LCBoZS5wcm90b3R5cGUucHJvamVjdEFuZEdldFBlcnNwZWN0aXZlUmF0aW8gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBbaSwgbywgMCwgMV07XG4gICAgICByZXR1cm4gdWUociwgciwgZSksIHtcbiAgICAgICAgcG9pbnQ6IG5ldyB0LlBvaW50KChyWzBdIC8gclszXSArIDEpIC8gMiAqIHRoaXMudHJhbnNmb3JtLndpZHRoICsgMTAwLCAoLXJbMV0gLyByWzNdICsgMSkgLyAyICogdGhpcy50cmFuc2Zvcm0uaGVpZ2h0ICsgMTAwKSxcbiAgICAgICAgcGVyc3BlY3RpdmVSYXRpbzogLjUgKyB0aGlzLnRyYW5zZm9ybS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIC8gclszXSAqIC41XG4gICAgICB9O1xuICAgIH0sIGhlLnByb3RvdHlwZS5pc09mZnNjcmVlbiA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICByZXR1cm4gaSA8IDEwMCB8fCB0ID49IHRoaXMuc2NyZWVuUmlnaHRCb3VuZGFyeSB8fCBvIDwgMTAwIHx8IGUgPiB0aGlzLnNjcmVlbkJvdHRvbUJvdW5kYXJ5O1xuICAgIH0sIGhlLnByb3RvdHlwZS5pc0luc2lkZUdyaWQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIGkgPj0gMCAmJiB0IDwgdGhpcy5ncmlkUmlnaHRCb3VuZGFyeSAmJiBvID49IDAgJiYgZSA8IHRoaXMuZ3JpZEJvdHRvbUJvdW5kYXJ5O1xuICAgIH0sIGhlLnByb3RvdHlwZS5nZXRWaWV3cG9ydE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdC5pZGVudGl0eShbXSk7XG4gICAgICByZXR1cm4gdC50cmFuc2xhdGUoZSwgZSwgWy0xMDAsIC0xMDAsIDBdKSwgZTtcbiAgICB9O1xuXG4gICAgdmFyIGRlID0gZnVuY3Rpb24gZGUodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy5vcGFjaXR5ID0gdCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQub3BhY2l0eSArICh0LnBsYWNlZCA/IGUgOiAtZSkpKSA6IG8gJiYgaSA/IDEgOiAwLCB0aGlzLnBsYWNlZCA9IGk7XG4gICAgfTtcblxuICAgIGRlLnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLm9wYWNpdHkgJiYgIXRoaXMucGxhY2VkO1xuICAgIH07XG5cbiAgICB2YXIgX2UgPSBmdW5jdGlvbiBfZSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB0aGlzLnRleHQgPSBuZXcgZGUodCA/IHQudGV4dCA6IG51bGwsIGUsIGksIHIpLCB0aGlzLmljb24gPSBuZXcgZGUodCA/IHQuaWNvbiA6IG51bGwsIGUsIG8sIHIpO1xuICAgIH07XG5cbiAgICBfZS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0LmlzSGlkZGVuKCkgJiYgdGhpcy5pY29uLmlzSGlkZGVuKCk7XG4gICAgfTtcblxuICAgIHZhciBmZSA9IGZ1bmN0aW9uIGZlKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMudGV4dCA9IHQsIHRoaXMuaWNvbiA9IGUsIHRoaXMuc2tpcEZhZGUgPSBpO1xuICAgIH0sXG4gICAgICAgIG1lID0gZnVuY3Rpb24gbWUoKSB7XG4gICAgICB0aGlzLmludlByb2pNYXRyaXggPSB0LmNyZWF0ZSgpLCB0aGlzLnZpZXdwb3J0TWF0cml4ID0gdC5jcmVhdGUoKSwgdGhpcy5jaXJjbGVzID0gW107XG4gICAgfSxcbiAgICAgICAgZ2UgPSBmdW5jdGlvbiBnZSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB0aGlzLmJ1Y2tldEluc3RhbmNlSWQgPSB0LCB0aGlzLmZlYXR1cmVJbmRleCA9IGUsIHRoaXMuc291cmNlTGF5ZXJJbmRleCA9IGksIHRoaXMuYnVja2V0SW5kZXggPSBvLCB0aGlzLnRpbGVJRCA9IHI7XG4gICAgfSxcbiAgICAgICAgdmUgPSBmdW5jdGlvbiB2ZSh0KSB7XG4gICAgICB0aGlzLmNyb3NzU291cmNlQ29sbGlzaW9ucyA9IHQsIHRoaXMubWF4R3JvdXBJRCA9IDAsIHRoaXMuY29sbGlzaW9uR3JvdXBzID0ge307XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHllKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gdC5nZXRBbmNob3JBbGlnbm1lbnQoZSksXG4gICAgICAgICAgcyA9IC0obi5ob3Jpem9udGFsQWxpZ24gLSAuNSkgKiBpLFxuICAgICAgICAgIGwgPSAtKG4udmVydGljYWxBbGlnbiAtIC41KSAqIG8sXG4gICAgICAgICAgYyA9IHQuZXZhbHVhdGVWYXJpYWJsZU9mZnNldChlLCByKTtcbiAgICAgIHJldHVybiBuZXcgdC5Qb2ludChzICsgY1swXSAqIGEsIGwgKyBjWzFdICogYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geGUoZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMgPSBlLngxLFxuICAgICAgICAgIGwgPSBlLngyLFxuICAgICAgICAgIGMgPSBlLnkxLFxuICAgICAgICAgIHUgPSBlLnkyLFxuICAgICAgICAgIGggPSBlLmFuY2hvclBvaW50WCxcbiAgICAgICAgICBwID0gZS5hbmNob3JQb2ludFksXG4gICAgICAgICAgZCA9IG5ldyB0LlBvaW50KGksIG8pO1xuICAgICAgcmV0dXJuIHIgJiYgZC5fcm90YXRlKGEgPyBuIDogLW4pLCB7XG4gICAgICAgIHgxOiBzICsgZC54LFxuICAgICAgICB5MTogYyArIGQueSxcbiAgICAgICAgeDI6IGwgKyBkLngsXG4gICAgICAgIHkyOiB1ICsgZC55LFxuICAgICAgICBhbmNob3JQb2ludFg6IGgsXG4gICAgICAgIGFuY2hvclBvaW50WTogcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLmNyb3NzU291cmNlQ29sbGlzaW9ucykgcmV0dXJuIHtcbiAgICAgICAgSUQ6IDAsXG4gICAgICAgIHByZWRpY2F0ZTogbnVsbFxuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbkdyb3Vwc1t0XSkge1xuICAgICAgICB2YXIgZSA9ICsrdGhpcy5tYXhHcm91cElEO1xuICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3Vwc1t0XSA9IHtcbiAgICAgICAgICBJRDogZSxcbiAgICAgICAgICBwcmVkaWNhdGU6IGZ1bmN0aW9uIHByZWRpY2F0ZSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5jb2xsaXNpb25Hcm91cElEID09PSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uR3JvdXBzW3RdO1xuICAgIH07XG5cbiAgICB2YXIgYmUgPSBmdW5jdGlvbiBiZSh0LCBlLCBpLCBvKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IHQuY2xvbmUoKSwgdGhpcy5jb2xsaXNpb25JbmRleCA9IG5ldyBoZSh0aGlzLnRyYW5zZm9ybSksIHRoaXMucGxhY2VtZW50cyA9IHt9LCB0aGlzLm9wYWNpdGllcyA9IHt9LCB0aGlzLnZhcmlhYmxlT2Zmc2V0cyA9IHt9LCB0aGlzLnN0YWxlID0gITEsIHRoaXMuY29tbWl0VGltZSA9IDAsIHRoaXMuZmFkZUR1cmF0aW9uID0gZSwgdGhpcy5yZXRhaW5lZFF1ZXJ5RGF0YSA9IHt9LCB0aGlzLmNvbGxpc2lvbkdyb3VwcyA9IG5ldyB2ZShpKSwgdGhpcy5jb2xsaXNpb25DaXJjbGVBcnJheXMgPSB7fSwgdGhpcy5wcmV2UGxhY2VtZW50ID0gbywgbyAmJiAoby5wcmV2UGxhY2VtZW50ID0gdm9pZCAwKSwgdGhpcy5wbGFjZWRPcmllbnRhdGlvbnMgPSB7fTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd2UodCwgZSwgaSwgbywgcikge1xuICAgICAgdC5lbXBsYWNlQmFjayhlID8gMSA6IDAsIGkgPyAxIDogMCwgbyB8fCAwLCByIHx8IDApLCB0LmVtcGxhY2VCYWNrKGUgPyAxIDogMCwgaSA/IDEgOiAwLCBvIHx8IDAsIHIgfHwgMCksIHQuZW1wbGFjZUJhY2soZSA/IDEgOiAwLCBpID8gMSA6IDAsIG8gfHwgMCwgciB8fCAwKSwgdC5lbXBsYWNlQmFjayhlID8gMSA6IDAsIGkgPyAxIDogMCwgbyB8fCAwLCByIHx8IDApO1xuICAgIH1cblxuICAgIGJlLnByb3RvdHlwZS5nZXRCdWNrZXRQYXJ0cyA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSA9IG8uZ2V0QnVja2V0KGkpLFxuICAgICAgICAgIG4gPSBvLmxhdGVzdEZlYXR1cmVJbmRleDtcblxuICAgICAgaWYgKGEgJiYgbiAmJiBpLmlkID09PSBhLmxheWVySWRzWzBdKSB7XG4gICAgICAgIHZhciBzID0gby5jb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgIGwgPSBhLmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgICAgICBjID0gTWF0aC5wb3coMiwgdGhpcy50cmFuc2Zvcm0uem9vbSAtIG8udGlsZUlELm92ZXJzY2FsZWRaKSxcbiAgICAgICAgICAgIHUgPSBvLnRpbGVTaXplIC8gdC5FWFRFTlQsXG4gICAgICAgICAgICBoID0gdGhpcy50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KG8udGlsZUlELnRvVW53cmFwcGVkKCkpLFxuICAgICAgICAgICAgcCA9IFwibWFwXCIgPT09IGwuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksXG4gICAgICAgICAgICBkID0gXCJtYXBcIiA9PT0gbC5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSxcbiAgICAgICAgICAgIF8gPSBwZShvLCAxLCB0aGlzLnRyYW5zZm9ybS56b29tKSxcbiAgICAgICAgICAgIGYgPSBKdChoLCBwLCBkLCB0aGlzLnRyYW5zZm9ybSwgXyksXG4gICAgICAgICAgICBtID0gbnVsbDtcblxuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIHZhciBnID0gUXQoaCwgcCwgZCwgdGhpcy50cmFuc2Zvcm0sIF8pO1xuICAgICAgICAgIG0gPSB0Lm11bHRpcGx5KFtdLCB0aGlzLnRyYW5zZm9ybS5sYWJlbFBsYW5lTWF0cml4LCBnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmV0YWluZWRRdWVyeURhdGFbYS5idWNrZXRJbnN0YW5jZUlkXSA9IG5ldyBnZShhLmJ1Y2tldEluc3RhbmNlSWQsIG4sIGEuc291cmNlTGF5ZXJJbmRleCwgYS5pbmRleCwgby50aWxlSUQpO1xuICAgICAgICB2YXIgdiA9IHtcbiAgICAgICAgICBidWNrZXQ6IGEsXG4gICAgICAgICAgbGF5b3V0OiBsLFxuICAgICAgICAgIHBvc01hdHJpeDogaCxcbiAgICAgICAgICB0ZXh0TGFiZWxQbGFuZU1hdHJpeDogZixcbiAgICAgICAgICBsYWJlbFRvU2NyZWVuTWF0cml4OiBtLFxuICAgICAgICAgIHNjYWxlOiBjLFxuICAgICAgICAgIHRleHRQaXhlbFJhdGlvOiB1LFxuICAgICAgICAgIGhvbGRpbmdGb3JGYWRlOiBvLmhvbGRpbmdGb3JGYWRlKCksXG4gICAgICAgICAgY29sbGlzaW9uQm94QXJyYXk6IHMsXG4gICAgICAgICAgcGFydGlhbGx5RXZhbHVhdGVkVGV4dFNpemU6IHQuZXZhbHVhdGVTaXplRm9yWm9vbShhLnRleHRTaXplRGF0YSwgdGhpcy50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgICAgY29sbGlzaW9uR3JvdXA6IHRoaXMuY29sbGlzaW9uR3JvdXBzLmdldChhLnNvdXJjZUlEKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocikgZm9yICh2YXIgeSA9IDAsIHggPSBhLnNvcnRLZXlSYW5nZXM7IHkgPCB4Lmxlbmd0aDsgeSArPSAxKSB7XG4gICAgICAgICAgdmFyIGIgPSB4W3ldO1xuICAgICAgICAgIGUucHVzaCh7XG4gICAgICAgICAgICBzb3J0S2V5OiBiLnNvcnRLZXksXG4gICAgICAgICAgICBzeW1ib2xJbnN0YW5jZVN0YXJ0OiBiLnN5bWJvbEluc3RhbmNlU3RhcnQsXG4gICAgICAgICAgICBzeW1ib2xJbnN0YW5jZUVuZDogYi5zeW1ib2xJbnN0YW5jZUVuZCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGUucHVzaCh7XG4gICAgICAgICAgc3ltYm9sSW5zdGFuY2VTdGFydDogMCxcbiAgICAgICAgICBzeW1ib2xJbnN0YW5jZUVuZDogYS5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHZcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgYmUucHJvdG90eXBlLmF0dGVtcHRBbmNob3JQbGFjZW1lbnQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSwgaCwgcCwgZCwgXykge1xuICAgICAgdmFyIGYsXG4gICAgICAgICAgbSA9IFtoLnRleHRPZmZzZXQwLCBoLnRleHRPZmZzZXQxXSxcbiAgICAgICAgICBnID0geWUodCwgaSwgbywgbSwgciksXG4gICAgICAgICAgdiA9IHRoaXMuY29sbGlzaW9uSW5kZXgucGxhY2VDb2xsaXNpb25Cb3goeGUoZSwgZy54LCBnLnksIGEsIG4sIHRoaXMudHJhbnNmb3JtLmFuZ2xlKSwgdSwgcywgbCwgYy5wcmVkaWNhdGUpO1xuICAgICAgaWYgKCFfIHx8IDAgIT09IHRoaXMuY29sbGlzaW9uSW5kZXgucGxhY2VDb2xsaXNpb25Cb3goeGUoXywgZy54LCBnLnksIGEsIG4sIHRoaXMudHJhbnNmb3JtLmFuZ2xlKSwgdSwgcywgbCwgYy5wcmVkaWNhdGUpLmJveC5sZW5ndGgpIHJldHVybiB2LmJveC5sZW5ndGggPiAwID8gKHRoaXMucHJldlBsYWNlbWVudCAmJiB0aGlzLnByZXZQbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzW2guY3Jvc3NUaWxlSURdICYmIHRoaXMucHJldlBsYWNlbWVudC5wbGFjZW1lbnRzW2guY3Jvc3NUaWxlSURdICYmIHRoaXMucHJldlBsYWNlbWVudC5wbGFjZW1lbnRzW2guY3Jvc3NUaWxlSURdLnRleHQgJiYgKGYgPSB0aGlzLnByZXZQbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzW2guY3Jvc3NUaWxlSURdLmFuY2hvciksIHRoaXMudmFyaWFibGVPZmZzZXRzW2guY3Jvc3NUaWxlSURdID0ge1xuICAgICAgICB0ZXh0T2Zmc2V0OiBtLFxuICAgICAgICB3aWR0aDogaSxcbiAgICAgICAgaGVpZ2h0OiBvLFxuICAgICAgICBhbmNob3I6IHQsXG4gICAgICAgIHRleHRCb3hTY2FsZTogcixcbiAgICAgICAgcHJldkFuY2hvcjogZlxuICAgICAgfSwgdGhpcy5tYXJrVXNlZEp1c3RpZmljYXRpb24ocCwgdCwgaCwgZCksIHAuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiAodGhpcy5tYXJrVXNlZE9yaWVudGF0aW9uKHAsIGQsIGgpLCB0aGlzLnBsYWNlZE9yaWVudGF0aW9uc1toLmNyb3NzVGlsZUlEXSA9IGQpLCB7XG4gICAgICAgIHNoaWZ0OiBnLFxuICAgICAgICBwbGFjZWRHbHlwaEJveGVzOiB2XG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICB9LCBiZS5wcm90b3R5cGUucGxhY2VMYXllckJ1Y2tldFBhcnQgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICAgIGEgPSBlLnBhcmFtZXRlcnMsXG4gICAgICAgICAgbiA9IGEuYnVja2V0LFxuICAgICAgICAgIHMgPSBhLmxheW91dCxcbiAgICAgICAgICBsID0gYS5wb3NNYXRyaXgsXG4gICAgICAgICAgYyA9IGEudGV4dExhYmVsUGxhbmVNYXRyaXgsXG4gICAgICAgICAgdSA9IGEubGFiZWxUb1NjcmVlbk1hdHJpeCxcbiAgICAgICAgICBoID0gYS50ZXh0UGl4ZWxSYXRpbyxcbiAgICAgICAgICBwID0gYS5ob2xkaW5nRm9yRmFkZSxcbiAgICAgICAgICBkID0gYS5jb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICBfID0gYS5wYXJ0aWFsbHlFdmFsdWF0ZWRUZXh0U2l6ZSxcbiAgICAgICAgICBmID0gYS5jb2xsaXNpb25Hcm91cCxcbiAgICAgICAgICBtID0gcy5nZXQoXCJ0ZXh0LW9wdGlvbmFsXCIpLFxuICAgICAgICAgIGcgPSBzLmdldChcImljb24tb3B0aW9uYWxcIiksXG4gICAgICAgICAgdiA9IHMuZ2V0KFwidGV4dC1hbGxvdy1vdmVybGFwXCIpLFxuICAgICAgICAgIHkgPSBzLmdldChcImljb24tYWxsb3ctb3ZlcmxhcFwiKSxcbiAgICAgICAgICB4ID0gXCJtYXBcIiA9PT0gcy5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSxcbiAgICAgICAgICBiID0gXCJtYXBcIiA9PT0gcy5nZXQoXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiKSxcbiAgICAgICAgICB3ID0gXCJub25lXCIgIT09IHMuZ2V0KFwiaWNvbi10ZXh0LWZpdFwiKSxcbiAgICAgICAgICBUID0gXCJ2aWV3cG9ydC15XCIgPT09IHMuZ2V0KFwic3ltYm9sLXotb3JkZXJcIiksXG4gICAgICAgICAgRSA9IHYgJiYgKHkgfHwgIW4uaGFzSWNvbkRhdGEoKSB8fCBnKSxcbiAgICAgICAgICBJID0geSAmJiAodiB8fCAhbi5oYXNUZXh0RGF0YSgpIHx8IG0pO1xuICAgICAgIW4uY29sbGlzaW9uQXJyYXlzICYmIGQgJiYgbi5kZXNlcmlhbGl6ZUNvbGxpc2lvbkJveGVzKGQpO1xuXG4gICAgICB2YXIgUCA9IGZ1bmN0aW9uIFAoZSwgYSkge1xuICAgICAgICBpZiAoIWlbZS5jcm9zc1RpbGVJRF0pIGlmIChwKSByLnBsYWNlbWVudHNbZS5jcm9zc1RpbGVJRF0gPSBuZXcgZmUoITEsICExLCAhMSk7ZWxzZSB7XG4gICAgICAgICAgdmFyIGQsXG4gICAgICAgICAgICAgIFQgPSAhMSxcbiAgICAgICAgICAgICAgUCA9ICExLFxuICAgICAgICAgICAgICBTID0gITAsXG4gICAgICAgICAgICAgIEMgPSBudWxsLFxuICAgICAgICAgICAgICB6ID0ge1xuICAgICAgICAgICAgYm94OiBudWxsLFxuICAgICAgICAgICAgb2Zmc2NyZWVuOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgRCA9IHtcbiAgICAgICAgICAgIGJveDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNjcmVlbjogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIEEgPSBudWxsLFxuICAgICAgICAgICAgICBNID0gbnVsbCxcbiAgICAgICAgICAgICAgTCA9IDAsXG4gICAgICAgICAgICAgIFIgPSAwLFxuICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICBhLnRleHRGZWF0dXJlSW5kZXggPyBMID0gYS50ZXh0RmVhdHVyZUluZGV4IDogZS51c2VSdW50aW1lQ29sbGlzaW9uQ2lyY2xlcyAmJiAoTCA9IGUuZmVhdHVyZUluZGV4KSwgYS52ZXJ0aWNhbFRleHRGZWF0dXJlSW5kZXggJiYgKFIgPSBhLnZlcnRpY2FsVGV4dEZlYXR1cmVJbmRleCk7XG4gICAgICAgICAgdmFyIEIgPSBhLnRleHRCb3g7XG5cbiAgICAgICAgICBpZiAoQikge1xuICAgICAgICAgICAgdmFyIE8gPSBmdW5jdGlvbiBPKGkpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSB0LldyaXRpbmdNb2RlLmhvcml6b250YWw7XG5cbiAgICAgICAgICAgICAgaWYgKG4uYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiAhaSAmJiByLnByZXZQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHIucHJldlBsYWNlbWVudC5wbGFjZWRPcmllbnRhdGlvbnNbZS5jcm9zc1RpbGVJRF07XG4gICAgICAgICAgICAgICAgYSAmJiAoci5wbGFjZWRPcmllbnRhdGlvbnNbZS5jcm9zc1RpbGVJRF0gPSBhLCByLm1hcmtVc2VkT3JpZW50YXRpb24obiwgbyA9IGEsIGUpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBGID0gZnVuY3Rpb24gRihpLCBvKSB7XG4gICAgICAgICAgICAgIGlmIChuLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgZS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMgPiAwICYmIGEudmVydGljYWxUZXh0Qm94KSBmb3IgKHZhciByID0gMCwgcyA9IG4ud3JpdGluZ01vZGVzOyByIDwgcy5sZW5ndGggJiYgKHNbcl0gPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgPyAoeiA9IG8oKSwgRCA9IHopIDogeiA9IGkoKSwgISh6ICYmIHouYm94ICYmIHouYm94Lmxlbmd0aCkpOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgIH0gZWxzZSB6ID0gaSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHMuZ2V0KFwidGV4dC12YXJpYWJsZS1hbmNob3JcIikpIHtcbiAgICAgICAgICAgICAgdmFyIFUgPSBzLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpO1xuXG4gICAgICAgICAgICAgIGlmIChyLnByZXZQbGFjZW1lbnQgJiYgci5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1tlLmNyb3NzVGlsZUlEXSkge1xuICAgICAgICAgICAgICAgIHZhciBOID0gci5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1tlLmNyb3NzVGlsZUlEXTtcbiAgICAgICAgICAgICAgICBVLmluZGV4T2YoTi5hbmNob3IpID4gMCAmJiAoVSA9IFUuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdCAhPT0gTi5hbmNob3I7XG4gICAgICAgICAgICAgICAgfSkpLnVuc2hpZnQoTi5hbmNob3IpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIFogPSBmdW5jdGlvbiBaKHQsIGksIG8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gdC54MiAtIHQueDEsIHMgPSB0LnkyIC0gdC55MSwgYyA9IGUudGV4dEJveFNjYWxlLCB1ID0gdyAmJiAheSA/IGkgOiBudWxsLCBwID0ge1xuICAgICAgICAgICAgICAgICAgYm94OiBbXSxcbiAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbjogITFcbiAgICAgICAgICAgICAgICB9LCBkID0gdiA/IDIgKiBVLmxlbmd0aCA6IFUubGVuZ3RoLCBfID0gMDsgXyA8IGQ7ICsrXykge1xuICAgICAgICAgICAgICAgICAgdmFyIG0gPSByLmF0dGVtcHRBbmNob3JQbGFjZW1lbnQoVVtfICUgVS5sZW5ndGhdLCB0LCBhLCBzLCBjLCB4LCBiLCBoLCBsLCBmLCBfID49IFUubGVuZ3RoLCBlLCBuLCBvLCB1KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgKHAgPSBtLnBsYWNlZEdseXBoQm94ZXMpICYmIHAuYm94ICYmIHAuYm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBUID0gITAsIEMgPSBtLnNoaWZ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBGKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWihCLCBhLmljb25Cb3gsIHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGEudmVydGljYWxUZXh0Qm94O1xuICAgICAgICAgICAgICAgIHJldHVybiBuLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgISh6ICYmIHouYm94ICYmIHouYm94Lmxlbmd0aCkgJiYgZS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMgPiAwICYmIGkgPyBaKGksIGEudmVydGljYWxJY29uQm94LCB0LldyaXRpbmdNb2RlLnZlcnRpY2FsKSA6IHtcbiAgICAgICAgICAgICAgICAgIGJveDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbjogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pLCB6ICYmIChUID0gei5ib3gsIFMgPSB6Lm9mZnNjcmVlbik7XG4gICAgICAgICAgICAgIHZhciBxID0gTyh6ICYmIHouYm94KTtcblxuICAgICAgICAgICAgICBpZiAoIVQgJiYgci5wcmV2UGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSByLnByZXZQbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzW2UuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgICAgIGogJiYgKHIudmFyaWFibGVPZmZzZXRzW2UuY3Jvc3NUaWxlSURdID0gaiwgci5tYXJrVXNlZEp1c3RpZmljYXRpb24obiwgai5hbmNob3IsIGUsIHEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIFYgPSBmdW5jdGlvbiBWKHQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHIuY29sbGlzaW9uSW5kZXgucGxhY2VDb2xsaXNpb25Cb3godCwgdiwgaCwgbCwgZi5wcmVkaWNhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvICYmIG8uYm94ICYmIG8uYm94Lmxlbmd0aCAmJiAoci5tYXJrVXNlZE9yaWVudGF0aW9uKG4sIGksIGUpLCByLnBsYWNlZE9yaWVudGF0aW9uc1tlLmNyb3NzVGlsZUlEXSA9IGkpLCBvO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIEYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWKEIsIHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGEudmVydGljYWxUZXh0Qm94O1xuICAgICAgICAgICAgICAgIHJldHVybiBuLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgZS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMgPiAwICYmIGkgPyBWKGksIHQuV3JpdGluZ01vZGUudmVydGljYWwpIDoge1xuICAgICAgICAgICAgICAgICAgYm94OiBudWxsLFxuICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSksIE8oeiAmJiB6LmJveCAmJiB6LmJveC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChUID0gKGQgPSB6KSAmJiBkLmJveCAmJiBkLmJveC5sZW5ndGggPiAwLCBTID0gZCAmJiBkLm9mZnNjcmVlbiwgZS51c2VSdW50aW1lQ29sbGlzaW9uQ2lyY2xlcykge1xuICAgICAgICAgICAgdmFyIEcgPSBuLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGUuY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4KSxcbiAgICAgICAgICAgICAgICBXID0gdC5ldmFsdWF0ZVNpemVGb3JGZWF0dXJlKG4udGV4dFNpemVEYXRhLCBfLCBHKSxcbiAgICAgICAgICAgICAgICBYID0gcy5nZXQoXCJ0ZXh0LXBhZGRpbmdcIik7XG4gICAgICAgICAgICBBID0gci5jb2xsaXNpb25JbmRleC5wbGFjZUNvbGxpc2lvbkNpcmNsZXModiwgRywgbi5saW5lVmVydGV4QXJyYXksIG4uZ2x5cGhPZmZzZXRBcnJheSwgVywgbCwgYywgdSwgbywgYiwgZi5wcmVkaWNhdGUsIGUuY29sbGlzaW9uQ2lyY2xlRGlhbWV0ZXIsIFgpLCBUID0gdiB8fCBBLmNpcmNsZXMubGVuZ3RoID4gMCAmJiAhQS5jb2xsaXNpb25EZXRlY3RlZCwgUyA9IFMgJiYgQS5vZmZzY3JlZW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGEuaWNvbkZlYXR1cmVJbmRleCAmJiAoayA9IGEuaWNvbkZlYXR1cmVJbmRleCksIGEuaWNvbkJveCkge1xuICAgICAgICAgICAgdmFyIEggPSBmdW5jdGlvbiBIKHQpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB3ICYmIEMgPyB4ZSh0LCBDLngsIEMueSwgeCwgYiwgci50cmFuc2Zvcm0uYW5nbGUpIDogdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHIuY29sbGlzaW9uSW5kZXgucGxhY2VDb2xsaXNpb25Cb3goZSwgeSwgaCwgbCwgZi5wcmVkaWNhdGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUCA9IEQgJiYgRC5ib3ggJiYgRC5ib3gubGVuZ3RoICYmIGEudmVydGljYWxJY29uQm94ID8gKE0gPSBIKGEudmVydGljYWxJY29uQm94KSkuYm94Lmxlbmd0aCA+IDAgOiAoTSA9IEgoYS5pY29uQm94KSkuYm94Lmxlbmd0aCA+IDAsIFMgPSBTICYmIE0ub2Zmc2NyZWVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBLID0gbSB8fCAwID09PSBlLm51bUhvcml6b250YWxHbHlwaFZlcnRpY2VzICYmIDAgPT09IGUubnVtVmVydGljYWxHbHlwaFZlcnRpY2VzLFxuICAgICAgICAgICAgICBZID0gZyB8fCAwID09PSBlLm51bUljb25WZXJ0aWNlcztcblxuICAgICAgICAgIGlmIChLIHx8IFkgPyBZID8gSyB8fCAoUCA9IFAgJiYgVCkgOiBUID0gUCAmJiBUIDogUCA9IFQgPSBQICYmIFQsIFQgJiYgZCAmJiBkLmJveCAmJiByLmNvbGxpc2lvbkluZGV4Lmluc2VydENvbGxpc2lvbkJveChkLmJveCwgcy5nZXQoXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIiksIG4uYnVja2V0SW5zdGFuY2VJZCwgRCAmJiBELmJveCAmJiBSID8gUiA6IEwsIGYuSUQpLCBQICYmIE0gJiYgci5jb2xsaXNpb25JbmRleC5pbnNlcnRDb2xsaXNpb25Cb3goTS5ib3gsIHMuZ2V0KFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCIpLCBuLmJ1Y2tldEluc3RhbmNlSWQsIGssIGYuSUQpLCBBICYmIChUICYmIHIuY29sbGlzaW9uSW5kZXguaW5zZXJ0Q29sbGlzaW9uQ2lyY2xlcyhBLmNpcmNsZXMsIHMuZ2V0KFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCIpLCBuLmJ1Y2tldEluc3RhbmNlSWQsIEwsIGYuSUQpLCBvKSkge1xuICAgICAgICAgICAgdmFyIEogPSBuLmJ1Y2tldEluc3RhbmNlSWQsXG4gICAgICAgICAgICAgICAgUSA9IHIuY29sbGlzaW9uQ2lyY2xlQXJyYXlzW0pdO1xuICAgICAgICAgICAgdm9pZCAwID09PSBRICYmIChRID0gci5jb2xsaXNpb25DaXJjbGVBcnJheXNbSl0gPSBuZXcgbWUoKSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyICQgPSAwOyAkIDwgQS5jaXJjbGVzLmxlbmd0aDsgJCArPSA0KSB7XG4gICAgICAgICAgICAgIFEuY2lyY2xlcy5wdXNoKEEuY2lyY2xlc1skICsgMF0pLCBRLmNpcmNsZXMucHVzaChBLmNpcmNsZXNbJCArIDFdKSwgUS5jaXJjbGVzLnB1c2goQS5jaXJjbGVzWyQgKyAyXSksIFEuY2lyY2xlcy5wdXNoKEEuY29sbGlzaW9uRGV0ZWN0ZWQgPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5wbGFjZW1lbnRzW2UuY3Jvc3NUaWxlSURdID0gbmV3IGZlKFQgfHwgRSwgUCB8fCBJLCBTIHx8IG4uanVzdFJlbG9hZGVkKSwgaVtlLmNyb3NzVGlsZUlEXSA9ICEwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoVCkgZm9yICh2YXIgUyA9IG4uZ2V0U29ydGVkU3ltYm9sSW5kZXhlcyh0aGlzLnRyYW5zZm9ybS5hbmdsZSksIEMgPSBTLmxlbmd0aCAtIDE7IEMgPj0gMDsgLS1DKSB7XG4gICAgICAgIHZhciB6ID0gU1tDXTtcbiAgICAgICAgUChuLnN5bWJvbEluc3RhbmNlcy5nZXQoeiksIG4uY29sbGlzaW9uQXJyYXlzW3pdKTtcbiAgICAgIH0gZWxzZSBmb3IgKHZhciBEID0gZS5zeW1ib2xJbnN0YW5jZVN0YXJ0OyBEIDwgZS5zeW1ib2xJbnN0YW5jZUVuZDsgRCsrKSB7XG4gICAgICAgIFAobi5zeW1ib2xJbnN0YW5jZXMuZ2V0KEQpLCBuLmNvbGxpc2lvbkFycmF5c1tEXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvICYmIG4uYnVja2V0SW5zdGFuY2VJZCBpbiB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5cykge1xuICAgICAgICB2YXIgQSA9IHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzW24uYnVja2V0SW5zdGFuY2VJZF07XG4gICAgICAgIHQuaW52ZXJ0KEEuaW52UHJvak1hdHJpeCwgbCksIEEudmlld3BvcnRNYXRyaXggPSB0aGlzLmNvbGxpc2lvbkluZGV4LmdldFZpZXdwb3J0TWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIG4uanVzdFJlbG9hZGVkID0gITE7XG4gICAgfSwgYmUucHJvdG90eXBlLm1hcmtVc2VkSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIGEgPSByID09PSB0LldyaXRpbmdNb2RlLnZlcnRpY2FsID8gby52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleCA6IHtcbiAgICAgICAgbGVmdDogby5sZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LFxuICAgICAgICBjZW50ZXI6IG8uY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LFxuICAgICAgICByaWdodDogby5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleFxuICAgICAgfVt0LmdldEFuY2hvckp1c3RpZmljYXRpb24oaSldO1xuXG4gICAgICBmb3IgKHZhciBuID0gMCwgcyA9IFtvLmxlZnRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIG8uY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBvLnJpZ2h0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBvLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4XTsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGwgPSBzW25dO1xuICAgICAgICBsID49IDAgJiYgKGUudGV4dC5wbGFjZWRTeW1ib2xBcnJheS5nZXQobCkuY3Jvc3NUaWxlSUQgPSBhID49IDAgJiYgbCAhPT0gYSA/IDAgOiBvLmNyb3NzVGlsZUlEKTtcbiAgICAgIH1cbiAgICB9LCBiZS5wcm90b3R5cGUubWFya1VzZWRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICBmb3IgKHZhciByID0gaSA9PT0gdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsIHx8IGkgPT09IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbE9ubHkgPyBpIDogMCwgYSA9IGkgPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgPyBpIDogMCwgbiA9IDAsIHMgPSBbby5sZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBvLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleF07IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIGUudGV4dC5wbGFjZWRTeW1ib2xBcnJheS5nZXQoc1tuXSkucGxhY2VkT3JpZW50YXRpb24gPSByO1xuICAgICAgfVxuXG4gICAgICBvLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4ICYmIChlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KG8udmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXgpLnBsYWNlZE9yaWVudGF0aW9uID0gYSk7XG4gICAgfSwgYmUucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNvbW1pdFRpbWUgPSB0LCB0aGlzLnpvb21BdExhc3RSZWNlbmN5Q2hlY2sgPSB0aGlzLnRyYW5zZm9ybS56b29tO1xuICAgICAgdmFyIGUgPSB0aGlzLnByZXZQbGFjZW1lbnQsXG4gICAgICAgICAgaSA9ICExO1xuICAgICAgdGhpcy5wcmV2Wm9vbUFkanVzdG1lbnQgPSBlID8gZS56b29tQWRqdXN0bWVudCh0aGlzLnRyYW5zZm9ybS56b29tKSA6IDA7XG4gICAgICB2YXIgbyA9IGUgPyBlLnN5bWJvbEZhZGVDaGFuZ2UodCkgOiAxLFxuICAgICAgICAgIHIgPSBlID8gZS5vcGFjaXRpZXMgOiB7fSxcbiAgICAgICAgICBhID0gZSA/IGUudmFyaWFibGVPZmZzZXRzIDoge30sXG4gICAgICAgICAgbiA9IGUgPyBlLnBsYWNlZE9yaWVudGF0aW9ucyA6IHt9O1xuXG4gICAgICBmb3IgKHZhciBzIGluIHRoaXMucGxhY2VtZW50cykge1xuICAgICAgICB2YXIgbCA9IHRoaXMucGxhY2VtZW50c1tzXSxcbiAgICAgICAgICAgIGMgPSByW3NdO1xuICAgICAgICBjID8gKHRoaXMub3BhY2l0aWVzW3NdID0gbmV3IF9lKGMsIG8sIGwudGV4dCwgbC5pY29uKSwgaSA9IGkgfHwgbC50ZXh0ICE9PSBjLnRleHQucGxhY2VkIHx8IGwuaWNvbiAhPT0gYy5pY29uLnBsYWNlZCkgOiAodGhpcy5vcGFjaXRpZXNbc10gPSBuZXcgX2UobnVsbCwgbywgbC50ZXh0LCBsLmljb24sIGwuc2tpcEZhZGUpLCBpID0gaSB8fCBsLnRleHQgfHwgbC5pY29uKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgdSBpbiByKSB7XG4gICAgICAgIHZhciBoID0gclt1XTtcblxuICAgICAgICBpZiAoIXRoaXMub3BhY2l0aWVzW3VdKSB7XG4gICAgICAgICAgdmFyIHAgPSBuZXcgX2UoaCwgbywgITEsICExKTtcbiAgICAgICAgICBwLmlzSGlkZGVuKCkgfHwgKHRoaXMub3BhY2l0aWVzW3VdID0gcCwgaSA9IGkgfHwgaC50ZXh0LnBsYWNlZCB8fCBoLmljb24ucGxhY2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBkIGluIGEpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU9mZnNldHNbZF0gfHwgIXRoaXMub3BhY2l0aWVzW2RdIHx8IHRoaXMub3BhY2l0aWVzW2RdLmlzSGlkZGVuKCkgfHwgKHRoaXMudmFyaWFibGVPZmZzZXRzW2RdID0gYVtkXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF8gaW4gbikge1xuICAgICAgICB0aGlzLnBsYWNlZE9yaWVudGF0aW9uc1tfXSB8fCAhdGhpcy5vcGFjaXRpZXNbX10gfHwgdGhpcy5vcGFjaXRpZXNbX10uaXNIaWRkZW4oKSB8fCAodGhpcy5wbGFjZWRPcmllbnRhdGlvbnNbX10gPSBuW19dKTtcbiAgICAgIH1cblxuICAgICAgaSA/IHRoaXMubGFzdFBsYWNlbWVudENoYW5nZVRpbWUgPSB0IDogXCJudW1iZXJcIiAhPSB0eXBlb2YgdGhpcy5sYXN0UGxhY2VtZW50Q2hhbmdlVGltZSAmJiAodGhpcy5sYXN0UGxhY2VtZW50Q2hhbmdlVGltZSA9IGUgPyBlLmxhc3RQbGFjZW1lbnRDaGFuZ2VUaW1lIDogdCk7XG4gICAgfSwgYmUucHJvdG90eXBlLnVwZGF0ZUxheWVyT3BhY2l0aWVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSB7fSwgbyA9IDAsIHIgPSBlOyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IHJbb10sXG4gICAgICAgICAgICBuID0gYS5nZXRCdWNrZXQodCk7XG4gICAgICAgIG4gJiYgYS5sYXRlc3RGZWF0dXJlSW5kZXggJiYgdC5pZCA9PT0gbi5sYXllcklkc1swXSAmJiB0aGlzLnVwZGF0ZUJ1Y2tldE9wYWNpdGllcyhuLCBpLCBhLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgIH1cbiAgICB9LCBiZS5wcm90b3R5cGUudXBkYXRlQnVja2V0T3BhY2l0aWVzID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gdGhpcztcbiAgICAgIGUuaGFzVGV4dERhdGEoKSAmJiBlLnRleHQub3BhY2l0eVZlcnRleEFycmF5LmNsZWFyKCksIGUuaGFzSWNvbkRhdGEoKSAmJiBlLmljb24ub3BhY2l0eVZlcnRleEFycmF5LmNsZWFyKCksIGUuaGFzSWNvbkNvbGxpc2lvbkJveERhdGEoKSAmJiBlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXkuY2xlYXIoKSwgZS5oYXNUZXh0Q29sbGlzaW9uQm94RGF0YSgpICYmIGUudGV4dENvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheS5jbGVhcigpO1xuICAgICAgdmFyIGEgPSBlLmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgICAgbiA9IG5ldyBfZShudWxsLCAwLCAhMSwgITEsICEwKSxcbiAgICAgICAgICBzID0gYS5nZXQoXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIiksXG4gICAgICAgICAgbCA9IGEuZ2V0KFwiaWNvbi1hbGxvdy1vdmVybGFwXCIpLFxuICAgICAgICAgIGMgPSBhLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpLFxuICAgICAgICAgIHUgPSBcIm1hcFwiID09PSBhLmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpLFxuICAgICAgICAgIGggPSBcIm1hcFwiID09PSBhLmdldChcInRleHQtcGl0Y2gtYWxpZ25tZW50XCIpLFxuICAgICAgICAgIHAgPSBcIm5vbmVcIiAhPT0gYS5nZXQoXCJpY29uLXRleHQtZml0XCIpLFxuICAgICAgICAgIGQgPSBuZXcgX2UobnVsbCwgMCwgcyAmJiAobCB8fCAhZS5oYXNJY29uRGF0YSgpIHx8IGEuZ2V0KFwiaWNvbi1vcHRpb25hbFwiKSksIGwgJiYgKHMgfHwgIWUuaGFzVGV4dERhdGEoKSB8fCBhLmdldChcInRleHQtb3B0aW9uYWxcIikpLCAhMCk7XG4gICAgICAhZS5jb2xsaXNpb25BcnJheXMgJiYgbyAmJiAoZS5oYXNJY29uQ29sbGlzaW9uQm94RGF0YSgpIHx8IGUuaGFzVGV4dENvbGxpc2lvbkJveERhdGEoKSkgJiYgZS5kZXNlcmlhbGl6ZUNvbGxpc2lvbkJveGVzKG8pO1xuXG4gICAgICBmb3IgKHZhciBfID0gZnVuY3Rpb24gXyh0LCBlLCBpKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZSAvIDQ7IG8rKykge1xuICAgICAgICAgIHQub3BhY2l0eVZlcnRleEFycmF5LmVtcGxhY2VCYWNrKGkpO1xuICAgICAgICB9XG4gICAgICB9LCBmID0gZnVuY3Rpb24gZihvKSB7XG4gICAgICAgIHZhciBhID0gZS5zeW1ib2xJbnN0YW5jZXMuZ2V0KG8pLFxuICAgICAgICAgICAgcyA9IGEubnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXMsXG4gICAgICAgICAgICBsID0gYS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMsXG4gICAgICAgICAgICBmID0gYS5jcm9zc1RpbGVJRCxcbiAgICAgICAgICAgIG0gPSByLm9wYWNpdGllc1tmXTtcbiAgICAgICAgaVtmXSA/IG0gPSBuIDogbSB8fCAoci5vcGFjaXRpZXNbZl0gPSBtID0gZCksIGlbZl0gPSAhMDtcbiAgICAgICAgdmFyIGcgPSBhLm51bUljb25WZXJ0aWNlcyA+IDAsXG4gICAgICAgICAgICB2ID0gci5wbGFjZWRPcmllbnRhdGlvbnNbYS5jcm9zc1RpbGVJRF0sXG4gICAgICAgICAgICB5ID0gdiA9PT0gdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCxcbiAgICAgICAgICAgIHggPSB2ID09PSB0LldyaXRpbmdNb2RlLmhvcml6b250YWwgfHwgdiA9PT0gdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsT25seTtcblxuICAgICAgICBpZiAocyA+IDAgfHwgbCA+IDApIHtcbiAgICAgICAgICB2YXIgYiA9IERlKG0udGV4dCk7XG4gICAgICAgICAgXyhlLnRleHQsIHMsIHkgPyBBZSA6IGIpLCBfKGUudGV4dCwgbCwgeCA/IEFlIDogYik7XG4gICAgICAgICAgdmFyIHcgPSBtLnRleHQuaXNIaWRkZW4oKTtcbiAgICAgICAgICBbYS5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgYS5jZW50ZXJKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIGEubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdCA+PSAwICYmIChlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KHQpLmhpZGRlbiA9IHcgfHwgeSA/IDEgOiAwKTtcbiAgICAgICAgICB9KSwgYS52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleCA+PSAwICYmIChlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGEudmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXgpLmhpZGRlbiA9IHcgfHwgeCA/IDEgOiAwKTtcbiAgICAgICAgICB2YXIgVCA9IHIudmFyaWFibGVPZmZzZXRzW2EuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgIFQgJiYgci5tYXJrVXNlZEp1c3RpZmljYXRpb24oZSwgVC5hbmNob3IsIGEsIHYpO1xuICAgICAgICAgIHZhciBFID0gci5wbGFjZWRPcmllbnRhdGlvbnNbYS5jcm9zc1RpbGVJRF07XG4gICAgICAgICAgRSAmJiAoci5tYXJrVXNlZEp1c3RpZmljYXRpb24oZSwgXCJsZWZ0XCIsIGEsIEUpLCByLm1hcmtVc2VkT3JpZW50YXRpb24oZSwgRSwgYSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgSSA9IERlKG0uaWNvbiksXG4gICAgICAgICAgICAgIFAgPSAhKHAgJiYgYS52ZXJ0aWNhbFBsYWNlZEljb25TeW1ib2xJbmRleCAmJiB5KTtcbiAgICAgICAgICBhLnBsYWNlZEljb25TeW1ib2xJbmRleCA+PSAwICYmIChfKGUuaWNvbiwgYS5udW1JY29uVmVydGljZXMsIFAgPyBJIDogQWUpLCBlLmljb24ucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGEucGxhY2VkSWNvblN5bWJvbEluZGV4KS5oaWRkZW4gPSBtLmljb24uaXNIaWRkZW4oKSksIGEudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiAoXyhlLmljb24sIGEubnVtVmVydGljYWxJY29uVmVydGljZXMsIFAgPyBBZSA6IEkpLCBlLmljb24ucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGEudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXgpLmhpZGRlbiA9IG0uaWNvbi5pc0hpZGRlbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmhhc0ljb25Db2xsaXNpb25Cb3hEYXRhKCkgfHwgZS5oYXNUZXh0Q29sbGlzaW9uQm94RGF0YSgpKSB7XG4gICAgICAgICAgdmFyIFMgPSBlLmNvbGxpc2lvbkFycmF5c1tvXTtcblxuICAgICAgICAgIGlmIChTKSB7XG4gICAgICAgICAgICB2YXIgQyA9IG5ldyB0LlBvaW50KDAsIDApO1xuXG4gICAgICAgICAgICBpZiAoUy50ZXh0Qm94IHx8IFMudmVydGljYWxUZXh0Qm94KSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gITA7XG5cbiAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IHIudmFyaWFibGVPZmZzZXRzW2ZdO1xuICAgICAgICAgICAgICAgIEQgPyAoQyA9IHllKEQuYW5jaG9yLCBELndpZHRoLCBELmhlaWdodCwgRC50ZXh0T2Zmc2V0LCBELnRleHRCb3hTY2FsZSksIHUgJiYgQy5fcm90YXRlKGggPyByLnRyYW5zZm9ybS5hbmdsZSA6IC1yLnRyYW5zZm9ybS5hbmdsZSkpIDogeiA9ICExO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgUy50ZXh0Qm94ICYmIHdlKGUudGV4dENvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheSwgbS50ZXh0LnBsYWNlZCwgIXogfHwgeSwgQy54LCBDLnkpLCBTLnZlcnRpY2FsVGV4dEJveCAmJiB3ZShlLnRleHRDb2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXksIG0udGV4dC5wbGFjZWQsICF6IHx8IHgsIEMueCwgQy55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIEEgPSBCb29sZWFuKCF4ICYmIFMudmVydGljYWxJY29uQm94KTtcbiAgICAgICAgICAgIFMuaWNvbkJveCAmJiB3ZShlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXksIG0uaWNvbi5wbGFjZWQsIEEsIHAgPyBDLnggOiAwLCBwID8gQy55IDogMCksIFMudmVydGljYWxJY29uQm94ICYmIHdlKGUuaWNvbkNvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheSwgbS5pY29uLnBsYWNlZCwgIUEsIHAgPyBDLnggOiAwLCBwID8gQy55IDogMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBtID0gMDsgbSA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIGYobSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnNvcnRGZWF0dXJlcyh0aGlzLnRyYW5zZm9ybS5hbmdsZSksIHRoaXMucmV0YWluZWRRdWVyeURhdGFbZS5idWNrZXRJbnN0YW5jZUlkXSAmJiAodGhpcy5yZXRhaW5lZFF1ZXJ5RGF0YVtlLmJ1Y2tldEluc3RhbmNlSWRdLmZlYXR1cmVTb3J0T3JkZXIgPSBlLmZlYXR1cmVTb3J0T3JkZXIpLCBlLmhhc1RleHREYXRhKCkgJiYgZS50ZXh0Lm9wYWNpdHlWZXJ0ZXhCdWZmZXIgJiYgZS50ZXh0Lm9wYWNpdHlWZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YShlLnRleHQub3BhY2l0eVZlcnRleEFycmF5KSwgZS5oYXNJY29uRGF0YSgpICYmIGUuaWNvbi5vcGFjaXR5VmVydGV4QnVmZmVyICYmIGUuaWNvbi5vcGFjaXR5VmVydGV4QnVmZmVyLnVwZGF0ZURhdGEoZS5pY29uLm9wYWNpdHlWZXJ0ZXhBcnJheSksIGUuaGFzSWNvbkNvbGxpc2lvbkJveERhdGEoKSAmJiBlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QnVmZmVyICYmIGUuaWNvbkNvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YShlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXkpLCBlLmhhc1RleHRDb2xsaXNpb25Cb3hEYXRhKCkgJiYgZS50ZXh0Q29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEJ1ZmZlciAmJiBlLnRleHRDb2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QnVmZmVyLnVwZGF0ZURhdGEoZS50ZXh0Q29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5KSwgZS5idWNrZXRJbnN0YW5jZUlkIGluIHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5jb2xsaXNpb25DaXJjbGVBcnJheXNbZS5idWNrZXRJbnN0YW5jZUlkXTtcbiAgICAgICAgZS5wbGFjZW1lbnRJbnZQcm9qTWF0cml4ID0gZy5pbnZQcm9qTWF0cml4LCBlLnBsYWNlbWVudFZpZXdwb3J0TWF0cml4ID0gZy52aWV3cG9ydE1hdHJpeCwgZS5jb2xsaXNpb25DaXJjbGVBcnJheSA9IGcuY2lyY2xlcywgZGVsZXRlIHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzW2UuYnVja2V0SW5zdGFuY2VJZF07XG4gICAgICB9XG4gICAgfSwgYmUucHJvdG90eXBlLnN5bWJvbEZhZGVDaGFuZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMuZmFkZUR1cmF0aW9uID8gMSA6ICh0IC0gdGhpcy5jb21taXRUaW1lKSAvIHRoaXMuZmFkZUR1cmF0aW9uICsgdGhpcy5wcmV2Wm9vbUFkanVzdG1lbnQ7XG4gICAgfSwgYmUucHJvdG90eXBlLnpvb21BZGp1c3RtZW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodGhpcy50cmFuc2Zvcm0uem9vbSAtIHQpIC8gMS41KTtcbiAgICB9LCBiZS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhbGUgfHwgdCAtIHRoaXMubGFzdFBsYWNlbWVudENoYW5nZVRpbWUgPCB0aGlzLmZhZGVEdXJhdGlvbjtcbiAgICB9LCBiZS5wcm90b3R5cGUuc3RpbGxSZWNlbnQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLnpvb21BdExhc3RSZWNlbmN5Q2hlY2sgPT09IGUgPyAxIC0gdGhpcy56b29tQWRqdXN0bWVudChlKSA6IDE7XG4gICAgICByZXR1cm4gdGhpcy56b29tQXRMYXN0UmVjZW5jeUNoZWNrID0gZSwgdGhpcy5jb21taXRUaW1lICsgdGhpcy5mYWRlRHVyYXRpb24gKiBpID4gdDtcbiAgICB9LCBiZS5wcm90b3R5cGUuc2V0U3RhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnN0YWxlID0gITA7XG4gICAgfTtcbiAgICB2YXIgVGUgPSBNYXRoLnBvdygyLCAyNSksXG4gICAgICAgIEVlID0gTWF0aC5wb3coMiwgMjQpLFxuICAgICAgICBJZSA9IE1hdGgucG93KDIsIDE3KSxcbiAgICAgICAgUGUgPSBNYXRoLnBvdygyLCAxNiksXG4gICAgICAgIFNlID0gTWF0aC5wb3coMiwgOSksXG4gICAgICAgIENlID0gTWF0aC5wb3coMiwgOCksXG4gICAgICAgIHplID0gTWF0aC5wb3coMiwgMSk7XG5cbiAgICBmdW5jdGlvbiBEZSh0KSB7XG4gICAgICBpZiAoMCA9PT0gdC5vcGFjaXR5ICYmICF0LnBsYWNlZCkgcmV0dXJuIDA7XG4gICAgICBpZiAoMSA9PT0gdC5vcGFjaXR5ICYmIHQucGxhY2VkKSByZXR1cm4gNDI5NDk2NzI5NTtcbiAgICAgIHZhciBlID0gdC5wbGFjZWQgPyAxIDogMCxcbiAgICAgICAgICBpID0gTWF0aC5mbG9vcigxMjcgKiB0Lm9wYWNpdHkpO1xuICAgICAgcmV0dXJuIGkgKiBUZSArIGUgKiBFZSArIGkgKiBJZSArIGUgKiBQZSArIGkgKiBTZSArIGUgKiBDZSArIGkgKiB6ZSArIGU7XG4gICAgfVxuXG4gICAgdmFyIEFlID0gMCxcbiAgICAgICAgTWUgPSBmdW5jdGlvbiBNZSh0KSB7XG4gICAgICB0aGlzLl9zb3J0QWNyb3NzVGlsZXMgPSBcInZpZXdwb3J0LXlcIiAhPT0gdC5sYXlvdXQuZ2V0KFwic3ltYm9sLXotb3JkZXJcIikgJiYgIXQubGF5b3V0LmdldChcInN5bWJvbC1zb3J0LWtleVwiKS5pc0NvbnN0YW50KCksIHRoaXMuX2N1cnJlbnRUaWxlSW5kZXggPSAwLCB0aGlzLl9jdXJyZW50UGFydEluZGV4ID0gMCwgdGhpcy5fc2VlbkNyb3NzVGlsZUlEcyA9IHt9LCB0aGlzLl9idWNrZXRQYXJ0cyA9IFtdO1xuICAgIH07XG5cbiAgICBNZS5wcm90b3R5cGUuY29udGludWVQbGFjZW1lbnQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgZm9yICh2YXIgYSA9IHRoaXMuX2J1Y2tldFBhcnRzOyB0aGlzLl9jdXJyZW50VGlsZUluZGV4IDwgdC5sZW5ndGg7KSB7XG4gICAgICAgIGlmIChlLmdldEJ1Y2tldFBhcnRzKGEsIG8sIHRbdGhpcy5fY3VycmVudFRpbGVJbmRleF0sIHRoaXMuX3NvcnRBY3Jvc3NUaWxlcyksIHRoaXMuX2N1cnJlbnRUaWxlSW5kZXgrKywgcigpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodGhpcy5fc29ydEFjcm9zc1RpbGVzICYmICh0aGlzLl9zb3J0QWNyb3NzVGlsZXMgPSAhMSwgYS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KSk7IHRoaXMuX2N1cnJlbnRQYXJ0SW5kZXggPCBhLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKGUucGxhY2VMYXllckJ1Y2tldFBhcnQoYVt0aGlzLl9jdXJyZW50UGFydEluZGV4XSwgdGhpcy5fc2VlbkNyb3NzVGlsZUlEcywgaSksIHRoaXMuX2N1cnJlbnRQYXJ0SW5kZXgrKywgcigpKSByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuXG4gICAgdmFyIExlID0gZnVuY3Rpb24gTGUodCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdGhpcy5wbGFjZW1lbnQgPSBuZXcgYmUodCwgciwgYSwgbiksIHRoaXMuX2N1cnJlbnRQbGFjZW1lbnRJbmRleCA9IGUubGVuZ3RoIC0gMSwgdGhpcy5fZm9yY2VGdWxsUGxhY2VtZW50ID0gaSwgdGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzID0gbywgdGhpcy5fZG9uZSA9ICExO1xuICAgIH07XG5cbiAgICBMZS5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RvbmU7XG4gICAgfSwgTGUucHJvdG90eXBlLmNvbnRpbnVlUGxhY2VtZW50ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLCBhID0gdC5icm93c2VyLm5vdygpLCBuID0gZnVuY3Rpb24gbigpIHtcbiAgICAgICAgdmFyIGUgPSB0LmJyb3dzZXIubm93KCkgLSBhO1xuICAgICAgICByZXR1cm4gIXIuX2ZvcmNlRnVsbFBsYWNlbWVudCAmJiBlID4gMjtcbiAgICAgIH07IHRoaXMuX2N1cnJlbnRQbGFjZW1lbnRJbmRleCA+PSAwOykge1xuICAgICAgICB2YXIgcyA9IGlbZVt0aGlzLl9jdXJyZW50UGxhY2VtZW50SW5kZXhdXSxcbiAgICAgICAgICAgIGwgPSB0aGlzLnBsYWNlbWVudC5jb2xsaXNpb25JbmRleC50cmFuc2Zvcm0uem9vbTtcblxuICAgICAgICBpZiAoXCJzeW1ib2xcIiA9PT0gcy50eXBlICYmICghcy5taW56b29tIHx8IHMubWluem9vbSA8PSBsKSAmJiAoIXMubWF4em9vbSB8fCBzLm1heHpvb20gPiBsKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pblByb2dyZXNzTGF5ZXIgfHwgKHRoaXMuX2luUHJvZ3Jlc3NMYXllciA9IG5ldyBNZShzKSksIHRoaXMuX2luUHJvZ3Jlc3NMYXllci5jb250aW51ZVBsYWNlbWVudChvW3Muc291cmNlXSwgdGhpcy5wbGFjZW1lbnQsIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcywgcywgbikpIHJldHVybjtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faW5Qcm9ncmVzc0xheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFBsYWNlbWVudEluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RvbmUgPSAhMDtcbiAgICB9LCBMZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYWNlbWVudC5jb21taXQodCksIHRoaXMucGxhY2VtZW50O1xuICAgIH07XG5cbiAgICB2YXIgUmUgPSA1MTIgLyB0LkVYVEVOVCAvIDIsXG4gICAgICAgIGtlID0gZnVuY3Rpb24ga2UodCwgZSwgaSkge1xuICAgICAgdGhpcy50aWxlSUQgPSB0LCB0aGlzLmluZGV4ZWRTeW1ib2xJbnN0YW5jZXMgPSB7fSwgdGhpcy5idWNrZXRJbnN0YW5jZUlkID0gaTtcblxuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciByID0gZS5nZXQobyksXG4gICAgICAgICAgICBhID0gci5rZXk7XG4gICAgICAgIHRoaXMuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1thXSB8fCAodGhpcy5pbmRleGVkU3ltYm9sSW5zdGFuY2VzW2FdID0gW10pLCB0aGlzLmluZGV4ZWRTeW1ib2xJbnN0YW5jZXNbYV0ucHVzaCh7XG4gICAgICAgICAgY3Jvc3NUaWxlSUQ6IHIuY3Jvc3NUaWxlSUQsXG4gICAgICAgICAgY29vcmQ6IHRoaXMuZ2V0U2NhbGVkQ29vcmRpbmF0ZXMociwgdClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGtlLnByb3RvdHlwZS5nZXRTY2FsZWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IFJlIC8gTWF0aC5wb3coMiwgaS5jYW5vbmljYWwueiAtIHRoaXMudGlsZUlELmNhbm9uaWNhbC56KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoKGkuY2Fub25pY2FsLnggKiB0LkVYVEVOVCArIGUuYW5jaG9yWCkgKiBvKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcigoaS5jYW5vbmljYWwueSAqIHQuRVhURU5UICsgZS5hbmNob3JZKSAqIG8pXG4gICAgICB9O1xuICAgIH0sIGtlLnByb3RvdHlwZS5maW5kTWF0Y2hlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gdGhpcy50aWxlSUQuY2Fub25pY2FsLnogPCBlLmNhbm9uaWNhbC56ID8gMSA6IE1hdGgucG93KDIsIHRoaXMudGlsZUlELmNhbm9uaWNhbC56IC0gZS5jYW5vbmljYWwueiksIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgYSA9IHQuZ2V0KHIpO1xuXG4gICAgICAgIGlmICghYS5jcm9zc1RpbGVJRCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5pbmRleGVkU3ltYm9sSW5zdGFuY2VzW2Eua2V5XTtcbiAgICAgICAgICBpZiAobikgZm9yICh2YXIgcyA9IHRoaXMuZ2V0U2NhbGVkQ29vcmRpbmF0ZXMoYSwgZSksIGwgPSAwLCBjID0gbjsgbCA8IGMubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB1ID0gY1tsXTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHUuY29vcmQueCAtIHMueCkgPD0gbyAmJiBNYXRoLmFicyh1LmNvb3JkLnkgLSBzLnkpIDw9IG8gJiYgIWlbdS5jcm9zc1RpbGVJRF0pIHtcbiAgICAgICAgICAgICAgaVt1LmNyb3NzVGlsZUlEXSA9ICEwLCBhLmNyb3NzVGlsZUlEID0gdS5jcm9zc1RpbGVJRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBCZSA9IGZ1bmN0aW9uIEJlKCkge1xuICAgICAgdGhpcy5tYXhDcm9zc1RpbGVJRCA9IDA7XG4gICAgfTtcblxuICAgIEJlLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiArK3RoaXMubWF4Q3Jvc3NUaWxlSUQ7XG4gICAgfTtcblxuICAgIHZhciBPZSA9IGZ1bmN0aW9uIE9lKCkge1xuICAgICAgdGhpcy5pbmRleGVzID0ge30sIHRoaXMudXNlZENyb3NzVGlsZUlEcyA9IHt9LCB0aGlzLmxuZyA9IDA7XG4gICAgfTtcblxuICAgIE9lLnByb3RvdHlwZS5oYW5kbGVXcmFwSnVtcCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE1hdGgucm91bmQoKHQgLSB0aGlzLmxuZykgLyAzNjApO1xuICAgICAgaWYgKDAgIT09IGUpIGZvciAodmFyIGkgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5pbmRleGVzW2ldLFxuICAgICAgICAgICAgciA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGEgaW4gbykge1xuICAgICAgICAgIHZhciBuID0gb1thXTtcbiAgICAgICAgICBuLnRpbGVJRCA9IG4udGlsZUlELnVud3JhcFRvKG4udGlsZUlELndyYXAgKyBlKSwgcltuLnRpbGVJRC5rZXldID0gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5kZXhlc1tpXSA9IHI7XG4gICAgICB9XG4gICAgICB0aGlzLmxuZyA9IHQ7XG4gICAgfSwgT2UucHJvdG90eXBlLmFkZEJ1Y2tldCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAodGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdICYmIHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXVt0LmtleV0pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXVt0LmtleV0uYnVja2V0SW5zdGFuY2VJZCA9PT0gZS5idWNrZXRJbnN0YW5jZUlkKSByZXR1cm4gITE7XG4gICAgICAgIHRoaXMucmVtb3ZlQnVja2V0Q3Jvc3NUaWxlSURzKHQub3ZlcnNjYWxlZFosIHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXVt0LmtleV0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIGUuc3ltYm9sSW5zdGFuY2VzLmdldChvKS5jcm9zc1RpbGVJRCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXNlZENyb3NzVGlsZUlEc1t0Lm92ZXJzY2FsZWRaXSB8fCAodGhpcy51c2VkQ3Jvc3NUaWxlSURzW3Qub3ZlcnNjYWxlZFpdID0ge30pO1xuICAgICAgdmFyIHIgPSB0aGlzLnVzZWRDcm9zc1RpbGVJRHNbdC5vdmVyc2NhbGVkWl07XG5cbiAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5pbmRleGVzW2FdO1xuICAgICAgICBpZiAoTnVtYmVyKGEpID4gdC5vdmVyc2NhbGVkWikgZm9yICh2YXIgcyBpbiBuKSB7XG4gICAgICAgICAgdmFyIGwgPSBuW3NdO1xuICAgICAgICAgIGwudGlsZUlELmlzQ2hpbGRPZih0KSAmJiBsLmZpbmRNYXRjaGVzKGUuc3ltYm9sSW5zdGFuY2VzLCB0LCByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYyA9IG5bdC5zY2FsZWRUbyhOdW1iZXIoYSkpLmtleV07XG4gICAgICAgICAgYyAmJiBjLmZpbmRNYXRjaGVzKGUuc3ltYm9sSW5zdGFuY2VzLCB0LCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIHZhciBoID0gZS5zeW1ib2xJbnN0YW5jZXMuZ2V0KHUpO1xuICAgICAgICBoLmNyb3NzVGlsZUlEIHx8IChoLmNyb3NzVGlsZUlEID0gaS5nZW5lcmF0ZSgpLCByW2guY3Jvc3NUaWxlSURdID0gITApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdm9pZCAwID09PSB0aGlzLmluZGV4ZXNbdC5vdmVyc2NhbGVkWl0gJiYgKHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXSA9IHt9KSwgdGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdW3Qua2V5XSA9IG5ldyBrZSh0LCBlLnN5bWJvbEluc3RhbmNlcywgZS5idWNrZXRJbnN0YW5jZUlkKSwgITA7XG4gICAgfSwgT2UucHJvdG90eXBlLnJlbW92ZUJ1Y2tldENyb3NzVGlsZUlEcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGUuaW5kZXhlZFN5bWJvbEluc3RhbmNlcykge1xuICAgICAgICBmb3IgKHZhciBvID0gMCwgciA9IGUuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1tpXTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy51c2VkQ3Jvc3NUaWxlSURzW3RdW3Jbb10uY3Jvc3NUaWxlSURdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgT2UucHJvdG90eXBlLnJlbW92ZVN0YWxlQnVja2V0cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICExO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgICB2YXIgbyA9IHRoaXMuaW5kZXhlc1tpXTtcblxuICAgICAgICBmb3IgKHZhciByIGluIG8pIHtcbiAgICAgICAgICB0W29bcl0uYnVja2V0SW5zdGFuY2VJZF0gfHwgKHRoaXMucmVtb3ZlQnVja2V0Q3Jvc3NUaWxlSURzKGksIG9bcl0pLCBkZWxldGUgb1tyXSwgZSA9ICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgdmFyIEZlID0gZnVuY3Rpb24gRmUoKSB7XG4gICAgICB0aGlzLmxheWVySW5kZXhlcyA9IHt9LCB0aGlzLmNyb3NzVGlsZUlEcyA9IG5ldyBCZSgpLCB0aGlzLm1heEJ1Y2tldEluc3RhbmNlSWQgPSAwLCB0aGlzLmJ1Y2tldHNJbkN1cnJlbnRQbGFjZW1lbnQgPSB7fTtcbiAgICB9O1xuXG4gICAgRmUucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5sYXllckluZGV4ZXNbdC5pZF07XG4gICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB0aGlzLmxheWVySW5kZXhlc1t0LmlkXSA9IG5ldyBPZSgpKTtcbiAgICAgIHZhciByID0gITEsXG4gICAgICAgICAgYSA9IHt9O1xuICAgICAgby5oYW5kbGVXcmFwSnVtcChpKTtcblxuICAgICAgZm9yICh2YXIgbiA9IDAsIHMgPSBlOyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgbCA9IHNbbl0sXG4gICAgICAgICAgICBjID0gbC5nZXRCdWNrZXQodCk7XG4gICAgICAgIGMgJiYgdC5pZCA9PT0gYy5sYXllcklkc1swXSAmJiAoYy5idWNrZXRJbnN0YW5jZUlkIHx8IChjLmJ1Y2tldEluc3RhbmNlSWQgPSArK3RoaXMubWF4QnVja2V0SW5zdGFuY2VJZCksIG8uYWRkQnVja2V0KGwudGlsZUlELCBjLCB0aGlzLmNyb3NzVGlsZUlEcykgJiYgKHIgPSAhMCksIGFbYy5idWNrZXRJbnN0YW5jZUlkXSA9ICEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG8ucmVtb3ZlU3RhbGVCdWNrZXRzKGEpICYmIChyID0gITApLCByO1xuICAgIH0sIEZlLnByb3RvdHlwZS5wcnVuZVVudXNlZExheWVycyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIHQuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICBlW3RdID0gITA7XG4gICAgICB9KSwgdGhpcy5sYXllckluZGV4ZXMpIHtcbiAgICAgICAgZVtpXSB8fCBkZWxldGUgdGhpcy5sYXllckluZGV4ZXNbaV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBVZSA9IGZ1bmN0aW9uIFVlKGUsIGkpIHtcbiAgICAgIHJldHVybiB0LmVtaXRWYWxpZGF0aW9uRXJyb3JzKGUsIGkgJiYgaS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwic291cmNlLmNhbnZhc1wiICE9PSB0LmlkZW50aWZpZXI7XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICAgICAgTmUgPSB0LnBpY2soWnQsIFtcImFkZExheWVyXCIsIFwicmVtb3ZlTGF5ZXJcIiwgXCJzZXRQYWludFByb3BlcnR5XCIsIFwic2V0TGF5b3V0UHJvcGVydHlcIiwgXCJzZXRGaWx0ZXJcIiwgXCJhZGRTb3VyY2VcIiwgXCJyZW1vdmVTb3VyY2VcIiwgXCJzZXRMYXllclpvb21SYW5nZVwiLCBcInNldExpZ2h0XCIsIFwic2V0VHJhbnNpdGlvblwiLCBcInNldEdlb0pTT05Tb3VyY2VEYXRhXCJdKSxcbiAgICAgICAgWmUgPSB0LnBpY2soWnQsIFtcInNldENlbnRlclwiLCBcInNldFpvb21cIiwgXCJzZXRCZWFyaW5nXCIsIFwic2V0UGl0Y2hcIl0pLFxuICAgICAgICBxZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0ge30sXG4gICAgICAgICAgaSA9IHQuc3R5bGVTcGVjLiR2ZXJzaW9uO1xuXG4gICAgICBmb3IgKHZhciBvIGluIHQuc3R5bGVTcGVjLiRyb290KSB7XG4gICAgICAgIHZhciByLFxuICAgICAgICAgICAgYSA9IHQuc3R5bGVTcGVjLiRyb290W29dO1xuICAgICAgICBpZiAoYS5yZXF1aXJlZCkgbnVsbCAhPSAociA9IFwidmVyc2lvblwiID09PSBvID8gaSA6IFwiYXJyYXlcIiA9PT0gYS50eXBlID8gW10gOiB7fSkgJiYgKGVbb10gPSByKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfSgpLFxuICAgICAgICBqZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKG8sIHIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIGUuY2FsbCh0aGlzKSwgdGhpcy5tYXAgPSBvLCB0aGlzLmRpc3BhdGNoZXIgPSBuZXcgRShGdCgpLCB0aGlzKSwgdGhpcy5pbWFnZU1hbmFnZXIgPSBuZXcgcCgpLCB0aGlzLmltYWdlTWFuYWdlci5zZXRFdmVudGVkUGFyZW50KHRoaXMpLCB0aGlzLmdseXBoTWFuYWdlciA9IG5ldyB5KG8uX3JlcXVlc3RNYW5hZ2VyLCByLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSksIHRoaXMubGluZUF0bGFzID0gbmV3IFQoMjU2LCA1MTIpLCB0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4ID0gbmV3IEZlKCksIHRoaXMuX2xheWVycyA9IHt9LCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzID0ge30sIHRoaXMuX29yZGVyID0gW10sIHRoaXMuc291cmNlQ2FjaGVzID0ge30sIHRoaXMuem9vbUhpc3RvcnkgPSBuZXcgdC5ab29tSGlzdG9yeSgpLCB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5fYXZhaWxhYmxlSW1hZ2VzID0gW10sIHRoaXMuX3Jlc2V0VXBkYXRlcygpLCB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0UmVmZXJyZXJcIiwgdC5nZXRSZWZlcnJlcigpKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICB0aGlzLl9ydGxUZXh0UGx1Z2luQ2FsbGJhY2sgPSBpLnJlZ2lzdGVyRm9yUGx1Z2luU3RhdGVDaGFuZ2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBuLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic3luY1JUTFBsdWdpblN0YXRlXCIsIHtcbiAgICAgICAgICAgIHBsdWdpblN0YXR1czogZS5wbHVnaW5TdGF0dXMsXG4gICAgICAgICAgICBwbHVnaW5VUkw6IGUucGx1Z2luVVJMXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIGlmICh0LnRyaWdnZXJQbHVnaW5Db21wbGV0aW9uRXZlbnQoZSksIGkgJiYgaS5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0pKSBmb3IgKHZhciBvIGluIG4uc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICAgIG4uc291cmNlQ2FjaGVzW29dLnJlbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgdGhpcy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoXCJzb3VyY2VcIiA9PT0gdC5kYXRhVHlwZSAmJiBcIm1ldGFkYXRhXCIgPT09IHQuc291cmNlRGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBlID0gYS5zb3VyY2VDYWNoZXNbdC5zb3VyY2VJZF07XG5cbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gZS5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgICAgaWYgKGkgJiYgaS52ZWN0b3JMYXllcklkcykgZm9yICh2YXIgbyBpbiBhLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGEuX2xheWVyc1tvXTtcbiAgICAgICAgICAgICAgICByLnNvdXJjZSA9PT0gaS5pZCAmJiBhLl92YWxpZGF0ZUxheWVyKHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZFVSTCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcztcbiAgICAgICAgdm9pZCAwID09PSBpICYmIChpID0ge30pLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciByID0gXCJib29sZWFuXCIgPT0gdHlwZW9mIGkudmFsaWRhdGUgPyBpLnZhbGlkYXRlIDogIXQuaXNNYXBib3hVUkwoZSk7XG4gICAgICAgIGUgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplU3R5bGVVUkwoZSwgaS5hY2Nlc3NUb2tlbik7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChlLCB0LlJlc291cmNlVHlwZS5TdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHQuZ2V0SlNPTihhLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIG8uX3JlcXVlc3QgPSBudWxsLCBlID8gby5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpIDogaSAmJiBvLl9sb2FkKGksIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRKU09OID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSB7fSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzdHlsZVwiXG4gICAgICAgIH0pKSwgdGhpcy5fcmVxdWVzdCA9IHQuYnJvd3Nlci5mcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgby5fcmVxdWVzdCA9IG51bGwsIG8uX2xvYWQoZSwgITEgIT09IGkudmFsaWRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInN0eWxlXCJcbiAgICAgICAgfSkpLCB0aGlzLl9sb2FkKHFlLCAhMSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGlmICghaSB8fCAhVWUodGhpcywgdC52YWxpZGF0ZVN0eWxlKGUpKSkge1xuICAgICAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5fbG9hZGVkID0gITAsIHRoaXMuc3R5bGVzaGVldCA9IGUsIGUuc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2UobywgZS5zb3VyY2VzW29dLCB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5zcHJpdGUgPyB0aGlzLl9sb2FkU3ByaXRlKGUuc3ByaXRlKSA6IHRoaXMuaW1hZ2VNYW5hZ2VyLnNldExvYWRlZCghMCksIHRoaXMuZ2x5cGhNYW5hZ2VyLnNldFVSTChlLmdseXBocyk7XG4gICAgICAgICAgdmFyIHIgPSBOdCh0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcbiAgICAgICAgICB0aGlzLl9vcmRlciA9IHIubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgICAgICB9KSwgdGhpcy5fbGF5ZXJzID0ge30sIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gcjsgYSA8IG4ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzID0gblthXTtcbiAgICAgICAgICAgIChzID0gdC5jcmVhdGVTdHlsZUxheWVyKHMpKS5zZXRFdmVudGVkUGFyZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogcy5pZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgdGhpcy5fbGF5ZXJzW3MuaWRdID0gcywgdGhpcy5fc2VyaWFsaXplZExheWVyc1tzLmlkXSA9IHMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcInNldExheWVyc1wiLCB0aGlzLl9zZXJpYWxpemVMYXllcnModGhpcy5fb3JkZXIpKSwgdGhpcy5saWdodCA9IG5ldyB3KHRoaXMuc3R5bGVzaGVldC5saWdodCksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwic3R5bGUubG9hZFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl9sb2FkU3ByaXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3Nwcml0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHZhciByLFxuICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICBzID0gdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxID8gXCJAMnhcIiA6IFwiXCIsXG4gICAgICAgICAgICAgIGwgPSB0LmdldEpTT04oaS50cmFuc2Zvcm1SZXF1ZXN0KGkubm9ybWFsaXplU3ByaXRlVVJMKGUsIHMsIFwiLmpzb25cIiksIHQuUmVzb3VyY2VUeXBlLlNwcml0ZUpTT04pLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgbCA9IG51bGwsIG4gfHwgKG4gPSB0LCByID0gZSwgdSgpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgYyA9IHQuZ2V0SW1hZ2UoaS50cmFuc2Zvcm1SZXF1ZXN0KGkubm9ybWFsaXplU3ByaXRlVVJMKGUsIHMsIFwiLnBuZ1wiKSwgdC5SZXNvdXJjZVR5cGUuU3ByaXRlSW1hZ2UpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgYyA9IG51bGwsIG4gfHwgKG4gPSB0LCBhID0gZSwgdSgpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgICBpZiAobikgbyhuKTtlbHNlIGlmIChyICYmIGEpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB0LmJyb3dzZXIuZ2V0SW1hZ2VEYXRhKGEpLFxuICAgICAgICAgICAgICAgICAgaSA9IHt9O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gcikge1xuICAgICAgICAgICAgICAgIHZhciBsID0gcltzXSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IGwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHUgPSBsLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaCA9IGwueCxcbiAgICAgICAgICAgICAgICAgICAgcCA9IGwueSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGwuc2RmLFxuICAgICAgICAgICAgICAgICAgICBfID0gbC5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICBmID0gbC5zdHJldGNoWCxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGwuc3RyZXRjaFksXG4gICAgICAgICAgICAgICAgICAgIGcgPSBsLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHYgPSBuZXcgdC5SR0JBSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IGMsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IHVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0LlJHQkFJbWFnZS5jb3B5KGUsIHYsIHtcbiAgICAgICAgICAgICAgICAgIHg6IGgsXG4gICAgICAgICAgICAgICAgICB5OiBwXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogYyxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdVxuICAgICAgICAgICAgICAgIH0pLCBpW3NdID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdixcbiAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IF8sXG4gICAgICAgICAgICAgICAgICBzZGY6IGQsXG4gICAgICAgICAgICAgICAgICBzdHJldGNoWDogZixcbiAgICAgICAgICAgICAgICAgIHN0cmV0Y2hZOiBtLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvKG51bGwsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgbCAmJiAobC5jYW5jZWwoKSwgbCA9IG51bGwpLCBjICYmIChjLmNhbmNlbCgpLCBjID0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfShlLCB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIsIGZ1bmN0aW9uIChlLCBvKSB7XG4gICAgICAgICAgaWYgKGkuX3Nwcml0ZVJlcXVlc3QgPSBudWxsLCBlKSBpLmZpcmUobmV3IHQuRXJyb3JFdmVudChlKSk7ZWxzZSBpZiAobykgZm9yICh2YXIgciBpbiBvKSB7XG4gICAgICAgICAgICBpLmltYWdlTWFuYWdlci5hZGRJbWFnZShyLCBvW3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaS5pbWFnZU1hbmFnZXIuc2V0TG9hZGVkKCEwKSwgaS5fYXZhaWxhYmxlSW1hZ2VzID0gaS5pbWFnZU1hbmFnZXIubGlzdEltYWdlcygpLCBpLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0SW1hZ2VzXCIsIGkuX2F2YWlsYWJsZUltYWdlcyksIGkuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5zb3VyY2VDYWNoZXNbZS5zb3VyY2VdO1xuXG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgdmFyIG8gPSBlLnNvdXJjZUxheWVyO1xuXG4gICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIHZhciByID0gaS5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIChcImdlb2pzb25cIiA9PT0gci50eXBlIHx8IHIudmVjdG9yTGF5ZXJJZHMgJiYgLTEgPT09IHIudmVjdG9yTGF5ZXJJZHMuaW5kZXhPZihvKSkgJiYgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdTb3VyY2UgbGF5ZXIgXCInICsgbyArICdcIiBkb2VzIG5vdCBleGlzdCBvbiBzb3VyY2UgXCInICsgci5pZCArICdcIiBhcyBzcGVjaWZpZWQgYnkgc3R5bGUgbGF5ZXIgXCInICsgZS5pZCArICdcIicpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl91cGRhdGVkU291cmNlcykubGVuZ3RoKSByZXR1cm4gITE7XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VDYWNoZXNbdF0ubG9hZGVkKCkpIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIXRoaXMuaW1hZ2VNYW5hZ2VyLmlzTG9hZGVkKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fc2VyaWFsaXplTGF5ZXJzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IFtdLCBpID0gMCwgbyA9IHQ7IGkgPCBvLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9sYXllcnNbb1tpXV07XG4gICAgICAgICAgXCJjdXN0b21cIiAhPT0gci50eXBlICYmIGUucHVzaChyLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpZ2h0ICYmIHRoaXMubGlnaHQuaGFzVHJhbnNpdGlvbigpKSByZXR1cm4gITA7XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlc1t0XS5oYXNUcmFuc2l0aW9uKCkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xheWVyc1tlXS5oYXNUcmFuc2l0aW9uKCkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9jaGVja0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHRocm93IG5ldyBFcnJvcihcIlN0eWxlIGlzIG5vdCBkb25lIGxvYWRpbmdcIik7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9jaGFuZ2VkO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmtleXModGhpcy5fdXBkYXRlZExheWVycyksXG4gICAgICAgICAgICAgICAgciA9IE9iamVjdC5rZXlzKHRoaXMuX3JlbW92ZWRMYXllcnMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhIGluIChvLmxlbmd0aCB8fCByLmxlbmd0aCkgJiYgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKG8sIHIpLCB0aGlzLl91cGRhdGVkU291cmNlcykge1xuICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2FdO1xuICAgICAgICAgICAgICBcInJlbG9hZFwiID09PSBuID8gdGhpcy5fcmVsb2FkU291cmNlKGEpIDogXCJjbGVhclwiID09PSBuICYmIHRoaXMuX2NsZWFyU291cmNlKGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuX3VwZGF0ZVRpbGVzRm9yQ2hhbmdlZEltYWdlcygpLCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbc10udXBkYXRlVHJhbnNpdGlvbnMoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGlnaHQudXBkYXRlVHJhbnNpdGlvbnMoZSksIHRoaXMuX3Jlc2V0VXBkYXRlcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBjIGluIHRoaXMuc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRoaXMuc291cmNlQ2FjaGVzW2NdO1xuICAgICAgICAgICAgbFtjXSA9IHUudXNlZCwgdS51c2VkID0gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaCA9IDAsIHAgPSB0aGlzLl9vcmRlcjsgaCA8IHAubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5fbGF5ZXJzW3BbaF1dO1xuICAgICAgICAgICAgZC5yZWNhbGN1bGF0ZShlLCB0aGlzLl9hdmFpbGFibGVJbWFnZXMpLCAhZC5pc0hpZGRlbihlLnpvb20pICYmIGQuc291cmNlICYmICh0aGlzLnNvdXJjZUNhY2hlc1tkLnNvdXJjZV0udXNlZCA9ICEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfIGluIGwpIHtcbiAgICAgICAgICAgIHZhciBmID0gdGhpcy5zb3VyY2VDYWNoZXNbX107XG4gICAgICAgICAgICBsW19dICE9PSBmLnVzZWQgJiYgZi5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcInZpc2liaWxpdHlcIixcbiAgICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUlkOiBfXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5saWdodC5yZWNhbGN1bGF0ZShlKSwgdGhpcy56ID0gZS56b29tLCBpICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVRpbGVzRm9yQ2hhbmdlZEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VkSW1hZ2VzKTtcblxuICAgICAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBlIGluIHRoaXMuc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlc1tlXS5yZWxvYWRUaWxlc0ZvckRlcGVuZGVuY2llcyhbXCJpY29uc1wiLCBcInBhdHRlcm5zXCJdLCB0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkSW1hZ2VzID0ge307XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVXb3JrZXJMYXllcnMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwidXBkYXRlTGF5ZXJzXCIsIHtcbiAgICAgICAgICBsYXllcnM6IHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0KSxcbiAgICAgICAgICByZW1vdmVkSWRzOiBlXG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3Jlc2V0VXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9ICExLCB0aGlzLl91cGRhdGVkTGF5ZXJzID0ge30sIHRoaXMuX3JlbW92ZWRMYXllcnMgPSB7fSwgdGhpcy5fdXBkYXRlZFNvdXJjZXMgPSB7fSwgdGhpcy5fdXBkYXRlZFBhaW50UHJvcHMgPSB7fSwgdGhpcy5fY2hhbmdlZEltYWdlcyA9IHt9O1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja0xvYWRlZCgpLCBVZSh0aGlzLCB0LnZhbGlkYXRlU3R5bGUoZSkpKSByZXR1cm4gITE7XG4gICAgICAgIChlID0gdC5jbG9uZSQxKGUpKS5sYXllcnMgPSBOdChlLmxheWVycyk7XG5cbiAgICAgICAgdmFyIG8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGlmICghZSkgcmV0dXJuIFt7XG4gICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgIGFyZ3M6IFtpXVxuICAgICAgICAgIH1dO1xuICAgICAgICAgIHZhciBvID0gW107XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChlLnZlcnNpb24sIGkudmVyc2lvbikpIHJldHVybiBbe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgYXJnczogW2ldXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHQuZGVlcEVxdWFsKGUuY2VudGVyLCBpLmNlbnRlcikgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0Q2VudGVyLFxuICAgICAgICAgICAgICBhcmdzOiBbaS5jZW50ZXJdXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS56b29tLCBpLnpvb20pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldFpvb20sXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLnpvb21dXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5iZWFyaW5nLCBpLmJlYXJpbmcpIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldEJlYXJpbmcsXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLmJlYXJpbmddXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5waXRjaCwgaS5waXRjaCkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0UGl0Y2gsXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLnBpdGNoXVxuICAgICAgICAgICAgfSksIHQuZGVlcEVxdWFsKGUuc3ByaXRlLCBpLnNwcml0ZSkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0U3ByaXRlLFxuICAgICAgICAgICAgICBhcmdzOiBbaS5zcHJpdGVdXG4gICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5nbHlwaHMsIGkuZ2x5cGhzKSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRHbHlwaHMsXG4gICAgICAgICAgICAgIGFyZ3M6IFtpLmdseXBoc11cbiAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChlLnRyYW5zaXRpb24sIGkudHJhbnNpdGlvbikgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0VHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgYXJnczogW2kudHJhbnNpdGlvbl1cbiAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChlLmxpZ2h0LCBpLmxpZ2h0KSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRMaWdodCxcbiAgICAgICAgICAgICAgYXJnczogW2kubGlnaHRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByID0ge30sXG4gICAgICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgIWZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgICAgICAgIHZhciBhO1xuXG4gICAgICAgICAgICAgIGZvciAoYSBpbiBpID0gaSB8fCB7fSwgZSA9IGUgfHwge30pIHtcbiAgICAgICAgICAgICAgICBlLmhhc093blByb3BlcnR5KGEpICYmIChpLmhhc093blByb3BlcnR5KGEpIHx8IGp0KGEsIG8sIHIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoYSBpbiBpKSB7XG4gICAgICAgICAgICAgICAgaS5oYXNPd25Qcm9wZXJ0eShhKSAmJiAoZS5oYXNPd25Qcm9wZXJ0eShhKSA/IHQuZGVlcEVxdWFsKGVbYV0sIGlbYV0pIHx8IChcImdlb2pzb25cIiA9PT0gZVthXS50eXBlICYmIFwiZ2VvanNvblwiID09PSBpW2FdLnR5cGUgJiYgR3QoZSwgaSwgYSkgPyBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0R2VvSlNPTlNvdXJjZURhdGEsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbYSwgaVthXS5kYXRhXVxuICAgICAgICAgICAgICAgIH0pIDogVnQoYSwgaSwgbywgcikpIDogcXQoYSwgaSwgbykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KGUuc291cmNlcywgaS5zb3VyY2VzLCBhLCByKTtcbiAgICAgICAgICAgIHZhciBuID0gW107XG4gICAgICAgICAgICBlLmxheWVycyAmJiBlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJbdC5zb3VyY2VdID8gby5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdC5pZF1cbiAgICAgICAgICAgICAgfSkgOiBuLnB1c2godCk7XG4gICAgICAgICAgICB9KSwgbyA9IG8uY29uY2F0KGEpLCBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgICAgICBpID0gaSB8fCBbXTtcblxuICAgICAgICAgICAgICB2YXIgcixcbiAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgdSxcbiAgICAgICAgICAgICAgICAgIGggPSAoZSA9IGUgfHwgW10pLm1hcChYdCksXG4gICAgICAgICAgICAgICAgICBwID0gaS5tYXAoWHQpLFxuICAgICAgICAgICAgICAgICAgZCA9IGUucmVkdWNlKEh0LCB7fSksXG4gICAgICAgICAgICAgICAgICBfID0gaS5yZWR1Y2UoSHQsIHt9KSxcbiAgICAgICAgICAgICAgICAgIGYgPSBoLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICBtID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBhID0gMDsgciA8IGgubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICBfLmhhc093blByb3BlcnR5KG4gPSBoW3JdKSA/IGErKyA6IChvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbbl1cbiAgICAgICAgICAgICAgICB9KSwgZi5zcGxpY2UoZi5pbmRleE9mKG4sIGEpLCAxKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBhID0gMDsgciA8IHAubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICBmW2YubGVuZ3RoIC0gMSAtIHJdICE9PSAobiA9IHBbcC5sZW5ndGggLSAxIC0gcl0pICYmIChkLmhhc093blByb3BlcnR5KG4pID8gKG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuXVxuICAgICAgICAgICAgICAgIH0pLCBmLnNwbGljZShmLmxhc3RJbmRleE9mKG4sIGYubGVuZ3RoIC0gYSksIDEpKSA6IGErKywgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LmFkZExheWVyLFxuICAgICAgICAgICAgICAgICAgYXJnczogW19bbl0sIGMgPSBmW2YubGVuZ3RoIC0gcl1dXG4gICAgICAgICAgICAgICAgfSksIGYuc3BsaWNlKGYubGVuZ3RoIC0gciwgMCwgbiksIG1bbl0gPSAhMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgcC5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgIGlmIChzID0gZFtuID0gcFtyXV0sIGwgPSBfW25dLCAhbVtuXSAmJiAhdC5kZWVwRXF1YWwocywgbCkpIGlmICh0LmRlZXBFcXVhbChzLnNvdXJjZSwgbC5zb3VyY2UpICYmIHQuZGVlcEVxdWFsKHNbXCJzb3VyY2UtbGF5ZXJcIl0sIGxbXCJzb3VyY2UtbGF5ZXJcIl0pICYmIHQuZGVlcEVxdWFsKHMudHlwZSwgbC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgZm9yICh1IGluIFd0KHMubGF5b3V0LCBsLmxheW91dCwgbywgbiwgbnVsbCwgWnQuc2V0TGF5b3V0UHJvcGVydHkpLCBXdChzLnBhaW50LCBsLnBhaW50LCBvLCBuLCBudWxsLCBadC5zZXRQYWludFByb3BlcnR5KSwgdC5kZWVwRXF1YWwocy5maWx0ZXIsIGwuZmlsdGVyKSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuLCBsLmZpbHRlcl1cbiAgICAgICAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChzLm1pbnpvb20sIGwubWluem9vbSkgJiYgdC5kZWVwRXF1YWwocy5tYXh6b29tLCBsLm1heHpvb20pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldExheWVyWm9vbVJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbiwgbC5taW56b29tLCBsLm1heHpvb21dXG4gICAgICAgICAgICAgICAgICB9KSwgcykge1xuICAgICAgICAgICAgICAgICAgICBzLmhhc093blByb3BlcnR5KHUpICYmIFwibGF5b3V0XCIgIT09IHUgJiYgXCJwYWludFwiICE9PSB1ICYmIFwiZmlsdGVyXCIgIT09IHUgJiYgXCJtZXRhZGF0YVwiICE9PSB1ICYmIFwibWluem9vbVwiICE9PSB1ICYmIFwibWF4em9vbVwiICE9PSB1ICYmICgwID09PSB1LmluZGV4T2YoXCJwYWludC5cIikgPyBXdChzW3VdLCBsW3VdLCBvLCBuLCB1LnNsaWNlKDYpLCBadC5zZXRQYWludFByb3BlcnR5KSA6IHQuZGVlcEVxdWFsKHNbdV0sIGxbdV0pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbiwgdSwgbFt1XV1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHUgaW4gbCkge1xuICAgICAgICAgICAgICAgICAgICBsLmhhc093blByb3BlcnR5KHUpICYmICFzLmhhc093blByb3BlcnR5KHUpICYmIFwibGF5b3V0XCIgIT09IHUgJiYgXCJwYWludFwiICE9PSB1ICYmIFwiZmlsdGVyXCIgIT09IHUgJiYgXCJtZXRhZGF0YVwiICE9PSB1ICYmIFwibWluem9vbVwiICE9PSB1ICYmIFwibWF4em9vbVwiICE9PSB1ICYmICgwID09PSB1LmluZGV4T2YoXCJwYWludC5cIikgPyBXdChzW3VdLCBsW3VdLCBvLCBuLCB1LnNsaWNlKDYpLCBadC5zZXRQYWludFByb3BlcnR5KSA6IHQuZGVlcEVxdWFsKHNbdV0sIGxbdV0pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbiwgdSwgbFt1XV1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbbl1cbiAgICAgICAgICAgICAgICB9KSwgYyA9IGZbZi5sYXN0SW5kZXhPZihuKSArIDFdLCBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuYWRkTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbbCwgY11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShuLCBpLmxheWVycywgbyk7XG4gICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNvbXB1dGUgc3R5bGUgZGlmZjpcIiwgdCksIG8gPSBbe1xuICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgYXJnczogW2ldXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSh0aGlzLnNlcmlhbGl6ZSgpLCBlKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gISh0LmNvbW1hbmQgaW4gWmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoMCA9PT0gby5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgdmFyIHIgPSBvLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhKHQuY29tbWFuZCBpbiBOZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoci5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkOiBcIiArIHIubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuY29tbWFuZDtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgXCJzZXRUcmFuc2l0aW9uXCIgIT09IHQuY29tbWFuZCAmJiBpW3QuY29tbWFuZF0uYXBwbHkoaSwgdC5hcmdzKTtcbiAgICAgICAgfSksIHRoaXMuc3R5bGVzaGVldCA9IGUsICEwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAodGhpcy5nZXRJbWFnZShlKSkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkFuIGltYWdlIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKSkpO1xuICAgICAgICB0aGlzLmltYWdlTWFuYWdlci5hZGRJbWFnZShlLCBpKSwgdGhpcy5fYWZ0ZXJJbWFnZVVwZGF0ZWQoZSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVJbWFnZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLnVwZGF0ZUltYWdlKHQsIGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZU1hbmFnZXIuZ2V0SW1hZ2UodCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRJbWFnZShlKSkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIk5vIGltYWdlIHdpdGggdGhpcyBuYW1lIGV4aXN0cy5cIikpKTtcbiAgICAgICAgdGhpcy5pbWFnZU1hbmFnZXIucmVtb3ZlSW1hZ2UoZSksIHRoaXMuX2FmdGVySW1hZ2VVcGRhdGVkKGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2FmdGVySW1hZ2VVcGRhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlSW1hZ2VzID0gdGhpcy5pbWFnZU1hbmFnZXIubGlzdEltYWdlcygpLCB0aGlzLl9jaGFuZ2VkSW1hZ2VzW2VdID0gITAsIHRoaXMuX2NoYW5nZWQgPSAhMCwgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcInNldEltYWdlc1wiLCB0aGlzLl9hdmFpbGFibGVJbWFnZXMpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICBkYXRhVHlwZTogXCJzdHlsZVwiXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxpc3RJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja0xvYWRlZCgpLCB0aGlzLmltYWdlTWFuYWdlci5saXN0SW1hZ2VzKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2YXIgciA9IHRoaXM7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHRoaXMuX2NoZWNrTG9hZGVkKCksIHZvaWQgMCAhPT0gdGhpcy5zb3VyY2VDYWNoZXNbZV0pIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIGFscmVhZHkgYSBzb3VyY2Ugd2l0aCB0aGlzIElEXCIpO1xuICAgICAgICBpZiAoIWkudHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgcHJvcGVydHkgbXVzdCBiZSBkZWZpbmVkLCBidXQgb25seSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgd2VyZSBnaXZlbjogXCIgKyBPYmplY3Qua2V5cyhpKS5qb2luKFwiLCBcIikgKyBcIi5cIik7XG5cbiAgICAgICAgaWYgKCEoW1widmVjdG9yXCIsIFwicmFzdGVyXCIsIFwiZ2VvanNvblwiLCBcInZpZGVvXCIsIFwiaW1hZ2VcIl0uaW5kZXhPZihpLnR5cGUpID49IDAgJiYgdGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLnNvdXJjZSwgXCJzb3VyY2VzLlwiICsgZSwgaSwgbnVsbCwgbykpKSB7XG4gICAgICAgICAgdGhpcy5tYXAgJiYgdGhpcy5tYXAuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyAmJiAoaS5jb2xsZWN0UmVzb3VyY2VUaW1pbmcgPSAhMCk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLnNvdXJjZUNhY2hlc1tlXSA9IG5ldyBEdChlLCBpLCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgICAgIGEuc3R5bGUgPSB0aGlzLCBhLnNldEV2ZW50ZWRQYXJlbnQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaXNTb3VyY2VMb2FkZWQ6IHIubG9hZGVkKCksXG4gICAgICAgICAgICAgIHNvdXJjZTogYS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgc291cmNlSWQ6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksIGEub25BZGQodGhpcy5tYXApLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja0xvYWRlZCgpLCB2b2lkIDAgPT09IHRoaXMuc291cmNlQ2FjaGVzW2VdKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCB0aGlzIElEXCIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xheWVyc1tpXS5zb3VyY2UgPT09IGUpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ1NvdXJjZSBcIicgKyBlICsgJ1wiIGNhbm5vdCBiZSByZW1vdmVkIHdoaWxlIGxheWVyIFwiJyArIGkgKyAnXCIgaXMgdXNpbmcgaXQuJykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvID0gdGhpcy5zb3VyY2VDYWNoZXNbZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZUNhY2hlc1tlXSwgZGVsZXRlIHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2VdLCBvLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhXCIsIHtcbiAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiLFxuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgIHNvdXJjZUlkOiBlXG4gICAgICAgIH0pKSwgby5zZXRFdmVudGVkUGFyZW50KG51bGwpLCBvLmNsZWFyVGlsZXMoKSwgby5vblJlbW92ZSAmJiBvLm9uUmVtb3ZlKHRoaXMubWFwKSwgdGhpcy5fY2hhbmdlZCA9ICEwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0R2VvSlNPTlNvdXJjZURhdGEgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpLCB0aGlzLnNvdXJjZUNhY2hlc1t0XS5nZXRTb3VyY2UoKS5zZXREYXRhKGUpLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZXNbdF0gJiYgdGhpcy5zb3VyY2VDYWNoZXNbdF0uZ2V0U291cmNlKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIHIgPSBlLmlkO1xuICAgICAgICBpZiAodGhpcy5nZXRMYXllcihyKSkgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdMYXllciB3aXRoIGlkIFwiJyArIHIgKyAnXCIgYWxyZWFkeSBleGlzdHMgb24gdGhpcyBtYXAnKSkpO2Vsc2Uge1xuICAgICAgICAgIHZhciBhO1xuXG4gICAgICAgICAgaWYgKFwiY3VzdG9tXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgaWYgKFVlKHRoaXMsIHQudmFsaWRhdGVDdXN0b21TdHlsZUxheWVyKGUpKSkgcmV0dXJuO1xuICAgICAgICAgICAgYSA9IHQuY3JlYXRlU3R5bGVMYXllcihlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUuc291cmNlICYmICh0aGlzLmFkZFNvdXJjZShyLCBlLnNvdXJjZSksIGUgPSB0LmNsb25lJDEoZSksIGUgPSB0LmV4dGVuZChlLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogclxuICAgICAgICAgICAgfSkpLCB0aGlzLl92YWxpZGF0ZSh0LnZhbGlkYXRlU3R5bGUubGF5ZXIsIFwibGF5ZXJzLlwiICsgciwgZSwge1xuICAgICAgICAgICAgICBhcnJheUluZGV4OiAtMVxuICAgICAgICAgICAgfSwgbykpIHJldHVybjtcbiAgICAgICAgICAgIGEgPSB0LmNyZWF0ZVN0eWxlTGF5ZXIoZSksIHRoaXMuX3ZhbGlkYXRlTGF5ZXIoYSksIGEuc2V0RXZlbnRlZFBhcmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnNbYS5pZF0gPSBhLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuID0gaSA/IHRoaXMuX29yZGVyLmluZGV4T2YoaSkgOiB0aGlzLl9vcmRlci5sZW5ndGg7XG4gICAgICAgICAgaWYgKGkgJiYgLTEgPT09IG4pIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignTGF5ZXIgd2l0aCBpZCBcIicgKyBpICsgJ1wiIGRvZXMgbm90IGV4aXN0IG9uIHRoaXMgbWFwLicpKSk7ZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3JkZXIuc3BsaWNlKG4sIDAsIHIpLCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCA9ICEwLCB0aGlzLl9sYXllcnNbcl0gPSBhLCB0aGlzLl9yZW1vdmVkTGF5ZXJzW3JdICYmIGEuc291cmNlICYmIFwiY3VzdG9tXCIgIT09IGEudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuX3JlbW92ZWRMYXllcnNbcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZW1vdmVkTGF5ZXJzW3JdLCBzLnR5cGUgIT09IGEudHlwZSA/IHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2Euc291cmNlXSA9IFwiY2xlYXJcIiA6ICh0aGlzLl91cGRhdGVkU291cmNlc1thLnNvdXJjZV0gPSBcInJlbG9hZFwiLCB0aGlzLnNvdXJjZUNhY2hlc1thLnNvdXJjZV0ucGF1c2UoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKGEpLCBhLm9uQWRkICYmIGEub25BZGQodGhpcy5tYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUubW92ZUxheWVyID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrTG9hZGVkKCksIHRoaXMuX2NoYW5nZWQgPSAhMCwgdGhpcy5fbGF5ZXJzW2VdKSB7XG4gICAgICAgICAgaWYgKGUgIT09IGkpIHtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5fb3JkZXIuaW5kZXhPZihlKTtcblxuICAgICAgICAgICAgdGhpcy5fb3JkZXIuc3BsaWNlKG8sIDEpO1xuXG4gICAgICAgICAgICB2YXIgciA9IGkgPyB0aGlzLl9vcmRlci5pbmRleE9mKGkpIDogdGhpcy5fb3JkZXIubGVuZ3RoO1xuICAgICAgICAgICAgaSAmJiAtMSA9PT0gciA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignTGF5ZXIgd2l0aCBpZCBcIicgKyBpICsgJ1wiIGRvZXMgbm90IGV4aXN0IG9uIHRoaXMgbWFwLicpKSkgOiAodGhpcy5fb3JkZXIuc3BsaWNlKHIsIDAsIGUpLCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSBtb3ZlZC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgaSA9IHRoaXMuX2xheWVyc1tlXTtcblxuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIGkuc2V0RXZlbnRlZFBhcmVudChudWxsKTtcblxuICAgICAgICAgIHZhciBvID0gdGhpcy5fb3JkZXIuaW5kZXhPZihlKTtcblxuICAgICAgICAgIHRoaXMuX29yZGVyLnNwbGljZShvLCAxKSwgdGhpcy5fbGF5ZXJPcmRlckNoYW5nZWQgPSAhMCwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl9yZW1vdmVkTGF5ZXJzW2VdID0gaSwgZGVsZXRlIHRoaXMuX2xheWVyc1tlXSwgZGVsZXRlIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnNbZV0sIGRlbGV0ZSB0aGlzLl91cGRhdGVkTGF5ZXJzW2VdLCBkZWxldGUgdGhpcy5fdXBkYXRlZFBhaW50UHJvcHNbZV0sIGkub25SZW1vdmUgJiYgaS5vblJlbW92ZSh0aGlzLm1hcCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSByZW1vdmVkLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0TGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW3RdO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFzTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCBpbiB0aGlzLl9sYXllcnM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRMYXllclpvb21SYW5nZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICByID8gci5taW56b29tID09PSBpICYmIHIubWF4em9vbSA9PT0gbyB8fCAobnVsbCAhPSBpICYmIChyLm1pbnpvb20gPSBpKSwgbnVsbCAhPSBvICYmIChyLm1heHpvb20gPSBvKSwgdGhpcy5fdXBkYXRlTGF5ZXIocikpIDogdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiVGhlIGxheWVyICdcIiArIGUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlIGFuZCBjYW5ub3QgaGF2ZSB6b29tIGV4dGVudC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldExheWVyKGUpO1xuXG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChyLmZpbHRlciwgaSkpIHJldHVybiBudWxsID09IGkgPyAoci5maWx0ZXIgPSB2b2lkIDAsIHZvaWQgdGhpcy5fdXBkYXRlTGF5ZXIocikpIDogdm9pZCAodGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLmZpbHRlciwgXCJsYXllcnMuXCIgKyByLmlkICsgXCIuZmlsdGVyXCIsIGksIG51bGwsIG8pIHx8IChyLmZpbHRlciA9IHQuY2xvbmUkMShpKSwgdGhpcy5fdXBkYXRlTGF5ZXIocikpKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIGZpbHRlcmVkLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHQuY2xvbmUkMSh0aGlzLmdldExheWVyKGUpLmZpbHRlcik7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICBhID8gdC5kZWVwRXF1YWwoYS5nZXRMYXlvdXRQcm9wZXJ0eShpKSwgbykgfHwgKGEuc2V0TGF5b3V0UHJvcGVydHkoaSwgbywgciksIHRoaXMuX3VwZGF0ZUxheWVyKGEpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIHN0eWxlZC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldExheW91dFByb3BlcnR5ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICBpZiAobykgcmV0dXJuIG8uZ2V0TGF5b3V0UHJvcGVydHkoaSk7XG4gICAgICAgIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZS5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRMYXllcihlKTtcbiAgICAgICAgYSA/IHQuZGVlcEVxdWFsKGEuZ2V0UGFpbnRQcm9wZXJ0eShpKSwgbykgfHwgKGEuc2V0UGFpbnRQcm9wZXJ0eShpLCBvLCByKSAmJiB0aGlzLl91cGRhdGVMYXllcihhKSwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wc1tlXSA9ICEwKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIHN0eWxlZC5cIikpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcih0KS5nZXRQYWludFByb3BlcnR5KGUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbyA9IGUuc291cmNlLFxuICAgICAgICAgICAgciA9IGUuc291cmNlTGF5ZXIsXG4gICAgICAgICAgICBhID0gdGhpcy5zb3VyY2VDYWNoZXNbb107XG5cbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSkge1xuICAgICAgICAgIHZhciBuID0gYS5nZXRTb3VyY2UoKS50eXBlO1xuICAgICAgICAgIFwiZ2VvanNvblwiID09PSBuICYmIHIgPyB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJHZW9KU09OIHNvdXJjZXMgY2Fubm90IGhhdmUgYSBzb3VyY2VMYXllciBwYXJhbWV0ZXIuXCIpKSkgOiBcInZlY3RvclwiICE9PSBuIHx8IHIgPyAodm9pZCAwID09PSBlLmlkICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBmZWF0dXJlIGlkIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkLlwiKSkpLCBhLnNldEZlYXR1cmVTdGF0ZShyLCBlLmlkLCBpKSkgOiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlTGF5ZXIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZlY3RvciBzb3VyY2UgdHlwZXMuXCIpKSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlICdcIiArIG8gKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbyA9IGUuc291cmNlLFxuICAgICAgICAgICAgciA9IHRoaXMuc291cmNlQ2FjaGVzW29dO1xuXG4gICAgICAgIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgICAgICB2YXIgYSA9IHIuZ2V0U291cmNlKCkudHlwZSxcbiAgICAgICAgICAgICAgbiA9IFwidmVjdG9yXCIgPT09IGEgPyBlLnNvdXJjZUxheWVyIDogdm9pZCAwO1xuICAgICAgICAgIFwidmVjdG9yXCIgIT09IGEgfHwgbiA/IGkgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZS5pZCAmJiBcIm51bWJlclwiICE9IHR5cGVvZiBlLmlkID8gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiQSBmZWF0dXJlIGlkIGlzIHJlcXVpcmVkIHRvIHJlbW92ZSBpdHMgc3BlY2lmaWMgc3RhdGUgcHJvcGVydHkuXCIpKSkgOiByLnJlbW92ZUZlYXR1cmVTdGF0ZShuLCBlLmlkLCBpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2VMYXllciBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgdmVjdG9yIHNvdXJjZSB0eXBlcy5cIikpKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2UgJ1wiICsgbyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUuXCIpKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpO1xuXG4gICAgICAgIHZhciBpID0gZS5zb3VyY2UsXG4gICAgICAgICAgICBvID0gZS5zb3VyY2VMYXllcixcbiAgICAgICAgICAgIHIgPSB0aGlzLnNvdXJjZUNhY2hlc1tpXTtcblxuICAgICAgICBpZiAodm9pZCAwICE9PSByKSB7XG4gICAgICAgICAgaWYgKFwidmVjdG9yXCIgIT09IHIuZ2V0U291cmNlKCkudHlwZSB8fCBvKSByZXR1cm4gdm9pZCAwID09PSBlLmlkICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBmZWF0dXJlIGlkIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkLlwiKSkpLCByLmdldEZlYXR1cmVTdGF0ZShvLCBlLmlkKTtcbiAgICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlTGF5ZXIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZlY3RvciBzb3VyY2UgdHlwZXMuXCIpKSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlICdcIiArIGkgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlLlwiKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKHtcbiAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgIGRlbGF5OiAwXG4gICAgICAgIH0sIHRoaXMuc3R5bGVzaGVldCAmJiB0aGlzLnN0eWxlc2hlZXQudHJhbnNpdGlvbik7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LmZpbHRlck9iamVjdCh7XG4gICAgICAgICAgdmVyc2lvbjogdGhpcy5zdHlsZXNoZWV0LnZlcnNpb24sXG4gICAgICAgICAgbmFtZTogdGhpcy5zdHlsZXNoZWV0Lm5hbWUsXG4gICAgICAgICAgbWV0YWRhdGE6IHRoaXMuc3R5bGVzaGVldC5tZXRhZGF0YSxcbiAgICAgICAgICBsaWdodDogdGhpcy5zdHlsZXNoZWV0LmxpZ2h0LFxuICAgICAgICAgIGNlbnRlcjogdGhpcy5zdHlsZXNoZWV0LmNlbnRlcixcbiAgICAgICAgICB6b29tOiB0aGlzLnN0eWxlc2hlZXQuem9vbSxcbiAgICAgICAgICBiZWFyaW5nOiB0aGlzLnN0eWxlc2hlZXQuYmVhcmluZyxcbiAgICAgICAgICBwaXRjaDogdGhpcy5zdHlsZXNoZWV0LnBpdGNoLFxuICAgICAgICAgIHNwcml0ZTogdGhpcy5zdHlsZXNoZWV0LnNwcml0ZSxcbiAgICAgICAgICBnbHlwaHM6IHRoaXMuc3R5bGVzaGVldC5nbHlwaHMsXG4gICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24sXG4gICAgICAgICAgc291cmNlczogdC5tYXBPYmplY3QodGhpcy5zb3VyY2VDYWNoZXMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsYXllcnM6IHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0aGlzLl9vcmRlcilcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSB0O1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVMYXllciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZWRMYXllcnNbdC5pZF0gPSAhMCwgdC5zb3VyY2UgJiYgIXRoaXMuX3VwZGF0ZWRTb3VyY2VzW3Quc291cmNlXSAmJiBcInJhc3RlclwiICE9PSB0aGlzLnNvdXJjZUNhY2hlc1t0LnNvdXJjZV0uZ2V0U291cmNlKCkudHlwZSAmJiAodGhpcy5fdXBkYXRlZFNvdXJjZXNbdC5zb3VyY2VdID0gXCJyZWxvYWRcIiwgdGhpcy5zb3VyY2VDYWNoZXNbdC5zb3VyY2VdLnBhdXNlKCkpLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZmxhdHRlbkFuZFNvcnRSZW5kZXJlZEZlYXR1cmVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMsIGkgPSBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJmaWxsLWV4dHJ1c2lvblwiID09PSBlLl9sYXllcnNbdF0udHlwZTtcbiAgICAgICAgfSwgbyA9IHt9LCByID0gW10sIGEgPSB0aGlzLl9vcmRlci5sZW5ndGggLSAxOyBhID49IDA7IGEtLSkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5fb3JkZXJbYV07XG5cbiAgICAgICAgICBpZiAoaShuKSkge1xuICAgICAgICAgICAgb1tuXSA9IGE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwLCBsID0gdDsgcyA8IGwubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBsW3NdW25dO1xuICAgICAgICAgICAgICBpZiAoYykgZm9yICh2YXIgdSA9IDAsIGggPSBjOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgICAgIHIucHVzaChoW3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiBlLmludGVyc2VjdGlvblogLSB0LmludGVyc2VjdGlvblo7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSBbXSwgZCA9IHRoaXMuX29yZGVyLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgdmFyIF8gPSB0aGlzLl9vcmRlcltkXTtcbiAgICAgICAgICBpZiAoaShfKSkgZm9yICh2YXIgZiA9IHIubGVuZ3RoIC0gMTsgZiA+PSAwOyBmLS0pIHtcbiAgICAgICAgICAgIHZhciBtID0gcltmXS5mZWF0dXJlO1xuICAgICAgICAgICAgaWYgKG9bbS5sYXllci5pZF0gPCBkKSBicmVhaztcbiAgICAgICAgICAgIHAucHVzaChtKSwgci5wb3AoKTtcbiAgICAgICAgICB9IGVsc2UgZm9yICh2YXIgZyA9IDAsIHYgPSB0OyBnIDwgdi5sZW5ndGg7IGcgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHkgPSB2W2ddW19dO1xuICAgICAgICAgICAgaWYgKHkpIGZvciAodmFyIHggPSAwLCBiID0geTsgeCA8IGIubGVuZ3RoOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgcC5wdXNoKGJbeF0uZmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICBpICYmIGkuZmlsdGVyICYmIHRoaXMuX3ZhbGlkYXRlKHQudmFsaWRhdGVTdHlsZS5maWx0ZXIsIFwicXVlcnlSZW5kZXJlZEZlYXR1cmVzLmZpbHRlclwiLCBpLmZpbHRlciwgbnVsbCwgaSk7XG4gICAgICAgIHZhciByID0ge307XG5cbiAgICAgICAgaWYgKGkgJiYgaS5sYXllcnMpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaS5sYXllcnMpKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwicGFyYW1ldGVycy5sYXllcnMgbXVzdCBiZSBhbiBBcnJheS5cIikpKSwgW107XG5cbiAgICAgICAgICBmb3IgKHZhciBhID0gMCwgbiA9IGkubGF5ZXJzOyBhIDwgbi5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuW2FdLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLl9sYXllcnNbc107XG4gICAgICAgICAgICBpZiAoIWwpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgcyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSBxdWVyaWVkIGZvciBmZWF0dXJlcy5cIikpKSwgW107XG4gICAgICAgICAgICByW2wuc291cmNlXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgdSBpbiBpLmF2YWlsYWJsZUltYWdlcyA9IHRoaXMuX2F2YWlsYWJsZUltYWdlcywgdGhpcy5zb3VyY2VDYWNoZXMpIHtcbiAgICAgICAgICBpLmxheWVycyAmJiAhclt1XSB8fCBjLnB1c2goTyh0aGlzLnNvdXJjZUNhY2hlc1t1XSwgdGhpcy5fbGF5ZXJzLCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzLCBlLCBpLCBvKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnQgJiYgYy5wdXNoKGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IHt9LCBsID0gYS5xdWVyeVJlbmRlcmVkU3ltYm9scyhvKSwgYyA9IFtdLCB1ID0gMCwgaCA9IE9iamVjdC5rZXlzKGwpLm1hcChOdW1iZXIpOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgYy5wdXNoKG5baFt1XV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMuc29ydChGKTtcblxuICAgICAgICAgIGZvciAodmFyIHAgPSBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBfW2RdLFxuICAgICAgICAgICAgICAgIG8gPSBpLmZlYXR1cmVJbmRleC5sb29rdXBTeW1ib2xGZWF0dXJlcyhsW2kuYnVja2V0SW5zdGFuY2VJZF0sIGUsIGkuYnVja2V0SW5kZXgsIGkuc291cmNlTGF5ZXJJbmRleCwgci5maWx0ZXIsIHIubGF5ZXJzLCByLmF2YWlsYWJsZUltYWdlcywgdCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4gbykge1xuICAgICAgICAgICAgICB2YXIgbiA9IHNbYV0gPSBzW2FdIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgYyA9IG9bYV07XG4gICAgICAgICAgICAgIGMuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gaS5mZWF0dXJlU29ydE9yZGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgIHZhciByID0gby5pbmRleE9mKHQuZmVhdHVyZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLmluZGV4T2YoZS5mZWF0dXJlSW5kZXgpIC0gcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZS5mZWF0dXJlSW5kZXggLSB0LmZlYXR1cmVJbmRleDtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgdSA9IDAsIGggPSBjOyB1IDwgaC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICAgICAgICAgIG4ucHVzaChoW3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGQgPSAwLCBfID0gYzsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgICAgIHAoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIGYoZSkge1xuICAgICAgICAgICAgc1tlXS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgIHZhciByID0gby5mZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgYSA9IGlbdFtlXS5zb3VyY2VdLmdldEZlYXR1cmVTdGF0ZShyLmxheWVyW1wic291cmNlLWxheWVyXCJdLCByLmlkKTtcbiAgICAgICAgICAgICAgci5zb3VyY2UgPSByLmxheWVyLnNvdXJjZSwgci5sYXllcltcInNvdXJjZS1sYXllclwiXSAmJiAoci5zb3VyY2VMYXllciA9IHIubGF5ZXJbXCJzb3VyY2UtbGF5ZXJcIl0pLCByLnN0YXRlID0gYTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBtIGluIHMpIHtcbiAgICAgICAgICAgIGYobSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0odGhpcy5fbGF5ZXJzLCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzLCB0aGlzLnNvdXJjZUNhY2hlcywgZSwgaSwgdGhpcy5wbGFjZW1lbnQuY29sbGlzaW9uSW5kZXgsIHRoaXMucGxhY2VtZW50LnJldGFpbmVkUXVlcnlEYXRhKSksIHRoaXMuX2ZsYXR0ZW5BbmRTb3J0UmVuZGVyZWRGZWF0dXJlcyhjKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnF1ZXJ5U291cmNlRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpICYmIGkuZmlsdGVyICYmIHRoaXMuX3ZhbGlkYXRlKHQudmFsaWRhdGVTdHlsZS5maWx0ZXIsIFwicXVlcnlTb3VyY2VGZWF0dXJlcy5maWx0ZXJcIiwgaS5maWx0ZXIsIG51bGwsIGkpO1xuICAgICAgICB2YXIgbyA9IHRoaXMuc291cmNlQ2FjaGVzW2VdO1xuICAgICAgICByZXR1cm4gbyA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHQuZ2V0UmVuZGVyYWJsZUlkcygpLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuZ2V0VGlsZUJ5SUQoZSk7XG4gICAgICAgICAgfSksIG8gPSBbXSwgciA9IHt9LCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIHZhciBuID0gaVthXSxcbiAgICAgICAgICAgICAgICBzID0gbi50aWxlSUQuY2Fub25pY2FsLmtleTtcbiAgICAgICAgICAgIHJbc10gfHwgKHJbc10gPSAhMCwgbi5xdWVyeVNvdXJjZUZlYXR1cmVzKG8sIGUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfShvLCBpKSA6IFtdO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWRkU291cmNlVHlwZSA9IGZ1bmN0aW9uICh0LCBlLCBvKSB7XG4gICAgICAgIHJldHVybiBpLmdldFNvdXJjZVR5cGUodCkgPyBvKG5ldyBFcnJvcignQSBzb3VyY2UgdHlwZSBjYWxsZWQgXCInICsgdCArICdcIiBhbHJlYWR5IGV4aXN0cy4nKSkgOiAoaS5zZXRTb3VyY2VUeXBlKHQsIGUpLCBlLndvcmtlclNvdXJjZVVSTCA/IHZvaWQgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcImxvYWRXb3JrZXJTb3VyY2VcIiwge1xuICAgICAgICAgIG5hbWU6IHQsXG4gICAgICAgICAgdXJsOiBlLndvcmtlclNvdXJjZVVSTFxuICAgICAgICB9LCBvKSA6IG8obnVsbCwgbnVsbCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0TGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZ2h0LmdldExpZ2h0KCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRMaWdodCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxpZ2h0LmdldExpZ2h0KCksXG4gICAgICAgICAgICByID0gITE7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiBlKSB7XG4gICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChlW2FdLCBvW2FdKSkge1xuICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgIG5vdzogdC5icm93c2VyLm5vdygpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdC5leHRlbmQoe1xuICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgICBkZWxheTogMFxuICAgICAgICAgICAgfSwgdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24pXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxpZ2h0LnNldExpZ2h0KGUsIGkpLCB0aGlzLmxpZ2h0LnVwZGF0ZVRyYW5zaXRpb25zKG4pO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhICYmIChhID0ge30pLCAoIWEgfHwgITEgIT09IGEudmFsaWRhdGUpICYmIFVlKHRoaXMsIGUuY2FsbCh0LnZhbGlkYXRlU3R5bGUsIHQuZXh0ZW5kKHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgc3R5bGU6IHRoaXMuc2VyaWFsaXplKCksXG4gICAgICAgICAgdmFsdWU6IG8sXG4gICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlY1xuICAgICAgICB9LCByKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLl9yZXF1ZXN0ICYmICh0aGlzLl9yZXF1ZXN0LmNhbmNlbCgpLCB0aGlzLl9yZXF1ZXN0ID0gbnVsbCksIHRoaXMuX3Nwcml0ZVJlcXVlc3QgJiYgKHRoaXMuX3Nwcml0ZVJlcXVlc3QuY2FuY2VsKCksIHRoaXMuX3Nwcml0ZVJlcXVlc3QgPSBudWxsKSwgdC5ldmVudGVkLm9mZihcInBsdWdpblN0YXRlQ2hhbmdlXCIsIHRoaXMuX3J0bFRleHRQbHVnaW5DYWxsYmFjayksIHRoaXMuX2xheWVycykge1xuICAgICAgICAgIHRoaXMuX2xheWVyc1tlXS5zZXRFdmVudGVkUGFyZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVzW2ldLmNsZWFyVGlsZXMoKSwgdGhpcy5zb3VyY2VDYWNoZXNbaV0uc2V0RXZlbnRlZFBhcmVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLnNldEV2ZW50ZWRQYXJlbnQobnVsbCksIHRoaXMuc2V0RXZlbnRlZFBhcmVudChudWxsKSwgdGhpcy5kaXNwYXRjaGVyLnJlbW92ZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2NsZWFyU291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VDYWNoZXNbdF0uY2xlYXJUaWxlcygpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbG9hZFNvdXJjZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuc291cmNlQ2FjaGVzW3RdLnJlc3VtZSgpLCB0aGlzLnNvdXJjZUNhY2hlc1t0XS5yZWxvYWQoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVTb3VyY2VzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLnNvdXJjZUNhY2hlcykge1xuICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVzW2VdLnVwZGF0ZSh0KTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX2dlbmVyYXRlQ29sbGlzaW9uQm94ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9yZWxvYWRTb3VyY2UodCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVQbGFjZW1lbnQgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMSk7XG5cbiAgICAgICAgZm9yICh2YXIgbiA9ICExLCBzID0gITEsIGwgPSB7fSwgYyA9IDAsIHUgPSB0aGlzLl9vcmRlcjsgYyA8IHUubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuX2xheWVyc1t1W2NdXTtcblxuICAgICAgICAgIGlmIChcInN5bWJvbFwiID09PSBoLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICghbFtoLnNvdXJjZV0pIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnNvdXJjZUNhY2hlc1toLnNvdXJjZV07XG4gICAgICAgICAgICAgIGxbaC5zb3VyY2VdID0gcC5nZXRSZW5kZXJhYmxlSWRzKCEwKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5nZXRUaWxlQnlJRCh0KTtcbiAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnRpbGVJRC5vdmVyc2NhbGVkWiAtIHQudGlsZUlELm92ZXJzY2FsZWRaIHx8ICh0LnRpbGVJRC5pc0xlc3NUaGFuKGUudGlsZUlEKSA/IC0xIDogMSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuY3Jvc3NUaWxlU3ltYm9sSW5kZXguYWRkTGF5ZXIoaCwgbFtoLnNvdXJjZV0sIGUuY2VudGVyLmxuZyk7XG4gICAgICAgICAgICBuID0gbiB8fCBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4LnBydW5lVW51c2VkTGF5ZXJzKHRoaXMuX29yZGVyKSwgKChhID0gYSB8fCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCB8fCAwID09PSBvKSB8fCAhdGhpcy5wYXVzZWFibGVQbGFjZW1lbnQgfHwgdGhpcy5wYXVzZWFibGVQbGFjZW1lbnQuaXNEb25lKCkgJiYgIXRoaXMucGxhY2VtZW50LnN0aWxsUmVjZW50KHQuYnJvd3Nlci5ub3coKSwgZS56b29tKSkgJiYgKHRoaXMucGF1c2VhYmxlUGxhY2VtZW50ID0gbmV3IExlKGUsIHRoaXMuX29yZGVyLCBhLCBpLCBvLCByLCB0aGlzLnBsYWNlbWVudCksIHRoaXMuX2xheWVyT3JkZXJDaGFuZ2VkID0gITEpLCB0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5pc0RvbmUoKSA/IHRoaXMucGxhY2VtZW50LnNldFN0YWxlKCkgOiAodGhpcy5wYXVzZWFibGVQbGFjZW1lbnQuY29udGludWVQbGFjZW1lbnQodGhpcy5fb3JkZXIsIHRoaXMuX2xheWVycywgbCksIHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LmlzRG9uZSgpICYmICh0aGlzLnBsYWNlbWVudCA9IHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LmNvbW1pdCh0LmJyb3dzZXIubm93KCkpLCBzID0gITApLCBuICYmIHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LnBsYWNlbWVudC5zZXRTdGFsZSgpKSwgcyB8fCBuKSBmb3IgKHZhciBfID0gMCwgZiA9IHRoaXMuX29yZGVyOyBfIDwgZi5sZW5ndGg7IF8gKz0gMSkge1xuICAgICAgICAgIHZhciBtID0gdGhpcy5fbGF5ZXJzW2ZbX11dO1xuICAgICAgICAgIFwic3ltYm9sXCIgPT09IG0udHlwZSAmJiB0aGlzLnBsYWNlbWVudC51cGRhdGVMYXllck9wYWNpdGllcyhtLCBsW20uc291cmNlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5pc0RvbmUoKSB8fCB0aGlzLnBsYWNlbWVudC5oYXNUcmFuc2l0aW9ucyh0LmJyb3dzZXIubm93KCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbGVhc2VTeW1ib2xGYWRlVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlc1t0XS5yZWxlYXNlU3ltYm9sRmFkZVRpbGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLmdldEltYWdlcyhlLmljb25zLCBpKSwgdGhpcy5fdXBkYXRlVGlsZXNGb3JDaGFuZ2VkSW1hZ2VzKCk7XG4gICAgICAgIHZhciBvID0gdGhpcy5zb3VyY2VDYWNoZXNbZS5zb3VyY2VdO1xuICAgICAgICBvICYmIG8uc2V0RGVwZW5kZW5jaWVzKGUudGlsZUlELmtleSwgZS50eXBlLCBlLmljb25zKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHRoaXMuZ2x5cGhNYW5hZ2VyLmdldEdseXBocyhlLnN0YWNrcywgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB0Lm1ha2VSZXF1ZXN0KGksIG8pO1xuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCk7XG5cbiAgICBqZS5nZXRTb3VyY2VUeXBlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBrW3RdO1xuICAgIH0sIGplLnNldFNvdXJjZVR5cGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAga1t0XSA9IGU7XG4gICAgfSwgamUucmVnaXN0ZXJGb3JQbHVnaW5TdGF0ZUNoYW5nZSA9IHQucmVnaXN0ZXJGb3JQbHVnaW5TdGF0ZUNoYW5nZTtcblxuICAgIHZhciBWZSA9IHQuY3JlYXRlTGF5b3V0KFt7XG4gICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBjb21wb25lbnRzOiAyXG4gICAgfV0pLFxuICAgICAgICBHZSA9IGdpKFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2Vsc2VcXG4jaWYgIWRlZmluZWQobG93cClcXG4jZGVmaW5lIGxvd3BcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQobWVkaXVtcClcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQoaGlnaHApXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcbiNlbmRpZlwiLCBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNpZiAhZGVmaW5lZChsb3dwKVxcbiNkZWZpbmUgbG93cFxcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZChtZWRpdW1wKVxcbiNkZWZpbmUgbWVkaXVtcFxcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZChoaWdocClcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuI2VuZGlmXFxudmVjMiB1bnBhY2tfZmxvYXQoY29uc3QgZmxvYXQgcGFja2VkVmFsdWUpIHtpbnQgcGFja2VkSW50VmFsdWU9aW50KHBhY2tlZFZhbHVlKTtpbnQgdjA9cGFja2VkSW50VmFsdWUvMjU2O3JldHVybiB2ZWMyKHYwLHBhY2tlZEludFZhbHVlLXYwKjI1Nik7fXZlYzIgdW5wYWNrX29wYWNpdHkoY29uc3QgZmxvYXQgcGFja2VkT3BhY2l0eSkge2ludCBpbnRPcGFjaXR5PWludChwYWNrZWRPcGFjaXR5KS8yO3JldHVybiB2ZWMyKGZsb2F0KGludE9wYWNpdHkpLzEyNy4wLG1vZChwYWNrZWRPcGFjaXR5LDIuMCkpO312ZWM0IGRlY29kZV9jb2xvcihjb25zdCB2ZWMyIGVuY29kZWRDb2xvcikge3JldHVybiB2ZWM0KHVucGFja19mbG9hdChlbmNvZGVkQ29sb3JbMF0pLzI1NS4wLHVucGFja19mbG9hdChlbmNvZGVkQ29sb3JbMV0pLzI1NS4wXFxuKTt9ZmxvYXQgdW5wYWNrX21peF92ZWMyKGNvbnN0IHZlYzIgcGFja2VkVmFsdWUsY29uc3QgZmxvYXQgdCkge3JldHVybiBtaXgocGFja2VkVmFsdWVbMF0scGFja2VkVmFsdWVbMV0sdCk7fXZlYzQgdW5wYWNrX21peF9jb2xvcihjb25zdCB2ZWM0IHBhY2tlZENvbG9ycyxjb25zdCBmbG9hdCB0KSB7dmVjNCBtaW5Db2xvcj1kZWNvZGVfY29sb3IodmVjMihwYWNrZWRDb2xvcnNbMF0scGFja2VkQ29sb3JzWzFdKSk7dmVjNCBtYXhDb2xvcj1kZWNvZGVfY29sb3IodmVjMihwYWNrZWRDb2xvcnNbMl0scGFja2VkQ29sb3JzWzNdKSk7cmV0dXJuIG1peChtaW5Db2xvcixtYXhDb2xvcix0KTt9dmVjMiBnZXRfcGF0dGVybl9wb3MoY29uc3QgdmVjMiBwaXhlbF9jb29yZF91cHBlcixjb25zdCB2ZWMyIHBpeGVsX2Nvb3JkX2xvd2VyLGNvbnN0IHZlYzIgcGF0dGVybl9zaXplLGNvbnN0IGZsb2F0IHRpbGVfdW5pdHNfdG9fcGl4ZWxzLGNvbnN0IHZlYzIgcG9zKSB7dmVjMiBvZmZzZXQ9bW9kKG1vZChtb2QocGl4ZWxfY29vcmRfdXBwZXIscGF0dGVybl9zaXplKSoyNTYuMCxwYXR0ZXJuX3NpemUpKjI1Ni4wK3BpeGVsX2Nvb3JkX2xvd2VyLHBhdHRlcm5fc2l6ZSk7cmV0dXJuICh0aWxlX3VuaXRzX3RvX3BpeGVscypwb3Mrb2Zmc2V0KS9wYXR0ZXJuX3NpemU7fVwiKSxcbiAgICAgICAgV2UgPSBnaShcInVuaWZvcm0gdmVjNCB1X2NvbG9yO3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O3ZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3I9dV9jb2xvcip1X29wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO31cIiksXG4gICAgICAgIFhlID0gZ2koXCJ1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2E7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9hO3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYjt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2I7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfbWl4O3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dm9pZCBtYWluKCkge3ZlYzIgaW1hZ2Vjb29yZD1tb2Qodl9wb3NfYSwxLjApO3ZlYzIgcG9zPW1peCh1X3BhdHRlcm5fdGxfYS91X3RleHNpemUsdV9wYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHVfcGF0dGVybl90bF9iL3VfdGV4c2l6ZSx1X3BhdHRlcm5fYnJfYi91X3RleHNpemUsaW1hZ2Vjb29yZF9iKTt2ZWM0IGNvbG9yMj10ZXh0dXJlMkQodV9pbWFnZSxwb3MyKTtnbF9GcmFnQ29sb3I9bWl4KGNvbG9yMSxjb2xvcjIsdV9taXgpKnVfb3BhY2l0eTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9hO3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9iO3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX3VwcGVyO3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX2xvd2VyO3VuaWZvcm0gZmxvYXQgdV9zY2FsZV9hO3VuaWZvcm0gZmxvYXQgdV9zY2FsZV9iO3VuaWZvcm0gZmxvYXQgdV90aWxlX3VuaXRzX3RvX3BpeGVsczthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZfcG9zX2E9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix1X3NjYWxlX2EqdV9wYXR0ZXJuX3NpemVfYSx1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzLGFfcG9zKTt2X3Bvc19iPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsdV9zY2FsZV9iKnVfcGF0dGVybl9zaXplX2IsdV90aWxlX3VuaXRzX3RvX3BpeGVscyxhX3Bvcyk7fVwiKSxcbiAgICAgICAgSGUgPSBnaShcInZhcnlpbmcgdmVjMyB2X2RhdGE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgc3Ryb2tlX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHN0cm9rZV93aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBzdHJva2Vfb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IHN0cm9rZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgc3Ryb2tlX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBzdHJva2Vfb3BhY2l0eVxcbnZlYzIgZXh0cnVkZT12X2RhdGEueHk7ZmxvYXQgZXh0cnVkZV9sZW5ndGg9bGVuZ3RoKGV4dHJ1ZGUpO2xvd3AgZmxvYXQgYW50aWFsaWFzYmx1cj12X2RhdGEuejtmbG9hdCBhbnRpYWxpYXNlZF9ibHVyPS1tYXgoYmx1cixhbnRpYWxpYXNibHVyKTtmbG9hdCBvcGFjaXR5X3Q9c21vb3Roc3RlcCgwLjAsYW50aWFsaWFzZWRfYmx1cixleHRydWRlX2xlbmd0aC0xLjApO2Zsb2F0IGNvbG9yX3Q9c3Ryb2tlX3dpZHRoIDwgMC4wMSA/IDAuMCA6IHNtb290aHN0ZXAoYW50aWFsaWFzZWRfYmx1ciwwLjAsZXh0cnVkZV9sZW5ndGgtcmFkaXVzLyhyYWRpdXMrc3Ryb2tlX3dpZHRoKSk7Z2xfRnJhZ0NvbG9yPW9wYWNpdHlfdCptaXgoY29sb3Iqb3BhY2l0eSxzdHJva2VfY29sb3Iqc3Ryb2tlX29wYWNpdHksY29sb3JfdCk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIGJvb2wgdV9zY2FsZV93aXRoX21hcDt1bmlmb3JtIGJvb2wgdV9waXRjaF93aXRoX21hcDt1bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO3VuaWZvcm0gbG93cCBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzMgdl9kYXRhO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IHN0cm9rZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBzdHJva2Vfd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgc3Ryb2tlX29wYWNpdHlcXG52b2lkIG1haW4odm9pZCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgc3Ryb2tlX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBzdHJva2Vfd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHN0cm9rZV9vcGFjaXR5XFxudmVjMiBleHRydWRlPXZlYzIobW9kKGFfcG9zLDIuMCkqMi4wLTEuMCk7dmVjMiBjaXJjbGVfY2VudGVyPWZsb29yKGFfcG9zKjAuNSk7aWYgKHVfcGl0Y2hfd2l0aF9tYXApIHt2ZWMyIGNvcm5lcl9wb3NpdGlvbj1jaXJjbGVfY2VudGVyO2lmICh1X3NjYWxlX3dpdGhfbWFwKSB7Y29ybmVyX3Bvc2l0aW9uKz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGU7fSBlbHNlIHt2ZWM0IHByb2plY3RlZF9jZW50ZXI9dV9tYXRyaXgqdmVjNChjaXJjbGVfY2VudGVyLDAsMSk7Y29ybmVyX3Bvc2l0aW9uKz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGUqKHByb2plY3RlZF9jZW50ZXIudy91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UpO31nbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGNvcm5lcl9wb3NpdGlvbiwwLDEpO30gZWxzZSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChjaXJjbGVfY2VudGVyLDAsMSk7aWYgKHVfc2NhbGVfd2l0aF9tYXApIHtnbF9Qb3NpdGlvbi54eSs9ZXh0cnVkZSoocmFkaXVzK3N0cm9rZV93aWR0aCkqdV9leHRydWRlX3NjYWxlKnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt9IGVsc2Uge2dsX1Bvc2l0aW9uLnh5Kz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGUqZ2xfUG9zaXRpb24udzt9fWxvd3AgZmxvYXQgYW50aWFsaWFzYmx1cj0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vKHJhZGl1cytzdHJva2Vfd2lkdGgpO3ZfZGF0YT12ZWMzKGV4dHJ1ZGUueCxleHRydWRlLnksYW50aWFsaWFzYmx1cik7fVwiKSxcbiAgICAgICAgS2UgPSBnaShcInZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3I9dmVjNCgxLjApO31cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt9XCIpLFxuICAgICAgICBZZSA9IGdpKFwidW5pZm9ybSBoaWdocCBmbG9hdCB1X2ludGVuc2l0eTt2YXJ5aW5nIHZlYzIgdl9leHRydWRlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuI2RlZmluZSBHQVVTU19DT0VGIDAuMzk4OTQyMjgwNDAxNDMyN1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCBmbG9hdCB3ZWlnaHRcXG5mbG9hdCBkPS0wLjUqMy4wKjMuMCpkb3Qodl9leHRydWRlLHZfZXh0cnVkZSk7ZmxvYXQgdmFsPXdlaWdodCp1X2ludGVuc2l0eSpHQVVTU19DT0VGKmV4cChkKTtnbF9GcmFnQ29sb3I9dmVjNCh2YWwsMS4wLDEuMCwxLjApO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSBmbG9hdCB1X2V4dHJ1ZGVfc2NhbGU7dW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7dW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9leHRydWRlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbmNvbnN0IGhpZ2hwIGZsb2F0IFpFUk89MS4wLzI1NS4wLzE2LjA7XFxuI2RlZmluZSBHQVVTU19DT0VGIDAuMzk4OTQyMjgwNDAxNDMyN1xcbnZvaWQgbWFpbih2b2lkKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG52ZWMyIHVuc2NhbGVkX2V4dHJ1ZGU9dmVjMihtb2QoYV9wb3MsMi4wKSoyLjAtMS4wKTtmbG9hdCBTPXNxcnQoLTIuMCpsb2coWkVSTy93ZWlnaHQvdV9pbnRlbnNpdHkvR0FVU1NfQ09FRikpLzMuMDt2X2V4dHJ1ZGU9Uyp1bnNjYWxlZF9leHRydWRlO3ZlYzIgZXh0cnVkZT12X2V4dHJ1ZGUqcmFkaXVzKnVfZXh0cnVkZV9zY2FsZTt2ZWM0IHBvcz12ZWM0KGZsb29yKGFfcG9zKjAuNSkrZXh0cnVkZSwwLDEpO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnBvczt9XCIpLFxuICAgICAgICBKZSA9IGdpKFwidW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTt1bmlmb3JtIHNhbXBsZXIyRCB1X2NvbG9yX3JhbXA7dW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7dmFyeWluZyB2ZWMyIHZfcG9zO3ZvaWQgbWFpbigpIHtmbG9hdCB0PXRleHR1cmUyRCh1X2ltYWdlLHZfcG9zKS5yO3ZlYzQgY29sb3I9dGV4dHVyZTJEKHVfY29sb3JfcmFtcCx2ZWMyKHQsMC41KSk7Z2xfRnJhZ0NvbG9yPWNvbG9yKnVfb3BhY2l0eTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMC4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3dvcmxkO2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3Bvcyp1X3dvcmxkLDAsMSk7dl9wb3MueD1hX3Bvcy54O3ZfcG9zLnk9MS4wLWFfcG9zLnk7fVwiKSxcbiAgICAgICAgUWUgPSBnaShcInZhcnlpbmcgZmxvYXQgdl9wbGFjZWQ7dmFyeWluZyBmbG9hdCB2X25vdFVzZWQ7dm9pZCBtYWluKCkge2Zsb2F0IGFscGhhPTAuNTtnbF9GcmFnQ29sb3I9dmVjNCgxLjAsMC4wLDAuMCwxLjApKmFscGhhO2lmICh2X3BsYWNlZCA+IDAuNSkge2dsX0ZyYWdDb2xvcj12ZWM0KDAuMCwwLjAsMS4wLDAuNSkqYWxwaGE7fWlmICh2X25vdFVzZWQgPiAwLjUpIHtnbF9GcmFnQ29sb3IqPS4xO319XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV9hbmNob3JfcG9zO2F0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTthdHRyaWJ1dGUgdmVjMiBhX3BsYWNlZDthdHRyaWJ1dGUgdmVjMiBhX3NoaWZ0O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO3VuaWZvcm0gZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdl9wbGFjZWQ7dmFyeWluZyBmbG9hdCB2X25vdFVzZWQ7dm9pZCBtYWluKCkge3ZlYzQgcHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX2FuY2hvcl9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgY29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqKHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlKSwwLjAsNC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAuMCwxLjApO2dsX1Bvc2l0aW9uLnh5Kz0oYV9leHRydWRlK2Ffc2hpZnQpKnVfZXh0cnVkZV9zY2FsZSpnbF9Qb3NpdGlvbi53KmNvbGxpc2lvbl9wZXJzcGVjdGl2ZV9yYXRpbzt2X3BsYWNlZD1hX3BsYWNlZC54O3Zfbm90VXNlZD1hX3BsYWNlZC55O31cIiksXG4gICAgICAgICRlID0gZ2koXCJ2YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO3ZhcnlpbmcgdmVjMiB2X2V4dHJ1ZGU7dmFyeWluZyBmbG9hdCB2X3BlcnNwZWN0aXZlX3JhdGlvO3ZhcnlpbmcgZmxvYXQgdl9jb2xsaXNpb247dm9pZCBtYWluKCkge2Zsb2F0IGFscGhhPTAuNSptaW4odl9wZXJzcGVjdGl2ZV9yYXRpbywxLjApO2Zsb2F0IHN0cm9rZV9yYWRpdXM9MC45Km1heCh2X3BlcnNwZWN0aXZlX3JhdGlvLDEuMCk7ZmxvYXQgZGlzdGFuY2VfdG9fY2VudGVyPWxlbmd0aCh2X2V4dHJ1ZGUpO2Zsb2F0IGRpc3RhbmNlX3RvX2VkZ2U9YWJzKGRpc3RhbmNlX3RvX2NlbnRlci12X3JhZGl1cyk7ZmxvYXQgb3BhY2l0eV90PXNtb290aHN0ZXAoLXN0cm9rZV9yYWRpdXMsMC4wLC1kaXN0YW5jZV90b19lZGdlKTt2ZWM0IGNvbG9yPW1peCh2ZWM0KDAuMCwwLjAsMS4wLDAuNSksdmVjNCgxLjAsMC4wLDAuMCwxLjApLHZfY29sbGlzaW9uKTtnbF9GcmFnQ29sb3I9Y29sb3IqYWxwaGEqb3BhY2l0eV90O31cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXM7YXR0cmlidXRlIHZlYzIgYV9mbGFnczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfaW52X21hdHJpeDt1bmlmb3JtIHZlYzIgdV92aWV3cG9ydF9zaXplO3VuaWZvcm0gZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdl9yYWRpdXM7dmFyeWluZyB2ZWMyIHZfZXh0cnVkZTt2YXJ5aW5nIGZsb2F0IHZfcGVyc3BlY3RpdmVfcmF0aW87dmFyeWluZyBmbG9hdCB2X2NvbGxpc2lvbjt2ZWMzIHRvVGlsZVBvc2l0aW9uKHZlYzIgc2NyZWVuUG9zKSB7dmVjNCByYXlTdGFydD11X2ludl9tYXRyaXgqdmVjNChzY3JlZW5Qb3MsLTEuMCwxLjApO3ZlYzQgcmF5RW5kICA9dV9pbnZfbWF0cml4KnZlYzQoc2NyZWVuUG9zLCAxLjAsMS4wKTtyYXlTdGFydC54eXovPXJheVN0YXJ0Lnc7cmF5RW5kLnh5eiAgLz1yYXlFbmQudztoaWdocCBmbG9hdCB0PSgwLjAtcmF5U3RhcnQueikvKHJheUVuZC56LXJheVN0YXJ0LnopO3JldHVybiBtaXgocmF5U3RhcnQueHl6LHJheUVuZC54eXosdCk7fXZvaWQgbWFpbigpIHt2ZWMyIHF1YWRDZW50ZXJQb3M9YV9wb3M7ZmxvYXQgcmFkaXVzPWFfcmFkaXVzO2Zsb2F0IGNvbGxpc2lvbj1hX2ZsYWdzLng7ZmxvYXQgdmVydGV4SWR4PWFfZmxhZ3MueTt2ZWMyIHF1YWRWZXJ0ZXhPZmZzZXQ9dmVjMihtaXgoLTEuMCwxLjAsZmxvYXQodmVydGV4SWR4ID49Mi4wKSksbWl4KC0xLjAsMS4wLGZsb2F0KHZlcnRleElkeCA+PTEuMCAmJiB2ZXJ0ZXhJZHggPD0yLjApKSk7dmVjMiBxdWFkVmVydGV4RXh0ZW50PXF1YWRWZXJ0ZXhPZmZzZXQqcmFkaXVzO3ZlYzMgdGlsZVBvcz10b1RpbGVQb3NpdGlvbihxdWFkQ2VudGVyUG9zKTt2ZWM0IGNsaXBQb3M9dV9tYXRyaXgqdmVjNCh0aWxlUG9zLDEuMCk7aGlnaHAgZmxvYXQgY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZT1jbGlwUG9zLnc7aGlnaHAgZmxvYXQgY29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqKHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlKSwwLjAsNC4wKTtmbG9hdCBwYWRkaW5nX2ZhY3Rvcj0xLjI7dl9yYWRpdXM9cmFkaXVzO3ZfZXh0cnVkZT1xdWFkVmVydGV4RXh0ZW50KnBhZGRpbmdfZmFjdG9yO3ZfcGVyc3BlY3RpdmVfcmF0aW89Y29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvO3ZfY29sbGlzaW9uPWNvbGxpc2lvbjtnbF9Qb3NpdGlvbj12ZWM0KGNsaXBQb3MueHl6L2NsaXBQb3MudywxLjApK3ZlYzQocXVhZFZlcnRleEV4dGVudCpwYWRkaW5nX2ZhY3Rvci91X3ZpZXdwb3J0X3NpemUqMi4wLDAuMCwwLjApO31cIiksXG4gICAgICAgIHRpID0gZ2koXCJ1bmlmb3JtIGhpZ2hwIHZlYzQgdV9jb2xvcjt1bmlmb3JtIHNhbXBsZXIyRCB1X292ZXJsYXk7dmFyeWluZyB2ZWMyIHZfdXY7dm9pZCBtYWluKCkge3ZlYzQgb3ZlcmxheV9jb2xvcj10ZXh0dXJlMkQodV9vdmVybGF5LHZfdXYpO2dsX0ZyYWdDb2xvcj1taXgodV9jb2xvcixvdmVybGF5X2NvbG9yLG92ZXJsYXlfY29sb3IuYSk7fVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO3ZhcnlpbmcgdmVjMiB2X3V2O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIGZsb2F0IHVfb3ZlcmxheV9zY2FsZTt2b2lkIG1haW4oKSB7dl91dj1hX3Bvcy84MTkyLjA7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3Bvcyp1X292ZXJsYXlfc2NhbGUsMCwxKTt9XCIpLFxuICAgICAgICBlaSA9IGdpKFwiI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX0ZyYWdDb2xvcj1jb2xvcipvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt9XCIpLFxuICAgICAgICBpaSA9IGdpKFwidmFyeWluZyB2ZWMyIHZfcG9zO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBvdXRsaW5lX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBvdXRsaW5lX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuZmxvYXQgZGlzdD1sZW5ndGgodl9wb3MtZ2xfRnJhZ0Nvb3JkLnh5KTtmbG9hdCBhbHBoYT0xLjAtc21vb3Roc3RlcCgwLjAsMS4wLGRpc3QpO2dsX0ZyYWdDb2xvcj1vdXRsaW5lX2NvbG9yKihhbHBoYSpvcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3dvcmxkO3ZhcnlpbmcgdmVjMiB2X3BvcztcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgb3V0bGluZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgb3V0bGluZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvcz0oZ2xfUG9zaXRpb24ueHkvZ2xfUG9zaXRpb24udysxLjApLzIuMCp1X3dvcmxkO31cIiksXG4gICAgICAgIG9pID0gZ2koXCJ1bmlmb3JtIHZlYzIgdV90ZXhzaXplO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dW5pZm9ybSBmbG9hdCB1X2ZhZGU7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dmFyeWluZyB2ZWMyIHZfcG9zO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dzt2ZWMyIGltYWdlY29vcmQ9bW9kKHZfcG9zX2EsMS4wKTt2ZWMyIHBvcz1taXgocGF0dGVybl90bF9hL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHBhdHRlcm5fdGxfYi91X3RleHNpemUscGF0dGVybl9icl9iL3VfdGV4c2l6ZSxpbWFnZWNvb3JkX2IpO3ZlYzQgY29sb3IyPXRleHR1cmUyRCh1X2ltYWdlLHBvczIpO2Zsb2F0IGRpc3Q9bGVuZ3RoKHZfcG9zLWdsX0ZyYWdDb29yZC54eSk7ZmxvYXQgYWxwaGE9MS4wLXNtb290aHN0ZXAoMC4wLDEuMCxkaXN0KTtnbF9GcmFnQ29sb3I9bWl4KGNvbG9yMSxjb2xvcjIsdV9mYWRlKSphbHBoYSpvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSB2ZWMyIHVfd29ybGQ7dW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfdXBwZXI7dW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfbG93ZXI7dW5pZm9ybSB2ZWMzIHVfc2NhbGU7YXR0cmlidXRlIHZlYzIgYV9wb3M7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dmFyeWluZyB2ZWMyIHZfcG9zO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dztmbG9hdCB0aWxlUmF0aW89dV9zY2FsZS54O2Zsb2F0IGZyb21TY2FsZT11X3NjYWxlLnk7ZmxvYXQgdG9TY2FsZT11X3NjYWxlLno7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZlYzIgZGlzcGxheV9zaXplX2E9KHBhdHRlcm5fYnJfYS1wYXR0ZXJuX3RsX2EpL3BpeGVsX3JhdGlvX2Zyb207dmVjMiBkaXNwbGF5X3NpemVfYj0ocGF0dGVybl9icl9iLXBhdHRlcm5fdGxfYikvcGl4ZWxfcmF0aW9fdG87dl9wb3NfYT1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLGZyb21TY2FsZSpkaXNwbGF5X3NpemVfYSx0aWxlUmF0aW8sYV9wb3MpO3ZfcG9zX2I9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix0b1NjYWxlKmRpc3BsYXlfc2l6ZV9iLHRpbGVSYXRpbyxhX3Bvcyk7dl9wb3M9KGdsX1Bvc2l0aW9uLnh5L2dsX1Bvc2l0aW9uLncrMS4wKS8yLjAqdV93b3JsZDt9XCIpLFxuICAgICAgICByaSA9IGdpKFwidW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfZmFkZTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvc19hO3ZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dzt2ZWMyIGltYWdlY29vcmQ9bW9kKHZfcG9zX2EsMS4wKTt2ZWMyIHBvcz1taXgocGF0dGVybl90bF9hL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHBhdHRlcm5fdGxfYi91X3RleHNpemUscGF0dGVybl9icl9iL3VfdGV4c2l6ZSxpbWFnZWNvb3JkX2IpO3ZlYzQgY29sb3IyPXRleHR1cmUyRCh1X2ltYWdlLHBvczIpO2dsX0ZyYWdDb2xvcj1taXgoY29sb3IxLGNvbG9yMix1X2ZhZGUpKm9wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF91cHBlcjt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF9sb3dlcjt1bmlmb3JtIHZlYzMgdV9zY2FsZTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVpvb21SYXRpbz11X3NjYWxlLng7ZmxvYXQgZnJvbVNjYWxlPXVfc2NhbGUueTtmbG9hdCB0b1NjYWxlPXVfc2NhbGUuejt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvc19hPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsZnJvbVNjYWxlKmRpc3BsYXlfc2l6ZV9hLHRpbGVab29tUmF0aW8sYV9wb3MpO3ZfcG9zX2I9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix0b1NjYWxlKmRpc3BsYXlfc2l6ZV9iLHRpbGVab29tUmF0aW8sYV9wb3MpO31cIiksXG4gICAgICAgIGFpID0gZ2koXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjt2b2lkIG1haW4oKSB7Z2xfRnJhZ0NvbG9yPXZfY29sb3I7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzMgdV9saWdodGNvbG9yO3VuaWZvcm0gbG93cCB2ZWMzIHVfbGlnaHRwb3M7dW5pZm9ybSBsb3dwIGZsb2F0IHVfbGlnaHRpbnRlbnNpdHk7dW5pZm9ybSBmbG9hdCB1X3ZlcnRpY2FsX2dyYWRpZW50O3VuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzQgYV9ub3JtYWxfZWQ7dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCBmbG9hdCBiYXNlXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgY29sb3JcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIGZsb2F0IGhlaWdodFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG52ZWMzIG5vcm1hbD1hX25vcm1hbF9lZC54eXo7YmFzZT1tYXgoMC4wLGJhc2UpO2hlaWdodD1tYXgoMC4wLGhlaWdodCk7ZmxvYXQgdD1tb2Qobm9ybWFsLngsMi4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLHQgPiAwLjAgPyBoZWlnaHQgOiBiYXNlLDEpO2Zsb2F0IGNvbG9ydmFsdWU9Y29sb3IuciowLjIxMjYrY29sb3IuZyowLjcxNTIrY29sb3IuYiowLjA3MjI7dl9jb2xvcj12ZWM0KDAuMCwwLjAsMC4wLDEuMCk7dmVjNCBhbWJpZW50bGlnaHQ9dmVjNCgwLjAzLDAuMDMsMC4wMywxLjApO2NvbG9yKz1hbWJpZW50bGlnaHQ7ZmxvYXQgZGlyZWN0aW9uYWw9Y2xhbXAoZG90KG5vcm1hbC8xNjM4NC4wLHVfbGlnaHRwb3MpLDAuMCwxLjApO2RpcmVjdGlvbmFsPW1peCgoMS4wLXVfbGlnaHRpbnRlbnNpdHkpLG1heCgoMS4wLWNvbG9ydmFsdWUrdV9saWdodGludGVuc2l0eSksMS4wKSxkaXJlY3Rpb25hbCk7aWYgKG5vcm1hbC55ICE9MC4wKSB7ZGlyZWN0aW9uYWwqPSgoMS4wLXVfdmVydGljYWxfZ3JhZGllbnQpKyh1X3ZlcnRpY2FsX2dyYWRpZW50KmNsYW1wKCh0K2Jhc2UpKnBvdyhoZWlnaHQvMTUwLjAsMC41KSxtaXgoMC43LDAuOTgsMS4wLXVfbGlnaHRpbnRlbnNpdHkpLDEuMCkpKTt9dl9jb2xvci5yKz1jbGFtcChjb2xvci5yKmRpcmVjdGlvbmFsKnVfbGlnaHRjb2xvci5yLG1peCgwLjAsMC4zLDEuMC11X2xpZ2h0Y29sb3IuciksMS4wKTt2X2NvbG9yLmcrPWNsYW1wKGNvbG9yLmcqZGlyZWN0aW9uYWwqdV9saWdodGNvbG9yLmcsbWl4KDAuMCwwLjMsMS4wLXVfbGlnaHRjb2xvci5nKSwxLjApO3ZfY29sb3IuYis9Y2xhbXAoY29sb3IuYipkaXJlY3Rpb25hbCp1X2xpZ2h0Y29sb3IuYixtaXgoMC4wLDAuMywxLjAtdV9saWdodGNvbG9yLmIpLDEuMCk7dl9jb2xvcio9dV9vcGFjaXR5O31cIiksXG4gICAgICAgIG5pID0gZ2koXCJ1bmlmb3JtIHZlYzIgdV90ZXhzaXplO3VuaWZvcm0gZmxvYXQgdV9mYWRlO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dmFyeWluZyB2ZWM0IHZfbGlnaHRpbmc7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJhc2VcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGVpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGVpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZlYzIgcGF0dGVybl90bF9hPXBhdHRlcm5fZnJvbS54eTt2ZWMyIHBhdHRlcm5fYnJfYT1wYXR0ZXJuX2Zyb20uenc7dmVjMiBwYXR0ZXJuX3RsX2I9cGF0dGVybl90by54eTt2ZWMyIHBhdHRlcm5fYnJfYj1wYXR0ZXJuX3RvLnp3O3ZlYzIgaW1hZ2Vjb29yZD1tb2Qodl9wb3NfYSwxLjApO3ZlYzIgcG9zPW1peChwYXR0ZXJuX3RsX2EvdV90ZXhzaXplLHBhdHRlcm5fYnJfYS91X3RleHNpemUsaW1hZ2Vjb29yZCk7dmVjNCBjb2xvcjE9dGV4dHVyZTJEKHVfaW1hZ2UscG9zKTt2ZWMyIGltYWdlY29vcmRfYj1tb2Qodl9wb3NfYiwxLjApO3ZlYzIgcG9zMj1taXgocGF0dGVybl90bF9iL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2IvdV90ZXhzaXplLGltYWdlY29vcmRfYik7dmVjNCBjb2xvcjI9dGV4dHVyZTJEKHVfaW1hZ2UscG9zMik7dmVjNCBtaXhlZENvbG9yPW1peChjb2xvcjEsY29sb3IyLHVfZmFkZSk7Z2xfRnJhZ0NvbG9yPW1peGVkQ29sb3Iqdl9saWdodGluZztcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX3VwcGVyO3VuaWZvcm0gdmVjMiB1X3BpeGVsX2Nvb3JkX2xvd2VyO3VuaWZvcm0gZmxvYXQgdV9oZWlnaHRfZmFjdG9yO3VuaWZvcm0gdmVjMyB1X3NjYWxlO3VuaWZvcm0gZmxvYXQgdV92ZXJ0aWNhbF9ncmFkaWVudDt1bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O3VuaWZvcm0gdmVjMyB1X2xpZ2h0Y29sb3I7dW5pZm9ybSBsb3dwIHZlYzMgdV9saWdodHBvczt1bmlmb3JtIGxvd3AgZmxvYXQgdV9saWdodGludGVuc2l0eTthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjNCBhX25vcm1hbF9lZDt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBiYXNlXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVJhdGlvPXVfc2NhbGUueDtmbG9hdCBmcm9tU2NhbGU9dV9zY2FsZS55O2Zsb2F0IHRvU2NhbGU9dV9zY2FsZS56O3ZlYzMgbm9ybWFsPWFfbm9ybWFsX2VkLnh5ejtmbG9hdCBlZGdlZGlzdGFuY2U9YV9ub3JtYWxfZWQudzt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO2Jhc2U9bWF4KDAuMCxiYXNlKTtoZWlnaHQ9bWF4KDAuMCxoZWlnaHQpO2Zsb2F0IHQ9bW9kKG5vcm1hbC54LDIuMCk7ZmxvYXQgej10ID4gMC4wID8gaGVpZ2h0IDogYmFzZTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLHosMSk7dmVjMiBwb3M9bm9ybWFsLng9PTEuMCAmJiBub3JtYWwueT09MC4wICYmIG5vcm1hbC56PT0xNjM4NC4wXFxuPyBhX3Bvc1xcbjogdmVjMihlZGdlZGlzdGFuY2Useip1X2hlaWdodF9mYWN0b3IpO3ZfcG9zX2E9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcixmcm9tU2NhbGUqZGlzcGxheV9zaXplX2EsdGlsZVJhdGlvLHBvcyk7dl9wb3NfYj1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLHRvU2NhbGUqZGlzcGxheV9zaXplX2IsdGlsZVJhdGlvLHBvcyk7dl9saWdodGluZz12ZWM0KDAuMCwwLjAsMC4wLDEuMCk7ZmxvYXQgZGlyZWN0aW9uYWw9Y2xhbXAoZG90KG5vcm1hbC8xNjM4My4wLHVfbGlnaHRwb3MpLDAuMCwxLjApO2RpcmVjdGlvbmFsPW1peCgoMS4wLXVfbGlnaHRpbnRlbnNpdHkpLG1heCgoMC41K3VfbGlnaHRpbnRlbnNpdHkpLDEuMCksZGlyZWN0aW9uYWwpO2lmIChub3JtYWwueSAhPTAuMCkge2RpcmVjdGlvbmFsKj0oKDEuMC11X3ZlcnRpY2FsX2dyYWRpZW50KSsodV92ZXJ0aWNhbF9ncmFkaWVudCpjbGFtcCgodCtiYXNlKSpwb3coaGVpZ2h0LzE1MC4wLDAuNSksbWl4KDAuNywwLjk4LDEuMC11X2xpZ2h0aW50ZW5zaXR5KSwxLjApKSk7fXZfbGlnaHRpbmcucmdiKz1jbGFtcChkaXJlY3Rpb25hbCp1X2xpZ2h0Y29sb3IsbWl4KHZlYzMoMC4wKSx2ZWMzKDAuMyksMS4wLXVfbGlnaHRjb2xvciksdmVjMygxLjApKTt2X2xpZ2h0aW5nKj11X29wYWNpdHk7fVwiKSxcbiAgICAgICAgc2kgPSBnaShcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvczt1bmlmb3JtIHZlYzIgdV9kaW1lbnNpb247dW5pZm9ybSBmbG9hdCB1X3pvb207dW5pZm9ybSB2ZWM0IHVfdW5wYWNrO2Zsb2F0IGdldEVsZXZhdGlvbih2ZWMyIGNvb3JkLGZsb2F0IGJpYXMpIHt2ZWM0IGRhdGE9dGV4dHVyZTJEKHVfaW1hZ2UsY29vcmQpKjI1NS4wO2RhdGEuYT0tMS4wO3JldHVybiBkb3QoZGF0YSx1X3VucGFjaykvNC4wO312b2lkIG1haW4oKSB7dmVjMiBlcHNpbG9uPTEuMC91X2RpbWVuc2lvbjtmbG9hdCBhPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKC1lcHNpbG9uLngsLWVwc2lsb24ueSksMC4wKTtmbG9hdCBiPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKDAsLWVwc2lsb24ueSksMC4wKTtmbG9hdCBjPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKGVwc2lsb24ueCwtZXBzaWxvbi55KSwwLjApO2Zsb2F0IGQ9Z2V0RWxldmF0aW9uKHZfcG9zK3ZlYzIoLWVwc2lsb24ueCwwKSwwLjApO2Zsb2F0IGU9Z2V0RWxldmF0aW9uKHZfcG9zLDAuMCk7ZmxvYXQgZj1nZXRFbGV2YXRpb24odl9wb3MrdmVjMihlcHNpbG9uLngsMCksMC4wKTtmbG9hdCBnPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKC1lcHNpbG9uLngsZXBzaWxvbi55KSwwLjApO2Zsb2F0IGg9Z2V0RWxldmF0aW9uKHZfcG9zK3ZlYzIoMCxlcHNpbG9uLnkpLDAuMCk7ZmxvYXQgaT1nZXRFbGV2YXRpb24odl9wb3MrdmVjMihlcHNpbG9uLngsZXBzaWxvbi55KSwwLjApO2Zsb2F0IGV4YWdnZXJhdGlvbkZhY3Rvcj11X3pvb20gPCAyLjAgPyAwLjQgOiB1X3pvb20gPCA0LjUgPyAwLjM1IDogMC4zO2Zsb2F0IGV4YWdnZXJhdGlvbj11X3pvb20gPCAxNS4wID8gKHVfem9vbS0xNS4wKSpleGFnZ2VyYXRpb25GYWN0b3IgOiAwLjA7dmVjMiBkZXJpdj12ZWMyKChjK2YrZitpKS0oYStkK2QrZyksKGcraCtoK2kpLShhK2IrYitjKSkvcG93KDIuMCxleGFnZ2VyYXRpb24rKDE5LjI1NjItdV96b29tKSk7Z2xfRnJhZ0NvbG9yPWNsYW1wKHZlYzQoZGVyaXYueC8yLjArMC41LGRlcml2LnkvMi4wKzAuNSwxLjAsMS4wKSwwLjAsMS4wKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X2RpbWVuc2lvbjthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2hpZ2hwIHZlYzIgZXBzaWxvbj0xLjAvdV9kaW1lbnNpb247ZmxvYXQgc2NhbGU9KHVfZGltZW5zaW9uLngtMi4wKS91X2RpbWVuc2lvbi54O3ZfcG9zPShhX3RleHR1cmVfcG9zLzgxOTIuMCkqc2NhbGUrZXBzaWxvbjt9XCIpLFxuICAgICAgICBsaSA9IGdpKFwidW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTt2YXJ5aW5nIHZlYzIgdl9wb3M7dW5pZm9ybSB2ZWMyIHVfbGF0cmFuZ2U7dW5pZm9ybSB2ZWMyIHVfbGlnaHQ7dW5pZm9ybSB2ZWM0IHVfc2hhZG93O3VuaWZvcm0gdmVjNCB1X2hpZ2hsaWdodDt1bmlmb3JtIHZlYzQgdV9hY2NlbnQ7XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5M1xcbnZvaWQgbWFpbigpIHt2ZWM0IHBpeGVsPXRleHR1cmUyRCh1X2ltYWdlLHZfcG9zKTt2ZWMyIGRlcml2PSgocGl4ZWwucmcqMi4wKS0xLjApO2Zsb2F0IHNjYWxlRmFjdG9yPWNvcyhyYWRpYW5zKCh1X2xhdHJhbmdlWzBdLXVfbGF0cmFuZ2VbMV0pKigxLjAtdl9wb3MueSkrdV9sYXRyYW5nZVsxXSkpO2Zsb2F0IHNsb3BlPWF0YW4oMS4yNSpsZW5ndGgoZGVyaXYpL3NjYWxlRmFjdG9yKTtmbG9hdCBhc3BlY3Q9ZGVyaXYueCAhPTAuMCA/IGF0YW4oZGVyaXYueSwtZGVyaXYueCkgOiBQSS8yLjAqKGRlcml2LnkgPiAwLjAgPyAxLjAgOi0xLjApO2Zsb2F0IGludGVuc2l0eT11X2xpZ2h0Lng7ZmxvYXQgYXppbXV0aD11X2xpZ2h0LnkrUEk7ZmxvYXQgYmFzZT0xLjg3NS1pbnRlbnNpdHkqMS43NTtmbG9hdCBtYXhWYWx1ZT0wLjUqUEk7ZmxvYXQgc2NhbGVkU2xvcGU9aW50ZW5zaXR5ICE9MC41ID8gKChwb3coYmFzZSxzbG9wZSktMS4wKS8ocG93KGJhc2UsbWF4VmFsdWUpLTEuMCkpKm1heFZhbHVlIDogc2xvcGU7ZmxvYXQgYWNjZW50PWNvcyhzY2FsZWRTbG9wZSk7dmVjNCBhY2NlbnRfY29sb3I9KDEuMC1hY2NlbnQpKnVfYWNjZW50KmNsYW1wKGludGVuc2l0eSoyLjAsMC4wLDEuMCk7ZmxvYXQgc2hhZGU9YWJzKG1vZCgoYXNwZWN0K2F6aW11dGgpL1BJKzAuNSwyLjApLTEuMCk7dmVjNCBzaGFkZV9jb2xvcj1taXgodV9zaGFkb3csdV9oaWdobGlnaHQsc2hhZGUpKnNpbihzY2FsZWRTbG9wZSkqY2xhbXAoaW50ZW5zaXR5KjIuMCwwLjAsMS4wKTtnbF9GcmFnQ29sb3I9YWNjZW50X2NvbG9yKigxLjAtc2hhZGVfY29sb3IuYSkrc2hhZGVfY29sb3I7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZfcG9zPWFfdGV4dHVyZV9wb3MvODE5Mi4wO31cIiksXG4gICAgICAgIGNpID0gZ2koXCJ1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWMyIHZfd2lkdGgyO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuZmxvYXQgZGlzdD1sZW5ndGgodl9ub3JtYWwpKnZfd2lkdGgyLnM7ZmxvYXQgYmx1cjI9KGJsdXIrMS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvKSp2X2dhbW1hX3NjYWxlO2Zsb2F0IGFscGhhPWNsYW1wKG1pbihkaXN0LSh2X3dpZHRoMi50LWJsdXIyKSx2X3dpZHRoMi5zLWRpc3QpL2JsdXIyLDAuMCwxLjApO2dsX0ZyYWdDb2xvcj1jb2xvciooYWxwaGEqb3BhY2l0eSk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcIlxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc19ub3JtYWw7YXR0cmlidXRlIHZlYzQgYV9kYXRhO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIHZlYzIgdV91bml0c190b19waXhlbHM7dW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO3ZhcnlpbmcgaGlnaHAgZmxvYXQgdl9saW5lc29mYXI7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG5mbG9hdCBBTlRJQUxJQVNJTkc9MS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvLzIuMDt2ZWMyIGFfZXh0cnVkZT1hX2RhdGEueHktMTI4LjA7ZmxvYXQgYV9kaXJlY3Rpb249bW9kKGFfZGF0YS56LDQuMCktMS4wO3ZfbGluZXNvZmFyPShmbG9vcihhX2RhdGEuei80LjApK2FfZGF0YS53KjY0LjApKjIuMDt2ZWMyIHBvcz1mbG9vcihhX3Bvc19ub3JtYWwqMC41KTttZWRpdW1wIHZlYzIgbm9ybWFsPWFfcG9zX25vcm1hbC0yLjAqcG9zO25vcm1hbC55PW5vcm1hbC55KjIuMC0xLjA7dl9ub3JtYWw9bm9ybWFsO2dhcHdpZHRoPWdhcHdpZHRoLzIuMDtmbG9hdCBoYWxmd2lkdGg9d2lkdGgvMi4wO29mZnNldD0tMS4wKm9mZnNldDtmbG9hdCBpbnNldD1nYXB3aWR0aCsoZ2Fwd2lkdGggPiAwLjAgPyBBTlRJQUxJQVNJTkcgOiAwLjApO2Zsb2F0IG91dHNldD1nYXB3aWR0aCtoYWxmd2lkdGgqKGdhcHdpZHRoID4gMC4wID8gMi4wIDogMS4wKSsoaGFsZndpZHRoPT0wLjAgPyAwLjAgOiBBTlRJQUxJQVNJTkcpO21lZGl1bXAgdmVjMiBkaXN0PW91dHNldCphX2V4dHJ1ZGUqc2NhbGU7bWVkaXVtcCBmbG9hdCB1PTAuNSphX2RpcmVjdGlvbjttZWRpdW1wIGZsb2F0IHQ9MS4wLWFicyh1KTttZWRpdW1wIHZlYzIgb2Zmc2V0Mj1vZmZzZXQqYV9leHRydWRlKnNjYWxlKm5vcm1hbC55Km1hdDIodCwtdSx1LHQpO3ZlYzQgcHJvamVjdGVkX2V4dHJ1ZGU9dV9tYXRyaXgqdmVjNChkaXN0L3VfcmF0aW8sMC4wLDAuMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChwb3Mrb2Zmc2V0Mi91X3JhdGlvLDAuMCwxLjApK3Byb2plY3RlZF9leHRydWRlO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmU9bGVuZ3RoKGRpc3QpO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU9bGVuZ3RoKHByb2plY3RlZF9leHRydWRlLnh5L2dsX1Bvc2l0aW9uLncqdV91bml0c190b19waXhlbHMpO3ZfZ2FtbWFfc2NhbGU9ZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZS9leHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlO3Zfd2lkdGgyPXZlYzIob3V0c2V0LGluc2V0KTt9XCIpLFxuICAgICAgICB1aSA9IGdpKFwidW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfd2lkdGgyO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCB2ZWMyIHZfdXY7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5mbG9hdCBkaXN0PWxlbmd0aCh2X25vcm1hbCkqdl93aWR0aDIucztmbG9hdCBibHVyMj0oYmx1cisxLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8pKnZfZ2FtbWFfc2NhbGU7ZmxvYXQgYWxwaGE9Y2xhbXAobWluKGRpc3QtKHZfd2lkdGgyLnQtYmx1cjIpLHZfd2lkdGgyLnMtZGlzdCkvYmx1cjIsMC4wLDEuMCk7dmVjNCBjb2xvcj10ZXh0dXJlMkQodV9pbWFnZSx2X3V2KTtnbF9GcmFnQ29sb3I9Y29sb3IqKGFscGhhKm9wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuYXR0cmlidXRlIHZlYzIgYV9wb3Nfbm9ybWFsO2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgZmxvYXQgYV91dl94O2F0dHJpYnV0ZSBmbG9hdCBhX3NwbGl0X2luZGV4O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfdW5pdHNfdG9fcGl4ZWxzO3VuaWZvcm0gZmxvYXQgdV9pbWFnZV9oZWlnaHQ7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCB2ZWMyIHZfdXY7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7aGlnaHAgZmxvYXQgdGV4ZWxfaGVpZ2h0PTEuMC91X2ltYWdlX2hlaWdodDtoaWdocCBmbG9hdCBoYWxmX3RleGVsX2hlaWdodD0wLjUqdGV4ZWxfaGVpZ2h0O3ZfdXY9dmVjMihhX3V2X3gsYV9zcGxpdF9pbmRleCp0ZXhlbF9oZWlnaHQtaGFsZl90ZXhlbF9oZWlnaHQpO3ZlYzIgcG9zPWZsb29yKGFfcG9zX25vcm1hbCowLjUpO21lZGl1bXAgdmVjMiBub3JtYWw9YV9wb3Nfbm9ybWFsLTIuMCpwb3M7bm9ybWFsLnk9bm9ybWFsLnkqMi4wLTEuMDt2X25vcm1hbD1ub3JtYWw7Z2Fwd2lkdGg9Z2Fwd2lkdGgvMi4wO2Zsb2F0IGhhbGZ3aWR0aD13aWR0aC8yLjA7b2Zmc2V0PS0xLjAqb2Zmc2V0O2Zsb2F0IGluc2V0PWdhcHdpZHRoKyhnYXB3aWR0aCA+IDAuMCA/IEFOVElBTElBU0lORyA6IDAuMCk7ZmxvYXQgb3V0c2V0PWdhcHdpZHRoK2hhbGZ3aWR0aCooZ2Fwd2lkdGggPiAwLjAgPyAyLjAgOiAxLjApKyhoYWxmd2lkdGg9PTAuMCA/IDAuMCA6IEFOVElBTElBU0lORyk7bWVkaXVtcCB2ZWMyIGRpc3Q9b3V0c2V0KmFfZXh0cnVkZSpzY2FsZTttZWRpdW1wIGZsb2F0IHU9MC41KmFfZGlyZWN0aW9uO21lZGl1bXAgZmxvYXQgdD0xLjAtYWJzKHUpO21lZGl1bXAgdmVjMiBvZmZzZXQyPW9mZnNldCphX2V4dHJ1ZGUqc2NhbGUqbm9ybWFsLnkqbWF0Mih0LC11LHUsdCk7dmVjNCBwcm9qZWN0ZWRfZXh0cnVkZT11X21hdHJpeCp2ZWM0KGRpc3QvdV9yYXRpbywwLjAsMC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KHBvcytvZmZzZXQyL3VfcmF0aW8sMC4wLDEuMCkrcHJvamVjdGVkX2V4dHJ1ZGU7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZT1sZW5ndGgoZGlzdCk7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZT1sZW5ndGgocHJvamVjdGVkX2V4dHJ1ZGUueHkvZ2xfUG9zaXRpb24udyp1X3VuaXRzX3RvX3BpeGVscyk7dl9nYW1tYV9zY2FsZT1leHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlL2V4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU7dl93aWR0aDI9dmVjMihvdXRzZXQsaW5zZXQpO31cIiksXG4gICAgICAgIGhpID0gZ2koXCJ1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfZmFkZTt1bmlmb3JtIG1lZGl1bXAgdmVjMyB1X3NjYWxlO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO3ZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTt2YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVpvb21SYXRpbz11X3NjYWxlLng7ZmxvYXQgZnJvbVNjYWxlPXVfc2NhbGUueTtmbG9hdCB0b1NjYWxlPXVfc2NhbGUuejt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO3ZlYzIgcGF0dGVybl9zaXplX2E9dmVjMihkaXNwbGF5X3NpemVfYS54KmZyb21TY2FsZS90aWxlWm9vbVJhdGlvLGRpc3BsYXlfc2l6ZV9hLnkpO3ZlYzIgcGF0dGVybl9zaXplX2I9dmVjMihkaXNwbGF5X3NpemVfYi54KnRvU2NhbGUvdGlsZVpvb21SYXRpbyxkaXNwbGF5X3NpemVfYi55KTtmbG9hdCBhc3BlY3RfYT1kaXNwbGF5X3NpemVfYS55L3Zfd2lkdGg7ZmxvYXQgYXNwZWN0X2I9ZGlzcGxheV9zaXplX2IueS92X3dpZHRoO2Zsb2F0IGRpc3Q9bGVuZ3RoKHZfbm9ybWFsKSp2X3dpZHRoMi5zO2Zsb2F0IGJsdXIyPShibHVyKzEuMC91X2RldmljZV9waXhlbF9yYXRpbykqdl9nYW1tYV9zY2FsZTtmbG9hdCBhbHBoYT1jbGFtcChtaW4oZGlzdC0odl93aWR0aDIudC1ibHVyMiksdl93aWR0aDIucy1kaXN0KS9ibHVyMiwwLjAsMS4wKTtmbG9hdCB4X2E9bW9kKHZfbGluZXNvZmFyL3BhdHRlcm5fc2l6ZV9hLngqYXNwZWN0X2EsMS4wKTtmbG9hdCB4X2I9bW9kKHZfbGluZXNvZmFyL3BhdHRlcm5fc2l6ZV9iLngqYXNwZWN0X2IsMS4wKTtmbG9hdCB5PTAuNSp2X25vcm1hbC55KzAuNTt2ZWMyIHRleGVsX3NpemU9MS4wL3VfdGV4c2l6ZTt2ZWMyIHBvc19hPW1peChwYXR0ZXJuX3RsX2EqdGV4ZWxfc2l6ZS10ZXhlbF9zaXplLHBhdHRlcm5fYnJfYSp0ZXhlbF9zaXplK3RleGVsX3NpemUsdmVjMih4X2EseSkpO3ZlYzIgcG9zX2I9bWl4KHBhdHRlcm5fdGxfYip0ZXhlbF9zaXplLXRleGVsX3NpemUscGF0dGVybl9icl9iKnRleGVsX3NpemUrdGV4ZWxfc2l6ZSx2ZWMyKHhfYix5KSk7dmVjNCBjb2xvcj1taXgodGV4dHVyZTJEKHVfaW1hZ2UscG9zX2EpLHRleHR1cmUyRCh1X2ltYWdlLHBvc19iKSx1X2ZhZGUpO2dsX0ZyYWdDb2xvcj1jb2xvciphbHBoYSpvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuI2RlZmluZSBMSU5FX0RJU1RBTkNFX1NDQUxFIDIuMFxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zX25vcm1hbDthdHRyaWJ1dGUgdmVjNCBhX2RhdGE7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3VuaXRzX3RvX3BpeGVsczt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO3ZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTt2YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBmbG9vcndpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7ZmxvYXQgYV9saW5lc29mYXI9KGZsb29yKGFfZGF0YS56LzQuMCkrYV9kYXRhLncqNjQuMCkqTElORV9ESVNUQU5DRV9TQ0FMRTt2ZWMyIHBvcz1mbG9vcihhX3Bvc19ub3JtYWwqMC41KTttZWRpdW1wIHZlYzIgbm9ybWFsPWFfcG9zX25vcm1hbC0yLjAqcG9zO25vcm1hbC55PW5vcm1hbC55KjIuMC0xLjA7dl9ub3JtYWw9bm9ybWFsO2dhcHdpZHRoPWdhcHdpZHRoLzIuMDtmbG9hdCBoYWxmd2lkdGg9d2lkdGgvMi4wO29mZnNldD0tMS4wKm9mZnNldDtmbG9hdCBpbnNldD1nYXB3aWR0aCsoZ2Fwd2lkdGggPiAwLjAgPyBBTlRJQUxJQVNJTkcgOiAwLjApO2Zsb2F0IG91dHNldD1nYXB3aWR0aCtoYWxmd2lkdGgqKGdhcHdpZHRoID4gMC4wID8gMi4wIDogMS4wKSsoaGFsZndpZHRoPT0wLjAgPyAwLjAgOiBBTlRJQUxJQVNJTkcpO21lZGl1bXAgdmVjMiBkaXN0PW91dHNldCphX2V4dHJ1ZGUqc2NhbGU7bWVkaXVtcCBmbG9hdCB1PTAuNSphX2RpcmVjdGlvbjttZWRpdW1wIGZsb2F0IHQ9MS4wLWFicyh1KTttZWRpdW1wIHZlYzIgb2Zmc2V0Mj1vZmZzZXQqYV9leHRydWRlKnNjYWxlKm5vcm1hbC55Km1hdDIodCwtdSx1LHQpO3ZlYzQgcHJvamVjdGVkX2V4dHJ1ZGU9dV9tYXRyaXgqdmVjNChkaXN0L3VfcmF0aW8sMC4wLDAuMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChwb3Mrb2Zmc2V0Mi91X3JhdGlvLDAuMCwxLjApK3Byb2plY3RlZF9leHRydWRlO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmU9bGVuZ3RoKGRpc3QpO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU9bGVuZ3RoKHByb2plY3RlZF9leHRydWRlLnh5L2dsX1Bvc2l0aW9uLncqdV91bml0c190b19waXhlbHMpO3ZfZ2FtbWFfc2NhbGU9ZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZS9leHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlO3ZfbGluZXNvZmFyPWFfbGluZXNvZmFyO3Zfd2lkdGgyPXZlYzIob3V0c2V0LGluc2V0KTt2X3dpZHRoPWZsb29yd2lkdGg7fVwiKSxcbiAgICAgICAgcGkgPSBnaShcInVuaWZvcm0gbG93cCBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbzt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3VuaWZvcm0gZmxvYXQgdV9zZGZnYW1tYTt1bmlmb3JtIGZsb2F0IHVfbWl4O3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyB2ZWMyIHZfdGV4X2E7dmFyeWluZyB2ZWMyIHZfdGV4X2I7dmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbmZsb2F0IGRpc3Q9bGVuZ3RoKHZfbm9ybWFsKSp2X3dpZHRoMi5zO2Zsb2F0IGJsdXIyPShibHVyKzEuMC91X2RldmljZV9waXhlbF9yYXRpbykqdl9nYW1tYV9zY2FsZTtmbG9hdCBhbHBoYT1jbGFtcChtaW4oZGlzdC0odl93aWR0aDIudC1ibHVyMiksdl93aWR0aDIucy1kaXN0KS9ibHVyMiwwLjAsMS4wKTtmbG9hdCBzZGZkaXN0X2E9dGV4dHVyZTJEKHVfaW1hZ2Usdl90ZXhfYSkuYTtmbG9hdCBzZGZkaXN0X2I9dGV4dHVyZTJEKHVfaW1hZ2Usdl90ZXhfYikuYTtmbG9hdCBzZGZkaXN0PW1peChzZGZkaXN0X2Esc2RmZGlzdF9iLHVfbWl4KTthbHBoYSo9c21vb3Roc3RlcCgwLjUtdV9zZGZnYW1tYS9mbG9vcndpZHRoLDAuNSt1X3NkZmdhbW1hL2Zsb29yd2lkdGgsc2RmZGlzdCk7Z2xfRnJhZ0NvbG9yPWNvbG9yKihhbHBoYSpvcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiXFxuI2RlZmluZSBzY2FsZSAwLjAxNTg3MzAxNlxcbiNkZWZpbmUgTElORV9ESVNUQU5DRV9TQ0FMRSAyLjBcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc19ub3JtYWw7YXR0cmlidXRlIHZlYzQgYV9kYXRhO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2E7dW5pZm9ybSBmbG9hdCB1X3RleF95X2E7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2I7dW5pZm9ybSBmbG9hdCB1X3RleF95X2I7dW5pZm9ybSB2ZWMyIHVfdW5pdHNfdG9fcGl4ZWxzO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyB2ZWMyIHZfdGV4X2E7dmFyeWluZyB2ZWMyIHZfdGV4X2I7dmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGZsb29yd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgZ2Fwd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGZsb29yd2lkdGhcXG5mbG9hdCBBTlRJQUxJQVNJTkc9MS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvLzIuMDt2ZWMyIGFfZXh0cnVkZT1hX2RhdGEueHktMTI4LjA7ZmxvYXQgYV9kaXJlY3Rpb249bW9kKGFfZGF0YS56LDQuMCktMS4wO2Zsb2F0IGFfbGluZXNvZmFyPShmbG9vcihhX2RhdGEuei80LjApK2FfZGF0YS53KjY0LjApKkxJTkVfRElTVEFOQ0VfU0NBTEU7dmVjMiBwb3M9Zmxvb3IoYV9wb3Nfbm9ybWFsKjAuNSk7bWVkaXVtcCB2ZWMyIG5vcm1hbD1hX3Bvc19ub3JtYWwtMi4wKnBvcztub3JtYWwueT1ub3JtYWwueSoyLjAtMS4wO3Zfbm9ybWFsPW5vcm1hbDtnYXB3aWR0aD1nYXB3aWR0aC8yLjA7ZmxvYXQgaGFsZndpZHRoPXdpZHRoLzIuMDtvZmZzZXQ9LTEuMCpvZmZzZXQ7ZmxvYXQgaW5zZXQ9Z2Fwd2lkdGgrKGdhcHdpZHRoID4gMC4wID8gQU5USUFMSUFTSU5HIDogMC4wKTtmbG9hdCBvdXRzZXQ9Z2Fwd2lkdGgraGFsZndpZHRoKihnYXB3aWR0aCA+IDAuMCA/IDIuMCA6IDEuMCkrKGhhbGZ3aWR0aD09MC4wID8gMC4wIDogQU5USUFMSUFTSU5HKTttZWRpdW1wIHZlYzIgZGlzdD1vdXRzZXQqYV9leHRydWRlKnNjYWxlO21lZGl1bXAgZmxvYXQgdT0wLjUqYV9kaXJlY3Rpb247bWVkaXVtcCBmbG9hdCB0PTEuMC1hYnModSk7bWVkaXVtcCB2ZWMyIG9mZnNldDI9b2Zmc2V0KmFfZXh0cnVkZSpzY2FsZSpub3JtYWwueSptYXQyKHQsLXUsdSx0KTt2ZWM0IHByb2plY3RlZF9leHRydWRlPXVfbWF0cml4KnZlYzQoZGlzdC91X3JhdGlvLDAuMCwwLjApO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQocG9zK29mZnNldDIvdV9yYXRpbywwLjAsMS4wKStwcm9qZWN0ZWRfZXh0cnVkZTtmbG9hdCBleHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlPWxlbmd0aChkaXN0KTtmbG9hdCBleHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlPWxlbmd0aChwcm9qZWN0ZWRfZXh0cnVkZS54eS9nbF9Qb3NpdGlvbi53KnVfdW5pdHNfdG9fcGl4ZWxzKTt2X2dhbW1hX3NjYWxlPWV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmUvZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZTt2X3RleF9hPXZlYzIoYV9saW5lc29mYXIqdV9wYXR0ZXJuc2NhbGVfYS54L2Zsb29yd2lkdGgsbm9ybWFsLnkqdV9wYXR0ZXJuc2NhbGVfYS55K3VfdGV4X3lfYSk7dl90ZXhfYj12ZWMyKGFfbGluZXNvZmFyKnVfcGF0dGVybnNjYWxlX2IueC9mbG9vcndpZHRoLG5vcm1hbC55KnVfcGF0dGVybnNjYWxlX2IueSt1X3RleF95X2IpO3Zfd2lkdGgyPXZlYzIob3V0c2V0LGluc2V0KTt9XCIpLFxuICAgICAgICBkaSA9IGdpKFwidW5pZm9ybSBmbG9hdCB1X2ZhZGVfdDt1bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMDt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMTt2YXJ5aW5nIHZlYzIgdl9wb3MwO3ZhcnlpbmcgdmVjMiB2X3BvczE7dW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3NfbG93O3VuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2hpZ2g7dW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb25fZmFjdG9yO3VuaWZvcm0gZmxvYXQgdV9jb250cmFzdF9mYWN0b3I7dW5pZm9ybSB2ZWMzIHVfc3Bpbl93ZWlnaHRzO3ZvaWQgbWFpbigpIHt2ZWM0IGNvbG9yMD10ZXh0dXJlMkQodV9pbWFnZTAsdl9wb3MwKTt2ZWM0IGNvbG9yMT10ZXh0dXJlMkQodV9pbWFnZTEsdl9wb3MxKTtpZiAoY29sb3IwLmEgPiAwLjApIHtjb2xvcjAucmdiPWNvbG9yMC5yZ2IvY29sb3IwLmE7fWlmIChjb2xvcjEuYSA+IDAuMCkge2NvbG9yMS5yZ2I9Y29sb3IxLnJnYi9jb2xvcjEuYTt9dmVjNCBjb2xvcj1taXgoY29sb3IwLGNvbG9yMSx1X2ZhZGVfdCk7Y29sb3IuYSo9dV9vcGFjaXR5O3ZlYzMgcmdiPWNvbG9yLnJnYjtyZ2I9dmVjMyhkb3QocmdiLHVfc3Bpbl93ZWlnaHRzLnh5eiksZG90KHJnYix1X3NwaW5fd2VpZ2h0cy56eHkpLGRvdChyZ2IsdV9zcGluX3dlaWdodHMueXp4KSk7ZmxvYXQgYXZlcmFnZT0oY29sb3Iucitjb2xvci5nK2NvbG9yLmIpLzMuMDtyZ2IrPShhdmVyYWdlLXJnYikqdV9zYXR1cmF0aW9uX2ZhY3RvcjtyZ2I9KHJnYi0wLjUpKnVfY29udHJhc3RfZmFjdG9yKzAuNTt2ZWMzIHVfaGlnaF92ZWM9dmVjMyh1X2JyaWdodG5lc3NfbG93LHVfYnJpZ2h0bmVzc19sb3csdV9icmlnaHRuZXNzX2xvdyk7dmVjMyB1X2xvd192ZWM9dmVjMyh1X2JyaWdodG5lc3NfaGlnaCx1X2JyaWdodG5lc3NfaGlnaCx1X2JyaWdodG5lc3NfaGlnaCk7Z2xfRnJhZ0NvbG9yPXZlYzQobWl4KHVfaGlnaF92ZWMsdV9sb3dfdmVjLHJnYikqY29sb3IuYSxjb2xvci5hKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDt1bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O3VuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3MwO3ZhcnlpbmcgdmVjMiB2X3BvczE7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3BvczA9KCgoYV90ZXh0dXJlX3Bvcy84MTkyLjApLTAuNSkvdV9idWZmZXJfc2NhbGUgKSswLjU7dl9wb3MxPSh2X3BvczAqdV9zY2FsZV9wYXJlbnQpK3VfdGxfcGFyZW50O31cIiksXG4gICAgICAgIF9pID0gZ2koXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7dmFyeWluZyB2ZWMyIHZfdGV4O3ZhcnlpbmcgZmxvYXQgdl9mYWRlX29wYWNpdHk7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxubG93cCBmbG9hdCBhbHBoYT1vcGFjaXR5KnZfZmFkZV9vcGFjaXR5O2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQodV90ZXh0dXJlLHZfdGV4KSphbHBoYTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiY29uc3QgZmxvYXQgUEk9My4xNDE1OTI2NTM1ODk3OTM7YXR0cmlidXRlIHZlYzQgYV9wb3Nfb2Zmc2V0O2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgdmVjNCBhX3BpeGVsb2Zmc2V0O2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9waXRjaDt1bmlmb3JtIGJvb2wgdV9yb3RhdGVfc3ltYm9sO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9hc3BlY3RfcmF0aW87dW5pZm9ybSBmbG9hdCB1X2ZhZGVfY2hhbmdlO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt2YXJ5aW5nIHZlYzIgdl90ZXg7dmFyeWluZyBmbG9hdCB2X2ZhZGVfb3BhY2l0eTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52ZWMyIGFfcG9zPWFfcG9zX29mZnNldC54eTt2ZWMyIGFfb2Zmc2V0PWFfcG9zX29mZnNldC56dzt2ZWMyIGFfdGV4PWFfZGF0YS54eTt2ZWMyIGFfc2l6ZT1hX2RhdGEuenc7ZmxvYXQgYV9zaXplX21pbj1mbG9vcihhX3NpemVbMF0qMC41KTt2ZWMyIGFfcHhvZmZzZXQ9YV9waXhlbG9mZnNldC54eTt2ZWMyIGFfbWluRm9udFNjYWxlPWFfcGl4ZWxvZmZzZXQuencvMjU2LjA7aGlnaHAgZmxvYXQgc2VnbWVudF9hbmdsZT0tYV9wcm9qZWN0ZWRfcG9zWzJdO2Zsb2F0IHNpemU7aWYgKCF1X2lzX3NpemVfem9vbV9jb25zdGFudCAmJiAhdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpIHtzaXplPW1peChhX3NpemVfbWluLGFfc2l6ZVsxXSx1X3NpemVfdCkvMTI4LjA7fSBlbHNlIGlmICh1X2lzX3NpemVfem9vbV9jb25zdGFudCAmJiAhdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpIHtzaXplPWFfc2l6ZV9taW4vMTI4LjA7fSBlbHNlIHtzaXplPXVfc2l6ZTt9dmVjNCBwcm9qZWN0ZWRQb2ludD11X21hdHJpeCp2ZWM0KGFfcG9zLDAsMSk7aGlnaHAgZmxvYXQgY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZT1wcm9qZWN0ZWRQb2ludC53O2hpZ2hwIGZsb2F0IGRpc3RhbmNlX3JhdGlvPXVfcGl0Y2hfd2l0aF9tYXAgP1xcbmNhbWVyYV90b19hbmNob3JfZGlzdGFuY2UvdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlIDpcXG51X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UvY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZTtoaWdocCBmbG9hdCBwZXJzcGVjdGl2ZV9yYXRpbz1jbGFtcCgwLjUrMC41KmRpc3RhbmNlX3JhdGlvLDAuMCw0LjApO3NpemUqPXBlcnNwZWN0aXZlX3JhdGlvO2Zsb2F0IGZvbnRTY2FsZT11X2lzX3RleHQgPyBzaXplLzI0LjAgOiBzaXplO2hpZ2hwIGZsb2F0IHN5bWJvbF9yb3RhdGlvbj0wLjA7aWYgKHVfcm90YXRlX3N5bWJvbCkge3ZlYzQgb2Zmc2V0UHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX3Bvcyt2ZWMyKDEsMCksMCwxKTt2ZWMyIGE9cHJvamVjdGVkUG9pbnQueHkvcHJvamVjdGVkUG9pbnQudzt2ZWMyIGI9b2Zmc2V0UHJvamVjdGVkUG9pbnQueHkvb2Zmc2V0UHJvamVjdGVkUG9pbnQudztzeW1ib2xfcm90YXRpb249YXRhbigoYi55LWEueSkvdV9hc3BlY3RfcmF0aW8sYi54LWEueCk7fWhpZ2hwIGZsb2F0IGFuZ2xlX3Npbj1zaW4oc2VnbWVudF9hbmdsZStzeW1ib2xfcm90YXRpb24pO2hpZ2hwIGZsb2F0IGFuZ2xlX2Nvcz1jb3Moc2VnbWVudF9hbmdsZStzeW1ib2xfcm90YXRpb24pO21hdDIgcm90YXRpb25fbWF0cml4PW1hdDIoYW5nbGVfY29zLC0xLjAqYW5nbGVfc2luLGFuZ2xlX3NpbixhbmdsZV9jb3MpO3ZlYzQgcHJvamVjdGVkX3Bvcz11X2xhYmVsX3BsYW5lX21hdHJpeCp2ZWM0KGFfcHJvamVjdGVkX3Bvcy54eSwwLjAsMS4wKTtnbF9Qb3NpdGlvbj11X2Nvb3JkX21hdHJpeCp2ZWM0KHByb2plY3RlZF9wb3MueHkvcHJvamVjdGVkX3Bvcy53K3JvdGF0aW9uX21hdHJpeCooYV9vZmZzZXQvMzIuMCptYXgoYV9taW5Gb250U2NhbGUsZm9udFNjYWxlKSthX3B4b2Zmc2V0LzE2LjApLDAuMCwxLjApO3ZfdGV4PWFfdGV4L3VfdGV4c2l6ZTt2ZWMyIGZhZGVfb3BhY2l0eT11bnBhY2tfb3BhY2l0eShhX2ZhZGVfb3BhY2l0eSk7ZmxvYXQgZmFkZV9jaGFuZ2U9ZmFkZV9vcGFjaXR5WzFdID4gMC41ID8gdV9mYWRlX2NoYW5nZSA6LXVfZmFkZV9jaGFuZ2U7dl9mYWRlX29wYWNpdHk9bWF4KDAuMCxtaW4oMS4wLGZhZGVfb3BhY2l0eVswXStmYWRlX2NoYW5nZSkpO31cIiksXG4gICAgICAgIGZpID0gZ2koXCIjZGVmaW5lIFNERl9QWCA4LjBcXG51bmlmb3JtIGJvb2wgdV9pc19oYWxvO3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfZ2FtbWFfc2NhbGU7dW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dmFyeWluZyB2ZWMyIHZfZGF0YTA7dmFyeWluZyB2ZWMzIHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxuZmxvYXQgRURHRV9HQU1NQT0wLjEwNS91X2RldmljZV9waXhlbF9yYXRpbzt2ZWMyIHRleD12X2RhdGEwLnh5O2Zsb2F0IGdhbW1hX3NjYWxlPXZfZGF0YTEueDtmbG9hdCBzaXplPXZfZGF0YTEueTtmbG9hdCBmYWRlX29wYWNpdHk9dl9kYXRhMVsyXTtmbG9hdCBmb250U2NhbGU9dV9pc190ZXh0ID8gc2l6ZS8yNC4wIDogc2l6ZTtsb3dwIHZlYzQgY29sb3I9ZmlsbF9jb2xvcjtoaWdocCBmbG9hdCBnYW1tYT1FREdFX0dBTU1BLyhmb250U2NhbGUqdV9nYW1tYV9zY2FsZSk7bG93cCBmbG9hdCBidWZmPSgyNTYuMC02NC4wKS8yNTYuMDtpZiAodV9pc19oYWxvKSB7Y29sb3I9aGFsb19jb2xvcjtnYW1tYT0oaGFsb19ibHVyKjEuMTkvU0RGX1BYK0VER0VfR0FNTUEpLyhmb250U2NhbGUqdV9nYW1tYV9zY2FsZSk7YnVmZj0oNi4wLWhhbG9fd2lkdGgvZm9udFNjYWxlKS9TREZfUFg7fWxvd3AgZmxvYXQgZGlzdD10ZXh0dXJlMkQodV90ZXh0dXJlLHRleCkuYTtoaWdocCBmbG9hdCBnYW1tYV9zY2FsZWQ9Z2FtbWEqZ2FtbWFfc2NhbGU7aGlnaHAgZmxvYXQgYWxwaGE9c21vb3Roc3RlcChidWZmLWdhbW1hX3NjYWxlZCxidWZmK2dhbW1hX3NjYWxlZCxkaXN0KTtnbF9GcmFnQ29sb3I9Y29sb3IqKGFscGhhKm9wYWNpdHkqZmFkZV9vcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiY29uc3QgZmxvYXQgUEk9My4xNDE1OTI2NTM1ODk3OTM7YXR0cmlidXRlIHZlYzQgYV9wb3Nfb2Zmc2V0O2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgdmVjNCBhX3BpeGVsb2Zmc2V0O2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3BpdGNoO3VuaWZvcm0gYm9vbCB1X3JvdGF0ZV9zeW1ib2w7dW5pZm9ybSBoaWdocCBmbG9hdCB1X2FzcGVjdF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVfZmFkZV9jaGFuZ2U7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt2YXJ5aW5nIHZlYzIgdl9kYXRhMDt2YXJ5aW5nIHZlYzMgdl9kYXRhMTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBoYWxvX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoYWxvX2JsdXJcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBmaWxsX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBoYWxvX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoYWxvX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoYWxvX2JsdXJcXG52ZWMyIGFfcG9zPWFfcG9zX29mZnNldC54eTt2ZWMyIGFfb2Zmc2V0PWFfcG9zX29mZnNldC56dzt2ZWMyIGFfdGV4PWFfZGF0YS54eTt2ZWMyIGFfc2l6ZT1hX2RhdGEuenc7ZmxvYXQgYV9zaXplX21pbj1mbG9vcihhX3NpemVbMF0qMC41KTt2ZWMyIGFfcHhvZmZzZXQ9YV9waXhlbG9mZnNldC54eTtoaWdocCBmbG9hdCBzZWdtZW50X2FuZ2xlPS1hX3Byb2plY3RlZF9wb3NbMl07ZmxvYXQgc2l6ZTtpZiAoIXVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9bWl4KGFfc2l6ZV9taW4sYV9zaXplWzFdLHVfc2l6ZV90KS8xMjguMDt9IGVsc2UgaWYgKHVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9YV9zaXplX21pbi8xMjguMDt9IGVsc2Uge3NpemU9dV9zaXplO312ZWM0IHByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgZGlzdGFuY2VfcmF0aW89dV9waXRjaF93aXRoX21hcCA/XFxuY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZS91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UgOlxcbnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlO2hpZ2hwIGZsb2F0IHBlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqZGlzdGFuY2VfcmF0aW8sMC4wLDQuMCk7c2l6ZSo9cGVyc3BlY3RpdmVfcmF0aW87ZmxvYXQgZm9udFNjYWxlPXVfaXNfdGV4dCA/IHNpemUvMjQuMCA6IHNpemU7aGlnaHAgZmxvYXQgc3ltYm9sX3JvdGF0aW9uPTAuMDtpZiAodV9yb3RhdGVfc3ltYm9sKSB7dmVjNCBvZmZzZXRQcm9qZWN0ZWRQb2ludD11X21hdHJpeCp2ZWM0KGFfcG9zK3ZlYzIoMSwwKSwwLDEpO3ZlYzIgYT1wcm9qZWN0ZWRQb2ludC54eS9wcm9qZWN0ZWRQb2ludC53O3ZlYzIgYj1vZmZzZXRQcm9qZWN0ZWRQb2ludC54eS9vZmZzZXRQcm9qZWN0ZWRQb2ludC53O3N5bWJvbF9yb3RhdGlvbj1hdGFuKChiLnktYS55KS91X2FzcGVjdF9yYXRpbyxiLngtYS54KTt9aGlnaHAgZmxvYXQgYW5nbGVfc2luPXNpbihzZWdtZW50X2FuZ2xlK3N5bWJvbF9yb3RhdGlvbik7aGlnaHAgZmxvYXQgYW5nbGVfY29zPWNvcyhzZWdtZW50X2FuZ2xlK3N5bWJvbF9yb3RhdGlvbik7bWF0MiByb3RhdGlvbl9tYXRyaXg9bWF0MihhbmdsZV9jb3MsLTEuMCphbmdsZV9zaW4sYW5nbGVfc2luLGFuZ2xlX2Nvcyk7dmVjNCBwcm9qZWN0ZWRfcG9zPXVfbGFiZWxfcGxhbmVfbWF0cml4KnZlYzQoYV9wcm9qZWN0ZWRfcG9zLnh5LDAuMCwxLjApO2dsX1Bvc2l0aW9uPXVfY29vcmRfbWF0cml4KnZlYzQocHJvamVjdGVkX3Bvcy54eS9wcm9qZWN0ZWRfcG9zLncrcm90YXRpb25fbWF0cml4KihhX29mZnNldC8zMi4wKmZvbnRTY2FsZSthX3B4b2Zmc2V0KSwwLjAsMS4wKTtmbG9hdCBnYW1tYV9zY2FsZT1nbF9Qb3NpdGlvbi53O3ZlYzIgZmFkZV9vcGFjaXR5PXVucGFja19vcGFjaXR5KGFfZmFkZV9vcGFjaXR5KTtmbG9hdCBmYWRlX2NoYW5nZT1mYWRlX29wYWNpdHlbMV0gPiAwLjUgPyB1X2ZhZGVfY2hhbmdlIDotdV9mYWRlX2NoYW5nZTtmbG9hdCBpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5PW1heCgwLjAsbWluKDEuMCxmYWRlX29wYWNpdHlbMF0rZmFkZV9jaGFuZ2UpKTt2X2RhdGEwPWFfdGV4L3VfdGV4c2l6ZTt2X2RhdGExPXZlYzMoZ2FtbWFfc2NhbGUsc2l6ZSxpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5KTt9XCIpLFxuICAgICAgICBtaSA9IGdpKFwiI2RlZmluZSBTREZfUFggOC4wXFxuI2RlZmluZSBTREYgMS4wXFxuI2RlZmluZSBJQ09OIDAuMFxcbnVuaWZvcm0gYm9vbCB1X2lzX2hhbG87dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZV9pY29uO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9nYW1tYV9zY2FsZTt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWM0IHZfZGF0YTA7dmFyeWluZyB2ZWM0IHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxuZmxvYXQgZmFkZV9vcGFjaXR5PXZfZGF0YTFbMl07aWYgKHZfZGF0YTEudz09SUNPTikge3ZlYzIgdGV4X2ljb249dl9kYXRhMC56dztsb3dwIGZsb2F0IGFscGhhPW9wYWNpdHkqZmFkZV9vcGFjaXR5O2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQodV90ZXh0dXJlX2ljb24sdGV4X2ljb24pKmFscGhhO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbnJldHVybjt9dmVjMiB0ZXg9dl9kYXRhMC54eTtmbG9hdCBFREdFX0dBTU1BPTAuMTA1L3VfZGV2aWNlX3BpeGVsX3JhdGlvO2Zsb2F0IGdhbW1hX3NjYWxlPXZfZGF0YTEueDtmbG9hdCBzaXplPXZfZGF0YTEueTtmbG9hdCBmb250U2NhbGU9c2l6ZS8yNC4wO2xvd3AgdmVjNCBjb2xvcj1maWxsX2NvbG9yO2hpZ2hwIGZsb2F0IGdhbW1hPUVER0VfR0FNTUEvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtsb3dwIGZsb2F0IGJ1ZmY9KDI1Ni4wLTY0LjApLzI1Ni4wO2lmICh1X2lzX2hhbG8pIHtjb2xvcj1oYWxvX2NvbG9yO2dhbW1hPShoYWxvX2JsdXIqMS4xOS9TREZfUFgrRURHRV9HQU1NQSkvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtidWZmPSg2LjAtaGFsb193aWR0aC9mb250U2NhbGUpL1NERl9QWDt9bG93cCBmbG9hdCBkaXN0PXRleHR1cmUyRCh1X3RleHR1cmUsdGV4KS5hO2hpZ2hwIGZsb2F0IGdhbW1hX3NjYWxlZD1nYW1tYSpnYW1tYV9zY2FsZTtoaWdocCBmbG9hdCBhbHBoYT1zbW9vdGhzdGVwKGJ1ZmYtZ2FtbWFfc2NhbGVkLGJ1ZmYrZ2FtbWFfc2NhbGVkLGRpc3QpO2dsX0ZyYWdDb2xvcj1jb2xvciooYWxwaGEqb3BhY2l0eSpmYWRlX29wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJjb25zdCBmbG9hdCBQST0zLjE0MTU5MjY1MzU4OTc5MzthdHRyaWJ1dGUgdmVjNCBhX3Bvc19vZmZzZXQ7YXR0cmlidXRlIHZlYzQgYV9kYXRhO2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3BpdGNoO3VuaWZvcm0gYm9vbCB1X3JvdGF0ZV9zeW1ib2w7dW5pZm9ybSBoaWdocCBmbG9hdCB1X2FzcGVjdF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVfZmFkZV9jaGFuZ2U7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIHZlYzIgdV90ZXhzaXplX2ljb247dmFyeWluZyB2ZWM0IHZfZGF0YTA7dmFyeWluZyB2ZWM0IHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudmVjMiBhX3Bvcz1hX3Bvc19vZmZzZXQueHk7dmVjMiBhX29mZnNldD1hX3Bvc19vZmZzZXQuenc7dmVjMiBhX3RleD1hX2RhdGEueHk7dmVjMiBhX3NpemU9YV9kYXRhLnp3O2Zsb2F0IGFfc2l6ZV9taW49Zmxvb3IoYV9zaXplWzBdKjAuNSk7ZmxvYXQgaXNfc2RmPWFfc2l6ZVswXS0yLjAqYV9zaXplX21pbjtoaWdocCBmbG9hdCBzZWdtZW50X2FuZ2xlPS1hX3Byb2plY3RlZF9wb3NbMl07ZmxvYXQgc2l6ZTtpZiAoIXVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9bWl4KGFfc2l6ZV9taW4sYV9zaXplWzFdLHVfc2l6ZV90KS8xMjguMDt9IGVsc2UgaWYgKHVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9YV9zaXplX21pbi8xMjguMDt9IGVsc2Uge3NpemU9dV9zaXplO312ZWM0IHByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgZGlzdGFuY2VfcmF0aW89dV9waXRjaF93aXRoX21hcCA/XFxuY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZS91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UgOlxcbnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlO2hpZ2hwIGZsb2F0IHBlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqZGlzdGFuY2VfcmF0aW8sMC4wLDQuMCk7c2l6ZSo9cGVyc3BlY3RpdmVfcmF0aW87ZmxvYXQgZm9udFNjYWxlPXNpemUvMjQuMDtoaWdocCBmbG9hdCBzeW1ib2xfcm90YXRpb249MC4wO2lmICh1X3JvdGF0ZV9zeW1ib2wpIHt2ZWM0IG9mZnNldFByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MrdmVjMigxLDApLDAsMSk7dmVjMiBhPXByb2plY3RlZFBvaW50Lnh5L3Byb2plY3RlZFBvaW50Lnc7dmVjMiBiPW9mZnNldFByb2plY3RlZFBvaW50Lnh5L29mZnNldFByb2plY3RlZFBvaW50Lnc7c3ltYm9sX3JvdGF0aW9uPWF0YW4oKGIueS1hLnkpL3VfYXNwZWN0X3JhdGlvLGIueC1hLngpO31oaWdocCBmbG9hdCBhbmdsZV9zaW49c2luKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTtoaWdocCBmbG9hdCBhbmdsZV9jb3M9Y29zKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTttYXQyIHJvdGF0aW9uX21hdHJpeD1tYXQyKGFuZ2xlX2NvcywtMS4wKmFuZ2xlX3NpbixhbmdsZV9zaW4sYW5nbGVfY29zKTt2ZWM0IHByb2plY3RlZF9wb3M9dV9sYWJlbF9wbGFuZV9tYXRyaXgqdmVjNChhX3Byb2plY3RlZF9wb3MueHksMC4wLDEuMCk7Z2xfUG9zaXRpb249dV9jb29yZF9tYXRyaXgqdmVjNChwcm9qZWN0ZWRfcG9zLnh5L3Byb2plY3RlZF9wb3Mudytyb3RhdGlvbl9tYXRyaXgqKGFfb2Zmc2V0LzMyLjAqZm9udFNjYWxlKSwwLjAsMS4wKTtmbG9hdCBnYW1tYV9zY2FsZT1nbF9Qb3NpdGlvbi53O3ZlYzIgZmFkZV9vcGFjaXR5PXVucGFja19vcGFjaXR5KGFfZmFkZV9vcGFjaXR5KTtmbG9hdCBmYWRlX2NoYW5nZT1mYWRlX29wYWNpdHlbMV0gPiAwLjUgPyB1X2ZhZGVfY2hhbmdlIDotdV9mYWRlX2NoYW5nZTtmbG9hdCBpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5PW1heCgwLjAsbWluKDEuMCxmYWRlX29wYWNpdHlbMF0rZmFkZV9jaGFuZ2UpKTt2X2RhdGEwLnh5PWFfdGV4L3VfdGV4c2l6ZTt2X2RhdGEwLnp3PWFfdGV4L3VfdGV4c2l6ZV9pY29uO3ZfZGF0YTE9dmVjNChnYW1tYV9zY2FsZSxzaXplLGludGVycG9sYXRlZF9mYWRlX29wYWNpdHksaXNfc2RmKTt9XCIpO1xuXG4gICAgZnVuY3Rpb24gZ2kodCwgZSkge1xuICAgICAgdmFyIGkgPSAvI3ByYWdtYSBtYXBib3g6IChbXFx3XSspIChbXFx3XSspIChbXFx3XSspIChbXFx3XSspL2csXG4gICAgICAgICAgbyA9IGUubWF0Y2goL2F0dHJpYnV0ZSAoW1xcd10rKSAoW1xcd10rKS9nKSxcbiAgICAgICAgICByID0gdC5tYXRjaCgvdW5pZm9ybSAoW1xcd10rKSAoW1xcd10rKShbXFxzXSopKFtcXHddKikvZyksXG4gICAgICAgICAgYSA9IGUubWF0Y2goL3VuaWZvcm0gKFtcXHddKykgKFtcXHddKykoW1xcc10qKShbXFx3XSopL2cpLFxuICAgICAgICAgIG4gPSBhID8gYS5jb25jYXQocikgOiByLFxuICAgICAgICAgIHMgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyYWdtZW50U291cmNlOiB0ID0gdC5yZXBsYWNlKGksIGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHNbcl0gPSAhMCwgXCJkZWZpbmVcIiA9PT0gZSA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxudmFyeWluZyBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIjtcXG4jZWxzZVxcbnVuaWZvcm0gXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgdV9cIiArIHIgKyBcIjtcXG4jZW5kaWZcXG5cIiA6IFwiXFxuI2lmZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiO1xuICAgICAgICB9KSxcbiAgICAgICAgdmVydGV4U291cmNlOiBlID0gZS5yZXBsYWNlKGksIGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICAgICAgdmFyIGEgPSBcImZsb2F0XCIgPT09IG8gPyBcInZlYzJcIiA6IFwidmVjNFwiLFxuICAgICAgICAgICAgICBuID0gci5tYXRjaCgvY29sb3IvKSA/IFwiY29sb3JcIiA6IGE7XG4gICAgICAgICAgcmV0dXJuIHNbcl0gPyBcImRlZmluZVwiID09PSBlID8gXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9cIiArIHIgKyBcIl90O1xcbmF0dHJpYnV0ZSBcIiArIGkgKyBcIiBcIiArIGEgKyBcIiBhX1wiICsgciArIFwiO1xcbnZhcnlpbmcgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCI7XFxuI2Vsc2VcXG51bmlmb3JtIFwiICsgaSArIFwiIFwiICsgbyArIFwiIHVfXCIgKyByICsgXCI7XFxuI2VuZGlmXFxuXCIgOiBcInZlYzRcIiA9PT0gbiA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxuICAgIFwiICsgciArIFwiID0gYV9cIiArIHIgKyBcIjtcXG4jZWxzZVxcbiAgICBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIiA9IHVfXCIgKyByICsgXCI7XFxuI2VuZGlmXFxuXCIgOiBcIlxcbiNpZm5kZWYgSEFTX1VOSUZPUk1fdV9cIiArIHIgKyBcIlxcbiAgICBcIiArIHIgKyBcIiA9IHVucGFja19taXhfXCIgKyBuICsgXCIoYV9cIiArIHIgKyBcIiwgdV9cIiArIHIgKyBcIl90KTtcXG4jZWxzZVxcbiAgICBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIiA9IHVfXCIgKyByICsgXCI7XFxuI2VuZGlmXFxuXCIgOiBcImRlZmluZVwiID09PSBlID8gXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9cIiArIHIgKyBcIl90O1xcbmF0dHJpYnV0ZSBcIiArIGkgKyBcIiBcIiArIGEgKyBcIiBhX1wiICsgciArIFwiO1xcbiNlbHNlXFxudW5pZm9ybSBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJ2ZWM0XCIgPT09IG4gPyBcIlxcbiNpZm5kZWYgSEFTX1VOSUZPUk1fdV9cIiArIHIgKyBcIlxcbiAgICBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIiA9IGFfXCIgKyByICsgXCI7XFxuI2Vsc2VcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1bnBhY2tfbWl4X1wiICsgbiArIFwiKGFfXCIgKyByICsgXCIsIHVfXCIgKyByICsgXCJfdCk7XFxuI2Vsc2VcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiO1xuICAgICAgICB9KSxcbiAgICAgICAgc3RhdGljQXR0cmlidXRlczogbyxcbiAgICAgICAgc3RhdGljVW5pZm9ybXM6IG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHZpID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICBwcmVsdWRlOiBHZSxcbiAgICAgIGJhY2tncm91bmQ6IFdlLFxuICAgICAgYmFja2dyb3VuZFBhdHRlcm46IFhlLFxuICAgICAgY2lyY2xlOiBIZSxcbiAgICAgIGNsaXBwaW5nTWFzazogS2UsXG4gICAgICBoZWF0bWFwOiBZZSxcbiAgICAgIGhlYXRtYXBUZXh0dXJlOiBKZSxcbiAgICAgIGNvbGxpc2lvbkJveDogUWUsXG4gICAgICBjb2xsaXNpb25DaXJjbGU6ICRlLFxuICAgICAgZGVidWc6IHRpLFxuICAgICAgZmlsbDogZWksXG4gICAgICBmaWxsT3V0bGluZTogaWksXG4gICAgICBmaWxsT3V0bGluZVBhdHRlcm46IG9pLFxuICAgICAgZmlsbFBhdHRlcm46IHJpLFxuICAgICAgZmlsbEV4dHJ1c2lvbjogYWksXG4gICAgICBmaWxsRXh0cnVzaW9uUGF0dGVybjogbmksXG4gICAgICBoaWxsc2hhZGVQcmVwYXJlOiBzaSxcbiAgICAgIGhpbGxzaGFkZTogbGksXG4gICAgICBsaW5lOiBjaSxcbiAgICAgIGxpbmVHcmFkaWVudDogdWksXG4gICAgICBsaW5lUGF0dGVybjogaGksXG4gICAgICBsaW5lU0RGOiBwaSxcbiAgICAgIHJhc3RlcjogZGksXG4gICAgICBzeW1ib2xJY29uOiBfaSxcbiAgICAgIHN5bWJvbFNERjogZmksXG4gICAgICBzeW1ib2xUZXh0QW5kSWNvbjogbWlcbiAgICB9KSxcbiAgICAgICAgeWkgPSBmdW5jdGlvbiB5aSgpIHtcbiAgICAgIHRoaXMuYm91bmRQcm9ncmFtID0gbnVsbCwgdGhpcy5ib3VuZExheW91dFZlcnRleEJ1ZmZlciA9IG51bGwsIHRoaXMuYm91bmRQYWludFZlcnRleEJ1ZmZlcnMgPSBbXSwgdGhpcy5ib3VuZEluZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5ib3VuZFZlcnRleE9mZnNldCA9IG51bGwsIHRoaXMuYm91bmREeW5hbWljVmVydGV4QnVmZmVyID0gbnVsbCwgdGhpcy52YW8gPSBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB4aSh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobnVsbCAhPT0gdFtpXSkge1xuICAgICAgICAgIHZhciBvID0gdFtpXS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgZS5wdXNoKG8ucG9wKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIHlpLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IHQ7XG5cbiAgICAgIGZvciAodmFyIGwgPSB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzLmxlbmd0aCAhPT0gby5sZW5ndGgsIGMgPSAwOyAhbCAmJiBjIDwgby5sZW5ndGg7IGMrKykge1xuICAgICAgICB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzW2NdICE9PSBvW2NdICYmIChsID0gITApO1xuICAgICAgfVxuXG4gICAgICB0LmV4dFZlcnRleEFycmF5T2JqZWN0ICYmIHRoaXMudmFvICYmIHRoaXMuYm91bmRQcm9ncmFtID09PSBlICYmIHRoaXMuYm91bmRMYXlvdXRWZXJ0ZXhCdWZmZXIgPT09IGkgJiYgIWwgJiYgdGhpcy5ib3VuZEluZGV4QnVmZmVyID09PSByICYmIHRoaXMuYm91bmRWZXJ0ZXhPZmZzZXQgPT09IGEgJiYgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIgPT09IG4gJiYgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIyID09PSBzID8gKHQuYmluZFZlcnRleEFycmF5T0VTLnNldCh0aGlzLnZhbyksIG4gJiYgbi5iaW5kKCksIHIgJiYgci5keW5hbWljRHJhdyAmJiByLmJpbmQoKSwgcyAmJiBzLmJpbmQoKSkgOiB0aGlzLmZyZXNoQmluZChlLCBpLCBvLCByLCBhLCBuLCBzKTtcbiAgICB9LCB5aS5wcm90b3R5cGUuZnJlc2hCaW5kID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzLFxuICAgICAgICAgIGwgPSB0Lm51bUF0dHJpYnV0ZXMsXG4gICAgICAgICAgYyA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICB1ID0gYy5nbDtcbiAgICAgIGlmIChjLmV4dFZlcnRleEFycmF5T2JqZWN0KSB0aGlzLnZhbyAmJiB0aGlzLmRlc3Ryb3koKSwgdGhpcy52YW8gPSBjLmV4dFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZVZlcnRleEFycmF5T0VTKCksIGMuYmluZFZlcnRleEFycmF5T0VTLnNldCh0aGlzLnZhbyksIHMgPSAwLCB0aGlzLmJvdW5kUHJvZ3JhbSA9IHQsIHRoaXMuYm91bmRMYXlvdXRWZXJ0ZXhCdWZmZXIgPSBlLCB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzID0gaSwgdGhpcy5ib3VuZEluZGV4QnVmZmVyID0gbywgdGhpcy5ib3VuZFZlcnRleE9mZnNldCA9IHIsIHRoaXMuYm91bmREeW5hbWljVmVydGV4QnVmZmVyID0gYSwgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIyID0gbjtlbHNlIHtcbiAgICAgICAgcyA9IGMuY3VycmVudE51bUF0dHJpYnV0ZXMgfHwgMDtcblxuICAgICAgICBmb3IgKHZhciBoID0gbDsgaCA8IHM7IGgrKykge1xuICAgICAgICAgIHUuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLmVuYWJsZUF0dHJpYnV0ZXModSwgdCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwLCBkID0gaTsgcCA8IGQubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgZFtwXS5lbmFibGVBdHRyaWJ1dGVzKHUsIHQpO1xuICAgICAgfVxuXG4gICAgICBhICYmIGEuZW5hYmxlQXR0cmlidXRlcyh1LCB0KSwgbiAmJiBuLmVuYWJsZUF0dHJpYnV0ZXModSwgdCksIGUuYmluZCgpLCBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKHUsIHQsIHIpO1xuXG4gICAgICBmb3IgKHZhciBfID0gMCwgZiA9IGk7IF8gPCBmLmxlbmd0aDsgXyArPSAxKSB7XG4gICAgICAgIHZhciBtID0gZltfXTtcbiAgICAgICAgbS5iaW5kKCksIG0uc2V0VmVydGV4QXR0cmliUG9pbnRlcnModSwgdCwgcik7XG4gICAgICB9XG5cbiAgICAgIGEgJiYgKGEuYmluZCgpLCBhLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKHUsIHQsIHIpKSwgbyAmJiBvLmJpbmQoKSwgbiAmJiAobi5iaW5kKCksIG4uc2V0VmVydGV4QXR0cmliUG9pbnRlcnModSwgdCwgcikpLCBjLmN1cnJlbnROdW1BdHRyaWJ1dGVzID0gbDtcbiAgICB9LCB5aS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudmFvICYmICh0aGlzLmNvbnRleHQuZXh0VmVydGV4QXJyYXlPYmplY3QuZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pLCB0aGlzLnZhbyA9IG51bGwpO1xuICAgIH07XG5cbiAgICB2YXIgYmkgPSBmdW5jdGlvbiBiaSh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IHQuZ2w7XG4gICAgICB0aGlzLnByb2dyYW0gPSBuLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgICAgZm9yICh2YXIgcyA9IHhpKGkuc3RhdGljQXR0cmlidXRlcyksIGwgPSBvID8gby5nZXRCaW5kZXJBdHRyaWJ1dGVzKCkgOiBbXSwgYyA9IHMuY29uY2F0KGwpLCB1ID0gaS5zdGF0aWNVbmlmb3JtcyA/IHhpKGkuc3RhdGljVW5pZm9ybXMpIDogW10sIGggPSBvID8gby5nZXRCaW5kZXJVbmlmb3JtcygpIDogW10sIHAgPSBbXSwgZCA9IDAsIF8gPSB1LmNvbmNhdChoKTsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgdmFyIGYgPSBfW2RdO1xuICAgICAgICBwLmluZGV4T2YoZikgPCAwICYmIHAucHVzaChmKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG0gPSBvID8gby5kZWZpbmVzKCkgOiBbXTtcbiAgICAgIGEgJiYgbS5wdXNoKFwiI2RlZmluZSBPVkVSRFJBV19JTlNQRUNUT1I7XCIpO1xuICAgICAgdmFyIGcgPSBtLmNvbmNhdChHZS5mcmFnbWVudFNvdXJjZSwgaS5mcmFnbWVudFNvdXJjZSkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICB2ID0gbS5jb25jYXQoR2UudmVydGV4U291cmNlLCBpLnZlcnRleFNvdXJjZSkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICB5ID0gbi5jcmVhdGVTaGFkZXIobi5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKG4uaXNDb250ZXh0TG9zdCgpKSB0aGlzLmZhaWxlZFRvQ3JlYXRlID0gITA7ZWxzZSB7XG4gICAgICAgIG4uc2hhZGVyU291cmNlKHksIGcpLCBuLmNvbXBpbGVTaGFkZXIoeSksIG4uYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgeSk7XG4gICAgICAgIHZhciB4ID0gbi5jcmVhdGVTaGFkZXIobi5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgaWYgKG4uaXNDb250ZXh0TG9zdCgpKSB0aGlzLmZhaWxlZFRvQ3JlYXRlID0gITA7ZWxzZSB7XG4gICAgICAgICAgbi5zaGFkZXJTb3VyY2UoeCwgdiksIG4uY29tcGlsZVNoYWRlcih4KSwgbi5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB4KSwgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgdmFyIGIgPSB7fTtcbiAgICAgICAgICB0aGlzLm51bUF0dHJpYnV0ZXMgPSBjLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgdGhpcy5udW1BdHRyaWJ1dGVzOyB3KyspIHtcbiAgICAgICAgICAgIGNbd10gJiYgKG4uYmluZEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdywgY1t3XSksIHRoaXMuYXR0cmlidXRlc1tjW3ddXSA9IHcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4ubGlua1Byb2dyYW0odGhpcy5wcm9ncmFtKSwgbi5kZWxldGVTaGFkZXIoeCksIG4uZGVsZXRlU2hhZGVyKHkpO1xuXG4gICAgICAgICAgZm9yICh2YXIgVCA9IDA7IFQgPCBwLmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICB2YXIgRSA9IHBbVF07XG5cbiAgICAgICAgICAgIGlmIChFICYmICFiW0VdKSB7XG4gICAgICAgICAgICAgIHZhciBJID0gbi5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBFKTtcbiAgICAgICAgICAgICAgSSAmJiAoYltFXSA9IEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZml4ZWRVbmlmb3JtcyA9IHIodCwgYiksIHRoaXMuYmluZGVyVW5pZm9ybXMgPSBvID8gby5nZXRVbmlmb3Jtcyh0LCBiKSA6IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdpKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gMSAvIHBlKGksIDEsIGUudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICByID0gTWF0aC5wb3coMiwgaS50aWxlSUQub3ZlcnNjYWxlZFopLFxuICAgICAgICAgIGEgPSBpLnRpbGVTaXplICogTWF0aC5wb3coMiwgZS50cmFuc2Zvcm0udGlsZVpvb20pIC8gcixcbiAgICAgICAgICBuID0gYSAqIChpLnRpbGVJRC5jYW5vbmljYWwueCArIGkudGlsZUlELndyYXAgKiByKSxcbiAgICAgICAgICBzID0gYSAqIGkudGlsZUlELmNhbm9uaWNhbC55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgdV90ZXhzaXplOiBpLmltYWdlQXRsYXNUZXh0dXJlLnNpemUsXG4gICAgICAgIHVfc2NhbGU6IFtvLCB0LmZyb21TY2FsZSwgdC50b1NjYWxlXSxcbiAgICAgICAgdV9mYWRlOiB0LnQsXG4gICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IFtuID4+IDE2LCBzID4+IDE2XSxcbiAgICAgICAgdV9waXhlbF9jb29yZF9sb3dlcjogWzY1NTM1ICYgbiwgNjU1MzUgJiBzXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBiaS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoLCBwLCBkLCBfLCBmKSB7XG4gICAgICB2YXIgbSxcbiAgICAgICAgICBnID0gdC5nbDtcblxuICAgICAgaWYgKCF0aGlzLmZhaWxlZFRvQ3JlYXRlKSB7XG4gICAgICAgIGZvciAodmFyIHYgaW4gdC5wcm9ncmFtLnNldCh0aGlzLnByb2dyYW0pLCB0LnNldERlcHRoTW9kZShpKSwgdC5zZXRTdGVuY2lsTW9kZShvKSwgdC5zZXRDb2xvck1vZGUociksIHQuc2V0Q3VsbEZhY2UoYSksIHRoaXMuZml4ZWRVbmlmb3Jtcykge1xuICAgICAgICAgIHRoaXMuZml4ZWRVbmlmb3Jtc1t2XS5zZXQoblt2XSk7XG4gICAgICAgIH1cblxuICAgICAgICBkICYmIGQuc2V0VW5pZm9ybXModCwgdGhpcy5iaW5kZXJVbmlmb3JtcywgaCwge1xuICAgICAgICAgIHpvb206IHBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IChtID0ge30sIG1bZy5MSU5FU10gPSAyLCBtW2cuVFJJQU5HTEVTXSA9IDMsIG1bZy5MSU5FX1NUUklQXSA9IDEsIG0pW2VdLCB4ID0gMCwgYiA9IHUuZ2V0KCk7IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgdmFyIHcgPSBiW3hdLFxuICAgICAgICAgICAgICBUID0gdy52YW9zIHx8ICh3LnZhb3MgPSB7fSk7XG4gICAgICAgICAgKFRbc10gfHwgKFRbc10gPSBuZXcgeWkoKSkpLmJpbmQodCwgdGhpcywgbCwgZCA/IGQuZ2V0UGFpbnRWZXJ0ZXhCdWZmZXJzKCkgOiBbXSwgYywgdy52ZXJ0ZXhPZmZzZXQsIF8sIGYpLCBnLmRyYXdFbGVtZW50cyhlLCB3LnByaW1pdGl2ZUxlbmd0aCAqIHksIGcuVU5TSUdORURfU0hPUlQsIHcucHJpbWl0aXZlT2Zmc2V0ICogeSAqIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBUaSA9IGZ1bmN0aW9uIFRpKGUsIGksIG8sIHIpIHtcbiAgICAgIHZhciBhID0gaS5zdHlsZS5saWdodCxcbiAgICAgICAgICBuID0gYS5wcm9wZXJ0aWVzLmdldChcInBvc2l0aW9uXCIpLFxuICAgICAgICAgIHMgPSBbbi54LCBuLnksIG4uel0sXG4gICAgICAgICAgbCA9IHQuY3JlYXRlJDEoKTtcbiAgICAgIFwidmlld3BvcnRcIiA9PT0gYS5wcm9wZXJ0aWVzLmdldChcImFuY2hvclwiKSAmJiB0LmZyb21Sb3RhdGlvbihsLCAtaS50cmFuc2Zvcm0uYW5nbGUpLCB0LnRyYW5zZm9ybU1hdDMocywgcywgbCk7XG4gICAgICB2YXIgYyA9IGEucHJvcGVydGllcy5nZXQoXCJjb2xvclwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiBlLFxuICAgICAgICB1X2xpZ2h0cG9zOiBzLFxuICAgICAgICB1X2xpZ2h0aW50ZW5zaXR5OiBhLnByb3BlcnRpZXMuZ2V0KFwiaW50ZW5zaXR5XCIpLFxuICAgICAgICB1X2xpZ2h0Y29sb3I6IFtjLnIsIGMuZywgYy5iXSxcbiAgICAgICAgdV92ZXJ0aWNhbF9ncmFkaWVudDogK28sXG4gICAgICAgIHVfb3BhY2l0eTogclxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBFaSA9IGZ1bmN0aW9uIEVpKGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIHJldHVybiB0LmV4dGVuZChUaShlLCBpLCBvLCByKSwgd2kobiwgaSwgcyksIHtcbiAgICAgICAgdV9oZWlnaHRfZmFjdG9yOiAtTWF0aC5wb3coMiwgYS5vdmVyc2NhbGVkWikgLyBzLnRpbGVTaXplIC8gOFxuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgSWkgPSBmdW5jdGlvbiBJaSh0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogdFxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBQaSA9IGZ1bmN0aW9uIFBpKGUsIGksIG8sIHIpIHtcbiAgICAgIHJldHVybiB0LmV4dGVuZChJaShlKSwgd2kobywgaSwgcikpO1xuICAgIH0sXG4gICAgICAgIFNpID0gZnVuY3Rpb24gU2kodCwgZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgIHVfd29ybGQ6IGVcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgQ2kgPSBmdW5jdGlvbiBDaShlLCBpLCBvLCByLCBhKSB7XG4gICAgICByZXR1cm4gdC5leHRlbmQoUGkoZSwgaSwgbywgciksIHtcbiAgICAgICAgdV93b3JsZDogYVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgemkgPSBmdW5jdGlvbiB6aShlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSBlLnRyYW5zZm9ybTtcblxuICAgICAgaWYgKFwibWFwXCIgPT09IHIucGFpbnQuZ2V0KFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiKSkge1xuICAgICAgICB2YXIgbCA9IHBlKG8sIDEsIHMuem9vbSk7XG4gICAgICAgIGEgPSAhMCwgbiA9IFtsLCBsXTtcbiAgICAgIH0gZWxzZSBhID0gITEsIG4gPSBzLnBpeGVsc1RvR0xVbml0cztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiBzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsXG4gICAgICAgIHVfc2NhbGVfd2l0aF9tYXA6ICsoXCJtYXBcIiA9PT0gci5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikpLFxuICAgICAgICB1X21hdHJpeDogZS50cmFuc2xhdGVQb3NNYXRyaXgoaS5wb3NNYXRyaXgsIG8sIHIucGFpbnQuZ2V0KFwiY2lyY2xlLXRyYW5zbGF0ZVwiKSwgci5wYWludC5nZXQoXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiKSksXG4gICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6ICthLFxuICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHVfZXh0cnVkZV9zY2FsZTogblxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBEaSA9IGZ1bmN0aW9uIERpKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gcGUoaSwgMSwgZS56b29tKSxcbiAgICAgICAgICByID0gTWF0aC5wb3coMiwgZS56b29tIC0gaS50aWxlSUQub3ZlcnNjYWxlZFopLFxuICAgICAgICAgIGEgPSBpLnRpbGVJRC5vdmVyc2NhbGVGYWN0b3IoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IGUuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSxcbiAgICAgICAgdV9waXhlbHNfdG9fdGlsZV91bml0czogbyxcbiAgICAgICAgdV9leHRydWRlX3NjYWxlOiBbZS5waXhlbHNUb0dMVW5pdHNbMF0gLyAobyAqIHIpLCBlLnBpeGVsc1RvR0xVbml0c1sxXSAvIChvICogcildLFxuICAgICAgICB1X292ZXJzY2FsZV9mYWN0b3I6IGFcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgQWkgPSBmdW5jdGlvbiBBaSh0LCBlLCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogdCxcbiAgICAgICAgdV9pbnZfbWF0cml4OiBlLFxuICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IGkuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSxcbiAgICAgICAgdV92aWV3cG9ydF9zaXplOiBbaS53aWR0aCwgaS5oZWlnaHRdXG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIE1pID0gZnVuY3Rpb24gTWkodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IDEpLCB7XG4gICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICB1X2NvbG9yOiBlLFxuICAgICAgICB1X292ZXJsYXk6IDAsXG4gICAgICAgIHVfb3ZlcmxheV9zY2FsZTogaVxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBMaSA9IGZ1bmN0aW9uIExpKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiB0XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIFJpID0gZnVuY3Rpb24gUmkodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgIHVfZXh0cnVkZV9zY2FsZTogcGUoZSwgMSwgaSksXG4gICAgICAgIHVfaW50ZW5zaXR5OiBvXG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGtpID0gZnVuY3Rpb24ga2koZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBlLnRyYW5zZm9ybTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiBOaShlLCBpLCBvKSxcbiAgICAgICAgdV9yYXRpbzogMSAvIHBlKGksIDEsIHIuem9vbSksXG4gICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgdV91bml0c190b19waXhlbHM6IFsxIC8gci5waXhlbHNUb0dMVW5pdHNbMF0sIDEgLyByLnBpeGVsc1RvR0xVbml0c1sxXV1cbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgQmkgPSBmdW5jdGlvbiBCaShlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4gdC5leHRlbmQoa2koZSwgaSwgbyksIHtcbiAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgdV9pbWFnZV9oZWlnaHQ6IHJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIE9pID0gZnVuY3Rpb24gT2koZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSBlLnRyYW5zZm9ybSxcbiAgICAgICAgICBuID0gVWkoaSwgYSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogTmkoZSwgaSwgbyksXG4gICAgICAgIHVfdGV4c2l6ZTogaS5pbWFnZUF0bGFzVGV4dHVyZS5zaXplLFxuICAgICAgICB1X3JhdGlvOiAxIC8gcGUoaSwgMSwgYS56b29tKSxcbiAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICB1X3NjYWxlOiBbbiwgci5mcm9tU2NhbGUsIHIudG9TY2FsZV0sXG4gICAgICAgIHVfZmFkZTogci50LFxuICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogWzEgLyBhLnBpeGVsc1RvR0xVbml0c1swXSwgMSAvIGEucGl4ZWxzVG9HTFVuaXRzWzFdXVxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBGaSA9IGZ1bmN0aW9uIEZpKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gZS5saW5lQXRsYXMsXG4gICAgICAgICAgcyA9IFVpKGksIGUudHJhbnNmb3JtKSxcbiAgICAgICAgICBsID0gXCJyb3VuZFwiID09PSBvLmxheW91dC5nZXQoXCJsaW5lLWNhcFwiKSxcbiAgICAgICAgICBjID0gbi5nZXREYXNoKHIuZnJvbSwgbCksXG4gICAgICAgICAgdSA9IG4uZ2V0RGFzaChyLnRvLCBsKSxcbiAgICAgICAgICBoID0gYy53aWR0aCAqIGEuZnJvbVNjYWxlLFxuICAgICAgICAgIHAgPSB1LndpZHRoICogYS50b1NjYWxlO1xuICAgICAgcmV0dXJuIHQuZXh0ZW5kKGtpKGUsIGksIG8pLCB7XG4gICAgICAgIHVfcGF0dGVybnNjYWxlX2E6IFtzIC8gaCwgLWMuaGVpZ2h0IC8gMl0sXG4gICAgICAgIHVfcGF0dGVybnNjYWxlX2I6IFtzIC8gcCwgLXUuaGVpZ2h0IC8gMl0sXG4gICAgICAgIHVfc2RmZ2FtbWE6IG4ud2lkdGggLyAoMjU2ICogTWF0aC5taW4oaCwgcCkgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbykgLyAyLFxuICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICB1X3RleF95X2E6IGMueSxcbiAgICAgICAgdV90ZXhfeV9iOiB1LnksXG4gICAgICAgIHVfbWl4OiBhLnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBVaSh0LCBlKSB7XG4gICAgICByZXR1cm4gMSAvIHBlKHQsIDEsIGUudGlsZVpvb20pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE5pKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiB0LnRyYW5zbGF0ZVBvc01hdHJpeChlLnRpbGVJRC5wb3NNYXRyaXgsIGUsIGkucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGVcIiksIGkucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgWmkgPSBmdW5jdGlvbiBaaSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X21hdHJpeDogdCxcbiAgICAgICAgdV90bF9wYXJlbnQ6IGUsXG4gICAgICAgIHVfc2NhbGVfcGFyZW50OiBpLFxuICAgICAgICB1X2J1ZmZlcl9zY2FsZTogMSxcbiAgICAgICAgdV9mYWRlX3Q6IG8ubWl4LFxuICAgICAgICB1X29wYWNpdHk6IG8ub3BhY2l0eSAqIHIucGFpbnQuZ2V0KFwicmFzdGVyLW9wYWNpdHlcIiksXG4gICAgICAgIHVfaW1hZ2UwOiAwLFxuICAgICAgICB1X2ltYWdlMTogMSxcbiAgICAgICAgdV9icmlnaHRuZXNzX2xvdzogci5wYWludC5nZXQoXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIiksXG4gICAgICAgIHVfYnJpZ2h0bmVzc19oaWdoOiByLnBhaW50LmdldChcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiKSxcbiAgICAgICAgdV9zYXR1cmF0aW9uX2ZhY3RvcjogKG4gPSByLnBhaW50LmdldChcInJhc3Rlci1zYXR1cmF0aW9uXCIpLCBuID4gMCA/IDEgLSAxIC8gKDEuMDAxIC0gbikgOiAtbiksXG4gICAgICAgIHVfY29udHJhc3RfZmFjdG9yOiAoYSA9IHIucGFpbnQuZ2V0KFwicmFzdGVyLWNvbnRyYXN0XCIpLCBhID4gMCA/IDEgLyAoMSAtIGEpIDogMSArIGEpLFxuICAgICAgICB1X3NwaW5fd2VpZ2h0czogcWkoci5wYWludC5nZXQoXCJyYXN0ZXItaHVlLXJvdGF0ZVwiKSlcbiAgICAgIH07XG4gICAgICB2YXIgYSwgbjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcWkodCkge1xuICAgICAgdCAqPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgdmFyIGUgPSBNYXRoLnNpbih0KSxcbiAgICAgICAgICBpID0gTWF0aC5jb3ModCk7XG4gICAgICByZXR1cm4gWygyICogaSArIDEpIC8gMywgKC1NYXRoLnNxcnQoMykgKiBlIC0gaSArIDEpIC8gMywgKE1hdGguc3FydCgzKSAqIGUgLSBpICsgMSkgLyAzXTtcbiAgICB9XG5cbiAgICB2YXIgamksXG4gICAgICAgIFZpID0gZnVuY3Rpb24gVmkodCwgZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYykge1xuICAgICAgdmFyIHUgPSByLnRyYW5zZm9ybTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiArKFwiY29uc3RhbnRcIiA9PT0gdCB8fCBcInNvdXJjZVwiID09PSB0KSxcbiAgICAgICAgdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQ6ICsoXCJjb25zdGFudFwiID09PSB0IHx8IFwiY2FtZXJhXCIgPT09IHQpLFxuICAgICAgICB1X3NpemVfdDogZSA/IGUudVNpemVUIDogMCxcbiAgICAgICAgdV9zaXplOiBlID8gZS51U2l6ZSA6IDAsXG4gICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogdS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlLFxuICAgICAgICB1X3BpdGNoOiB1LnBpdGNoIC8gMzYwICogMiAqIE1hdGguUEksXG4gICAgICAgIHVfcm90YXRlX3N5bWJvbDogK2ksXG4gICAgICAgIHVfYXNwZWN0X3JhdGlvOiB1LndpZHRoIC8gdS5oZWlnaHQsXG4gICAgICAgIHVfZmFkZV9jaGFuZ2U6IHIub3B0aW9ucy5mYWRlRHVyYXRpb24gPyByLnN5bWJvbEZhZGVDaGFuZ2UgOiAxLFxuICAgICAgICB1X21hdHJpeDogYSxcbiAgICAgICAgdV9sYWJlbF9wbGFuZV9tYXRyaXg6IG4sXG4gICAgICAgIHVfY29vcmRfbWF0cml4OiBzLFxuICAgICAgICB1X2lzX3RleHQ6ICtsLFxuICAgICAgICB1X3BpdGNoX3dpdGhfbWFwOiArbyxcbiAgICAgICAgdV90ZXhzaXplOiBjLFxuICAgICAgICB1X3RleHR1cmU6IDBcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgR2kgPSBmdW5jdGlvbiBHaShlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoKSB7XG4gICAgICB2YXIgcCA9IGEudHJhbnNmb3JtO1xuICAgICAgcmV0dXJuIHQuZXh0ZW5kKFZpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUpLCB7XG4gICAgICAgIHVfZ2FtbWFfc2NhbGU6IHIgPyBNYXRoLmNvcyhwLl9waXRjaCkgKiBwLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UgOiAxLFxuICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHVfaXNfaGFsbzogK2hcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIFdpID0gZnVuY3Rpb24gV2koZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSkge1xuICAgICAgcmV0dXJuIHQuZXh0ZW5kKEdpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsICEwLCBjLCAhMCksIHtcbiAgICAgICAgdV90ZXhzaXplX2ljb246IHUsXG4gICAgICAgIHVfdGV4dHVyZV9pY29uOiAxXG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICBYaSA9IGZ1bmN0aW9uIFhpKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICB1X29wYWNpdHk6IGUsXG4gICAgICAgIHVfY29sb3I6IGlcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgSGkgPSBmdW5jdGlvbiBIaShlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICByZXR1cm4gdC5leHRlbmQoZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgdmFyIHIgPSBpLmltYWdlTWFuYWdlci5nZXRQYXR0ZXJuKHQuZnJvbS50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGEgPSBpLmltYWdlTWFuYWdlci5nZXRQYXR0ZXJuKHQudG8udG9TdHJpbmcoKSksXG4gICAgICAgICAgICBuID0gaS5pbWFnZU1hbmFnZXIuZ2V0UGl4ZWxTaXplKCksXG4gICAgICAgICAgICBzID0gbi53aWR0aCxcbiAgICAgICAgICAgIGwgPSBuLmhlaWdodCxcbiAgICAgICAgICAgIGMgPSBNYXRoLnBvdygyLCBvLnRpbGVJRC5vdmVyc2NhbGVkWiksXG4gICAgICAgICAgICB1ID0gby50aWxlU2l6ZSAqIE1hdGgucG93KDIsIGkudHJhbnNmb3JtLnRpbGVab29tKSAvIGMsXG4gICAgICAgICAgICBoID0gdSAqIChvLnRpbGVJRC5jYW5vbmljYWwueCArIG8udGlsZUlELndyYXAgKiBjKSxcbiAgICAgICAgICAgIHAgPSB1ICogby50aWxlSUQuY2Fub25pY2FsLnk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgICB1X3BhdHRlcm5fdGxfYTogci50bCxcbiAgICAgICAgICB1X3BhdHRlcm5fYnJfYTogci5icixcbiAgICAgICAgICB1X3BhdHRlcm5fdGxfYjogYS50bCxcbiAgICAgICAgICB1X3BhdHRlcm5fYnJfYjogYS5icixcbiAgICAgICAgICB1X3RleHNpemU6IFtzLCBsXSxcbiAgICAgICAgICB1X21peDogZS50LFxuICAgICAgICAgIHVfcGF0dGVybl9zaXplX2E6IHIuZGlzcGxheVNpemUsXG4gICAgICAgICAgdV9wYXR0ZXJuX3NpemVfYjogYS5kaXNwbGF5U2l6ZSxcbiAgICAgICAgICB1X3NjYWxlX2E6IGUuZnJvbVNjYWxlLFxuICAgICAgICAgIHVfc2NhbGVfYjogZS50b1NjYWxlLFxuICAgICAgICAgIHVfdGlsZV91bml0c190b19waXhlbHM6IDEgLyBwZShvLCAxLCBpLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgdV9waXhlbF9jb29yZF91cHBlcjogW2ggPj4gMTYsIHAgPj4gMTZdLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IFs2NTUzNSAmIGgsIDY1NTM1ICYgcF1cbiAgICAgICAgfTtcbiAgICAgIH0ociwgbiwgbywgYSksIHtcbiAgICAgICAgdV9tYXRyaXg6IGUsXG4gICAgICAgIHVfb3BhY2l0eTogaVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgS2kgPSB7XG4gICAgICBmaWxsRXh0cnVzaW9uOiBmdW5jdGlvbiBmaWxsRXh0cnVzaW9uKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfbGlnaHRwb3M6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfbGlnaHRwb3MpLFxuICAgICAgICAgIHVfbGlnaHRpbnRlbnNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfbGlnaHRpbnRlbnNpdHkpLFxuICAgICAgICAgIHVfbGlnaHRjb2xvcjogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9saWdodGNvbG9yKSxcbiAgICAgICAgICB1X3ZlcnRpY2FsX2dyYWRpZW50OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3ZlcnRpY2FsX2dyYWRpZW50KSxcbiAgICAgICAgICB1X29wYWNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3BhY2l0eSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmaWxsRXh0cnVzaW9uUGF0dGVybjogZnVuY3Rpb24gZmlsbEV4dHJ1c2lvblBhdHRlcm4oZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV9saWdodHBvczogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9saWdodHBvcyksXG4gICAgICAgICAgdV9saWdodGludGVuc2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9saWdodGludGVuc2l0eSksXG4gICAgICAgICAgdV9saWdodGNvbG9yOiBuZXcgdC5Vbmlmb3JtM2YoZSwgaS51X2xpZ2h0Y29sb3IpLFxuICAgICAgICAgIHVfdmVydGljYWxfZ3JhZGllbnQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdmVydGljYWxfZ3JhZGllbnQpLFxuICAgICAgICAgIHVfaGVpZ2h0X2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9oZWlnaHRfZmFjdG9yKSxcbiAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgdV9waXhlbF9jb29yZF91cHBlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF91cHBlciksXG4gICAgICAgICAgdV9waXhlbF9jb29yZF9sb3dlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF9sb3dlciksXG4gICAgICAgICAgdV9zY2FsZTogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9zY2FsZSksXG4gICAgICAgICAgdV9mYWRlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGUpLFxuICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmaWxsUGF0dGVybjogZnVuY3Rpb24gZmlsbFBhdHRlcm4oZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfdXBwZXIpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfbG93ZXIpLFxuICAgICAgICAgIHVfc2NhbGU6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc2NhbGUpLFxuICAgICAgICAgIHVfZmFkZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZpbGxPdXRsaW5lOiBmdW5jdGlvbiBmaWxsT3V0bGluZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3dvcmxkOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3dvcmxkKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZpbGxPdXRsaW5lUGF0dGVybjogZnVuY3Rpb24gZmlsbE91dGxpbmVQYXR0ZXJuKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfd29ybGQ6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfd29ybGQpLFxuICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgIHVfdGV4c2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV90ZXhzaXplKSxcbiAgICAgICAgICB1X3BpeGVsX2Nvb3JkX3VwcGVyOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BpeGVsX2Nvb3JkX3VwcGVyKSxcbiAgICAgICAgICB1X3BpeGVsX2Nvb3JkX2xvd2VyOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BpeGVsX2Nvb3JkX2xvd2VyKSxcbiAgICAgICAgICB1X3NjYWxlOiBuZXcgdC5Vbmlmb3JtM2YoZSwgaS51X3NjYWxlKSxcbiAgICAgICAgICB1X2ZhZGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZmFkZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UpLFxuICAgICAgICAgIHVfc2NhbGVfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfc2NhbGVfd2l0aF9tYXApLFxuICAgICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcGl0Y2hfd2l0aF9tYXApLFxuICAgICAgICAgIHVfZXh0cnVkZV9zY2FsZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9leHRydWRlX3NjYWxlKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb2xsaXNpb25Cb3g6IGZ1bmN0aW9uIGNvbGxpc2lvbkJveChlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgdV9waXhlbHNfdG9fdGlsZV91bml0czogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9waXhlbHNfdG9fdGlsZV91bml0cyksXG4gICAgICAgICAgdV9leHRydWRlX3NjYWxlOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X2V4dHJ1ZGVfc2NhbGUpLFxuICAgICAgICAgIHVfb3ZlcnNjYWxlX2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vdmVyc2NhbGVfZmFjdG9yKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNvbGxpc2lvbkNpcmNsZTogZnVuY3Rpb24gY29sbGlzaW9uQ2lyY2xlKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfaW52X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9pbnZfbWF0cml4KSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgdV92aWV3cG9ydF9zaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3ZpZXdwb3J0X3NpemUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X2NvbG9yOiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X2NvbG9yKSxcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfb3ZlcmxheTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9vdmVybGF5KSxcbiAgICAgICAgICB1X292ZXJsYXlfc2NhbGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3ZlcmxheV9zY2FsZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjbGlwcGluZ01hc2s6IGZ1bmN0aW9uIGNsaXBwaW5nTWFzayhlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGhlYXRtYXA6IGZ1bmN0aW9uIGhlYXRtYXAoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfZXh0cnVkZV9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9leHRydWRlX3NjYWxlKSxcbiAgICAgICAgICB1X2ludGVuc2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9pbnRlbnNpdHkpLFxuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBoZWF0bWFwVGV4dHVyZTogZnVuY3Rpb24gaGVhdG1hcFRleHR1cmUoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV93b3JsZDogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV93b3JsZCksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV9jb2xvcl9yYW1wOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2NvbG9yX3JhbXApLFxuICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGhpbGxzaGFkZTogZnVuY3Rpb24gaGlsbHNoYWRlKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgIHVfbGF0cmFuZ2U6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfbGF0cmFuZ2UpLFxuICAgICAgICAgIHVfbGlnaHQ6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfbGlnaHQpLFxuICAgICAgICAgIHVfc2hhZG93OiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X3NoYWRvdyksXG4gICAgICAgICAgdV9oaWdobGlnaHQ6IG5ldyB0LlVuaWZvcm1Db2xvcihlLCBpLnVfaGlnaGxpZ2h0KSxcbiAgICAgICAgICB1X2FjY2VudDogbmV3IHQuVW5pZm9ybUNvbG9yKGUsIGkudV9hY2NlbnQpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaGlsbHNoYWRlUHJlcGFyZTogZnVuY3Rpb24gaGlsbHNoYWRlUHJlcGFyZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICB1X2RpbWVuc2lvbjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9kaW1lbnNpb24pLFxuICAgICAgICAgIHVfem9vbTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV96b29tKSxcbiAgICAgICAgICB1X3VucGFjazogbmV3IHQuVW5pZm9ybTRmKGUsIGkudV91bnBhY2spXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGluZTogZnVuY3Rpb24gbGluZShlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3VuaXRzX3RvX3BpeGVscylcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsaW5lR3JhZGllbnQ6IGZ1bmN0aW9uIGxpbmVHcmFkaWVudChlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3VuaXRzX3RvX3BpeGVscyksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV9pbWFnZV9oZWlnaHQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfaW1hZ2VfaGVpZ2h0KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxpbmVQYXR0ZXJuOiBmdW5jdGlvbiBsaW5lUGF0dGVybihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgdV9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9yYXRpbyksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV91bml0c190b19waXhlbHMpLFxuICAgICAgICAgIHVfc2NhbGU6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc2NhbGUpLFxuICAgICAgICAgIHVfZmFkZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxpbmVTREY6IGZ1bmN0aW9uIGxpbmVTREYoZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgdV9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9yYXRpbyksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV91bml0c190b19waXhlbHMpLFxuICAgICAgICAgIHVfcGF0dGVybnNjYWxlX2E6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybnNjYWxlX2EpLFxuICAgICAgICAgIHVfcGF0dGVybnNjYWxlX2I6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybnNjYWxlX2IpLFxuICAgICAgICAgIHVfc2RmZ2FtbWE6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2RmZ2FtbWEpLFxuICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgIHVfdGV4X3lfYTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV90ZXhfeV9hKSxcbiAgICAgICAgICB1X3RleF95X2I6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdGV4X3lfYiksXG4gICAgICAgICAgdV9taXg6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfbWl4KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJhc3RlcjogZnVuY3Rpb24gcmFzdGVyKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfdGxfcGFyZW50OiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RsX3BhcmVudCksXG4gICAgICAgICAgdV9zY2FsZV9wYXJlbnQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2NhbGVfcGFyZW50KSxcbiAgICAgICAgICB1X2J1ZmZlcl9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9idWZmZXJfc2NhbGUpLFxuICAgICAgICAgIHVfZmFkZV90OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGVfdCksXG4gICAgICAgICAgdV9vcGFjaXR5OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X29wYWNpdHkpLFxuICAgICAgICAgIHVfaW1hZ2UwOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlMCksXG4gICAgICAgICAgdV9pbWFnZTE6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UxKSxcbiAgICAgICAgICB1X2JyaWdodG5lc3NfbG93OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2JyaWdodG5lc3NfbG93KSxcbiAgICAgICAgICB1X2JyaWdodG5lc3NfaGlnaDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9icmlnaHRuZXNzX2hpZ2gpLFxuICAgICAgICAgIHVfc2F0dXJhdGlvbl9mYWN0b3I6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2F0dXJhdGlvbl9mYWN0b3IpLFxuICAgICAgICAgIHVfY29udHJhc3RfZmFjdG9yOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2NvbnRyYXN0X2ZhY3RvciksXG4gICAgICAgICAgdV9zcGluX3dlaWdodHM6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc3Bpbl93ZWlnaHRzKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHN5bWJvbEljb246IGZ1bmN0aW9uIHN5bWJvbEljb24oZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3NpemVfem9vbV9jb25zdGFudCksXG4gICAgICAgICAgdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50KSxcbiAgICAgICAgICB1X3NpemVfdDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplX3QpLFxuICAgICAgICAgIHVfc2l6ZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplKSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgdV9waXRjaDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9waXRjaCksXG4gICAgICAgICAgdV9yb3RhdGVfc3ltYm9sOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3JvdGF0ZV9zeW1ib2wpLFxuICAgICAgICAgIHVfYXNwZWN0X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2FzcGVjdF9yYXRpbyksXG4gICAgICAgICAgdV9mYWRlX2NoYW5nZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlX2NoYW5nZSksXG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X2xhYmVsX3BsYW5lX21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9sYWJlbF9wbGFuZV9tYXRyaXgpLFxuICAgICAgICAgIHVfY29vcmRfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2Nvb3JkX21hdHJpeCksXG4gICAgICAgICAgdV9pc190ZXh0OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3RleHQpLFxuICAgICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcGl0Y2hfd2l0aF9tYXApLFxuICAgICAgICAgIHVfdGV4c2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV90ZXhzaXplKSxcbiAgICAgICAgICB1X3RleHR1cmU6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfdGV4dHVyZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzeW1ib2xTREY6IGZ1bmN0aW9uIHN5bWJvbFNERihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9pc19zaXplX3pvb21fY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV96b29tX2NvbnN0YW50KSxcbiAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpLFxuICAgICAgICAgIHVfc2l6ZV90OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemVfdCksXG4gICAgICAgICAgdV9zaXplOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemUpLFxuICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICB1X3BpdGNoOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3BpdGNoKSxcbiAgICAgICAgICB1X3JvdGF0ZV9zeW1ib2w6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcm90YXRlX3N5bWJvbCksXG4gICAgICAgICAgdV9hc3BlY3RfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfYXNwZWN0X3JhdGlvKSxcbiAgICAgICAgICB1X2ZhZGVfY2hhbmdlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGVfY2hhbmdlKSxcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfbGFiZWxfcGxhbmVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2xhYmVsX3BsYW5lX21hdHJpeCksXG4gICAgICAgICAgdV9jb29yZF9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfY29vcmRfbWF0cml4KSxcbiAgICAgICAgICB1X2lzX3RleHQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfdGV4dCksXG4gICAgICAgICAgdV9waXRjaF93aXRoX21hcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9waXRjaF93aXRoX21hcCksXG4gICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgIHVfdGV4dHVyZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV90ZXh0dXJlKSxcbiAgICAgICAgICB1X2dhbW1hX3NjYWxlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2dhbW1hX3NjYWxlKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgIHVfaXNfaGFsbzogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19oYWxvKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHN5bWJvbFRleHRBbmRJY29uOiBmdW5jdGlvbiBzeW1ib2xUZXh0QW5kSWNvbihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9pc19zaXplX3pvb21fY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV96b29tX2NvbnN0YW50KSxcbiAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpLFxuICAgICAgICAgIHVfc2l6ZV90OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemVfdCksXG4gICAgICAgICAgdV9zaXplOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemUpLFxuICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICB1X3BpdGNoOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3BpdGNoKSxcbiAgICAgICAgICB1X3JvdGF0ZV9zeW1ib2w6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcm90YXRlX3N5bWJvbCksXG4gICAgICAgICAgdV9hc3BlY3RfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfYXNwZWN0X3JhdGlvKSxcbiAgICAgICAgICB1X2ZhZGVfY2hhbmdlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGVfY2hhbmdlKSxcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfbGFiZWxfcGxhbmVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2xhYmVsX3BsYW5lX21hdHJpeCksXG4gICAgICAgICAgdV9jb29yZF9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfY29vcmRfbWF0cml4KSxcbiAgICAgICAgICB1X2lzX3RleHQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfdGV4dCksXG4gICAgICAgICAgdV9waXRjaF93aXRoX21hcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9waXRjaF93aXRoX21hcCksXG4gICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgIHVfdGV4c2l6ZV9pY29uOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemVfaWNvbiksXG4gICAgICAgICAgdV90ZXh0dXJlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3RleHR1cmUpLFxuICAgICAgICAgIHVfdGV4dHVyZV9pY29uOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3RleHR1cmVfaWNvbiksXG4gICAgICAgICAgdV9nYW1tYV9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9nYW1tYV9zY2FsZSksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICB1X2lzX2hhbG86IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfaGFsbylcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbiBiYWNrZ3JvdW5kKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KSxcbiAgICAgICAgICB1X2NvbG9yOiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X2NvbG9yKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmRQYXR0ZXJuOiBmdW5jdGlvbiBiYWNrZ3JvdW5kUGF0dGVybihlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICB1X29wYWNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3BhY2l0eSksXG4gICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgdV9wYXR0ZXJuX3RsX2E6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybl90bF9hKSxcbiAgICAgICAgICB1X3BhdHRlcm5fYnJfYTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9wYXR0ZXJuX2JyX2EpLFxuICAgICAgICAgIHVfcGF0dGVybl90bF9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fdGxfYiksXG4gICAgICAgICAgdV9wYXR0ZXJuX2JyX2I6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybl9icl9iKSxcbiAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgdV9taXg6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfbWl4KSxcbiAgICAgICAgICB1X3BhdHRlcm5fc2l6ZV9hOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fc2l6ZV9hKSxcbiAgICAgICAgICB1X3BhdHRlcm5fc2l6ZV9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fc2l6ZV9iKSxcbiAgICAgICAgICB1X3NjYWxlX2E6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2NhbGVfYSksXG4gICAgICAgICAgdV9zY2FsZV9iOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NjYWxlX2IpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfdXBwZXIpLFxuICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfbG93ZXIpLFxuICAgICAgICAgIHVfdGlsZV91bml0c190b19waXhlbHM6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdGlsZV91bml0c190b19waXhlbHMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFlpKGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgIGZvciAodmFyIGwgPSBlLmNvbnRleHQsIGMgPSBsLmdsLCB1ID0gZS51c2VQcm9ncmFtKFwiY29sbGlzaW9uQm94XCIpLCBoID0gW10sIHAgPSAwLCBkID0gMCwgXyA9IDA7IF8gPCByLmxlbmd0aDsgXysrKSB7XG4gICAgICAgIHZhciBmID0gcltfXSxcbiAgICAgICAgICAgIG0gPSBpLmdldFRpbGUoZiksXG4gICAgICAgICAgICBnID0gbS5nZXRCdWNrZXQobyk7XG5cbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgdiA9IGYucG9zTWF0cml4O1xuICAgICAgICAgIDAgPT09IGFbMF0gJiYgMCA9PT0gYVsxXSB8fCAodiA9IGUudHJhbnNsYXRlUG9zTWF0cml4KGYucG9zTWF0cml4LCBtLCBhLCBuKSk7XG4gICAgICAgICAgdmFyIHkgPSBzID8gZy50ZXh0Q29sbGlzaW9uQm94IDogZy5pY29uQ29sbGlzaW9uQm94LFxuICAgICAgICAgICAgICB4ID0gZy5jb2xsaXNpb25DaXJjbGVBcnJheTtcblxuICAgICAgICAgIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBiID0gdC5jcmVhdGUoKSxcbiAgICAgICAgICAgICAgICB3ID0gdjtcbiAgICAgICAgICAgIHQubXVsKGIsIGcucGxhY2VtZW50SW52UHJvak1hdHJpeCwgZS50cmFuc2Zvcm0uZ2xDb29yZE1hdHJpeCksIHQubXVsKGIsIGIsIGcucGxhY2VtZW50Vmlld3BvcnRNYXRyaXgpLCBoLnB1c2goe1xuICAgICAgICAgICAgICBjaXJjbGVBcnJheTogeCxcbiAgICAgICAgICAgICAgY2lyY2xlT2Zmc2V0OiBkLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHcsXG4gICAgICAgICAgICAgIGludlRyYW5zZm9ybTogYlxuICAgICAgICAgICAgfSksIGQgPSBwICs9IHgubGVuZ3RoIC8gNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5ICYmIHUuZHJhdyhsLCBjLkxJTkVTLCBJdC5kaXNhYmxlZCwgUHQuZGlzYWJsZWQsIGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBDdC5kaXNhYmxlZCwgRGkodiwgZS50cmFuc2Zvcm0sIG0pLCBvLmlkLCB5LmxheW91dFZlcnRleEJ1ZmZlciwgeS5pbmRleEJ1ZmZlciwgeS5zZWdtZW50cywgbnVsbCwgZS50cmFuc2Zvcm0uem9vbSwgbnVsbCwgbnVsbCwgeS5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzICYmIGgubGVuZ3RoKSB7XG4gICAgICAgIHZhciBUID0gZS51c2VQcm9ncmFtKFwiY29sbGlzaW9uQ2lyY2xlXCIpLFxuICAgICAgICAgICAgRSA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0MmYxZjJpMTYoKTtcbiAgICAgICAgRS5yZXNpemUoNCAqIHApLCBFLl90cmltKCk7XG5cbiAgICAgICAgZm9yICh2YXIgSSA9IDAsIFAgPSAwLCBTID0gaDsgUCA8IFMubGVuZ3RoOyBQICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBDID0gU1tQXSwgeiA9IDA7IHogPCBDLmNpcmNsZUFycmF5Lmxlbmd0aCAvIDQ7IHorKykge1xuICAgICAgICAgICAgdmFyIEQgPSA0ICogeixcbiAgICAgICAgICAgICAgICBBID0gQy5jaXJjbGVBcnJheVtEICsgMF0sXG4gICAgICAgICAgICAgICAgTSA9IEMuY2lyY2xlQXJyYXlbRCArIDFdLFxuICAgICAgICAgICAgICAgIEwgPSBDLmNpcmNsZUFycmF5W0QgKyAyXSxcbiAgICAgICAgICAgICAgICBSID0gQy5jaXJjbGVBcnJheVtEICsgM107XG4gICAgICAgICAgICBFLmVtcGxhY2UoSSsrLCBBLCBNLCBMLCBSLCAwKSwgRS5lbXBsYWNlKEkrKywgQSwgTSwgTCwgUiwgMSksIEUuZW1wbGFjZShJKyssIEEsIE0sIEwsIFIsIDIpLCBFLmVtcGxhY2UoSSsrLCBBLCBNLCBMLCBSLCAzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAoIWppIHx8IGppLmxlbmd0aCA8IDIgKiBwKSAmJiAoamkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gMiAqIGUsXG4gICAgICAgICAgICAgIG8gPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDN1aTYoKTtcbiAgICAgICAgICBvLnJlc2l6ZShpKSwgby5fdHJpbSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBpOyByKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gNiAqIHI7XG4gICAgICAgICAgICBvLnVpbnQxNlthICsgMF0gPSA0ICogciArIDAsIG8udWludDE2W2EgKyAxXSA9IDQgKiByICsgMSwgby51aW50MTZbYSArIDJdID0gNCAqIHIgKyAyLCBvLnVpbnQxNlthICsgM10gPSA0ICogciArIDIsIG8udWludDE2W2EgKyA0XSA9IDQgKiByICsgMywgby51aW50MTZbYSArIDVdID0gNCAqIHIgKyAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9KHApKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gbC5jcmVhdGVJbmRleEJ1ZmZlcihqaSwgITApLCBCID0gbC5jcmVhdGVWZXJ0ZXhCdWZmZXIoRSwgdC5jb2xsaXNpb25DaXJjbGVMYXlvdXQubWVtYmVycywgITApLCBPID0gMCwgRiA9IGg7IE8gPCBGLmxlbmd0aDsgTyArPSAxKSB7XG4gICAgICAgICAgdmFyIFUgPSBGW09dLFxuICAgICAgICAgICAgICBOID0gQWkoVS50cmFuc2Zvcm0sIFUuaW52VHJhbnNmb3JtLCBlLnRyYW5zZm9ybSk7XG4gICAgICAgICAgVC5kcmF3KGwsIGMuVFJJQU5HTEVTLCBJdC5kaXNhYmxlZCwgUHQuZGlzYWJsZWQsIGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBDdC5kaXNhYmxlZCwgTiwgby5pZCwgQiwgaywgdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMiAqIFUuY2lyY2xlT2Zmc2V0LCBVLmNpcmNsZUFycmF5Lmxlbmd0aCwgVS5jaXJjbGVBcnJheS5sZW5ndGggLyAyKSwgbnVsbCwgZS50cmFuc2Zvcm0uem9vbSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBCLmRlc3Ryb3koKSwgay5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEppID0gdC5pZGVudGl0eShuZXcgRmxvYXQzMkFycmF5KDE2KSk7XG5cbiAgICBmdW5jdGlvbiBRaShlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyA9IHQuZ2V0QW5jaG9yQWxpZ25tZW50KGUpLFxuICAgICAgICAgIGwgPSAtKHMuaG9yaXpvbnRhbEFsaWduIC0gLjUpICogaSxcbiAgICAgICAgICBjID0gLShzLnZlcnRpY2FsQWxpZ24gLSAuNSkgKiBvLFxuICAgICAgICAgIHUgPSB0LmV2YWx1YXRlVmFyaWFibGVPZmZzZXQoZSwgcik7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQoKGwgLyBhICsgdVswXSkgKiBuLCAoYyAvIGEgKyB1WzFdKSAqIG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgpIHtcbiAgICAgIHZhciBwID0gZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LFxuICAgICAgICAgIGQgPSBlLnRleHQuZHluYW1pY0xheW91dFZlcnRleEFycmF5LFxuICAgICAgICAgIF8gPSBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEFycmF5LFxuICAgICAgICAgIGYgPSB7fTtcbiAgICAgIGQuY2xlYXIoKTtcblxuICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBwLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIHZhciBnID0gcC5nZXQobSksXG4gICAgICAgICAgICB2ID0gZy5oaWRkZW4gfHwgIWcuY3Jvc3NUaWxlSUQgfHwgZS5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmICFnLnBsYWNlZE9yaWVudGF0aW9uID8gbnVsbCA6IHJbZy5jcm9zc1RpbGVJRF07XG5cbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICB2YXIgeSA9IG5ldyB0LlBvaW50KGcuYW5jaG9yWCwgZy5hbmNob3JZKSxcbiAgICAgICAgICAgICAgeCA9ICR0KHksIG8gPyBsIDogcyksXG4gICAgICAgICAgICAgIGIgPSB0ZShuLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsIHguc2lnbmVkRGlzdGFuY2VGcm9tQ2FtZXJhKSxcbiAgICAgICAgICAgICAgdyA9IGEuZXZhbHVhdGVTaXplRm9yRmVhdHVyZShlLnRleHRTaXplRGF0YSwgdSwgZykgKiBiIC8gdC5PTkVfRU07XG4gICAgICAgICAgbyAmJiAodyAqPSBlLnRpbGVQaXhlbFJhdGlvIC8gYyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBUID0gUWkodi5hbmNob3IsIHYud2lkdGgsIHYuaGVpZ2h0LCB2LnRleHRPZmZzZXQsIHYudGV4dEJveFNjYWxlLCB3KSwgRSA9IG8gPyAkdCh5LmFkZChUKSwgcykucG9pbnQgOiB4LnBvaW50LmFkZChpID8gVC5yb3RhdGUoLW4uYW5nbGUpIDogVCksIEkgPSBlLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgZy5wbGFjZWRPcmllbnRhdGlvbiA9PT0gdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCA/IE1hdGguUEkgLyAyIDogMCwgUCA9IDA7IFAgPCBnLm51bUdseXBoczsgUCsrKSB7XG4gICAgICAgICAgICB0LmFkZER5bmFtaWNBdHRyaWJ1dGVzKGQsIEUsIEkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGggJiYgZy5hc3NvY2lhdGVkSWNvbkluZGV4ID49IDAgJiYgKGZbZy5hc3NvY2lhdGVkSWNvbkluZGV4XSA9IHtcbiAgICAgICAgICAgIHNoaWZ0ZWRBbmNob3I6IEUsXG4gICAgICAgICAgICBhbmdsZTogSVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgY2UoZy5udW1HbHlwaHMsIGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCkge1xuICAgICAgICBfLmNsZWFyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgUyA9IGUuaWNvbi5wbGFjZWRTeW1ib2xBcnJheSwgQyA9IDA7IEMgPCBTLmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgdmFyIHogPSBTLmdldChDKTtcbiAgICAgICAgICBpZiAoei5oaWRkZW4pIGNlKHoubnVtR2x5cGhzLCBfKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBEID0gZltDXTtcbiAgICAgICAgICAgIGlmIChEKSBmb3IgKHZhciBBID0gMDsgQSA8IHoubnVtR2x5cGhzOyBBKyspIHtcbiAgICAgICAgICAgICAgdC5hZGREeW5hbWljQXR0cmlidXRlcyhfLCBELnNoaWZ0ZWRBbmNob3IsIEQuYW5nbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGNlKHoubnVtR2x5cGhzLCBfKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKF8pO1xuICAgICAgfVxuXG4gICAgICBlLnRleHQuZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiBpLmljb25zSW5UZXh0ICYmIGUgPyBcInN5bWJvbFRleHRBbmRJY29uXCIgOiB0ID8gXCJzeW1ib2xTREZcIiA6IFwic3ltYm9sSWNvblwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVvKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgsIHApIHtcbiAgICAgIGZvciAodmFyIGQgPSBlLmNvbnRleHQsIF8gPSBkLmdsLCBmID0gZS50cmFuc2Zvcm0sIG0gPSBcIm1hcFwiID09PSBsLCBnID0gXCJtYXBcIiA9PT0gYywgdiA9IG0gJiYgXCJwb2ludFwiICE9PSBvLmxheW91dC5nZXQoXCJzeW1ib2wtcGxhY2VtZW50XCIpLCB5ID0gbSAmJiAhZyAmJiAhdiwgeCA9ICFvLmxheW91dC5nZXQoXCJzeW1ib2wtc29ydC1rZXlcIikuaXNDb25zdGFudCgpLCBiID0gITEsIHcgPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKDAsIEl0LlJlYWRPbmx5KSwgVCA9IG8ubGF5b3V0LmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpLCBFID0gW10sIEkgPSAwLCBQID0gcjsgSSA8IFAubGVuZ3RoOyBJICs9IDEpIHtcbiAgICAgICAgdmFyIFMgPSBQW0ldLFxuICAgICAgICAgICAgQyA9IGkuZ2V0VGlsZShTKSxcbiAgICAgICAgICAgIHogPSBDLmdldEJ1Y2tldChvKTtcblxuICAgICAgICBpZiAoeikge1xuICAgICAgICAgIHZhciBEID0gYSA/IHoudGV4dCA6IHouaWNvbjtcblxuICAgICAgICAgIGlmIChEICYmIEQuc2VnbWVudHMuZ2V0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgQSA9IEQucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmdldChvLmlkKSxcbiAgICAgICAgICAgICAgICBNID0gYSB8fCB6LnNkZkljb25zLFxuICAgICAgICAgICAgICAgIEwgPSBhID8gei50ZXh0U2l6ZURhdGEgOiB6Lmljb25TaXplRGF0YSxcbiAgICAgICAgICAgICAgICBSID0gZyB8fCAwICE9PSBmLnBpdGNoLFxuICAgICAgICAgICAgICAgIGsgPSBlLnVzZVByb2dyYW0odG8oTSwgYSwgeiksIEEpLFxuICAgICAgICAgICAgICAgIEIgPSB0LmV2YWx1YXRlU2l6ZUZvclpvb20oTCwgZi56b29tKSxcbiAgICAgICAgICAgICAgICBPID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIEYgPSBbMCwgMF0sXG4gICAgICAgICAgICAgICAgVSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBOID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIFogPSBudWxsLFxuICAgICAgICAgICAgICAgIHEgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYSkgVSA9IEMuZ2x5cGhBdGxhc1RleHR1cmUsIE4gPSBfLkxJTkVBUiwgTyA9IEMuZ2x5cGhBdGxhc1RleHR1cmUuc2l6ZSwgei5pY29uc0luVGV4dCAmJiAoRiA9IEMuaW1hZ2VBdGxhc1RleHR1cmUuc2l6ZSwgWiA9IEMuaW1hZ2VBdGxhc1RleHR1cmUsIHEgPSBSIHx8IGUub3B0aW9ucy5yb3RhdGluZyB8fCBlLm9wdGlvbnMuem9vbWluZyB8fCBcImNvbXBvc2l0ZVwiID09PSBMLmtpbmQgfHwgXCJjYW1lcmFcIiA9PT0gTC5raW5kID8gXy5MSU5FQVIgOiBfLk5FQVJFU1QpO2Vsc2Uge1xuICAgICAgICAgICAgICB2YXIgaiA9IDEgIT09IG8ubGF5b3V0LmdldChcImljb24tc2l6ZVwiKS5jb25zdGFudE9yKDApIHx8IHouaWNvbnNOZWVkTGluZWFyO1xuICAgICAgICAgICAgICBVID0gQy5pbWFnZUF0bGFzVGV4dHVyZSwgTiA9IE0gfHwgZS5vcHRpb25zLnJvdGF0aW5nIHx8IGUub3B0aW9ucy56b29taW5nIHx8IGogfHwgUiA/IF8uTElORUFSIDogXy5ORUFSRVNULCBPID0gQy5pbWFnZUF0bGFzVGV4dHVyZS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIFYgPSBwZShDLCAxLCBlLnRyYW5zZm9ybS56b29tKSxcbiAgICAgICAgICAgICAgICBHID0gSnQoUy5wb3NNYXRyaXgsIGcsIG0sIGUudHJhbnNmb3JtLCBWKSxcbiAgICAgICAgICAgICAgICBXID0gUXQoUy5wb3NNYXRyaXgsIGcsIG0sIGUudHJhbnNmb3JtLCBWKSxcbiAgICAgICAgICAgICAgICBYID0gVCAmJiB6Lmhhc1RleHREYXRhKCksXG4gICAgICAgICAgICAgICAgSCA9IFwibm9uZVwiICE9PSBvLmxheW91dC5nZXQoXCJpY29uLXRleHQtZml0XCIpICYmIFggJiYgei5oYXNJY29uRGF0YSgpO1xuICAgICAgICAgICAgdiAmJiBpZSh6LCBTLnBvc01hdHJpeCwgZSwgYSwgRywgVywgZywgdSk7XG4gICAgICAgICAgICB2YXIgSyA9IGUudHJhbnNsYXRlUG9zTWF0cml4KFMucG9zTWF0cml4LCBDLCBuLCBzKSxcbiAgICAgICAgICAgICAgICBZID0gdiB8fCBhICYmIFQgfHwgSCA/IEppIDogRyxcbiAgICAgICAgICAgICAgICBKID0gZS50cmFuc2xhdGVQb3NNYXRyaXgoVywgQywgbiwgcywgITApLFxuICAgICAgICAgICAgICAgIFEgPSBNICYmIDAgIT09IG8ucGFpbnQuZ2V0KGEgPyBcInRleHQtaGFsby13aWR0aFwiIDogXCJpY29uLWhhbG8td2lkdGhcIikuY29uc3RhbnRPcigxKSxcbiAgICAgICAgICAgICAgICAkID0ge1xuICAgICAgICAgICAgICBwcm9ncmFtOiBrLFxuICAgICAgICAgICAgICBidWZmZXJzOiBELFxuICAgICAgICAgICAgICB1bmlmb3JtVmFsdWVzOiBNID8gei5pY29uc0luVGV4dCA/IFdpKEwua2luZCwgQiwgeSwgZywgZSwgSywgWSwgSiwgTywgRikgOiBHaShMLmtpbmQsIEIsIHksIGcsIGUsIEssIFksIEosIGEsIE8sICEwKSA6IFZpKEwua2luZCwgQiwgeSwgZywgZSwgSywgWSwgSiwgYSwgTyksXG4gICAgICAgICAgICAgIGF0bGFzVGV4dHVyZTogVSxcbiAgICAgICAgICAgICAgYXRsYXNUZXh0dXJlSWNvbjogWixcbiAgICAgICAgICAgICAgYXRsYXNJbnRlcnBvbGF0aW9uOiBOLFxuICAgICAgICAgICAgICBhdGxhc0ludGVycG9sYXRpb25JY29uOiBxLFxuICAgICAgICAgICAgICBpc1NERjogTSxcbiAgICAgICAgICAgICAgaGFzSGFsbzogUVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHggJiYgei5jYW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgIGIgPSAhMDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciB0dCA9IDAsIGV0ID0gRC5zZWdtZW50cy5nZXQoKTsgdHQgPCBldC5sZW5ndGg7IHR0ICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXQgPSBldFt0dF07XG4gICAgICAgICAgICAgICAgRS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnRzOiBuZXcgdC5TZWdtZW50VmVjdG9yKFtpdF0pLFxuICAgICAgICAgICAgICAgICAgc29ydEtleTogaXQuc29ydEtleSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBFLnB1c2goe1xuICAgICAgICAgICAgICBzZWdtZW50czogRC5zZWdtZW50cyxcbiAgICAgICAgICAgICAgc29ydEtleTogMCxcbiAgICAgICAgICAgICAgc3RhdGU6ICRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiICYmIEUuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5zb3J0S2V5IC0gZS5zb3J0S2V5O1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIG90ID0gMCwgcnQgPSBFOyBvdCA8IHJ0Lmxlbmd0aDsgb3QgKz0gMSkge1xuICAgICAgICB2YXIgYXQgPSBydFtvdF0sXG4gICAgICAgICAgICBudCA9IGF0LnN0YXRlO1xuXG4gICAgICAgIGlmIChkLmFjdGl2ZVRleHR1cmUuc2V0KF8uVEVYVFVSRTApLCBudC5hdGxhc1RleHR1cmUuYmluZChudC5hdGxhc0ludGVycG9sYXRpb24sIF8uQ0xBTVBfVE9fRURHRSksIG50LmF0bGFzVGV4dHVyZUljb24gJiYgKGQuYWN0aXZlVGV4dHVyZS5zZXQoXy5URVhUVVJFMSksIG50LmF0bGFzVGV4dHVyZUljb24gJiYgbnQuYXRsYXNUZXh0dXJlSWNvbi5iaW5kKG50LmF0bGFzSW50ZXJwb2xhdGlvbkljb24sIF8uQ0xBTVBfVE9fRURHRSkpLCBudC5pc1NERikge1xuICAgICAgICAgIHZhciBzdCA9IG50LnVuaWZvcm1WYWx1ZXM7XG4gICAgICAgICAgbnQuaGFzSGFsbyAmJiAoc3QudV9pc19oYWxvID0gMSwgaW8obnQuYnVmZmVycywgYXQuc2VnbWVudHMsIG8sIGUsIG50LnByb2dyYW0sIHcsIGgsIHAsIHN0KSksIHN0LnVfaXNfaGFsbyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpbyhudC5idWZmZXJzLCBhdC5zZWdtZW50cywgbywgZSwgbnQucHJvZ3JhbSwgdywgaCwgcCwgbnQudW5pZm9ybVZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW8odCwgZSwgaSwgbywgciwgYSwgbiwgcywgbCkge1xuICAgICAgdmFyIGMgPSBvLmNvbnRleHQ7XG4gICAgICByLmRyYXcoYywgYy5nbC5UUklBTkdMRVMsIGEsIG4sIHMsIEN0LmRpc2FibGVkLCBsLCBpLmlkLCB0LmxheW91dFZlcnRleEJ1ZmZlciwgdC5pbmRleEJ1ZmZlciwgZSwgaS5wYWludCwgby50cmFuc2Zvcm0uem9vbSwgdC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KGkuaWQpLCB0LmR5bmFtaWNMYXlvdXRWZXJ0ZXhCdWZmZXIsIHQub3BhY2l0eVZlcnRleEJ1ZmZlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb28odCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBwID0gdC5jb250ZXh0LmdsLFxuICAgICAgICAgIGQgPSBpLnBhaW50LmdldChcImZpbGwtcGF0dGVyblwiKSxcbiAgICAgICAgICBfID0gZCAmJiBkLmNvbnN0YW50T3IoMSksXG4gICAgICAgICAgZiA9IGkuZ2V0Q3Jvc3NmYWRlUGFyYW1ldGVycygpO1xuXG4gICAgICBuID8gKGwgPSBfICYmICFpLmdldFBhaW50UHJvcGVydHkoXCJmaWxsLW91dGxpbmUtY29sb3JcIikgPyBcImZpbGxPdXRsaW5lUGF0dGVyblwiIDogXCJmaWxsT3V0bGluZVwiLCBzID0gcC5MSU5FUykgOiAobCA9IF8gPyBcImZpbGxQYXR0ZXJuXCIgOiBcImZpbGxcIiwgcyA9IHAuVFJJQU5HTEVTKTtcblxuICAgICAgZm9yICh2YXIgbSA9IDAsIGcgPSBvOyBtIDwgZy5sZW5ndGg7IG0gKz0gMSkge1xuICAgICAgICB2YXIgdiA9IGdbbV0sXG4gICAgICAgICAgICB5ID0gZS5nZXRUaWxlKHYpO1xuXG4gICAgICAgIGlmICghXyB8fCB5LnBhdHRlcm5zTG9hZGVkKCkpIHtcbiAgICAgICAgICB2YXIgeCA9IHkuZ2V0QnVja2V0KGkpO1xuXG4gICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgIHZhciBiID0geC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KGkuaWQpLFxuICAgICAgICAgICAgICAgIHcgPSB0LnVzZVByb2dyYW0obCwgYik7XG4gICAgICAgICAgICBfICYmICh0LmNvbnRleHQuYWN0aXZlVGV4dHVyZS5zZXQocC5URVhUVVJFMCksIHkuaW1hZ2VBdGxhc1RleHR1cmUuYmluZChwLkxJTkVBUiwgcC5DTEFNUF9UT19FREdFKSwgYi51cGRhdGVQYWludEJ1ZmZlcnMoZikpO1xuICAgICAgICAgICAgdmFyIFQgPSBkLmNvbnN0YW50T3IobnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChUICYmIHkuaW1hZ2VBdGxhcykge1xuICAgICAgICAgICAgICB2YXIgRSA9IHkuaW1hZ2VBdGxhcyxcbiAgICAgICAgICAgICAgICAgIEkgPSBFLnBhdHRlcm5Qb3NpdGlvbnNbVC50by50b1N0cmluZygpXSxcbiAgICAgICAgICAgICAgICAgIFAgPSBFLnBhdHRlcm5Qb3NpdGlvbnNbVC5mcm9tLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICBJICYmIFAgJiYgYi5zZXRDb25zdGFudFBhdHRlcm5Qb3NpdGlvbnMoSSwgUCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBTID0gdC50cmFuc2xhdGVQb3NNYXRyaXgodi5wb3NNYXRyaXgsIHksIGkucGFpbnQuZ2V0KFwiZmlsbC10cmFuc2xhdGVcIiksIGkucGFpbnQuZ2V0KFwiZmlsbC10cmFuc2xhdGUtYW5jaG9yXCIpKTtcblxuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgdSA9IHguaW5kZXhCdWZmZXIyLCBoID0geC5zZWdtZW50czI7XG4gICAgICAgICAgICAgIHZhciBDID0gW3AuZHJhd2luZ0J1ZmZlcldpZHRoLCBwLmRyYXdpbmdCdWZmZXJIZWlnaHRdO1xuICAgICAgICAgICAgICBjID0gXCJmaWxsT3V0bGluZVBhdHRlcm5cIiA9PT0gbCAmJiBfID8gQ2koUywgdCwgZiwgeSwgQykgOiBTaShTLCBDKTtcbiAgICAgICAgICAgIH0gZWxzZSB1ID0geC5pbmRleEJ1ZmZlciwgaCA9IHguc2VnbWVudHMsIGMgPSBfID8gUGkoUywgdCwgZiwgeSkgOiBJaShTKTtcblxuICAgICAgICAgICAgdy5kcmF3KHQuY29udGV4dCwgcywgciwgdC5zdGVuY2lsTW9kZUZvckNsaXBwaW5nKHYpLCBhLCBDdC5kaXNhYmxlZCwgYywgaS5pZCwgeC5sYXlvdXRWZXJ0ZXhCdWZmZXIsIHUsIGgsIGkucGFpbnQsIHQudHJhbnNmb3JtLnpvb20sIGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvKHQsIGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIGZvciAodmFyIHMgPSB0LmNvbnRleHQsIGwgPSBzLmdsLCBjID0gaS5wYWludC5nZXQoXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCIpLCB1ID0gYy5jb25zdGFudE9yKDEpLCBoID0gaS5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzKCksIHAgPSBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIiksIGQgPSAwLCBfID0gbzsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgdmFyIGYgPSBfW2RdLFxuICAgICAgICAgICAgbSA9IGUuZ2V0VGlsZShmKSxcbiAgICAgICAgICAgIGcgPSBtLmdldEJ1Y2tldChpKTtcblxuICAgICAgICBpZiAoZykge1xuICAgICAgICAgIHZhciB2ID0gZy5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KGkuaWQpLFxuICAgICAgICAgICAgICB5ID0gdC51c2VQcm9ncmFtKHUgPyBcImZpbGxFeHRydXNpb25QYXR0ZXJuXCIgOiBcImZpbGxFeHRydXNpb25cIiwgdik7XG4gICAgICAgICAgdSAmJiAodC5jb250ZXh0LmFjdGl2ZVRleHR1cmUuc2V0KGwuVEVYVFVSRTApLCBtLmltYWdlQXRsYXNUZXh0dXJlLmJpbmQobC5MSU5FQVIsIGwuQ0xBTVBfVE9fRURHRSksIHYudXBkYXRlUGFpbnRCdWZmZXJzKGgpKTtcbiAgICAgICAgICB2YXIgeCA9IGMuY29uc3RhbnRPcihudWxsKTtcblxuICAgICAgICAgIGlmICh4ICYmIG0uaW1hZ2VBdGxhcykge1xuICAgICAgICAgICAgdmFyIGIgPSBtLmltYWdlQXRsYXMsXG4gICAgICAgICAgICAgICAgdyA9IGIucGF0dGVyblBvc2l0aW9uc1t4LnRvLnRvU3RyaW5nKCldLFxuICAgICAgICAgICAgICAgIFQgPSBiLnBhdHRlcm5Qb3NpdGlvbnNbeC5mcm9tLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgdyAmJiBUICYmIHYuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zKHcsIFQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBFID0gdC50cmFuc2xhdGVQb3NNYXRyaXgoZi5wb3NNYXRyaXgsIG0sIGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCIpLCBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIikpLFxuICAgICAgICAgICAgICBJID0gaS5wYWludC5nZXQoXCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiKSxcbiAgICAgICAgICAgICAgUCA9IHUgPyBFaShFLCB0LCBJLCBwLCBmLCBoLCBtKSA6IFRpKEUsIHQsIEksIHApO1xuICAgICAgICAgIHkuZHJhdyhzLCBzLmdsLlRSSUFOR0xFUywgciwgYSwgbiwgQ3QuYmFja0NDVywgUCwgaS5pZCwgZy5sYXlvdXRWZXJ0ZXhCdWZmZXIsIGcuaW5kZXhCdWZmZXIsIGcuc2VnbWVudHMsIGkucGFpbnQsIHQudHJhbnNmb3JtLnpvb20sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW8oZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMgPSBlLmNvbnRleHQsXG4gICAgICAgICAgbCA9IHMuZ2wsXG4gICAgICAgICAgYyA9IGkuZmJvO1xuXG4gICAgICBpZiAoYykge1xuICAgICAgICB2YXIgdSA9IGUudXNlUHJvZ3JhbShcImhpbGxzaGFkZVwiKTtcbiAgICAgICAgcy5hY3RpdmVUZXh0dXJlLnNldChsLlRFWFRVUkUwKSwgbC5iaW5kVGV4dHVyZShsLlRFWFRVUkVfMkQsIGMuY29sb3JBdHRhY2htZW50LmdldCgpKTtcblxuICAgICAgICB2YXIgaCA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgdmFyIHIgPSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIiksXG4gICAgICAgICAgICAgIGEgPSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIiksXG4gICAgICAgICAgICAgIG4gPSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1hY2NlbnQtY29sb3JcIiksXG4gICAgICAgICAgICAgIHMgPSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCIpICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICAgIFwidmlld3BvcnRcIiA9PT0gby5wYWludC5nZXQoXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiKSAmJiAocyAtPSBlLnRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgICAgdmFyIGwsXG4gICAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAgIHUsXG4gICAgICAgICAgICAgIGggPSAhZS5vcHRpb25zLm1vdmluZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9tYXRyaXg6IGUudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeChpLnRpbGVJRC50b1Vud3JhcHBlZCgpLCBoKSxcbiAgICAgICAgICAgIHVfaW1hZ2U6IDAsXG4gICAgICAgICAgICB1X2xhdHJhbmdlOiAobCA9IGkudGlsZUlELCBjID0gTWF0aC5wb3coMiwgbC5jYW5vbmljYWwueiksIHUgPSBsLmNhbm9uaWNhbC55LCBbbmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKDAsIHUgLyBjKS50b0xuZ0xhdCgpLmxhdCwgbmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKDAsICh1ICsgMSkgLyBjKS50b0xuZ0xhdCgpLmxhdF0pLFxuICAgICAgICAgICAgdV9saWdodDogW28ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiKSwgc10sXG4gICAgICAgICAgICB1X3NoYWRvdzogcixcbiAgICAgICAgICAgIHVfaGlnaGxpZ2h0OiBhLFxuICAgICAgICAgICAgdV9hY2NlbnQ6IG5cbiAgICAgICAgICB9O1xuICAgICAgICB9KGUsIGksIG8pO1xuXG4gICAgICAgIHUuZHJhdyhzLCBsLlRSSUFOR0xFUywgciwgYSwgbiwgQ3QuZGlzYWJsZWQsIGgsIG8uaWQsIGUucmFzdGVyQm91bmRzQnVmZmVyLCBlLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCBlLnJhc3RlckJvdW5kc1NlZ21lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBubyhlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyA9IGUuY29udGV4dCxcbiAgICAgICAgICBsID0gcy5nbCxcbiAgICAgICAgICBjID0gaS5kZW07XG5cbiAgICAgIGlmIChjICYmIGMuZGF0YSkge1xuICAgICAgICB2YXIgdSA9IGMuZGltLFxuICAgICAgICAgICAgaCA9IGMuc3RyaWRlLFxuICAgICAgICAgICAgcCA9IGMuZ2V0UGl4ZWxzKCk7XG5cbiAgICAgICAgaWYgKHMuYWN0aXZlVGV4dHVyZS5zZXQobC5URVhUVVJFMSksIHMucGl4ZWxTdG9yZVVucGFja1ByZW11bHRpcGx5QWxwaGEuc2V0KCExKSwgaS5kZW1UZXh0dXJlID0gaS5kZW1UZXh0dXJlIHx8IGUuZ2V0VGlsZVRleHR1cmUoaCksIGkuZGVtVGV4dHVyZSkge1xuICAgICAgICAgIHZhciBkID0gaS5kZW1UZXh0dXJlO1xuICAgICAgICAgIGQudXBkYXRlKHAsIHtcbiAgICAgICAgICAgIHByZW11bHRpcGx5OiAhMVxuICAgICAgICAgIH0pLCBkLmJpbmQobC5ORUFSRVNULCBsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB9IGVsc2UgaS5kZW1UZXh0dXJlID0gbmV3IHQuVGV4dHVyZShzLCBwLCBsLlJHQkEsIHtcbiAgICAgICAgICBwcmVtdWx0aXBseTogITFcbiAgICAgICAgfSksIGkuZGVtVGV4dHVyZS5iaW5kKGwuTkVBUkVTVCwgbC5DTEFNUF9UT19FREdFKTtcblxuICAgICAgICBzLmFjdGl2ZVRleHR1cmUuc2V0KGwuVEVYVFVSRTApO1xuICAgICAgICB2YXIgXyA9IGkuZmJvO1xuXG4gICAgICAgIGlmICghXykge1xuICAgICAgICAgIHZhciBmID0gbmV3IHQuVGV4dHVyZShzLCB7XG4gICAgICAgICAgICB3aWR0aDogdSxcbiAgICAgICAgICAgIGhlaWdodDogdSxcbiAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICB9LCBsLlJHQkEpO1xuICAgICAgICAgIGYuYmluZChsLkxJTkVBUiwgbC5DTEFNUF9UT19FREdFKSwgKF8gPSBpLmZibyA9IHMuY3JlYXRlRnJhbWVidWZmZXIodSwgdSwgITApKS5jb2xvckF0dGFjaG1lbnQuc2V0KGYudGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzLmJpbmRGcmFtZWJ1ZmZlci5zZXQoXy5mcmFtZWJ1ZmZlciksIHMudmlld3BvcnQuc2V0KFswLCAwLCB1LCB1XSksIGUudXNlUHJvZ3JhbShcImhpbGxzaGFkZVByZXBhcmVcIikuZHJhdyhzLCBsLlRSSUFOR0xFUywgciwgYSwgbiwgQ3QuZGlzYWJsZWQsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdmFyIG8gPSBpLnN0cmlkZSxcbiAgICAgICAgICAgICAgciA9IHQuY3JlYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIHQub3J0aG8ociwgMCwgdC5FWFRFTlQsIC10LkVYVEVOVCwgMCwgMCwgMSksIHQudHJhbnNsYXRlKHIsIHIsIFswLCAtdC5FWFRFTlQsIDBdKSwge1xuICAgICAgICAgICAgdV9tYXRyaXg6IHIsXG4gICAgICAgICAgICB1X2ltYWdlOiAxLFxuICAgICAgICAgICAgdV9kaW1lbnNpb246IFtvLCBvXSxcbiAgICAgICAgICAgIHVfem9vbTogZS5vdmVyc2NhbGVkWixcbiAgICAgICAgICAgIHVfdW5wYWNrOiBpLmdldFVucGFja1ZlY3RvcigpXG4gICAgICAgICAgfTtcbiAgICAgICAgfShpLnRpbGVJRCwgYyksIG8uaWQsIGUucmFzdGVyQm91bmRzQnVmZmVyLCBlLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCBlLnJhc3RlckJvdW5kc1NlZ21lbnRzKSwgaS5uZWVkc0hpbGxzaGFkZVByZXBhcmUgPSAhMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbyhlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IHIucGFpbnQuZ2V0KFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIik7XG5cbiAgICAgIGlmIChuID4gMCkge1xuICAgICAgICB2YXIgcyA9IHQuYnJvd3Nlci5ub3coKSxcbiAgICAgICAgICAgIGwgPSAocyAtIGUudGltZUFkZGVkKSAvIG4sXG4gICAgICAgICAgICBjID0gaSA/IChzIC0gaS50aW1lQWRkZWQpIC8gbiA6IC0xLFxuICAgICAgICAgICAgdSA9IG8uZ2V0U291cmNlKCksXG4gICAgICAgICAgICBoID0gYS5jb3ZlcmluZ1pvb21MZXZlbCh7XG4gICAgICAgICAgdGlsZVNpemU6IHUudGlsZVNpemUsXG4gICAgICAgICAgcm91bmRab29tOiB1LnJvdW5kWm9vbVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIHAgPSAhaSB8fCBNYXRoLmFicyhpLnRpbGVJRC5vdmVyc2NhbGVkWiAtIGgpID4gTWF0aC5hYnMoZS50aWxlSUQub3ZlcnNjYWxlZFogLSBoKSxcbiAgICAgICAgICAgIGQgPSBwICYmIGUucmVmcmVzaGVkVXBvbkV4cGlyYXRpb24gPyAxIDogdC5jbGFtcChwID8gbCA6IDEgLSBjLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIGUucmVmcmVzaGVkVXBvbkV4cGlyYXRpb24gJiYgbCA+PSAxICYmIChlLnJlZnJlc2hlZFVwb25FeHBpcmF0aW9uID0gITEpLCBpID8ge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgbWl4OiAxIC0gZFxuICAgICAgICB9IDoge1xuICAgICAgICAgIG9wYWNpdHk6IGQsXG4gICAgICAgICAgbWl4OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIG1peDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbG8gPSBuZXcgdC5Db2xvcigxLCAwLCAwLCAxKSxcbiAgICAgICAgY28gPSBuZXcgdC5Db2xvcigwLCAxLCAwLCAxKSxcbiAgICAgICAgdW8gPSBuZXcgdC5Db2xvcigwLCAwLCAxLCAxKSxcbiAgICAgICAgaG8gPSBuZXcgdC5Db2xvcigxLCAwLCAxLCAxKSxcbiAgICAgICAgcG8gPSBuZXcgdC5Db2xvcigwLCAxLCAxLCAxKTtcblxuICAgIGZ1bmN0aW9uIF9vKHQsIGUsIGksIG8pIHtcbiAgICAgIG1vKHQsIDAsIGUgKyBpIC8gMiwgdC50cmFuc2Zvcm0ud2lkdGgsIGksIG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvKHQsIGUsIGksIG8pIHtcbiAgICAgIG1vKHQsIGUgLSBpIC8gMiwgMCwgaSwgdC50cmFuc2Zvcm0uaGVpZ2h0LCBvKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtbyhlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyA9IGUuY29udGV4dCxcbiAgICAgICAgICBsID0gcy5nbDtcbiAgICAgIGwuZW5hYmxlKGwuU0NJU1NPUl9URVNUKSwgbC5zY2lzc29yKGkgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbywgbyAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLCByICogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sIGEgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyksIHMuY2xlYXIoe1xuICAgICAgICBjb2xvcjogblxuICAgICAgfSksIGwuZGlzYWJsZShsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ28oZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBlLmNvbnRleHQsXG4gICAgICAgICAgYSA9IHIuZ2wsXG4gICAgICAgICAgbiA9IG8ucG9zTWF0cml4LFxuICAgICAgICAgIHMgPSBlLnVzZVByb2dyYW0oXCJkZWJ1Z1wiKSxcbiAgICAgICAgICBsID0gSXQuZGlzYWJsZWQsXG4gICAgICAgICAgYyA9IFB0LmRpc2FibGVkLFxuICAgICAgICAgIHUgPSBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKTtcbiAgICAgIHIuYWN0aXZlVGV4dHVyZS5zZXQoYS5URVhUVVJFMCksIGUuZW1wdHlUZXh0dXJlLmJpbmQoYS5MSU5FQVIsIGEuQ0xBTVBfVE9fRURHRSksIHMuZHJhdyhyLCBhLkxJTkVfU1RSSVAsIGwsIGMsIHUsIEN0LmRpc2FibGVkLCBNaShuLCB0LkNvbG9yLnJlZCksIFwiJGRlYnVnXCIsIGUuZGVidWdCdWZmZXIsIGUudGlsZUJvcmRlckluZGV4QnVmZmVyLCBlLmRlYnVnU2VnbWVudHMpO1xuXG4gICAgICB2YXIgaCA9IGkuZ2V0VGlsZUJ5SUQoby5rZXkpLmxhdGVzdFJhd1RpbGVEYXRhLFxuICAgICAgICAgIHAgPSBNYXRoLmZsb29yKChoICYmIGguYnl0ZUxlbmd0aCB8fCAwKSAvIDEwMjQpLFxuICAgICAgICAgIGQgPSBpLmdldFRpbGUobykudGlsZVNpemUsXG4gICAgICAgICAgXyA9IDUxMiAvIE1hdGgubWluKGQsIDUxMikgKiAoby5vdmVyc2NhbGVkWiAvIGUudHJhbnNmb3JtLnpvb20pICogLjUsXG4gICAgICAgICAgZiA9IG8uY2Fub25pY2FsLnRvU3RyaW5nKCk7XG5cbiAgICAgIG8ub3ZlcnNjYWxlZFogIT09IG8uY2Fub25pY2FsLnogJiYgKGYgKz0gXCIgPT4gXCIgKyBvLm92ZXJzY2FsZWRaKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdC5pbml0RGVidWdPdmVybGF5Q2FudmFzKCk7XG4gICAgICAgIHZhciBpID0gdC5kZWJ1Z092ZXJsYXlDYW52YXMsXG4gICAgICAgICAgICBvID0gdC5jb250ZXh0LmdsLFxuICAgICAgICAgICAgciA9IHQuZGVidWdPdmVybGF5Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgci5jbGVhclJlY3QoMCwgMCwgaS53aWR0aCwgaS5oZWlnaHQpLCByLnNoYWRvd0NvbG9yID0gXCJ3aGl0ZVwiLCByLnNoYWRvd0JsdXIgPSAyLCByLmxpbmVXaWR0aCA9IDEuNSwgci5zdHJva2VTdHlsZSA9IFwid2hpdGVcIiwgci50ZXh0QmFzZWxpbmUgPSBcInRvcFwiLCByLmZvbnQgPSBcImJvbGQgMzZweCBPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIiwgci5maWxsVGV4dChlLCA1LCA1KSwgci5zdHJva2VUZXh0KGUsIDUsIDUpLCB0LmRlYnVnT3ZlcmxheVRleHR1cmUudXBkYXRlKGkpLCB0LmRlYnVnT3ZlcmxheVRleHR1cmUuYmluZChvLkxJTkVBUiwgby5DTEFNUF9UT19FREdFKTtcbiAgICAgIH0oZSwgZiArIFwiIFwiICsgcCArIFwia2JcIiksIHMuZHJhdyhyLCBhLlRSSUFOR0xFUywgbCwgYywgU3QuYWxwaGFCbGVuZGVkLCBDdC5kaXNhYmxlZCwgTWkobiwgdC5Db2xvci50cmFuc3BhcmVudCwgXyksIFwiJGRlYnVnXCIsIGUuZGVidWdCdWZmZXIsIGUucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIGUuZGVidWdTZWdtZW50cyk7XG4gICAgfVxuXG4gICAgdmFyIHZvID0ge1xuICAgICAgc3ltYm9sOiBmdW5jdGlvbiBzeW1ib2woZSwgaSwgbywgciwgYSkge1xuICAgICAgICBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSBlLnJlbmRlclBhc3MpIHtcbiAgICAgICAgICB2YXIgbiA9IFB0LmRpc2FibGVkLFxuICAgICAgICAgICAgICBzID0gZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCk7XG4gICAgICAgICAgby5sYXlvdXQuZ2V0KFwidGV4dC12YXJpYWJsZS1hbmNob3JcIikgJiYgZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSBpLnRyYW5zZm9ybSwgYyA9IFwibWFwXCIgPT09IGEsIHUgPSBcIm1hcFwiID09PSBuLCBoID0gMCwgcCA9IGU7IGggPCBwLmxlbmd0aDsgaCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gcFtoXSxcbiAgICAgICAgICAgICAgICAgIF8gPSByLmdldFRpbGUoZCksXG4gICAgICAgICAgICAgICAgICBmID0gXy5nZXRCdWNrZXQobyk7XG5cbiAgICAgICAgICAgICAgaWYgKGYgJiYgZi50ZXh0ICYmIGYudGV4dC5zZWdtZW50cy5nZXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHQuZXZhbHVhdGVTaXplRm9yWm9vbShmLnRleHRTaXplRGF0YSwgbC56b29tKSxcbiAgICAgICAgICAgICAgICAgICAgZyA9IHBlKF8sIDEsIGkudHJhbnNmb3JtLnpvb20pLFxuICAgICAgICAgICAgICAgICAgICB2ID0gSnQoZC5wb3NNYXRyaXgsIHUsIGMsIGkudHJhbnNmb3JtLCBnKSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IFwibm9uZVwiICE9PSBvLmxheW91dC5nZXQoXCJpY29uLXRleHQtZml0XCIpICYmIGYuaGFzSWNvbkRhdGEoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGgucG93KDIsIGwuem9vbSAtIF8udGlsZUlELm92ZXJzY2FsZWRaKTtcbiAgICAgICAgICAgICAgICAgICRpKGYsIGMsIHUsIHMsIHQuc3ltYm9sU2l6ZSwgbCwgdiwgZC5wb3NNYXRyaXgsIHgsIG0sIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0ociwgZSwgbywgaSwgby5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIiksIG8ubGF5b3V0LmdldChcInRleHQtcGl0Y2gtYWxpZ25tZW50XCIpLCBhKSwgMCAhPT0gby5wYWludC5nZXQoXCJpY29uLW9wYWNpdHlcIikuY29uc3RhbnRPcigxKSAmJiBlbyhlLCBpLCBvLCByLCAhMSwgby5wYWludC5nZXQoXCJpY29uLXRyYW5zbGF0ZVwiKSwgby5wYWludC5nZXQoXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIiksIG8ubGF5b3V0LmdldChcImljb24tcm90YXRpb24tYWxpZ25tZW50XCIpLCBvLmxheW91dC5nZXQoXCJpY29uLXBpdGNoLWFsaWdubWVudFwiKSwgby5sYXlvdXQuZ2V0KFwiaWNvbi1rZWVwLXVwcmlnaHRcIiksIG4sIHMpLCAwICE9PSBvLnBhaW50LmdldChcInRleHQtb3BhY2l0eVwiKS5jb25zdGFudE9yKDEpICYmIGVvKGUsIGksIG8sIHIsICEwLCBvLnBhaW50LmdldChcInRleHQtdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiKSwgby5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIiksIG8ubGF5b3V0LmdldChcInRleHQtcGl0Y2gtYWxpZ25tZW50XCIpLCBvLmxheW91dC5nZXQoXCJ0ZXh0LWtlZXAtdXByaWdodFwiKSwgbiwgcyksIGkubWFwLnNob3dDb2xsaXNpb25Cb3hlcyAmJiAoWWkoZSwgaSwgbywgciwgby5wYWludC5nZXQoXCJ0ZXh0LXRyYW5zbGF0ZVwiKSwgby5wYWludC5nZXQoXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIiksICEwKSwgWWkoZSwgaSwgbywgciwgby5wYWludC5nZXQoXCJpY29uLXRyYW5zbGF0ZVwiKSwgby5wYWludC5nZXQoXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIiksICExKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShlLCBpLCBvLCByKSB7XG4gICAgICAgIGlmIChcInRyYW5zbHVjZW50XCIgPT09IGUucmVuZGVyUGFzcykge1xuICAgICAgICAgIHZhciBhID0gby5wYWludC5nZXQoXCJjaXJjbGUtb3BhY2l0eVwiKSxcbiAgICAgICAgICAgICAgbiA9IG8ucGFpbnQuZ2V0KFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiKSxcbiAgICAgICAgICAgICAgcyA9IG8ucGFpbnQuZ2V0KFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCIpLFxuICAgICAgICAgICAgICBsID0gIW8ubGF5b3V0LmdldChcImNpcmNsZS1zb3J0LWtleVwiKS5pc0NvbnN0YW50KCk7XG5cbiAgICAgICAgICBpZiAoMCAhPT0gYS5jb25zdGFudE9yKDEpIHx8IDAgIT09IG4uY29uc3RhbnRPcigxKSAmJiAwICE9PSBzLmNvbnN0YW50T3IoMSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSBlLmNvbnRleHQsIHUgPSBjLmdsLCBoID0gZS5kZXB0aE1vZGVGb3JTdWJsYXllcigwLCBJdC5SZWFkT25seSksIHAgPSBQdC5kaXNhYmxlZCwgZCA9IGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBfID0gW10sIGYgPSAwOyBmIDwgci5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICB2YXIgbSA9IHJbZl0sXG4gICAgICAgICAgICAgICAgICBnID0gaS5nZXRUaWxlKG0pLFxuICAgICAgICAgICAgICAgICAgdiA9IGcuZ2V0QnVja2V0KG8pO1xuXG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB2LnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoby5pZCksXG4gICAgICAgICAgICAgICAgICAgIHggPSB7XG4gICAgICAgICAgICAgICAgICBwcm9ncmFtQ29uZmlndXJhdGlvbjogeSxcbiAgICAgICAgICAgICAgICAgIHByb2dyYW06IGUudXNlUHJvZ3JhbShcImNpcmNsZVwiLCB5KSxcbiAgICAgICAgICAgICAgICAgIGxheW91dFZlcnRleEJ1ZmZlcjogdi5sYXlvdXRWZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICAgICAgICBpbmRleEJ1ZmZlcjogdi5pbmRleEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgIHVuaWZvcm1WYWx1ZXM6IHppKGUsIG0sIGcsIG8pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobCkgZm9yICh2YXIgYiA9IDAsIHcgPSB2LnNlZ21lbnRzLmdldCgpOyBiIDwgdy5sZW5ndGg7IGIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIFQgPSB3W2JdO1xuXG4gICAgICAgICAgICAgICAgICBfLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50czogbmV3IHQuU2VnbWVudFZlY3RvcihbVF0pLFxuICAgICAgICAgICAgICAgICAgICBzb3J0S2V5OiBULnNvcnRLZXksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB4XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgXy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnRzOiB2LnNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgc29ydEtleTogMCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiB4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCAmJiBfLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQuc29ydEtleSAtIGUuc29ydEtleTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBFID0gMCwgSSA9IF87IEUgPCBJLmxlbmd0aDsgRSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBQID0gSVtFXSxcbiAgICAgICAgICAgICAgICAgIFMgPSBQLnN0YXRlO1xuICAgICAgICAgICAgICBTLnByb2dyYW0uZHJhdyhjLCB1LlRSSUFOR0xFUywgaCwgcCwgZCwgQ3QuZGlzYWJsZWQsIFMudW5pZm9ybVZhbHVlcywgby5pZCwgUy5sYXlvdXRWZXJ0ZXhCdWZmZXIsIFMuaW5kZXhCdWZmZXIsIFAuc2VnbWVudHMsIG8ucGFpbnQsIGUudHJhbnNmb3JtLnpvb20sIFMucHJvZ3JhbUNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhlYXRtYXA6IGZ1bmN0aW9uIGhlYXRtYXAoZSwgaSwgbywgcikge1xuICAgICAgICBpZiAoMCAhPT0gby5wYWludC5nZXQoXCJoZWF0bWFwLW9wYWNpdHlcIikpIGlmIChcIm9mZnNjcmVlblwiID09PSBlLnJlbmRlclBhc3MpIHtcbiAgICAgICAgICB2YXIgYSA9IGUuY29udGV4dCxcbiAgICAgICAgICAgICAgbiA9IGEuZ2wsXG4gICAgICAgICAgICAgIHMgPSBQdC5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgbCA9IG5ldyBTdChbbi5PTkUsIG4uT05FXSwgdC5Db2xvci50cmFuc3BhcmVudCwgWyEwLCAhMCwgITAsICEwXSk7XG4gICAgICAgICAgIWZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHQuZ2w7XG4gICAgICAgICAgICB0LmFjdGl2ZVRleHR1cmUuc2V0KG8uVEVYVFVSRTEpLCB0LnZpZXdwb3J0LnNldChbMCwgMCwgZS53aWR0aCAvIDQsIGUuaGVpZ2h0IC8gNF0pO1xuICAgICAgICAgICAgdmFyIHIgPSBpLmhlYXRtYXBGYm87XG4gICAgICAgICAgICBpZiAocikgby5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsIHIuY29sb3JBdHRhY2htZW50LmdldCgpKSwgdC5iaW5kRnJhbWVidWZmZXIuc2V0KHIuZnJhbWVidWZmZXIpO2Vsc2Uge1xuICAgICAgICAgICAgICB2YXIgYSA9IG8uY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgICBvLmJpbmRUZXh0dXJlKG8uVEVYVFVSRV8yRCwgYSksIG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsIG8uVEVYVFVSRV9XUkFQX1MsIG8uQ0xBTVBfVE9fRURHRSksIG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsIG8uVEVYVFVSRV9XUkFQX1QsIG8uQ0xBTVBfVE9fRURHRSksIG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsIG8uVEVYVFVSRV9NSU5fRklMVEVSLCBvLkxJTkVBUiksIG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsIG8uVEVYVFVSRV9NQUdfRklMVEVSLCBvLkxJTkVBUiksIHIgPSBpLmhlYXRtYXBGYm8gPSB0LmNyZWF0ZUZyYW1lYnVmZmVyKGUud2lkdGggLyA0LCBlLmhlaWdodCAvIDQsICExKSwgZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHQuZ2w7XG4gICAgICAgICAgICAgICAgci50ZXhJbWFnZTJEKHIuVEVYVFVSRV8yRCwgMCwgci5SR0JBLCBlLndpZHRoIC8gNCwgZS5oZWlnaHQgLyA0LCAwLCByLlJHQkEsIHQuZXh0UmVuZGVyVG9UZXh0dXJlSGFsZkZsb2F0ID8gdC5leHRUZXh0dXJlSGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTIDogci5VTlNJR05FRF9CWVRFLCBudWxsKSwgby5jb2xvckF0dGFjaG1lbnQuc2V0KGkpO1xuICAgICAgICAgICAgICB9KHQsIGUsIGEsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oYSwgZSwgbyksIGEuY2xlYXIoe1xuICAgICAgICAgICAgY29sb3I6IHQuQ29sb3IudHJhbnNwYXJlbnRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgci5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgdmFyIHUgPSByW2NdO1xuXG4gICAgICAgICAgICBpZiAoIWkuaGFzUmVuZGVyYWJsZVBhcmVudCh1KSkge1xuICAgICAgICAgICAgICB2YXIgaCA9IGkuZ2V0VGlsZSh1KSxcbiAgICAgICAgICAgICAgICAgIHAgPSBoLmdldEJ1Y2tldChvKTtcblxuICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gcC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KG8uaWQpO1xuICAgICAgICAgICAgICAgIGUudXNlUHJvZ3JhbShcImhlYXRtYXBcIiwgZCkuZHJhdyhhLCBuLlRSSUFOR0xFUywgSXQuZGlzYWJsZWQsIHMsIGwsIEN0LmRpc2FibGVkLCBSaSh1LnBvc01hdHJpeCwgaCwgZS50cmFuc2Zvcm0uem9vbSwgby5wYWludC5nZXQoXCJoZWF0bWFwLWludGVuc2l0eVwiKSksIG8uaWQsIHAubGF5b3V0VmVydGV4QnVmZmVyLCBwLmluZGV4QnVmZmVyLCBwLnNlZ21lbnRzLCBvLnBhaW50LCBlLnRyYW5zZm9ybS56b29tLCBkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGEudmlld3BvcnQuc2V0KFswLCAwLCBlLndpZHRoLCBlLmhlaWdodF0pO1xuICAgICAgICB9IGVsc2UgXCJ0cmFuc2x1Y2VudFwiID09PSBlLnJlbmRlclBhc3MgJiYgKGUuY29udGV4dC5zZXRDb2xvck1vZGUoZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCkpLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gZS5jb250ZXh0LFxuICAgICAgICAgICAgICByID0gby5nbCxcbiAgICAgICAgICAgICAgYSA9IGkuaGVhdG1hcEZibztcblxuICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICBvLmFjdGl2ZVRleHR1cmUuc2V0KHIuVEVYVFVSRTApLCByLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCwgYS5jb2xvckF0dGFjaG1lbnQuZ2V0KCkpLCBvLmFjdGl2ZVRleHR1cmUuc2V0KHIuVEVYVFVSRTEpO1xuICAgICAgICAgICAgdmFyIG4gPSBpLmNvbG9yUmFtcFRleHR1cmU7XG4gICAgICAgICAgICBuIHx8IChuID0gaS5jb2xvclJhbXBUZXh0dXJlID0gbmV3IHQuVGV4dHVyZShvLCBpLmNvbG9yUmFtcCwgci5SR0JBKSksIG4uYmluZChyLkxJTkVBUiwgci5DTEFNUF9UT19FREdFKSwgZS51c2VQcm9ncmFtKFwiaGVhdG1hcFRleHR1cmVcIikuZHJhdyhvLCByLlRSSUFOR0xFUywgSXQuZGlzYWJsZWQsIFB0LmRpc2FibGVkLCBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSwgQ3QuZGlzYWJsZWQsIGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gdC5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgdC5vcnRobyhhLCAwLCBlLndpZHRoLCBlLmhlaWdodCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgIHZhciBuID0gZS5jb250ZXh0LmdsO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVfbWF0cml4OiBhLFxuICAgICAgICAgICAgICAgIHVfd29ybGQ6IFtuLmRyYXdpbmdCdWZmZXJXaWR0aCwgbi5kcmF3aW5nQnVmZmVySGVpZ2h0XSxcbiAgICAgICAgICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICAgICAgICAgIHVfY29sb3JfcmFtcDogMSxcbiAgICAgICAgICAgICAgICB1X29wYWNpdHk6IGkucGFpbnQuZ2V0KFwiaGVhdG1hcC1vcGFjaXR5XCIpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGUsIGkpLCBpLmlkLCBlLnZpZXdwb3J0QnVmZmVyLCBlLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCBlLnZpZXdwb3J0U2VnbWVudHMsIGkucGFpbnQsIGUudHJhbnNmb3JtLnpvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfShlLCBvKSk7XG4gICAgICB9LFxuICAgICAgbGluZTogZnVuY3Rpb24gbGluZShlLCBpLCBvLCByKSB7XG4gICAgICAgIGlmIChcInRyYW5zbHVjZW50XCIgPT09IGUucmVuZGVyUGFzcykge1xuICAgICAgICAgIHZhciBhID0gby5wYWludC5nZXQoXCJsaW5lLW9wYWNpdHlcIiksXG4gICAgICAgICAgICAgIG4gPSBvLnBhaW50LmdldChcImxpbmUtd2lkdGhcIik7XG4gICAgICAgICAgaWYgKDAgIT09IGEuY29uc3RhbnRPcigxKSAmJiAwICE9PSBuLmNvbnN0YW50T3IoMSkpIGZvciAodmFyIHMgPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKDAsIEl0LlJlYWRPbmx5KSwgbCA9IGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBjID0gby5wYWludC5nZXQoXCJsaW5lLWRhc2hhcnJheVwiKSwgdSA9IG8ucGFpbnQuZ2V0KFwibGluZS1wYXR0ZXJuXCIpLCBoID0gdS5jb25zdGFudE9yKDEpLCBwID0gby5wYWludC5nZXQoXCJsaW5lLWdyYWRpZW50XCIpLCBkID0gby5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzKCksIF8gPSBoID8gXCJsaW5lUGF0dGVyblwiIDogYyA/IFwibGluZVNERlwiIDogcCA/IFwibGluZUdyYWRpZW50XCIgOiBcImxpbmVcIiwgZiA9IGUuY29udGV4dCwgbSA9IGYuZ2wsIGcgPSAhMCwgdiA9IDAsIHkgPSByOyB2IDwgeS5sZW5ndGg7IHYgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHggPSB5W3ZdLFxuICAgICAgICAgICAgICAgIGIgPSBpLmdldFRpbGUoeCk7XG5cbiAgICAgICAgICAgIGlmICghaCB8fCBiLnBhdHRlcm5zTG9hZGVkKCkpIHtcbiAgICAgICAgICAgICAgdmFyIHcgPSBiLmdldEJ1Y2tldChvKTtcblxuICAgICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgIHZhciBUID0gdy5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KG8uaWQpLFxuICAgICAgICAgICAgICAgICAgICBFID0gZS5jb250ZXh0LnByb2dyYW0uZ2V0KCksXG4gICAgICAgICAgICAgICAgICAgIEkgPSBlLnVzZVByb2dyYW0oXywgVCksXG4gICAgICAgICAgICAgICAgICAgIFAgPSBnIHx8IEkucHJvZ3JhbSAhPT0gRSxcbiAgICAgICAgICAgICAgICAgICAgUyA9IHUuY29uc3RhbnRPcihudWxsKTtcblxuICAgICAgICAgICAgICAgIGlmIChTICYmIGIuaW1hZ2VBdGxhcykge1xuICAgICAgICAgICAgICAgICAgdmFyIEMgPSBiLmltYWdlQXRsYXMsXG4gICAgICAgICAgICAgICAgICAgICAgeiA9IEMucGF0dGVyblBvc2l0aW9uc1tTLnRvLnRvU3RyaW5nKCldLFxuICAgICAgICAgICAgICAgICAgICAgIEQgPSBDLnBhdHRlcm5Qb3NpdGlvbnNbUy5mcm9tLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgICAgeiAmJiBEICYmIFQuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zKHosIEQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBBID0gaCA/IE9pKGUsIGIsIG8sIGQpIDogYyA/IEZpKGUsIGIsIG8sIGMsIGQpIDogcCA/IEJpKGUsIGIsIG8sIHcubGluZUNsaXBzQXJyYXkubGVuZ3RoKSA6IGtpKGUsIGIsIG8pO1xuICAgICAgICAgICAgICAgIGlmIChoKSBmLmFjdGl2ZVRleHR1cmUuc2V0KG0uVEVYVFVSRTApLCBiLmltYWdlQXRsYXNUZXh0dXJlLmJpbmQobS5MSU5FQVIsIG0uQ0xBTVBfVE9fRURHRSksIFQudXBkYXRlUGFpbnRCdWZmZXJzKGQpO2Vsc2UgaWYgKGMgJiYgKFAgfHwgZS5saW5lQXRsYXMuZGlydHkpKSBmLmFjdGl2ZVRleHR1cmUuc2V0KG0uVEVYVFVSRTApLCBlLmxpbmVBdGxhcy5iaW5kKGYpO2Vsc2UgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBNID0gdy5ncmFkaWVudHNbby5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgTCA9IE0udGV4dHVyZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG8uZ3JhZGllbnRWZXJzaW9uICE9PSBNLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFIgPSAyNTY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3RlcEludGVycG9sYW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBpLmdldFNvdXJjZSgpLm1heHpvb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEIgPSB4LmNhbm9uaWNhbC56ID09PSBrID8gTWF0aC5jZWlsKDEgPDwgZS50cmFuc2Zvcm0ubWF4Wm9vbSAtIHguY2Fub25pY2FsLnopIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICBSID0gdC5jbGFtcCh0Lm5leHRQb3dlck9mVHdvKHcubWF4TGluZUxlbmd0aCAvIHQuRVhURU5UICogMTAyNCAqIEIpLCAyNTYsIGYubWF4VGV4dHVyZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgTS5ncmFkaWVudCA9IHQucmVuZGVyQ29sb3JSYW1wKHtcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBvLmdyYWRpZW50RXhwcmVzc2lvbigpLFxuICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25LZXk6IFwibGluZVByb2dyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogUixcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogTS5ncmFkaWVudCB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgY2xpcHM6IHcubGluZUNsaXBzQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgfSksIE0udGV4dHVyZSA/IE0udGV4dHVyZS51cGRhdGUoTS5ncmFkaWVudCkgOiBNLnRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKGYsIE0uZ3JhZGllbnQsIG0uUkdCQSksIE0udmVyc2lvbiA9IG8uZ3JhZGllbnRWZXJzaW9uLCBMID0gTS50ZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmLmFjdGl2ZVRleHR1cmUuc2V0KG0uVEVYVFVSRTApLCBMLmJpbmQoby5zdGVwSW50ZXJwb2xhbnQgPyBtLk5FQVJFU1QgOiBtLkxJTkVBUiwgbS5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgSS5kcmF3KGYsIG0uVFJJQU5HTEVTLCBzLCBlLnN0ZW5jaWxNb2RlRm9yQ2xpcHBpbmcoeCksIGwsIEN0LmRpc2FibGVkLCBBLCBvLmlkLCB3LmxheW91dFZlcnRleEJ1ZmZlciwgdy5pbmRleEJ1ZmZlciwgdy5zZWdtZW50cywgby5wYWludCwgZS50cmFuc2Zvcm0uem9vbSwgVCwgdy5sYXlvdXRWZXJ0ZXhCdWZmZXIyKSwgZyA9ICExO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmlsbDogZnVuY3Rpb24gZmlsbChlLCBpLCBvLCByKSB7XG4gICAgICAgIHZhciBhID0gby5wYWludC5nZXQoXCJmaWxsLWNvbG9yXCIpLFxuICAgICAgICAgICAgbiA9IG8ucGFpbnQuZ2V0KFwiZmlsbC1vcGFjaXR5XCIpO1xuXG4gICAgICAgIGlmICgwICE9PSBuLmNvbnN0YW50T3IoMSkpIHtcbiAgICAgICAgICB2YXIgcyA9IGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLFxuICAgICAgICAgICAgICBsID0gby5wYWludC5nZXQoXCJmaWxsLXBhdHRlcm5cIiksXG4gICAgICAgICAgICAgIGMgPSBlLm9wYXF1ZVBhc3NFbmFibGVkRm9yTGF5ZXIoKSAmJiAhbC5jb25zdGFudE9yKDEpICYmIDEgPT09IGEuY29uc3RhbnRPcih0LkNvbG9yLnRyYW5zcGFyZW50KS5hICYmIDEgPT09IG4uY29uc3RhbnRPcigwKSA/IFwib3BhcXVlXCIgOiBcInRyYW5zbHVjZW50XCI7XG5cbiAgICAgICAgICBpZiAoZS5yZW5kZXJQYXNzID09PSBjKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGUuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMSwgXCJvcGFxdWVcIiA9PT0gZS5yZW5kZXJQYXNzID8gSXQuUmVhZFdyaXRlIDogSXQuUmVhZE9ubHkpO1xuICAgICAgICAgICAgb28oZSwgaSwgbywgciwgdSwgcywgITEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcInRyYW5zbHVjZW50XCIgPT09IGUucmVuZGVyUGFzcyAmJiBvLnBhaW50LmdldChcImZpbGwtYW50aWFsaWFzXCIpKSB7XG4gICAgICAgICAgICB2YXIgaCA9IGUuZGVwdGhNb2RlRm9yU3VibGF5ZXIoby5nZXRQYWludFByb3BlcnR5KFwiZmlsbC1vdXRsaW5lLWNvbG9yXCIpID8gMiA6IDAsIEl0LlJlYWRPbmx5KTtcbiAgICAgICAgICAgIG9vKGUsIGksIG8sIHIsIGgsIHMsICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZpbGwtZXh0cnVzaW9uXCI6IGZ1bmN0aW9uIGZpbGxFeHRydXNpb24odCwgZSwgaSwgbykge1xuICAgICAgICB2YXIgciA9IGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiKTtcblxuICAgICAgICBpZiAoMCAhPT0gciAmJiBcInRyYW5zbHVjZW50XCIgPT09IHQucmVuZGVyUGFzcykge1xuICAgICAgICAgIHZhciBhID0gbmV3IEl0KHQuY29udGV4dC5nbC5MRVFVQUwsIEl0LlJlYWRXcml0ZSwgdC5kZXB0aFJhbmdlRm9yM0QpO1xuICAgICAgICAgIGlmICgxICE9PSByIHx8IGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiKS5jb25zdGFudE9yKDEpKSBybyh0LCBlLCBpLCBvLCBhLCBQdC5kaXNhYmxlZCwgU3QuZGlzYWJsZWQpLCBybyh0LCBlLCBpLCBvLCBhLCB0LnN0ZW5jaWxNb2RlRm9yM0QoKSwgdC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCkpO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIG4gPSB0LmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKTtcbiAgICAgICAgICAgIHJvKHQsIGUsIGksIG8sIGEsIFB0LmRpc2FibGVkLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoaWxsc2hhZGU6IGZ1bmN0aW9uIGhpbGxzaGFkZSh0LCBlLCBpLCBvKSB7XG4gICAgICAgIGlmIChcIm9mZnNjcmVlblwiID09PSB0LnJlbmRlclBhc3MgfHwgXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gdC5jb250ZXh0LCBhID0gdC5kZXB0aE1vZGVGb3JTdWJsYXllcigwLCBJdC5SZWFkT25seSksIG4gPSB0LmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSwgcyA9IFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzID8gdC5zdGVuY2lsQ29uZmlnRm9yT3ZlcmxhcChvKSA6IFt7fSwgb10sIGwgPSBzWzBdLCBjID0gMCwgdSA9IHNbMV07IGMgPCB1Lmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHVbY10sXG4gICAgICAgICAgICAgICAgcCA9IGUuZ2V0VGlsZShoKTtcbiAgICAgICAgICAgIHAubmVlZHNIaWxsc2hhZGVQcmVwYXJlICYmIFwib2Zmc2NyZWVuXCIgPT09IHQucmVuZGVyUGFzcyA/IG5vKHQsIHAsIGksIGEsIFB0LmRpc2FibGVkLCBuKSA6IFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzICYmIGFvKHQsIHAsIGksIGEsIGxbaC5vdmVyc2NhbGVkWl0sIG4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudmlld3BvcnQuc2V0KFswLCAwLCB0LndpZHRoLCB0LmhlaWdodF0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmFzdGVyOiBmdW5jdGlvbiByYXN0ZXIodCwgZSwgaSwgbykge1xuICAgICAgICBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MgJiYgMCAhPT0gaS5wYWludC5nZXQoXCJyYXN0ZXItb3BhY2l0eVwiKSAmJiBvLmxlbmd0aCkgZm9yICh2YXIgciA9IHQuY29udGV4dCwgYSA9IHIuZ2wsIG4gPSBlLmdldFNvdXJjZSgpLCBzID0gdC51c2VQcm9ncmFtKFwicmFzdGVyXCIpLCBsID0gdC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksIGMgPSBuIGluc3RhbmNlb2YgTSA/IFt7fSwgb10gOiB0LnN0ZW5jaWxDb25maWdGb3JPdmVybGFwKG8pLCB1ID0gY1swXSwgaCA9IGNbMV0sIHAgPSBoW2gubGVuZ3RoIC0gMV0ub3ZlcnNjYWxlZFosIGQgPSAhdC5vcHRpb25zLm1vdmluZywgXyA9IDAsIGYgPSBoOyBfIDwgZi5sZW5ndGg7IF8gKz0gMSkge1xuICAgICAgICAgIHZhciBtID0gZltfXSxcbiAgICAgICAgICAgICAgZyA9IHQuZGVwdGhNb2RlRm9yU3VibGF5ZXIobS5vdmVyc2NhbGVkWiAtIHAsIDEgPT09IGkucGFpbnQuZ2V0KFwicmFzdGVyLW9wYWNpdHlcIikgPyBJdC5SZWFkV3JpdGUgOiBJdC5SZWFkT25seSwgYS5MRVNTKSxcbiAgICAgICAgICAgICAgdiA9IGUuZ2V0VGlsZShtKSxcbiAgICAgICAgICAgICAgeSA9IHQudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeChtLnRvVW53cmFwcGVkKCksIGQpO1xuICAgICAgICAgIHYucmVnaXN0ZXJGYWRlRHVyYXRpb24oaS5wYWludC5nZXQoXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiKSk7XG4gICAgICAgICAgdmFyIHggPSBlLmZpbmRMb2FkZWRQYXJlbnQobSwgMCksXG4gICAgICAgICAgICAgIGIgPSBzbyh2LCB4LCBlLCBpLCB0LnRyYW5zZm9ybSksXG4gICAgICAgICAgICAgIHcgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIFQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIEUgPSBcIm5lYXJlc3RcIiA9PT0gaS5wYWludC5nZXQoXCJyYXN0ZXItcmVzYW1wbGluZ1wiKSA/IGEuTkVBUkVTVCA6IGEuTElORUFSO1xuICAgICAgICAgIHIuYWN0aXZlVGV4dHVyZS5zZXQoYS5URVhUVVJFMCksIHYudGV4dHVyZS5iaW5kKEUsIGEuQ0xBTVBfVE9fRURHRSwgYS5MSU5FQVJfTUlQTUFQX05FQVJFU1QpLCByLmFjdGl2ZVRleHR1cmUuc2V0KGEuVEVYVFVSRTEpLCB4ID8gKHgudGV4dHVyZS5iaW5kKEUsIGEuQ0xBTVBfVE9fRURHRSwgYS5MSU5FQVJfTUlQTUFQX05FQVJFU1QpLCB3ID0gTWF0aC5wb3coMiwgeC50aWxlSUQub3ZlcnNjYWxlZFogLSB2LnRpbGVJRC5vdmVyc2NhbGVkWiksIFQgPSBbdi50aWxlSUQuY2Fub25pY2FsLnggKiB3ICUgMSwgdi50aWxlSUQuY2Fub25pY2FsLnkgKiB3ICUgMV0pIDogdi50ZXh0dXJlLmJpbmQoRSwgYS5DTEFNUF9UT19FREdFLCBhLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICAgICAgdmFyIEkgPSBaaSh5LCBUIHx8IFswLCAwXSwgdyB8fCAxLCBiLCBpKTtcbiAgICAgICAgICBuIGluc3RhbmNlb2YgTSA/IHMuZHJhdyhyLCBhLlRSSUFOR0xFUywgZywgUHQuZGlzYWJsZWQsIGwsIEN0LmRpc2FibGVkLCBJLCBpLmlkLCBuLmJvdW5kc0J1ZmZlciwgdC5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgbi5ib3VuZHNTZWdtZW50cykgOiBzLmRyYXcociwgYS5UUklBTkdMRVMsIGcsIHVbbS5vdmVyc2NhbGVkWl0sIGwsIEN0LmRpc2FibGVkLCBJLCBpLmlkLCB0LnJhc3RlckJvdW5kc0J1ZmZlciwgdC5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgdC5yYXN0ZXJCb3VuZHNTZWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbiBiYWNrZ3JvdW5kKHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSBpLnBhaW50LmdldChcImJhY2tncm91bmQtY29sb3JcIiksXG4gICAgICAgICAgICByID0gaS5wYWludC5nZXQoXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIik7XG5cbiAgICAgICAgaWYgKDAgIT09IHIpIHtcbiAgICAgICAgICB2YXIgYSA9IHQuY29udGV4dCxcbiAgICAgICAgICAgICAgbiA9IGEuZ2wsXG4gICAgICAgICAgICAgIHMgPSB0LnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgbCA9IHMudGlsZVNpemUsXG4gICAgICAgICAgICAgIGMgPSBpLnBhaW50LmdldChcImJhY2tncm91bmQtcGF0dGVyblwiKTtcblxuICAgICAgICAgIGlmICghdC5pc1BhdHRlcm5NaXNzaW5nKGMpKSB7XG4gICAgICAgICAgICB2YXIgdSA9ICFjICYmIDEgPT09IG8uYSAmJiAxID09PSByICYmIHQub3BhcXVlUGFzc0VuYWJsZWRGb3JMYXllcigpID8gXCJvcGFxdWVcIiA6IFwidHJhbnNsdWNlbnRcIjtcblxuICAgICAgICAgICAgaWYgKHQucmVuZGVyUGFzcyA9PT0gdSkge1xuICAgICAgICAgICAgICB2YXIgaCA9IFB0LmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgcCA9IHQuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgXCJvcGFxdWVcIiA9PT0gdSA/IEl0LlJlYWRXcml0ZSA6IEl0LlJlYWRPbmx5KSxcbiAgICAgICAgICAgICAgICAgIGQgPSB0LmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSxcbiAgICAgICAgICAgICAgICAgIF8gPSB0LnVzZVByb2dyYW0oYyA/IFwiYmFja2dyb3VuZFBhdHRlcm5cIiA6IFwiYmFja2dyb3VuZFwiKSxcbiAgICAgICAgICAgICAgICAgIGYgPSBzLmNvdmVyaW5nVGlsZXMoe1xuICAgICAgICAgICAgICAgIHRpbGVTaXplOiBsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGMgJiYgKGEuYWN0aXZlVGV4dHVyZS5zZXQobi5URVhUVVJFMCksIHQuaW1hZ2VNYW5hZ2VyLmJpbmQodC5jb250ZXh0KSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IGkuZ2V0Q3Jvc3NmYWRlUGFyYW1ldGVycygpLCBnID0gMCwgdiA9IGY7IGcgPCB2Lmxlbmd0aDsgZyArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB2W2ddLFxuICAgICAgICAgICAgICAgICAgICB4ID0gdC50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KHkudG9VbndyYXBwZWQoKSksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBjID8gSGkoeCwgciwgdCwgYywge1xuICAgICAgICAgICAgICAgICAgdGlsZUlEOiB5LFxuICAgICAgICAgICAgICAgICAgdGlsZVNpemU6IGxcbiAgICAgICAgICAgICAgICB9LCBtKSA6IFhpKHgsIHIsIG8pO1xuXG4gICAgICAgICAgICAgICAgXy5kcmF3KGEsIG4uVFJJQU5HTEVTLCBwLCBoLCBkLCBDdC5kaXNhYmxlZCwgYiwgaS5pZCwgdC50aWxlRXh0ZW50QnVmZmVyLCB0LnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCB0LnRpbGVFeHRlbnRTZWdtZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcodCwgZSwgaSkge1xuICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGkubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICBnbyh0LCBlLCBpW29dKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0LmNvbnRleHQsXG4gICAgICAgICAgICByID0gaS5pbXBsZW1lbnRhdGlvbjtcblxuICAgICAgICBpZiAoXCJvZmZzY3JlZW5cIiA9PT0gdC5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgdmFyIGEgPSByLnByZXJlbmRlcjtcbiAgICAgICAgICBhICYmICh0LnNldEN1c3RvbUxheWVyRGVmYXVsdHMoKSwgby5zZXRDb2xvck1vZGUodC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCkpLCBhLmNhbGwociwgby5nbCwgdC50cmFuc2Zvcm0uY3VzdG9tTGF5ZXJNYXRyaXgoKSksIG8uc2V0RGlydHkoKSwgdC5zZXRCYXNlU3RhdGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MpIHtcbiAgICAgICAgICB0LnNldEN1c3RvbUxheWVyRGVmYXVsdHMoKSwgby5zZXRDb2xvck1vZGUodC5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCkpLCBvLnNldFN0ZW5jaWxNb2RlKFB0LmRpc2FibGVkKTtcbiAgICAgICAgICB2YXIgbiA9IFwiM2RcIiA9PT0gci5yZW5kZXJpbmdNb2RlID8gbmV3IEl0KHQuY29udGV4dC5nbC5MRVFVQUwsIEl0LlJlYWRXcml0ZSwgdC5kZXB0aFJhbmdlRm9yM0QpIDogdC5kZXB0aE1vZGVGb3JTdWJsYXllcigwLCBJdC5SZWFkT25seSk7XG4gICAgICAgICAgby5zZXREZXB0aE1vZGUobiksIHIucmVuZGVyKG8uZ2wsIHQudHJhbnNmb3JtLmN1c3RvbUxheWVyTWF0cml4KCkpLCBvLnNldERpcnR5KCksIHQuc2V0QmFzZVN0YXRlKCksIG8uYmluZEZyYW1lYnVmZmVyLnNldChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgICAgIHlvID0gZnVuY3Rpb24geW8odCwgZSkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IHp0KHQpLCB0aGlzLnRyYW5zZm9ybSA9IGUsIHRoaXMuX3RpbGVUZXh0dXJlcyA9IHt9LCB0aGlzLnNldHVwKCksIHRoaXMubnVtU3VibGF5ZXJzID0gRHQubWF4VW5kZXJ6b29taW5nICsgRHQubWF4T3Zlcnpvb21pbmcgKyAxLCB0aGlzLmRlcHRoRXBzaWxvbiA9IDEgLyBNYXRoLnBvdygyLCAxNiksIHRoaXMuY3Jvc3NUaWxlU3ltYm9sSW5kZXggPSBuZXcgRmUoKSwgdGhpcy5ncHVUaW1lcnMgPSB7fTtcbiAgICB9O1xuXG4gICAgeW8ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBpZiAodGhpcy53aWR0aCA9IGUgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbywgdGhpcy5oZWlnaHQgPSBpICogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sIHRoaXMuY29udGV4dC52aWV3cG9ydC5zZXQoWzAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSksIHRoaXMuc3R5bGUpIGZvciAodmFyIG8gPSAwLCByID0gdGhpcy5zdHlsZS5fb3JkZXI7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuX2xheWVyc1tyW29dXS5yZXNpemUoKTtcbiAgICAgIH1cbiAgICB9LCB5by5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBpID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyaTQoKTtcbiAgICAgIGkuZW1wbGFjZUJhY2soMCwgMCksIGkuZW1wbGFjZUJhY2sodC5FWFRFTlQsIDApLCBpLmVtcGxhY2VCYWNrKDAsIHQuRVhURU5UKSwgaS5lbXBsYWNlQmFjayh0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcihpLCBWZS5tZW1iZXJzKSwgdGhpcy50aWxlRXh0ZW50U2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKTtcbiAgICAgIHZhciBvID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyaTQoKTtcbiAgICAgIG8uZW1wbGFjZUJhY2soMCwgMCksIG8uZW1wbGFjZUJhY2sodC5FWFRFTlQsIDApLCBvLmVtcGxhY2VCYWNrKDAsIHQuRVhURU5UKSwgby5lbXBsYWNlQmFjayh0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLmRlYnVnQnVmZmVyID0gZS5jcmVhdGVWZXJ0ZXhCdWZmZXIobywgVmUubWVtYmVycyksIHRoaXMuZGVidWdTZWdtZW50cyA9IHQuU2VnbWVudFZlY3Rvci5zaW1wbGVTZWdtZW50KDAsIDAsIDQsIDUpO1xuICAgICAgdmFyIHIgPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDRpOCgpO1xuICAgICAgci5lbXBsYWNlQmFjaygwLCAwLCAwLCAwKSwgci5lbXBsYWNlQmFjayh0LkVYVEVOVCwgMCwgdC5FWFRFTlQsIDApLCByLmVtcGxhY2VCYWNrKDAsIHQuRVhURU5ULCAwLCB0LkVYVEVOVCksIHIuZW1wbGFjZUJhY2sodC5FWFRFTlQsIHQuRVhURU5ULCB0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLnJhc3RlckJvdW5kc0J1ZmZlciA9IGUuY3JlYXRlVmVydGV4QnVmZmVyKHIsIEEubWVtYmVycyksIHRoaXMucmFzdGVyQm91bmRzU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKTtcbiAgICAgIHZhciBhID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyaTQoKTtcbiAgICAgIGEuZW1wbGFjZUJhY2soMCwgMCksIGEuZW1wbGFjZUJhY2soMSwgMCksIGEuZW1wbGFjZUJhY2soMCwgMSksIGEuZW1wbGFjZUJhY2soMSwgMSksIHRoaXMudmlld3BvcnRCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcihhLCBWZS5tZW1iZXJzKSwgdGhpcy52aWV3cG9ydFNlZ21lbnRzID0gdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMCwgNCwgMik7XG4gICAgICB2YXIgbiA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0MXVpMigpO1xuICAgICAgbi5lbXBsYWNlQmFjaygwKSwgbi5lbXBsYWNlQmFjaygxKSwgbi5lbXBsYWNlQmFjaygzKSwgbi5lbXBsYWNlQmFjaygyKSwgbi5lbXBsYWNlQmFjaygwKSwgdGhpcy50aWxlQm9yZGVySW5kZXhCdWZmZXIgPSBlLmNyZWF0ZUluZGV4QnVmZmVyKG4pO1xuICAgICAgdmFyIHMgPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDN1aTYoKTtcbiAgICAgIHMuZW1wbGFjZUJhY2soMCwgMSwgMiksIHMuZW1wbGFjZUJhY2soMiwgMSwgMyksIHRoaXMucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIgPSBlLmNyZWF0ZUluZGV4QnVmZmVyKHMpLCB0aGlzLmVtcHR5VGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZSwge1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBkYXRhOiBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMF0pXG4gICAgICB9LCBlLmdsLlJHQkEpO1xuICAgICAgdmFyIGwgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICB0aGlzLnN0ZW5jaWxDbGVhck1vZGUgPSBuZXcgUHQoe1xuICAgICAgICBmdW5jOiBsLkFMV0FZUyxcbiAgICAgICAgbWFzazogMFxuICAgICAgfSwgMCwgMjU1LCBsLlpFUk8sIGwuWkVSTywgbC5aRVJPKTtcbiAgICB9LCB5by5wcm90b3R5cGUuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaSA9IGUuZ2w7XG4gICAgICB0aGlzLm5leHRTdGVuY2lsSUQgPSAxLCB0aGlzLmN1cnJlbnRTdGVuY2lsU291cmNlID0gdm9pZCAwO1xuICAgICAgdmFyIG8gPSB0LmNyZWF0ZSgpO1xuICAgICAgdC5vcnRobyhvLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgMCwgMSksIHQuc2NhbGUobywgbywgW2kuZHJhd2luZ0J1ZmZlcldpZHRoLCBpLmRyYXdpbmdCdWZmZXJIZWlnaHQsIDBdKSwgdGhpcy51c2VQcm9ncmFtKFwiY2xpcHBpbmdNYXNrXCIpLmRyYXcoZSwgaS5UUklBTkdMRVMsIEl0LmRpc2FibGVkLCB0aGlzLnN0ZW5jaWxDbGVhck1vZGUsIFN0LmRpc2FibGVkLCBDdC5kaXNhYmxlZCwgTGkobyksIFwiJGNsaXBwaW5nXCIsIHRoaXMudmlld3BvcnRCdWZmZXIsIHRoaXMucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIHRoaXMudmlld3BvcnRTZWdtZW50cyk7XG4gICAgfSwgeW8ucHJvdG90eXBlLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50U3RlbmNpbFNvdXJjZSAhPT0gdC5zb3VyY2UgJiYgdC5pc1RpbGVDbGlwcGVkKCkgJiYgZSAmJiBlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVuY2lsU291cmNlID0gdC5zb3VyY2U7XG4gICAgICAgIHZhciBpID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgbyA9IGkuZ2w7XG4gICAgICAgIHRoaXMubmV4dFN0ZW5jaWxJRCArIGUubGVuZ3RoID4gMjU2ICYmIHRoaXMuY2xlYXJTdGVuY2lsKCksIGkuc2V0Q29sb3JNb2RlKFN0LmRpc2FibGVkKSwgaS5zZXREZXB0aE1vZGUoSXQuZGlzYWJsZWQpO1xuICAgICAgICB2YXIgciA9IHRoaXMudXNlUHJvZ3JhbShcImNsaXBwaW5nTWFza1wiKTtcbiAgICAgICAgdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gZTsgYSA8IG4ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICB2YXIgcyA9IG5bYV0sXG4gICAgICAgICAgICAgIGwgPSB0aGlzLl90aWxlQ2xpcHBpbmdNYXNrSURzW3Mua2V5XSA9IHRoaXMubmV4dFN0ZW5jaWxJRCsrO1xuICAgICAgICAgIHIuZHJhdyhpLCBvLlRSSUFOR0xFUywgSXQuZGlzYWJsZWQsIG5ldyBQdCh7XG4gICAgICAgICAgICBmdW5jOiBvLkFMV0FZUyxcbiAgICAgICAgICAgIG1hc2s6IDBcbiAgICAgICAgICB9LCBsLCAyNTUsIG8uS0VFUCwgby5LRUVQLCBvLlJFUExBQ0UpLCBTdC5kaXNhYmxlZCwgQ3QuZGlzYWJsZWQsIExpKHMucG9zTWF0cml4KSwgXCIkY2xpcHBpbmdcIiwgdGhpcy50aWxlRXh0ZW50QnVmZmVyLCB0aGlzLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCB0aGlzLnRpbGVFeHRlbnRTZWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB5by5wcm90b3R5cGUuc3RlbmNpbE1vZGVGb3IzRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZW5jaWxTb3VyY2UgPSB2b2lkIDAsIHRoaXMubmV4dFN0ZW5jaWxJRCArIDEgPiAyNTYgJiYgdGhpcy5jbGVhclN0ZW5jaWwoKTtcbiAgICAgIHZhciB0ID0gdGhpcy5uZXh0U3RlbmNpbElEKyssXG4gICAgICAgICAgZSA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgIHJldHVybiBuZXcgUHQoe1xuICAgICAgICBmdW5jOiBlLk5PVEVRVUFMLFxuICAgICAgICBtYXNrOiAyNTVcbiAgICAgIH0sIHQsIDI1NSwgZS5LRUVQLCBlLktFRVAsIGUuUkVQTEFDRSk7XG4gICAgfSwgeW8ucHJvdG90eXBlLnN0ZW5jaWxNb2RlRm9yQ2xpcHBpbmcgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICByZXR1cm4gbmV3IFB0KHtcbiAgICAgICAgZnVuYzogZS5FUVVBTCxcbiAgICAgICAgbWFzazogMjU1XG4gICAgICB9LCB0aGlzLl90aWxlQ2xpcHBpbmdNYXNrSURzW3Qua2V5XSwgMCwgZS5LRUVQLCBlLktFRVAsIGUuUkVQTEFDRSk7XG4gICAgfSwgeW8ucHJvdG90eXBlLnN0ZW5jaWxDb25maWdGb3JPdmVybGFwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlLFxuICAgICAgICAgIGkgPSB0aGlzLmNvbnRleHQuZ2wsXG4gICAgICAgICAgbyA9IHQuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZS5vdmVyc2NhbGVkWiAtIHQub3ZlcnNjYWxlZFo7XG4gICAgICB9KSxcbiAgICAgICAgICByID0gb1tvLmxlbmd0aCAtIDFdLm92ZXJzY2FsZWRaLFxuICAgICAgICAgIGEgPSBvWzBdLm92ZXJzY2FsZWRaIC0gciArIDE7XG5cbiAgICAgIGlmIChhID4gMSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVuY2lsU291cmNlID0gdm9pZCAwLCB0aGlzLm5leHRTdGVuY2lsSUQgKyBhID4gMjU2ICYmIHRoaXMuY2xlYXJTdGVuY2lsKCk7XG5cbiAgICAgICAgZm9yICh2YXIgbiA9IHt9LCBzID0gMDsgcyA8IGE7IHMrKykge1xuICAgICAgICAgIG5bcyArIHJdID0gbmV3IFB0KHtcbiAgICAgICAgICAgIGZ1bmM6IGkuR0VRVUFMLFxuICAgICAgICAgICAgbWFzazogMjU1XG4gICAgICAgICAgfSwgcyArIHRoaXMubmV4dFN0ZW5jaWxJRCwgMjU1LCBpLktFRVAsIGkuS0VFUCwgaS5SRVBMQUNFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRTdGVuY2lsSUQgKz0gYSwgW24sIG9dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gWyhlID0ge30sIGVbcl0gPSBQdC5kaXNhYmxlZCwgZSksIG9dO1xuICAgIH0sIHlvLnByb3RvdHlwZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICByZXR1cm4gdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID8gbmV3IFN0KFtlLkNPTlNUQU5UX0NPTE9SLCBlLk9ORV0sIG5ldyB0LkNvbG9yKDEgLyA4LCAxIC8gOCwgMSAvIDgsIDApLCBbITAsICEwLCAhMCwgITBdKSA6IFwib3BhcXVlXCIgPT09IHRoaXMucmVuZGVyUGFzcyA/IFN0LnVuYmxlbmRlZCA6IFN0LmFscGhhQmxlbmRlZDtcbiAgICB9LCB5by5wcm90b3R5cGUuZGVwdGhNb2RlRm9yU3VibGF5ZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgaWYgKCF0aGlzLm9wYXF1ZVBhc3NFbmFibGVkRm9yTGF5ZXIoKSkgcmV0dXJuIEl0LmRpc2FibGVkO1xuICAgICAgdmFyIG8gPSAxIC0gKCgxICsgdGhpcy5jdXJyZW50TGF5ZXIpICogdGhpcy5udW1TdWJsYXllcnMgKyB0KSAqIHRoaXMuZGVwdGhFcHNpbG9uO1xuICAgICAgcmV0dXJuIG5ldyBJdChpIHx8IHRoaXMuY29udGV4dC5nbC5MRVFVQUwsIGUsIFtvLCBvXSk7XG4gICAgfSwgeW8ucHJvdG90eXBlLm9wYXF1ZVBhc3NFbmFibGVkRm9yTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TGF5ZXIgPCB0aGlzLm9wYXF1ZVBhc3NDdXRvZmY7XG4gICAgfSwgeW8ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICB0aGlzLnN0eWxlID0gZSwgdGhpcy5vcHRpb25zID0gaSwgdGhpcy5saW5lQXRsYXMgPSBlLmxpbmVBdGxhcywgdGhpcy5pbWFnZU1hbmFnZXIgPSBlLmltYWdlTWFuYWdlciwgdGhpcy5nbHlwaE1hbmFnZXIgPSBlLmdseXBoTWFuYWdlciwgdGhpcy5zeW1ib2xGYWRlQ2hhbmdlID0gZS5wbGFjZW1lbnQuc3ltYm9sRmFkZUNoYW5nZSh0LmJyb3dzZXIubm93KCkpLCB0aGlzLmltYWdlTWFuYWdlci5iZWdpbkZyYW1lKCk7XG4gICAgICB2YXIgciA9IHRoaXMuc3R5bGUuX29yZGVyLFxuICAgICAgICAgIGEgPSB0aGlzLnN0eWxlLnNvdXJjZUNhY2hlcztcblxuICAgICAgZm9yICh2YXIgbiBpbiBhKSB7XG4gICAgICAgIHZhciBzID0gYVtuXTtcbiAgICAgICAgcy51c2VkICYmIHMucHJlcGFyZSh0aGlzLmNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHUgPSB7fSxcbiAgICAgICAgICBoID0ge30sXG4gICAgICAgICAgcCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBkIGluIGEpIHtcbiAgICAgICAgdmFyIF8gPSBhW2RdO1xuICAgICAgICB1W2RdID0gXy5nZXRWaXNpYmxlQ29vcmRpbmF0ZXMoKSwgaFtkXSA9IHVbZF0uc2xpY2UoKS5yZXZlcnNlKCksIHBbZF0gPSBfLmdldFZpc2libGVDb29yZGluYXRlcyghMCkucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wYXF1ZVBhc3NDdXRvZmYgPSAxIC8gMDtcblxuICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCByLmxlbmd0aDsgZisrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLl9sYXllcnNbcltmXV0uaXMzRCgpKSB7XG4gICAgICAgICAgdGhpcy5vcGFxdWVQYXNzQ3V0b2ZmID0gZjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlclBhc3MgPSBcIm9mZnNjcmVlblwiO1xuXG4gICAgICBmb3IgKHZhciBtID0gMCwgZyA9IHI7IG0gPCBnLmxlbmd0aDsgbSArPSAxKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5zdHlsZS5fbGF5ZXJzW2dbbV1dO1xuXG4gICAgICAgIGlmICh2Lmhhc09mZnNjcmVlblBhc3MoKSAmJiAhdi5pc0hpZGRlbih0aGlzLnRyYW5zZm9ybS56b29tKSkge1xuICAgICAgICAgIHZhciB5ID0gaFt2LnNvdXJjZV07XG4gICAgICAgICAgKFwiY3VzdG9tXCIgPT09IHYudHlwZSB8fCB5Lmxlbmd0aCkgJiYgdGhpcy5yZW5kZXJMYXllcih0aGlzLCBhW3Yuc291cmNlXSwgdiwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh0aGlzLmNvbnRleHQuYmluZEZyYW1lYnVmZmVyLnNldChudWxsKSwgdGhpcy5jb250ZXh0LmNsZWFyKHtcbiAgICAgICAgY29sb3I6IGkuc2hvd092ZXJkcmF3SW5zcGVjdG9yID8gdC5Db2xvci5ibGFjayA6IHQuQ29sb3IudHJhbnNwYXJlbnQsXG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KSwgdGhpcy5jbGVhclN0ZW5jaWwoKSwgdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID0gaS5zaG93T3ZlcmRyYXdJbnNwZWN0b3IsIHRoaXMuZGVwdGhSYW5nZUZvcjNEID0gWzAsIDEgLSAoZS5fb3JkZXIubGVuZ3RoICsgMikgKiB0aGlzLm51bVN1YmxheWVycyAqIHRoaXMuZGVwdGhFcHNpbG9uXSwgdGhpcy5yZW5kZXJQYXNzID0gXCJvcGFxdWVcIiwgdGhpcy5jdXJyZW50TGF5ZXIgPSByLmxlbmd0aCAtIDE7IHRoaXMuY3VycmVudExheWVyID49IDA7IHRoaXMuY3VycmVudExheWVyLS0pIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnN0eWxlLl9sYXllcnNbclt0aGlzLmN1cnJlbnRMYXllcl1dLFxuICAgICAgICAgICAgYiA9IGFbeC5zb3VyY2VdLFxuICAgICAgICAgICAgdyA9IHVbeC5zb3VyY2VdO1xuICAgICAgICB0aGlzLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyh4LCB3KSwgdGhpcy5yZW5kZXJMYXllcih0aGlzLCBiLCB4LCB3KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh0aGlzLnJlbmRlclBhc3MgPSBcInRyYW5zbHVjZW50XCIsIHRoaXMuY3VycmVudExheWVyID0gMDsgdGhpcy5jdXJyZW50TGF5ZXIgPCByLmxlbmd0aDsgdGhpcy5jdXJyZW50TGF5ZXIrKykge1xuICAgICAgICB2YXIgVCA9IHRoaXMuc3R5bGUuX2xheWVyc1tyW3RoaXMuY3VycmVudExheWVyXV0sXG4gICAgICAgICAgICBFID0gYVtULnNvdXJjZV0sXG4gICAgICAgICAgICBJID0gKFwic3ltYm9sXCIgPT09IFQudHlwZSA/IHAgOiBoKVtULnNvdXJjZV07XG4gICAgICAgIHRoaXMuX3JlbmRlclRpbGVDbGlwcGluZ01hc2tzKFQsIHVbVC5zb3VyY2VdKSwgdGhpcy5yZW5kZXJMYXllcih0aGlzLCBFLCBULCBJKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLnNob3dUaWxlQm91bmRhcmllcyAmJiAodC52YWx1ZXModGhpcy5zdHlsZS5fbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQuc291cmNlICYmICF0LmlzSGlkZGVuKG8udHJhbnNmb3JtLnpvb20pICYmICh0LnNvdXJjZSAhPT0gKGMgJiYgYy5pZCkgJiYgKGMgPSBvLnN0eWxlLnNvdXJjZUNhY2hlc1t0LnNvdXJjZV0pLCAoIWwgfHwgbC5nZXRTb3VyY2UoKS5tYXh6b29tIDwgYy5nZXRTb3VyY2UoKS5tYXh6b29tKSAmJiAobCA9IGMpKTtcbiAgICAgIH0pLCBsICYmIHZvLmRlYnVnKHRoaXMsIGwsIGwuZ2V0VmlzaWJsZUNvb3JkaW5hdGVzKCkpKSwgdGhpcy5vcHRpb25zLnNob3dQYWRkaW5nICYmIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdC50cmFuc2Zvcm0ucGFkZGluZztcbiAgICAgICAgX28odCwgdC50cmFuc2Zvcm0uaGVpZ2h0IC0gKGUudG9wIHx8IDApLCAzLCBsbyksIF9vKHQsIGUuYm90dG9tIHx8IDAsIDMsIGNvKSwgZm8odCwgZS5sZWZ0IHx8IDAsIDMsIHVvKSwgZm8odCwgdC50cmFuc2Zvcm0ud2lkdGggLSAoZS5yaWdodCB8fCAwKSwgMywgaG8pO1xuICAgICAgICB2YXIgaSA9IHQudHJhbnNmb3JtLmNlbnRlclBvaW50O1xuICAgICAgICAhZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgICBtbyh0LCBlIC0gMSwgaSAtIDEwLCAyLCAyMCwgbyksIG1vKHQsIGUgLSAxMCwgaSAtIDEsIDIwLCAyLCBvKTtcbiAgICAgICAgfSh0LCBpLngsIHQudHJhbnNmb3JtLmhlaWdodCAtIGkueSwgcG8pO1xuICAgICAgfSh0aGlzKSwgdGhpcy5jb250ZXh0LnNldERlZmF1bHQoKTtcbiAgICB9LCB5by5wcm90b3R5cGUucmVuZGVyTGF5ZXIgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgaS5pc0hpZGRlbih0aGlzLnRyYW5zZm9ybS56b29tKSB8fCAoXCJiYWNrZ3JvdW5kXCIgPT09IGkudHlwZSB8fCBcImN1c3RvbVwiID09PSBpLnR5cGUgfHwgby5sZW5ndGgpICYmICh0aGlzLmlkID0gaS5pZCwgdGhpcy5ncHVUaW1pbmdTdGFydChpKSwgdm9baS50eXBlXSh0LCBlLCBpLCBvLCB0aGlzLnN0eWxlLnBsYWNlbWVudC52YXJpYWJsZU9mZnNldHMpLCB0aGlzLmdwdVRpbWluZ0VuZCgpKTtcbiAgICB9LCB5by5wcm90b3R5cGUuZ3B1VGltaW5nU3RhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncHVUaW1pbmcpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQuZXh0VGltZXJRdWVyeSxcbiAgICAgICAgICAgIGkgPSB0aGlzLmdwdVRpbWVyc1t0LmlkXTtcbiAgICAgICAgaSB8fCAoaSA9IHRoaXMuZ3B1VGltZXJzW3QuaWRdID0ge1xuICAgICAgICAgIGNhbGxzOiAwLFxuICAgICAgICAgIGNwdVRpbWU6IDAsXG4gICAgICAgICAgcXVlcnk6IGUuY3JlYXRlUXVlcnlFWFQoKVxuICAgICAgICB9KSwgaS5jYWxscysrLCBlLmJlZ2luUXVlcnlFWFQoZS5USU1FX0VMQVBTRURfRVhULCBpLnF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9LCB5by5wcm90b3R5cGUuZ3B1VGltaW5nRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncHVUaW1pbmcpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmNvbnRleHQuZXh0VGltZXJRdWVyeTtcbiAgICAgICAgdC5lbmRRdWVyeUVYVCh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgfVxuICAgIH0sIHlvLnByb3RvdHlwZS5jb2xsZWN0R3B1VGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmdwdVRpbWVycztcbiAgICAgIHJldHVybiB0aGlzLmdwdVRpbWVycyA9IHt9LCB0O1xuICAgIH0sIHlvLnByb3RvdHlwZS5xdWVyeUdwdVRpbWVycyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIHQpIHtcbiAgICAgICAgdmFyIG8gPSB0W2ldLFxuICAgICAgICAgICAgciA9IHRoaXMuY29udGV4dC5leHRUaW1lclF1ZXJ5LFxuICAgICAgICAgICAgYSA9IHIuZ2V0UXVlcnlPYmplY3RFWFQoby5xdWVyeSwgci5RVUVSWV9SRVNVTFRfRVhUKSAvIDFlNjtcbiAgICAgICAgci5kZWxldGVRdWVyeUVYVChvLnF1ZXJ5KSwgZVtpXSA9IGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH0sIHlvLnByb3RvdHlwZS50cmFuc2xhdGVQb3NNYXRyaXggPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgaWYgKCFvWzBdICYmICFvWzFdKSByZXR1cm4gZTtcbiAgICAgIHZhciBuID0gYSA/IFwibWFwXCIgPT09IHIgPyB0aGlzLnRyYW5zZm9ybS5hbmdsZSA6IDAgOiBcInZpZXdwb3J0XCIgPT09IHIgPyAtdGhpcy50cmFuc2Zvcm0uYW5nbGUgOiAwO1xuXG4gICAgICBpZiAobikge1xuICAgICAgICB2YXIgcyA9IE1hdGguc2luKG4pLFxuICAgICAgICAgICAgbCA9IE1hdGguY29zKG4pO1xuICAgICAgICBvID0gW29bMF0gKiBsIC0gb1sxXSAqIHMsIG9bMF0gKiBzICsgb1sxXSAqIGxdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYyA9IFthID8gb1swXSA6IHBlKGksIG9bMF0sIHRoaXMudHJhbnNmb3JtLnpvb20pLCBhID8gb1sxXSA6IHBlKGksIG9bMV0sIHRoaXMudHJhbnNmb3JtLnpvb20pLCAwXSxcbiAgICAgICAgICB1ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICByZXR1cm4gdC50cmFuc2xhdGUodSwgZSwgYyksIHU7XG4gICAgfSwgeW8ucHJvdG90eXBlLnNhdmVUaWxlVGV4dHVyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3RpbGVUZXh0dXJlc1t0LnNpemVbMF1dO1xuICAgICAgZSA/IGUucHVzaCh0KSA6IHRoaXMuX3RpbGVUZXh0dXJlc1t0LnNpemVbMF1dID0gW3RdO1xuICAgIH0sIHlvLnByb3RvdHlwZS5nZXRUaWxlVGV4dHVyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3RpbGVUZXh0dXJlc1t0XTtcbiAgICAgIHJldHVybiBlICYmIGUubGVuZ3RoID4gMCA/IGUucG9wKCkgOiBudWxsO1xuICAgIH0sIHlvLnByb3RvdHlwZS5pc1BhdHRlcm5NaXNzaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICghdCkgcmV0dXJuICExO1xuICAgICAgaWYgKCF0LmZyb20gfHwgIXQudG8pIHJldHVybiAhMDtcbiAgICAgIHZhciBlID0gdGhpcy5pbWFnZU1hbmFnZXIuZ2V0UGF0dGVybih0LmZyb20udG9TdHJpbmcoKSksXG4gICAgICAgICAgaSA9IHRoaXMuaW1hZ2VNYW5hZ2VyLmdldFBhdHRlcm4odC50by50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiAhZSB8fCAhaTtcbiAgICB9LCB5by5wcm90b3R5cGUudXNlUHJvZ3JhbSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZSB8fCB7fTtcbiAgICAgIHZhciBpID0gXCJcIiArIHQgKyAoZSA/IGUuY2FjaGVLZXkgOiBcIlwiKSArICh0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPyBcIi9vdmVyZHJhd1wiIDogXCJcIik7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVtpXSB8fCAodGhpcy5jYWNoZVtpXSA9IG5ldyBiaSh0aGlzLmNvbnRleHQsIHQsIHZpW3RdLCBlLCBLaVt0XSwgdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yKSksIHRoaXMuY2FjaGVbaV07XG4gICAgfSwgeW8ucHJvdG90eXBlLnNldEN1c3RvbUxheWVyRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnRleHQudW5iaW5kVkFPKCksIHRoaXMuY29udGV4dC5jdWxsRmFjZS5zZXREZWZhdWx0KCksIHRoaXMuY29udGV4dC5hY3RpdmVUZXh0dXJlLnNldERlZmF1bHQoKSwgdGhpcy5jb250ZXh0LnBpeGVsU3RvcmVVbnBhY2suc2V0RGVmYXVsdCgpLCB0aGlzLmNvbnRleHQucGl4ZWxTdG9yZVVucGFja1ByZW11bHRpcGx5QWxwaGEuc2V0RGVmYXVsdCgpLCB0aGlzLmNvbnRleHQucGl4ZWxTdG9yZVVucGFja0ZsaXBZLnNldERlZmF1bHQoKTtcbiAgICB9LCB5by5wcm90b3R5cGUuc2V0QmFzZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICB0aGlzLmNvbnRleHQuY3VsbEZhY2Uuc2V0KCExKSwgdGhpcy5jb250ZXh0LnZpZXdwb3J0LnNldChbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdKSwgdGhpcy5jb250ZXh0LmJsZW5kRXF1YXRpb24uc2V0KHQuRlVOQ19BREQpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5pbml0RGVidWdPdmVybGF5Q2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgbnVsbCA9PSB0aGlzLmRlYnVnT3ZlcmxheUNhbnZhcyAmJiAodGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMgPSB0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCB0aGlzLmRlYnVnT3ZlcmxheUNhbnZhcy53aWR0aCA9IDUxMiwgdGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMuaGVpZ2h0ID0gNTEyLCB0aGlzLmRlYnVnT3ZlcmxheVRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKHRoaXMuY29udGV4dCwgdGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMsIHRoaXMuY29udGV4dC5nbC5SR0JBKSk7XG4gICAgfSwgeW8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVtcHR5VGV4dHVyZS5kZXN0cm95KCksIHRoaXMuZGVidWdPdmVybGF5VGV4dHVyZSAmJiB0aGlzLmRlYnVnT3ZlcmxheVRleHR1cmUuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICB2YXIgeG8gPSBmdW5jdGlvbiB4byh0LCBlKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IHQsIHRoaXMucGxhbmVzID0gZTtcbiAgICB9O1xuXG4gICAgeG8uZnJvbUludlByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBNYXRoLnBvdygyLCBvKSxcbiAgICAgICAgICBhID0gW1stMSwgMSwgLTEsIDFdLCBbMSwgMSwgLTEsIDFdLCBbMSwgLTEsIC0xLCAxXSwgWy0xLCAtMSwgLTEsIDFdLCBbLTEsIDEsIDEsIDFdLCBbMSwgMSwgMSwgMV0sIFsxLCAtMSwgMSwgMV0sIFstMSwgLTEsIDEsIDFdXS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHQudHJhbnNmb3JtTWF0NChbXSwgaSwgZSk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHQuc2NhbGUkMShbXSwgZSwgMSAvIGVbM10gLyBpICogcik7XG4gICAgICB9KSxcbiAgICAgICAgICBuID0gW1swLCAxLCAyXSwgWzYsIDUsIDRdLCBbMCwgMywgN10sIFsyLCAxLCA1XSwgWzMsIDIsIDZdLCBbMCwgNCwgNV1dLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHQuc3ViKFtdLCBhW2VbMF1dLCBhW2VbMV1dKSxcbiAgICAgICAgICAgIG8gPSB0LnN1YihbXSwgYVtlWzJdXSwgYVtlWzFdXSksXG4gICAgICAgICAgICByID0gdC5ub3JtYWxpemUoW10sIHQuY3Jvc3MoW10sIGksIG8pKSxcbiAgICAgICAgICAgIG4gPSAtdC5kb3QociwgYVtlWzFdXSk7XG4gICAgICAgIHJldHVybiByLmNvbmNhdChuKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyB4byhhLCBuKTtcbiAgICB9O1xuXG4gICAgdmFyIGJvID0gZnVuY3Rpb24gYm8oZSwgaSkge1xuICAgICAgdGhpcy5taW4gPSBlLCB0aGlzLm1heCA9IGksIHRoaXMuY2VudGVyID0gdC5zY2FsZSQyKFtdLCB0LmFkZChbXSwgdGhpcy5taW4sIHRoaXMubWF4KSwgLjUpO1xuICAgIH07XG5cbiAgICBiby5wcm90b3R5cGUucXVhZHJhbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZm9yICh2YXIgaSA9IFtlICUgMiA9PSAwLCBlIDwgMl0sIG8gPSB0LmNsb25lJDIodGhpcy5taW4pLCByID0gdC5jbG9uZSQyKHRoaXMubWF4KSwgYSA9IDA7IGEgPCBpLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIG9bYV0gPSBpW2FdID8gdGhpcy5taW5bYV0gOiB0aGlzLmNlbnRlclthXSwgclthXSA9IGlbYV0gPyB0aGlzLmNlbnRlclthXSA6IHRoaXMubWF4W2FdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gclsyXSA9IHRoaXMubWF4WzJdLCBuZXcgYm8obywgcik7XG4gICAgfSwgYm8ucHJvdG90eXBlLmRpc3RhbmNlWCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5tYXhbMF0sIHRbMF0pLCB0aGlzLm1pblswXSkgLSB0WzBdO1xuICAgIH0sIGJvLnByb3RvdHlwZS5kaXN0YW5jZVkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHRoaXMubWF4WzFdLCB0WzFdKSwgdGhpcy5taW5bMV0pIC0gdFsxXTtcbiAgICB9LCBiby5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmb3IgKHZhciBpID0gW1t0aGlzLm1pblswXSwgdGhpcy5taW5bMV0sIDAsIDFdLCBbdGhpcy5tYXhbMF0sIHRoaXMubWluWzFdLCAwLCAxXSwgW3RoaXMubWF4WzBdLCB0aGlzLm1heFsxXSwgMCwgMV0sIFt0aGlzLm1pblswXSwgdGhpcy5tYXhbMV0sIDAsIDFdXSwgbyA9ICEwLCByID0gMDsgciA8IGUucGxhbmVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBlLnBsYW5lc1tyXSwgbiA9IDAsIHMgPSAwOyBzIDwgaS5sZW5ndGg7IHMrKykge1xuICAgICAgICAgIG4gKz0gdC5kb3QkMShhLCBpW3NdKSA+PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDAgPT09IG4pIHJldHVybiAwO1xuICAgICAgICBuICE9PSBpLmxlbmd0aCAmJiAobyA9ICExKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG8pIHJldHVybiAyO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IDM7IGwrKykge1xuICAgICAgICBmb3IgKHZhciBjID0gTnVtYmVyLk1BWF9WQUxVRSwgdSA9IC1OdW1iZXIuTUFYX1ZBTFVFLCBoID0gMDsgaCA8IGUucG9pbnRzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgdmFyIHAgPSBlLnBvaW50c1toXVtsXSAtIHRoaXMubWluW2xdO1xuICAgICAgICAgIGMgPSBNYXRoLm1pbihjLCBwKSwgdSA9IE1hdGgubWF4KHUsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHUgPCAwIHx8IGMgPiB0aGlzLm1heFtsXSAtIHRoaXMubWluW2xdKSByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfTtcblxuICAgIHZhciB3byA9IGZ1bmN0aW9uIHdvKHQsIGUsIGksIG8pIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQgJiYgKHQgPSAwKSwgdm9pZCAwID09PSBlICYmIChlID0gMCksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IDApLCB2b2lkIDAgPT09IG8gJiYgKG8gPSAwKSwgaXNOYU4odCkgfHwgdCA8IDAgfHwgaXNOYU4oZSkgfHwgZSA8IDAgfHwgaXNOYU4oaSkgfHwgaSA8IDAgfHwgaXNOYU4obykgfHwgbyA8IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGVkZ2UtaW5zZXRzLCB0b3AsIGJvdHRvbSwgbGVmdCBhbmQgcmlnaHQgbXVzdCBhbGwgYmUgbnVtYmVyc1wiKTtcbiAgICAgIHRoaXMudG9wID0gdCwgdGhpcy5ib3R0b20gPSBlLCB0aGlzLmxlZnQgPSBpLCB0aGlzLnJpZ2h0ID0gbztcbiAgICB9O1xuXG4gICAgd28ucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHJldHVybiBudWxsICE9IGkudG9wICYmIG51bGwgIT0gZS50b3AgJiYgKHRoaXMudG9wID0gdC5udW1iZXIoZS50b3AsIGkudG9wLCBvKSksIG51bGwgIT0gaS5ib3R0b20gJiYgbnVsbCAhPSBlLmJvdHRvbSAmJiAodGhpcy5ib3R0b20gPSB0Lm51bWJlcihlLmJvdHRvbSwgaS5ib3R0b20sIG8pKSwgbnVsbCAhPSBpLmxlZnQgJiYgbnVsbCAhPSBlLmxlZnQgJiYgKHRoaXMubGVmdCA9IHQubnVtYmVyKGUubGVmdCwgaS5sZWZ0LCBvKSksIG51bGwgIT0gaS5yaWdodCAmJiBudWxsICE9IGUucmlnaHQgJiYgKHRoaXMucmlnaHQgPSB0Lm51bWJlcihlLnJpZ2h0LCBpLnJpZ2h0LCBvKSksIHRoaXM7XG4gICAgfSwgd28ucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IHQuY2xhbXAoKHRoaXMubGVmdCArIGUgLSB0aGlzLnJpZ2h0KSAvIDIsIDAsIGUpLFxuICAgICAgICAgIHIgPSB0LmNsYW1wKCh0aGlzLnRvcCArIGkgLSB0aGlzLmJvdHRvbSkgLyAyLCAwLCBpKTtcbiAgICAgIHJldHVybiBuZXcgdC5Qb2ludChvLCByKTtcbiAgICB9LCB3by5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvcCA9PT0gdC50b3AgJiYgdGhpcy5ib3R0b20gPT09IHQuYm90dG9tICYmIHRoaXMubGVmdCA9PT0gdC5sZWZ0ICYmIHRoaXMucmlnaHQgPT09IHQucmlnaHQ7XG4gICAgfSwgd28ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyB3byh0aGlzLnRvcCwgdGhpcy5ib3R0b20sIHRoaXMubGVmdCwgdGhpcy5yaWdodCk7XG4gICAgfSwgd28ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgIGJvdHRvbTogdGhpcy5ib3R0b20sXG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBUbyA9IGZ1bmN0aW9uIFRvKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHRoaXMudGlsZVNpemUgPSA1MTIsIHRoaXMubWF4VmFsaWRMYXRpdHVkZSA9IDg1LjA1MTEyOSwgdGhpcy5fcmVuZGVyV29ybGRDb3BpZXMgPSB2b2lkIDAgPT09IGEgfHwgYSwgdGhpcy5fbWluWm9vbSA9IGUgfHwgMCwgdGhpcy5fbWF4Wm9vbSA9IGkgfHwgMjIsIHRoaXMuX21pblBpdGNoID0gbnVsbCA9PSBvID8gMCA6IG8sIHRoaXMuX21heFBpdGNoID0gbnVsbCA9PSByID8gNjAgOiByLCB0aGlzLnNldE1heEJvdW5kcygpLCB0aGlzLndpZHRoID0gMCwgdGhpcy5oZWlnaHQgPSAwLCB0aGlzLl9jZW50ZXIgPSBuZXcgdC5MbmdMYXQoMCwgMCksIHRoaXMuem9vbSA9IDAsIHRoaXMuYW5nbGUgPSAwLCB0aGlzLl9mb3YgPSAuNjQzNTAxMTA4NzkzMjg0NCwgdGhpcy5fcGl0Y2ggPSAwLCB0aGlzLl91bm1vZGlmaWVkID0gITAsIHRoaXMuX2VkZ2VJbnNldHMgPSBuZXcgd28oKSwgdGhpcy5fcG9zTWF0cml4Q2FjaGUgPSB7fSwgdGhpcy5fYWxpZ25lZFBvc01hdHJpeENhY2hlID0ge307XG4gICAgfSxcbiAgICAgICAgRW8gPSB7XG4gICAgICBtaW5ab29tOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBtYXhab29tOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBtaW5QaXRjaDoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgbWF4UGl0Y2g6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHJlbmRlcldvcmxkQ29waWVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICB3b3JsZFNpemU6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIGNlbnRlck9mZnNldDoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgYmVhcmluZzoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgcGl0Y2g6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIGZvdjoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgem9vbToge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBjZW50ZXJQb2ludDoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgdW5tb2RpZmllZDoge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9LFxuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfVxuICAgIH07XG5cbiAgICBUby5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IG5ldyBUbyh0aGlzLl9taW5ab29tLCB0aGlzLl9tYXhab29tLCB0aGlzLl9taW5QaXRjaCwgdGhpcy5tYXhQaXRjaCwgdGhpcy5fcmVuZGVyV29ybGRDb3BpZXMpO1xuICAgICAgcmV0dXJuIHQudGlsZVNpemUgPSB0aGlzLnRpbGVTaXplLCB0LmxhdFJhbmdlID0gdGhpcy5sYXRSYW5nZSwgdC53aWR0aCA9IHRoaXMud2lkdGgsIHQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHQuX2NlbnRlciA9IHRoaXMuX2NlbnRlciwgdC56b29tID0gdGhpcy56b29tLCB0LmFuZ2xlID0gdGhpcy5hbmdsZSwgdC5fZm92ID0gdGhpcy5fZm92LCB0Ll9waXRjaCA9IHRoaXMuX3BpdGNoLCB0Ll91bm1vZGlmaWVkID0gdGhpcy5fdW5tb2RpZmllZCwgdC5fZWRnZUluc2V0cyA9IHRoaXMuX2VkZ2VJbnNldHMuY2xvbmUoKSwgdC5fY2FsY01hdHJpY2VzKCksIHQ7XG4gICAgfSwgRW8ubWluWm9vbS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWluWm9vbTtcbiAgICB9LCBFby5taW5ab29tLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9taW5ab29tICE9PSB0ICYmICh0aGlzLl9taW5ab29tID0gdCwgdGhpcy56b29tID0gTWF0aC5tYXgodGhpcy56b29tLCB0KSk7XG4gICAgfSwgRW8ubWF4Wm9vbS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4Wm9vbTtcbiAgICB9LCBFby5tYXhab29tLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXhab29tICE9PSB0ICYmICh0aGlzLl9tYXhab29tID0gdCwgdGhpcy56b29tID0gTWF0aC5taW4odGhpcy56b29tLCB0KSk7XG4gICAgfSwgRW8ubWluUGl0Y2guZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pblBpdGNoO1xuICAgIH0sIEVvLm1pblBpdGNoLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9taW5QaXRjaCAhPT0gdCAmJiAodGhpcy5fbWluUGl0Y2ggPSB0LCB0aGlzLnBpdGNoID0gTWF0aC5tYXgodGhpcy5waXRjaCwgdCkpO1xuICAgIH0sIEVvLm1heFBpdGNoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXhQaXRjaDtcbiAgICB9LCBFby5tYXhQaXRjaC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWF4UGl0Y2ggIT09IHQgJiYgKHRoaXMuX21heFBpdGNoID0gdCwgdGhpcy5waXRjaCA9IE1hdGgubWluKHRoaXMucGl0Y2gsIHQpKTtcbiAgICB9LCBFby5yZW5kZXJXb3JsZENvcGllcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyV29ybGRDb3BpZXM7XG4gICAgfSwgRW8ucmVuZGVyV29ybGRDb3BpZXMuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvaWQgMCA9PT0gdCA/IHQgPSAhMCA6IG51bGwgPT09IHQgJiYgKHQgPSAhMSksIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzID0gdDtcbiAgICB9LCBFby53b3JsZFNpemUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUgKiB0aGlzLnNjYWxlO1xuICAgIH0sIEVvLmNlbnRlck9mZnNldC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZW50ZXJQb2ludC5fc3ViKHRoaXMuc2l6ZS5fZGl2KDIpKTtcbiAgICB9LCBFby5zaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgdC5Qb2ludCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSwgRW8uYmVhcmluZy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLXRoaXMuYW5nbGUgLyBNYXRoLlBJICogMTgwO1xuICAgIH0sIEVvLmJlYXJpbmcuc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gLXQud3JhcChlLCAtMTgwLCAxODApICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIHRoaXMuYW5nbGUgIT09IGkgJiYgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5hbmdsZSA9IGksIHRoaXMuX2NhbGNNYXRyaWNlcygpLCB0aGlzLnJvdGF0aW9uTWF0cml4ID0gdC5jcmVhdGUkMigpLCB0LnJvdGF0ZSh0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLmFuZ2xlKSk7XG4gICAgfSwgRW8ucGl0Y2guZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BpdGNoIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LCBFby5waXRjaC5zZXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0LmNsYW1wKGUsIHRoaXMubWluUGl0Y2gsIHRoaXMubWF4UGl0Y2gpIC8gMTgwICogTWF0aC5QSTtcbiAgICAgIHRoaXMuX3BpdGNoICE9PSBpICYmICh0aGlzLl91bm1vZGlmaWVkID0gITEsIHRoaXMuX3BpdGNoID0gaSwgdGhpcy5fY2FsY01hdHJpY2VzKCkpO1xuICAgIH0sIEVvLmZvdi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm92IC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LCBFby5mb3Yuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQgPSBNYXRoLm1heCguMDEsIE1hdGgubWluKDYwLCB0KSksIHRoaXMuX2ZvdiAhPT0gdCAmJiAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9mb3YgPSB0IC8gMTgwICogTWF0aC5QSSwgdGhpcy5fY2FsY01hdHJpY2VzKCkpO1xuICAgIH0sIEVvLnpvb20uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3pvb207XG4gICAgfSwgRW8uem9vbS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBNYXRoLm1pbihNYXRoLm1heCh0LCB0aGlzLm1pblpvb20pLCB0aGlzLm1heFpvb20pO1xuICAgICAgdGhpcy5fem9vbSAhPT0gZSAmJiAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl96b29tID0gZSwgdGhpcy5zY2FsZSA9IHRoaXMuem9vbVNjYWxlKGUpLCB0aGlzLnRpbGVab29tID0gTWF0aC5mbG9vcihlKSwgdGhpcy56b29tRnJhY3Rpb24gPSBlIC0gdGhpcy50aWxlWm9vbSwgdGhpcy5fY29uc3RyYWluKCksIHRoaXMuX2NhbGNNYXRyaWNlcygpKTtcbiAgICB9LCBFby5jZW50ZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcbiAgICB9LCBFby5jZW50ZXIuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQubGF0ID09PSB0aGlzLl9jZW50ZXIubGF0ICYmIHQubG5nID09PSB0aGlzLl9jZW50ZXIubG5nIHx8ICh0aGlzLl91bm1vZGlmaWVkID0gITEsIHRoaXMuX2NlbnRlciA9IHQsIHRoaXMuX2NvbnN0cmFpbigpLCB0aGlzLl9jYWxjTWF0cmljZXMoKSk7XG4gICAgfSwgRW8ucGFkZGluZy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWRnZUluc2V0cy50b0pTT04oKTtcbiAgICB9LCBFby5wYWRkaW5nLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9lZGdlSW5zZXRzLmVxdWFscyh0KSB8fCAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9lZGdlSW5zZXRzLmludGVycG9sYXRlKHRoaXMuX2VkZ2VJbnNldHMsIHQsIDEpLCB0aGlzLl9jYWxjTWF0cmljZXMoKSk7XG4gICAgfSwgRW8uY2VudGVyUG9pbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkZ2VJbnNldHMuZ2V0Q2VudGVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LCBUby5wcm90b3R5cGUuaXNQYWRkaW5nRXF1YWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkZ2VJbnNldHMuZXF1YWxzKHQpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVBhZGRpbmcgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9lZGdlSW5zZXRzLmludGVycG9sYXRlKHQsIGUsIGkpLCB0aGlzLl9jb25zdHJhaW4oKSwgdGhpcy5fY2FsY01hdHJpY2VzKCk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmNvdmVyaW5nWm9vbUxldmVsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gKHQucm91bmRab29tID8gTWF0aC5yb3VuZCA6IE1hdGguZmxvb3IpKHRoaXMuem9vbSArIHRoaXMuc2NhbGVab29tKHRoaXMudGlsZVNpemUgLyB0LnRpbGVTaXplKSk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgZSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmdldFZpc2libGVVbndyYXBwZWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IFtuZXcgdC5VbndyYXBwZWRUaWxlSUQoMCwgZSldO1xuICAgICAgaWYgKHRoaXMuX3JlbmRlcldvcmxkQ29waWVzKSBmb3IgKHZhciBvID0gdGhpcy5wb2ludENvb3JkaW5hdGUobmV3IHQuUG9pbnQoMCwgMCkpLCByID0gdGhpcy5wb2ludENvb3JkaW5hdGUobmV3IHQuUG9pbnQodGhpcy53aWR0aCwgMCkpLCBhID0gdGhpcy5wb2ludENvb3JkaW5hdGUobmV3IHQuUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpKSwgbiA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KDAsIHRoaXMuaGVpZ2h0KSksIHMgPSBNYXRoLmZsb29yKE1hdGgubWluKG8ueCwgci54LCBhLngsIG4ueCkpLCBsID0gTWF0aC5mbG9vcihNYXRoLm1heChvLngsIHIueCwgYS54LCBuLngpKSwgYyA9IHMgLSAxOyBjIDw9IGwgKyAxOyBjKyspIHtcbiAgICAgICAgMCAhPT0gYyAmJiBpLnB1c2gobmV3IHQuVW53cmFwcGVkVGlsZUlEKGMsIGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5jb3ZlcmluZ1RpbGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5jb3ZlcmluZ1pvb21MZXZlbChlKSxcbiAgICAgICAgICBvID0gaTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGUubWluem9vbSAmJiBpIDwgZS5taW56b29tKSByZXR1cm4gW107XG4gICAgICB2b2lkIDAgIT09IGUubWF4em9vbSAmJiBpID4gZS5tYXh6b29tICYmIChpID0gZS5tYXh6b29tKTtcbiAgICAgIHZhciByID0gdC5NZXJjYXRvckNvb3JkaW5hdGUuZnJvbUxuZ0xhdCh0aGlzLmNlbnRlciksXG4gICAgICAgICAgYSA9IE1hdGgucG93KDIsIGkpLFxuICAgICAgICAgIG4gPSBbYSAqIHIueCwgYSAqIHIueSwgMF0sXG4gICAgICAgICAgcyA9IHhvLmZyb21JbnZQcm9qZWN0aW9uTWF0cml4KHRoaXMuaW52UHJvak1hdHJpeCwgdGhpcy53b3JsZFNpemUsIGkpLFxuICAgICAgICAgIGwgPSBlLm1pbnpvb20gfHwgMDtcbiAgICAgIHRoaXMucGl0Y2ggPD0gNjAgJiYgdGhpcy5fZWRnZUluc2V0cy50b3AgPCAuMSAmJiAobCA9IGkpO1xuXG4gICAgICB2YXIgYyA9IGZ1bmN0aW9uIGModCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFhYmI6IG5ldyBibyhbdCAqIGEsIDAsIDBdLCBbKHQgKyAxKSAqIGEsIGEsIDBdKSxcbiAgICAgICAgICB6b29tOiAwLFxuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3cmFwOiB0LFxuICAgICAgICAgIGZ1bGx5VmlzaWJsZTogITFcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAgICAgdSA9IFtdLFxuICAgICAgICAgIGggPSBbXSxcbiAgICAgICAgICBwID0gaSxcbiAgICAgICAgICBkID0gZS5yZXBhcnNlT3ZlcnNjYWxlZCA/IG8gOiBpO1xuXG4gICAgICBpZiAodGhpcy5fcmVuZGVyV29ybGRDb3BpZXMpIGZvciAodmFyIF8gPSAxOyBfIDw9IDM7IF8rKykge1xuICAgICAgICB1LnB1c2goYygtXykpLCB1LnB1c2goYyhfKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodS5wdXNoKGMoMCkpOyB1Lmxlbmd0aCA+IDA7KSB7XG4gICAgICAgIHZhciBmID0gdS5wb3AoKSxcbiAgICAgICAgICAgIG0gPSBmLngsXG4gICAgICAgICAgICBnID0gZi55LFxuICAgICAgICAgICAgdiA9IGYuZnVsbHlWaXNpYmxlO1xuXG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgIHZhciB5ID0gZi5hYWJiLmludGVyc2VjdHMocyk7XG4gICAgICAgICAgaWYgKDAgPT09IHkpIGNvbnRpbnVlO1xuICAgICAgICAgIHYgPSAyID09PSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBmLmFhYmIuZGlzdGFuY2VYKG4pLFxuICAgICAgICAgICAgYiA9IGYuYWFiYi5kaXN0YW5jZVkobiksXG4gICAgICAgICAgICB3ID0gTWF0aC5tYXgoTWF0aC5hYnMoeCksIE1hdGguYWJzKGIpKTtcbiAgICAgICAgaWYgKGYuem9vbSA9PT0gcCB8fCB3ID4gMyArICgxIDw8IHAgLSBmLnpvb20pIC0gMiAmJiBmLnpvb20gPj0gbCkgaC5wdXNoKHtcbiAgICAgICAgICB0aWxlSUQ6IG5ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZi56b29tID09PSBwID8gZCA6IGYuem9vbSwgZi53cmFwLCBmLnpvb20sIG0sIGcpLFxuICAgICAgICAgIGRpc3RhbmNlU3E6IHQuc3FyTGVuKFtuWzBdIC0gLjUgLSBtLCBuWzFdIC0gLjUgLSBnXSlcbiAgICAgICAgfSk7ZWxzZSBmb3IgKHZhciBUID0gMDsgVCA8IDQ7IFQrKykge1xuICAgICAgICAgIHZhciBFID0gKG0gPDwgMSkgKyBUICUgMixcbiAgICAgICAgICAgICAgSSA9IChnIDw8IDEpICsgKFQgPj4gMSk7XG4gICAgICAgICAgdS5wdXNoKHtcbiAgICAgICAgICAgIGFhYmI6IGYuYWFiYi5xdWFkcmFudChUKSxcbiAgICAgICAgICAgIHpvb206IGYuem9vbSArIDEsXG4gICAgICAgICAgICB4OiBFLFxuICAgICAgICAgICAgeTogSSxcbiAgICAgICAgICAgIHdyYXA6IGYud3JhcCxcbiAgICAgICAgICAgIGZ1bGx5VmlzaWJsZTogdlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHQuZGlzdGFuY2VTcSAtIGUuZGlzdGFuY2VTcTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC50aWxlSUQ7XG4gICAgICB9KTtcbiAgICB9LCBUby5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0LCB0aGlzLmhlaWdodCA9IGUsIHRoaXMucGl4ZWxzVG9HTFVuaXRzID0gWzIgLyB0LCAtMiAvIGVdLCB0aGlzLl9jb25zdHJhaW4oKSwgdGhpcy5fY2FsY01hdHJpY2VzKCk7XG4gICAgfSwgRW8udW5tb2RpZmllZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdW5tb2RpZmllZDtcbiAgICB9LCBUby5wcm90b3R5cGUuem9vbVNjYWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCB0KTtcbiAgICB9LCBUby5wcm90b3R5cGUuc2NhbGVab29tID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLmxvZyh0KSAvIE1hdGguTE4yO1xuICAgIH0sIFRvLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gdC5jbGFtcChlLmxhdCwgLXRoaXMubWF4VmFsaWRMYXRpdHVkZSwgdGhpcy5tYXhWYWxpZExhdGl0dWRlKTtcbiAgICAgIHJldHVybiBuZXcgdC5Qb2ludCh0Lm1lcmNhdG9yWGZyb21MbmcoZS5sbmcpICogdGhpcy53b3JsZFNpemUsIHQubWVyY2F0b3JZZnJvbUxhdChpKSAqIHRoaXMud29ybGRTaXplKTtcbiAgICB9LCBUby5wcm90b3R5cGUudW5wcm9qZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoZS54IC8gdGhpcy53b3JsZFNpemUsIGUueSAvIHRoaXMud29ybGRTaXplKS50b0xuZ0xhdCgpO1xuICAgIH0sIEVvLnBvaW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3QodGhpcy5jZW50ZXIpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5zZXRMb2NhdGlvbkF0UG9pbnQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnBvaW50Q29vcmRpbmF0ZShpKSxcbiAgICAgICAgICByID0gdGhpcy5wb2ludENvb3JkaW5hdGUodGhpcy5jZW50ZXJQb2ludCksXG4gICAgICAgICAgYSA9IHRoaXMubG9jYXRpb25Db29yZGluYXRlKGUpLFxuICAgICAgICAgIG4gPSBuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoYS54IC0gKG8ueCAtIHIueCksIGEueSAtIChvLnkgLSByLnkpKTtcbiAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24obiksIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzICYmICh0aGlzLmNlbnRlciA9IHRoaXMuY2VudGVyLndyYXAoKSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmxvY2F0aW9uUG9pbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZVBvaW50KHRoaXMubG9jYXRpb25Db29yZGluYXRlKHQpKTtcbiAgICB9LCBUby5wcm90b3R5cGUucG9pbnRMb2NhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlTG9jYXRpb24odGhpcy5wb2ludENvb3JkaW5hdGUodCkpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5sb2NhdGlvbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHQuTWVyY2F0b3JDb29yZGluYXRlLmZyb21MbmdMYXQoZSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmNvb3JkaW5hdGVMb2NhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC50b0xuZ0xhdCgpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5wb2ludENvb3JkaW5hdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSBbZS54LCBlLnksIDAsIDFdLFxuICAgICAgICAgIG8gPSBbZS54LCBlLnksIDEsIDFdO1xuICAgICAgdC50cmFuc2Zvcm1NYXQ0KGksIGksIHRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlKSwgdC50cmFuc2Zvcm1NYXQ0KG8sIG8sIHRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlKTtcbiAgICAgIHZhciByID0gaVszXSxcbiAgICAgICAgICBhID0gb1szXSxcbiAgICAgICAgICBuID0gaVsxXSAvIHIsXG4gICAgICAgICAgcyA9IG9bMV0gLyBhLFxuICAgICAgICAgIGwgPSBpWzJdIC8gcixcbiAgICAgICAgICBjID0gb1syXSAvIGEsXG4gICAgICAgICAgdSA9IGwgPT09IGMgPyAwIDogKDAgLSBsKSAvIChjIC0gbCk7XG4gICAgICByZXR1cm4gbmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKHQubnVtYmVyKGlbMF0gLyByLCBvWzBdIC8gYSwgdSkgLyB0aGlzLndvcmxkU2l6ZSwgdC5udW1iZXIobiwgcywgdSkgLyB0aGlzLndvcmxkU2l6ZSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmNvb3JkaW5hdGVQb2ludCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IFtlLnggKiB0aGlzLndvcmxkU2l6ZSwgZS55ICogdGhpcy53b3JsZFNpemUsIDAsIDFdO1xuICAgICAgcmV0dXJuIHQudHJhbnNmb3JtTWF0NChpLCBpLCB0aGlzLnBpeGVsTWF0cml4KSwgbmV3IHQuUG9pbnQoaVswXSAvIGlbM10sIGlbMV0gLyBpWzNdKTtcbiAgICB9LCBUby5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyB0LkxuZ0xhdEJvdW5kcygpLmV4dGVuZCh0aGlzLnBvaW50TG9jYXRpb24obmV3IHQuUG9pbnQoMCwgMCkpKS5leHRlbmQodGhpcy5wb2ludExvY2F0aW9uKG5ldyB0LlBvaW50KHRoaXMud2lkdGgsIDApKSkuZXh0ZW5kKHRoaXMucG9pbnRMb2NhdGlvbihuZXcgdC5Qb2ludCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpKS5leHRlbmQodGhpcy5wb2ludExvY2F0aW9uKG5ldyB0LlBvaW50KDAsIHRoaXMuaGVpZ2h0KSkpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5nZXRNYXhCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRSYW5nZSAmJiAyID09PSB0aGlzLmxhdFJhbmdlLmxlbmd0aCAmJiB0aGlzLmxuZ1JhbmdlICYmIDIgPT09IHRoaXMubG5nUmFuZ2UubGVuZ3RoID8gbmV3IHQuTG5nTGF0Qm91bmRzKFt0aGlzLmxuZ1JhbmdlWzBdLCB0aGlzLmxhdFJhbmdlWzBdXSwgW3RoaXMubG5nUmFuZ2VbMV0sIHRoaXMubGF0UmFuZ2VbMV1dKSA6IG51bGw7XG4gICAgfSwgVG8ucHJvdG90eXBlLnNldE1heEJvdW5kcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0ID8gKHRoaXMubG5nUmFuZ2UgPSBbdC5nZXRXZXN0KCksIHQuZ2V0RWFzdCgpXSwgdGhpcy5sYXRSYW5nZSA9IFt0LmdldFNvdXRoKCksIHQuZ2V0Tm9ydGgoKV0sIHRoaXMuX2NvbnN0cmFpbigpKSA6ICh0aGlzLmxuZ1JhbmdlID0gbnVsbCwgdGhpcy5sYXRSYW5nZSA9IFstdGhpcy5tYXhWYWxpZExhdGl0dWRlLCB0aGlzLm1heFZhbGlkTGF0aXR1ZGVdKTtcbiAgICB9LCBUby5wcm90b3R5cGUuY2FsY3VsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9ICExKTtcbiAgICAgIHZhciBvID0gZS5rZXksXG4gICAgICAgICAgciA9IGkgPyB0aGlzLl9hbGlnbmVkUG9zTWF0cml4Q2FjaGUgOiB0aGlzLl9wb3NNYXRyaXhDYWNoZTtcbiAgICAgIGlmIChyW29dKSByZXR1cm4gcltvXTtcbiAgICAgIHZhciBhID0gZS5jYW5vbmljYWwsXG4gICAgICAgICAgbiA9IHRoaXMud29ybGRTaXplIC8gdGhpcy56b29tU2NhbGUoYS56KSxcbiAgICAgICAgICBzID0gYS54ICsgTWF0aC5wb3coMiwgYS56KSAqIGUud3JhcCxcbiAgICAgICAgICBsID0gdC5pZGVudGl0eShuZXcgRmxvYXQ2NEFycmF5KDE2KSk7XG4gICAgICByZXR1cm4gdC50cmFuc2xhdGUobCwgbCwgW3MgKiBuLCBhLnkgKiBuLCAwXSksIHQuc2NhbGUobCwgbCwgW24gLyB0LkVYVEVOVCwgbiAvIHQuRVhURU5ULCAxXSksIHQubXVsdGlwbHkobCwgaSA/IHRoaXMuYWxpZ25lZFByb2pNYXRyaXggOiB0aGlzLnByb2pNYXRyaXgsIGwpLCByW29dID0gbmV3IEZsb2F0MzJBcnJheShsKSwgcltvXTtcbiAgICB9LCBUby5wcm90b3R5cGUuY3VzdG9tTGF5ZXJNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXJjYXRvck1hdHJpeC5zbGljZSgpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5fY29uc3RyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuY2VudGVyICYmIHRoaXMud2lkdGggJiYgdGhpcy5oZWlnaHQgJiYgIXRoaXMuX2NvbnN0cmFpbmluZykge1xuICAgICAgICB0aGlzLl9jb25zdHJhaW5pbmcgPSAhMDtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBhID0gLTkwLFxuICAgICAgICAgICAgbiA9IDkwLFxuICAgICAgICAgICAgcyA9IC0xODAsXG4gICAgICAgICAgICBsID0gMTgwLFxuICAgICAgICAgICAgYyA9IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgIHUgPSB0aGlzLl91bm1vZGlmaWVkO1xuXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgdmFyIGggPSB0aGlzLmxhdFJhbmdlO1xuICAgICAgICAgIGEgPSB0Lm1lcmNhdG9yWWZyb21MYXQoaFsxXSkgKiB0aGlzLndvcmxkU2l6ZSwgZSA9IChuID0gdC5tZXJjYXRvcllmcm9tTGF0KGhbMF0pICogdGhpcy53b3JsZFNpemUpIC0gYSA8IGMueSA/IGMueSAvIChuIC0gYSkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXMubG5nUmFuZ2U7XG4gICAgICAgICAgcyA9IHQubWVyY2F0b3JYZnJvbUxuZyhwWzBdKSAqIHRoaXMud29ybGRTaXplLCBpID0gKGwgPSB0Lm1lcmNhdG9yWGZyb21MbmcocFsxXSkgKiB0aGlzLndvcmxkU2l6ZSkgLSBzIDwgYy54ID8gYy54IC8gKGwgLSBzKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZCA9IHRoaXMucG9pbnQsXG4gICAgICAgICAgICBfID0gTWF0aC5tYXgoaSB8fCAwLCBlIHx8IDApO1xuXG4gICAgICAgIGlmIChfKSByZXR1cm4gdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgdC5Qb2ludChpID8gKGwgKyBzKSAvIDIgOiBkLngsIGUgPyAobiArIGEpIC8gMiA6IGQueSkpLCB0aGlzLnpvb20gKz0gdGhpcy5zY2FsZVpvb20oXyksIHRoaXMuX3VubW9kaWZpZWQgPSB1LCB2b2lkICh0aGlzLl9jb25zdHJhaW5pbmcgPSAhMSk7XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICB2YXIgZiA9IGQueSxcbiAgICAgICAgICAgICAgbSA9IGMueSAvIDI7XG4gICAgICAgICAgZiAtIG0gPCBhICYmIChyID0gYSArIG0pLCBmICsgbSA+IG4gJiYgKHIgPSBuIC0gbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgIHZhciBnID0gZC54LFxuICAgICAgICAgICAgICB2ID0gYy54IC8gMjtcbiAgICAgICAgICBnIC0gdiA8IHMgJiYgKG8gPSBzICsgdiksIGcgKyB2ID4gbCAmJiAobyA9IGwgLSB2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZvaWQgMCA9PT0gbyAmJiB2b2lkIDAgPT09IHIgfHwgKHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IHQuUG9pbnQodm9pZCAwICE9PSBvID8gbyA6IGQueCwgdm9pZCAwICE9PSByID8gciA6IGQueSkpKSwgdGhpcy5fdW5tb2RpZmllZCA9IHUsIHRoaXMuX2NvbnN0cmFpbmluZyA9ICExO1xuICAgICAgfVxuICAgIH0sIFRvLnByb3RvdHlwZS5fY2FsY01hdHJpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jZW50ZXJPZmZzZXQ7XG4gICAgICAgIHRoaXMuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSA9IC41IC8gTWF0aC50YW4odGhpcy5fZm92IC8gMikgKiB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLlBJIC8gMiArIHRoaXMuX3BpdGNoLFxuICAgICAgICAgICAgbyA9IHRoaXMuX2ZvdiAqICguNSArIGUueSAvIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgIHIgPSBNYXRoLnNpbihvKSAqIHRoaXMuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSAvIE1hdGguc2luKHQuY2xhbXAoTWF0aC5QSSAtIGkgLSBvLCAuMDEsIE1hdGguUEkgLSAuMDEpKSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnBvaW50LFxuICAgICAgICAgICAgbiA9IGEueCxcbiAgICAgICAgICAgIHMgPSBhLnksXG4gICAgICAgICAgICBsID0gMS4wMSAqIChNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHRoaXMuX3BpdGNoKSAqIHIgKyB0aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UpLFxuICAgICAgICAgICAgYyA9IHRoaXMuaGVpZ2h0IC8gNTAsXG4gICAgICAgICAgICB1ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIHQucGVyc3BlY3RpdmUodSwgdGhpcy5fZm92LCB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQsIGMsIGwpLCB1WzhdID0gMiAqIC1lLnggLyB0aGlzLndpZHRoLCB1WzldID0gMiAqIGUueSAvIHRoaXMuaGVpZ2h0LCB0LnNjYWxlKHUsIHUsIFsxLCAtMSwgMV0pLCB0LnRyYW5zbGF0ZSh1LCB1LCBbMCwgMCwgLXRoaXMuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZV0pLCB0LnJvdGF0ZVgodSwgdSwgdGhpcy5fcGl0Y2gpLCB0LnJvdGF0ZVoodSwgdSwgdGhpcy5hbmdsZSksIHQudHJhbnNsYXRlKHUsIHUsIFstbiwgLXMsIDBdKSwgdGhpcy5tZXJjYXRvck1hdHJpeCA9IHQuc2NhbGUoW10sIHUsIFt0aGlzLndvcmxkU2l6ZSwgdGhpcy53b3JsZFNpemUsIHRoaXMud29ybGRTaXplXSksIHQuc2NhbGUodSwgdSwgWzEsIDEsIHQubWVyY2F0b3JaZnJvbUFsdGl0dWRlKDEsIHRoaXMuY2VudGVyLmxhdCkgKiB0aGlzLndvcmxkU2l6ZSwgMV0pLCB0aGlzLnByb2pNYXRyaXggPSB1LCB0aGlzLmludlByb2pNYXRyaXggPSB0LmludmVydChbXSwgdGhpcy5wcm9qTWF0cml4KTtcblxuICAgICAgICB2YXIgaCA9IHRoaXMud2lkdGggJSAyIC8gMixcbiAgICAgICAgICAgIHAgPSB0aGlzLmhlaWdodCAlIDIgLyAyLFxuICAgICAgICAgICAgZCA9IE1hdGguY29zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgICAgXyA9IE1hdGguc2luKHRoaXMuYW5nbGUpLFxuICAgICAgICAgICAgZiA9IG4gLSBNYXRoLnJvdW5kKG4pICsgZCAqIGggKyBfICogcCxcbiAgICAgICAgICAgIG0gPSBzIC0gTWF0aC5yb3VuZChzKSArIGQgKiBwICsgXyAqIGgsXG4gICAgICAgICAgICBnID0gbmV3IEZsb2F0NjRBcnJheSh1KTtcblxuICAgICAgICBpZiAodC50cmFuc2xhdGUoZywgZywgW2YgPiAuNSA/IGYgLSAxIDogZiwgbSA+IC41ID8gbSAtIDEgOiBtLCAwXSksIHRoaXMuYWxpZ25lZFByb2pNYXRyaXggPSBnLCB1ID0gdC5jcmVhdGUoKSwgdC5zY2FsZSh1LCB1LCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKSwgdC50cmFuc2xhdGUodSwgdSwgWzEsIC0xLCAwXSksIHRoaXMubGFiZWxQbGFuZU1hdHJpeCA9IHUsIHUgPSB0LmNyZWF0ZSgpLCB0LnNjYWxlKHUsIHUsIFsxLCAtMSwgMV0pLCB0LnRyYW5zbGF0ZSh1LCB1LCBbLTEsIC0xLCAwXSksIHQuc2NhbGUodSwgdSwgWzIgLyB0aGlzLndpZHRoLCAyIC8gdGhpcy5oZWlnaHQsIDFdKSwgdGhpcy5nbENvb3JkTWF0cml4ID0gdSwgdGhpcy5waXhlbE1hdHJpeCA9IHQubXVsdGlwbHkobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMubGFiZWxQbGFuZU1hdHJpeCwgdGhpcy5wcm9qTWF0cml4KSwgISh1ID0gdC5pbnZlcnQobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMucGl4ZWxNYXRyaXgpKSkgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGludmVydCBtYXRyaXhcIik7XG4gICAgICAgIHRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlID0gdSwgdGhpcy5fcG9zTWF0cml4Q2FjaGUgPSB7fSwgdGhpcy5fYWxpZ25lZFBvc01hdHJpeENhY2hlID0ge307XG4gICAgICB9XG4gICAgfSwgVG8ucHJvdG90eXBlLm1heFBpdGNoU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlKSByZXR1cm4gMTtcbiAgICAgIHZhciBlID0gdGhpcy5wb2ludENvb3JkaW5hdGUobmV3IHQuUG9pbnQoMCwgMCkpLFxuICAgICAgICAgIGkgPSBbZS54ICogdGhpcy53b3JsZFNpemUsIGUueSAqIHRoaXMud29ybGRTaXplLCAwLCAxXTtcbiAgICAgIHJldHVybiB0LnRyYW5zZm9ybU1hdDQoaSwgaSwgdGhpcy5waXhlbE1hdHJpeClbM10gLyB0aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2U7XG4gICAgfSwgVG8ucHJvdG90eXBlLmdldENhbWVyYVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSBNYXRoLnRhbih0aGlzLl9waXRjaCkgKiAodGhpcy5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIHx8IDEpO1xuICAgICAgcmV0dXJuIHRoaXMuY2VudGVyUG9pbnQuYWRkKG5ldyB0LlBvaW50KDAsIGUpKTtcbiAgICB9LCBUby5wcm90b3R5cGUuZ2V0Q2FtZXJhUXVlcnlHZW9tZXRyeSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZ2V0Q2FtZXJhUG9pbnQoKTtcbiAgICAgIGlmICgxID09PSBlLmxlbmd0aCkgcmV0dXJuIFtlWzBdLCBpXTtcblxuICAgICAgZm9yICh2YXIgbyA9IGkueCwgciA9IGkueSwgYSA9IGkueCwgbiA9IGkueSwgcyA9IDAsIGwgPSBlOyBzIDwgbC5sZW5ndGg7IHMgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGxbc107XG4gICAgICAgIG8gPSBNYXRoLm1pbihvLCBjLngpLCByID0gTWF0aC5taW4ociwgYy55KSwgYSA9IE1hdGgubWF4KGEsIGMueCksIG4gPSBNYXRoLm1heChuLCBjLnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW25ldyB0LlBvaW50KG8sIHIpLCBuZXcgdC5Qb2ludChhLCByKSwgbmV3IHQuUG9pbnQoYSwgbiksIG5ldyB0LlBvaW50KG8sIG4pLCBuZXcgdC5Qb2ludChvLCByKV07XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVG8ucHJvdG90eXBlLCBFbyk7XG5cbiAgICB2YXIgSW8gPSBmdW5jdGlvbiBJbyhlKSB7XG4gICAgICB2YXIgaSwgbywgciwgX2EzO1xuXG4gICAgICB0aGlzLl9oYXNoTmFtZSA9IGUgJiYgZW5jb2RlVVJJQ29tcG9uZW50KGUpLCB0LmJpbmRBbGwoW1wiX2dldEN1cnJlbnRIYXNoXCIsIFwiX29uSGFzaENoYW5nZVwiLCBcIl91cGRhdGVIYXNoXCJdLCB0aGlzKSwgdGhpcy5fdXBkYXRlSGFzaCA9IChpID0gdGhpcy5fdXBkYXRlSGFzaFVudGhyb3R0bGVkLmJpbmQodGhpcyksIG8gPSAhMSwgciA9IG51bGwsIF9hMyA9IGZ1bmN0aW9uIGEoKSB7XG4gICAgICAgIHIgPSBudWxsLCBvICYmIChpKCksIHIgPSBzZXRUaW1lb3V0KF9hMywgMzAwKSwgbyA9ICExKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG8gPSAhMCwgciB8fCBfYTMoKSwgcjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBJby5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IGUsIHQud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIHRoaXMuX29uSGFzaENoYW5nZSwgITEpLCB0aGlzLl9tYXAub24oXCJtb3ZlZW5kXCIsIHRoaXMuX3VwZGF0ZUhhc2gpLCB0aGlzO1xuICAgIH0sIElvLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIiwgdGhpcy5fb25IYXNoQ2hhbmdlLCAhMSksIHRoaXMuX21hcC5vZmYoXCJtb3ZlZW5kXCIsIHRoaXMuX3VwZGF0ZUhhc2gpLCBjbGVhclRpbWVvdXQodGhpcy5fdXBkYXRlSGFzaCgpKSwgZGVsZXRlIHRoaXMuX21hcCwgdGhpcztcbiAgICB9LCBJby5wcm90b3R5cGUuZ2V0SGFzaFN0cmluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKSxcbiAgICAgICAgICBvID0gTWF0aC5yb3VuZCgxMDAgKiB0aGlzLl9tYXAuZ2V0Wm9vbSgpKSAvIDEwMCxcbiAgICAgICAgICByID0gTWF0aC5jZWlsKChvICogTWF0aC5MTjIgKyBNYXRoLmxvZyg1MTIgLyAzNjAgLyAuNSkpIC8gTWF0aC5MTjEwKSxcbiAgICAgICAgICBhID0gTWF0aC5wb3coMTAsIHIpLFxuICAgICAgICAgIG4gPSBNYXRoLnJvdW5kKGkubG5nICogYSkgLyBhLFxuICAgICAgICAgIHMgPSBNYXRoLnJvdW5kKGkubGF0ICogYSkgLyBhLFxuICAgICAgICAgIGwgPSB0aGlzLl9tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAgIGMgPSB0aGlzLl9tYXAuZ2V0UGl0Y2goKSxcbiAgICAgICAgICB1ID0gXCJcIjtcblxuICAgICAgaWYgKHUgKz0gZSA/IFwiL1wiICsgbiArIFwiL1wiICsgcyArIFwiL1wiICsgbyA6IG8gKyBcIi9cIiArIHMgKyBcIi9cIiArIG4sIChsIHx8IGMpICYmICh1ICs9IFwiL1wiICsgTWF0aC5yb3VuZCgxMCAqIGwpIC8gMTApLCBjICYmICh1ICs9IFwiL1wiICsgTWF0aC5yb3VuZChjKSksIHRoaXMuX2hhc2hOYW1lKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5faGFzaE5hbWUsXG4gICAgICAgICAgICBwID0gITEsXG4gICAgICAgICAgICBkID0gdC53aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKS5zcGxpdChcIiZcIikubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0LnNwbGl0KFwiPVwiKVswXTtcbiAgICAgICAgICByZXR1cm4gZSA9PT0gaCA/IChwID0gITAsIGUgKyBcIj1cIiArIHUpIDogdDtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcCB8fCBkLnB1c2goaCArIFwiPVwiICsgdSksIFwiI1wiICsgZC5qb2luKFwiJlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiI1wiICsgdTtcbiAgICB9LCBJby5wcm90b3R5cGUuX2dldEN1cnJlbnRIYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgaSA9IHRoaXMsXG4gICAgICAgICAgbyA9IHQud2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gICAgICByZXR1cm4gdGhpcy5faGFzaE5hbWUgPyAoby5zcGxpdChcIiZcIikubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnNwbGl0KFwiPVwiKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdFswXSA9PT0gaS5faGFzaE5hbWUgJiYgKGUgPSB0KTtcbiAgICAgIH0pLCAoZSAmJiBlWzFdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKSkgOiBvLnNwbGl0KFwiL1wiKTtcbiAgICB9LCBJby5wcm90b3R5cGUuX29uSGFzaENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fZ2V0Q3VycmVudEhhc2goKTtcblxuICAgICAgaWYgKHQubGVuZ3RoID49IDMgJiYgIXQuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gaXNOYU4odCk7XG4gICAgICB9KSkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuX21hcC5kcmFnUm90YXRlLmlzRW5hYmxlZCgpICYmIHRoaXMuX21hcC50b3VjaFpvb21Sb3RhdGUuaXNFbmFibGVkKCkgPyArKHRbM10gfHwgMCkgOiB0aGlzLl9tYXAuZ2V0QmVhcmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgICAgY2VudGVyOiBbK3RbMl0sICt0WzFdXSxcbiAgICAgICAgICB6b29tOiArdFswXSxcbiAgICAgICAgICBiZWFyaW5nOiBlLFxuICAgICAgICAgIHBpdGNoOiArKHRbNF0gfHwgMClcbiAgICAgICAgfSksICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgSW8ucHJvdG90eXBlLl91cGRhdGVIYXNoVW50aHJvdHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHQud2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvKCMuKyk/JC8sIHRoaXMuZ2V0SGFzaFN0cmluZygpKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdC53aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUodC53aW5kb3cuaGlzdG9yeS5zdGF0ZSwgbnVsbCwgZSk7XG4gICAgICB9IGNhdGNoICh0KSB7fVxuICAgIH07XG5cbiAgICB2YXIgUG8gPSB7XG4gICAgICBsaW5lYXJpdHk6IC4zLFxuICAgICAgZWFzaW5nOiB0LmJlemllcigwLCAwLCAuMywgMSlcbiAgICB9LFxuICAgICAgICBTbyA9IHQuZXh0ZW5kKHtcbiAgICAgIGRlY2VsZXJhdGlvbjogMjUwMCxcbiAgICAgIG1heFNwZWVkOiAxNDAwXG4gICAgfSwgUG8pLFxuICAgICAgICBDbyA9IHQuZXh0ZW5kKHtcbiAgICAgIGRlY2VsZXJhdGlvbjogMjAsXG4gICAgICBtYXhTcGVlZDogMTQwMFxuICAgIH0sIFBvKSxcbiAgICAgICAgem8gPSB0LmV4dGVuZCh7XG4gICAgICBkZWNlbGVyYXRpb246IDFlMyxcbiAgICAgIG1heFNwZWVkOiAzNjBcbiAgICB9LCBQbyksXG4gICAgICAgIERvID0gdC5leHRlbmQoe1xuICAgICAgZGVjZWxlcmF0aW9uOiAxZTMsXG4gICAgICBtYXhTcGVlZDogOTBcbiAgICB9LCBQbyksXG4gICAgICAgIEFvID0gZnVuY3Rpb24gQW8odCkge1xuICAgICAgdGhpcy5fbWFwID0gdCwgdGhpcy5jbGVhcigpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBNbyh0LCBlKSB7XG4gICAgICAoIXQuZHVyYXRpb24gfHwgdC5kdXJhdGlvbiA8IGUuZHVyYXRpb24pICYmICh0LmR1cmF0aW9uID0gZS5kdXJhdGlvbiwgdC5lYXNpbmcgPSBlLmVhc2luZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG8oZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBvLm1heFNwZWVkLFxuICAgICAgICAgIGEgPSBvLmxpbmVhcml0eSxcbiAgICAgICAgICBuID0gby5kZWNlbGVyYXRpb24sXG4gICAgICAgICAgcyA9IHQuY2xhbXAoZSAqIGEgLyAoaSAvIDFlMyksIC1yLCByKSxcbiAgICAgICAgICBsID0gTWF0aC5hYnMocykgLyAobiAqIGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWFzaW5nOiBvLmVhc2luZyxcbiAgICAgICAgZHVyYXRpb246IDFlMyAqIGwsXG4gICAgICAgIGFtb3VudDogcyAqIChsIC8gMilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgQW8ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5faW5lcnRpYUJ1ZmZlciA9IFtdO1xuICAgIH0sIEFvLnByb3RvdHlwZS5yZWNvcmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fZHJhaW5JbmVydGlhQnVmZmVyKCksIHRoaXMuX2luZXJ0aWFCdWZmZXIucHVzaCh7XG4gICAgICAgIHRpbWU6IHQuYnJvd3Nlci5ub3coKSxcbiAgICAgICAgc2V0dGluZ3M6IGVcbiAgICAgIH0pO1xuICAgIH0sIEFvLnByb3RvdHlwZS5fZHJhaW5JbmVydGlhQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRoaXMuX2luZXJ0aWFCdWZmZXIsIGkgPSB0LmJyb3dzZXIubm93KCk7IGUubGVuZ3RoID4gMCAmJiBpIC0gZVswXS50aW1lID4gMTYwOykge1xuICAgICAgICBlLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfSwgQW8ucHJvdG90eXBlLl9vbk1vdmVFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpLCAhKHRoaXMuX2luZXJ0aWFCdWZmZXIubGVuZ3RoIDwgMikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHtcbiAgICAgICAgICB6b29tOiAwLFxuICAgICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgICAgcGl0Y2g6IDAsXG4gICAgICAgICAgcGFuOiBuZXcgdC5Qb2ludCgwLCAwKSxcbiAgICAgICAgICBwaW5jaEFyb3VuZDogdm9pZCAwLFxuICAgICAgICAgIGFyb3VuZDogdm9pZCAwXG4gICAgICAgIH0sIG8gPSAwLCByID0gdGhpcy5faW5lcnRpYUJ1ZmZlcjsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHJbb10uc2V0dGluZ3M7XG4gICAgICAgICAgaS56b29tICs9IGEuem9vbURlbHRhIHx8IDAsIGkuYmVhcmluZyArPSBhLmJlYXJpbmdEZWx0YSB8fCAwLCBpLnBpdGNoICs9IGEucGl0Y2hEZWx0YSB8fCAwLCBhLnBhbkRlbHRhICYmIGkucGFuLl9hZGQoYS5wYW5EZWx0YSksIGEuYXJvdW5kICYmIChpLmFyb3VuZCA9IGEuYXJvdW5kKSwgYS5waW5jaEFyb3VuZCAmJiAoaS5waW5jaEFyb3VuZCA9IGEucGluY2hBcm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSB0aGlzLl9pbmVydGlhQnVmZmVyW3RoaXMuX2luZXJ0aWFCdWZmZXIubGVuZ3RoIC0gMV0udGltZSAtIHRoaXMuX2luZXJ0aWFCdWZmZXJbMF0udGltZSxcbiAgICAgICAgICAgIHMgPSB7fTtcblxuICAgICAgICBpZiAoaS5wYW4ubWFnKCkpIHtcbiAgICAgICAgICB2YXIgbCA9IExvKGkucGFuLm1hZygpLCBuLCB0LmV4dGVuZCh7fSwgU28sIGUgfHwge30pKTtcbiAgICAgICAgICBzLm9mZnNldCA9IGkucGFuLm11bHQobC5hbW91bnQgLyBpLnBhbi5tYWcoKSksIHMuY2VudGVyID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5jZW50ZXIsIE1vKHMsIGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkuem9vbSkge1xuICAgICAgICAgIHZhciBjID0gTG8oaS56b29tLCBuLCBDbyk7XG4gICAgICAgICAgcy56b29tID0gdGhpcy5fbWFwLnRyYW5zZm9ybS56b29tICsgYy5hbW91bnQsIE1vKHMsIGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkuYmVhcmluZykge1xuICAgICAgICAgIHZhciB1ID0gTG8oaS5iZWFyaW5nLCBuLCB6byk7XG4gICAgICAgICAgcy5iZWFyaW5nID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5iZWFyaW5nICsgdC5jbGFtcCh1LmFtb3VudCwgLTE3OSwgMTc5KSwgTW8ocywgdSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaS5waXRjaCkge1xuICAgICAgICAgIHZhciBoID0gTG8oaS5waXRjaCwgbiwgRG8pO1xuICAgICAgICAgIHMucGl0Y2ggPSB0aGlzLl9tYXAudHJhbnNmb3JtLnBpdGNoICsgaC5hbW91bnQsIE1vKHMsIGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMuem9vbSB8fCBzLmJlYXJpbmcpIHtcbiAgICAgICAgICB2YXIgcCA9IHZvaWQgMCA9PT0gaS5waW5jaEFyb3VuZCA/IGkuYXJvdW5kIDogaS5waW5jaEFyb3VuZDtcbiAgICAgICAgICBzLmFyb3VuZCA9IHAgPyB0aGlzLl9tYXAudW5wcm9qZWN0KHApIDogdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKSwgdC5leHRlbmQocywge1xuICAgICAgICAgIG5vTW92ZVN0YXJ0OiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFJvID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIG8obywgciwgYSwgbikge1xuICAgICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSB7fSk7XG4gICAgICAgIHZhciBzID0gaS5tb3VzZVBvcyhyLmdldENhbnZhc0NvbnRhaW5lcigpLCBhKSxcbiAgICAgICAgICAgIGwgPSByLnVucHJvamVjdChzKTtcbiAgICAgICAgZS5jYWxsKHRoaXMsIG8sIHQuZXh0ZW5kKHtcbiAgICAgICAgICBwb2ludDogcyxcbiAgICAgICAgICBsbmdMYXQ6IGwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogYVxuICAgICAgICB9LCBuKSksIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSAhMSwgdGhpcy50YXJnZXQgPSByO1xuICAgICAgfVxuXG4gICAgICBlICYmIChvLl9fcHJvdG9fXyA9IGUpLCAoby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IG87XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgfSwgci5kZWZhdWx0UHJldmVudGVkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLnByb3RvdHlwZSwgciksIG87XG4gICAgfSh0LkV2ZW50KSxcbiAgICAgICAga28gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gbyhvLCByLCBhKSB7XG4gICAgICAgIHZhciBuID0gXCJ0b3VjaGVuZFwiID09PSBvID8gYS5jaGFuZ2VkVG91Y2hlcyA6IGEudG91Y2hlcyxcbiAgICAgICAgICAgIHMgPSBpLnRvdWNoUG9zKHIuZ2V0Q2FudmFzQ29udGFpbmVyKCksIG4pLFxuICAgICAgICAgICAgbCA9IHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHIudW5wcm9qZWN0KHQpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGMgPSBzLnJlZHVjZShmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICAgIHJldHVybiB0LmFkZChlLmRpdihvLmxlbmd0aCkpO1xuICAgICAgICB9LCBuZXcgdC5Qb2ludCgwLCAwKSksXG4gICAgICAgICAgICB1ID0gci51bnByb2plY3QoYyk7XG4gICAgICAgIGUuY2FsbCh0aGlzLCBvLCB7XG4gICAgICAgICAgcG9pbnRzOiBzLFxuICAgICAgICAgIHBvaW50OiBjLFxuICAgICAgICAgIGxuZ0xhdHM6IGwsXG4gICAgICAgICAgbG5nTGF0OiB1LFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGFcbiAgICAgICAgfSksIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSAhMTtcbiAgICAgIH1cblxuICAgICAgZSAmJiAoby5fX3Byb3RvX18gPSBlKSwgKG8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBvO1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gby5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgIH0sIHIuZGVmYXVsdFByZXZlbnRlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoby5wcm90b3R5cGUsIHIpLCBvO1xuICAgIH0odC5FdmVudCksXG4gICAgICAgIEJvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgaSwgbykge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9cbiAgICAgICAgfSksIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSAhMTtcbiAgICAgIH1cblxuICAgICAgdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlO1xuICAgICAgdmFyIGkgPSB7XG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gZS5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgIH0sIGkuZGVmYXVsdFByZXZlbnRlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIGkpLCBlO1xuICAgIH0odC5FdmVudCksXG4gICAgICAgIE9vID0gZnVuY3Rpb24gT28odCwgZSkge1xuICAgICAgdGhpcy5fbWFwID0gdCwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgPSBlLmNsaWNrVG9sZXJhbmNlO1xuICAgIH07XG5cbiAgICBPby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fbW91c2Vkb3duUG9zO1xuICAgIH0sIE9vLnByb3RvdHlwZS53aGVlbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyZVByZXZlbnRhYmxlKG5ldyBCbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlZG93blBvcyA9IGUsIHRoaXMuX2ZpcmVQcmV2ZW50YWJsZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUubW91c2V1cCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5fbW91c2Vkb3duUG9zICYmIHRoaXMuX21vdXNlZG93blBvcy5kaXN0KGUpID49IHRoaXMuX2NsaWNrVG9sZXJhbmNlIHx8IHRoaXMuX21hcC5maXJlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5kYmxjbGljayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyZVByZXZlbnRhYmxlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5tb3VzZW92ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJlUHJldmVudGFibGUobmV3IGtvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcga28odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IGtvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBrbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5fZmlyZVByZXZlbnRhYmxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLl9tYXAuZmlyZSh0KSwgdC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4ge307XG4gICAgfSwgT28ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9LCBPby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgT28ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHt9LCBPby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdmFyIEZvID0gZnVuY3Rpb24gRm8odCkge1xuICAgICAgdGhpcy5fbWFwID0gdDtcbiAgICB9O1xuXG4gICAgRm8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZGVsYXlDb250ZXh0TWVudSA9ICExLCBkZWxldGUgdGhpcy5fY29udGV4dE1lbnVFdmVudDtcbiAgICB9LCBGby5wcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIEZvLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9kZWxheUNvbnRleHRNZW51ID0gITA7XG4gICAgfSwgRm8ucHJvdG90eXBlLm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9kZWxheUNvbnRleHRNZW51ID0gITEsIHRoaXMuX2NvbnRleHRNZW51RXZlbnQgJiYgKHRoaXMuX21hcC5maXJlKG5ldyBSbyhcImNvbnRleHRtZW51XCIsIHRoaXMuX21hcCwgdGhpcy5fY29udGV4dE1lbnVFdmVudCkpLCBkZWxldGUgdGhpcy5fY29udGV4dE1lbnVFdmVudCk7XG4gICAgfSwgRm8ucHJvdG90eXBlLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2RlbGF5Q29udGV4dE1lbnUgPyB0aGlzLl9jb250ZXh0TWVudUV2ZW50ID0gdCA6IHRoaXMuX21hcC5maXJlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpLCB0aGlzLl9tYXAubGlzdGVucyhcImNvbnRleHRtZW51XCIpICYmIHQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBGby5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIEZvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBGby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge30sIEZvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB2YXIgVW8gPSBmdW5jdGlvbiBVbyh0LCBlKSB7XG4gICAgICB0aGlzLl9tYXAgPSB0LCB0aGlzLl9lbCA9IHQuZ2V0Q2FudmFzQ29udGFpbmVyKCksIHRoaXMuX2NvbnRhaW5lciA9IHQuZ2V0Q29udGFpbmVyKCksIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gZS5jbGlja1RvbGVyYW5jZSB8fCAxO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBObyh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpID0ge30sIG8gPSAwOyBvIDwgdC5sZW5ndGg7IG8rKykge1xuICAgICAgICBpW3Rbb10uaWRlbnRpZmllcl0gPSBlW29dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBVby5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBVby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9hY3RpdmU7XG4gICAgfSwgVW8ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkKCkgfHwgKHRoaXMuX2VuYWJsZWQgPSAhMCk7XG4gICAgfSwgVW8ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCgpICYmICh0aGlzLl9lbmFibGVkID0gITEpO1xuICAgIH0sIFVvLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQoKSAmJiB0LnNoaWZ0S2V5ICYmIDAgPT09IHQuYnV0dG9uICYmIChpLmRpc2FibGVEcmFnKCksIHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbGFzdFBvcyA9IGUsIHRoaXMuX2FjdGl2ZSA9ICEwKTtcbiAgICB9LCBVby5wcm90b3R5cGUubW91c2Vtb3ZlV2luZG93ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgdmFyIG8gPSBlO1xuXG4gICAgICAgIGlmICghKHRoaXMuX2xhc3RQb3MuZXF1YWxzKG8pIHx8ICF0aGlzLl9ib3ggJiYgby5kaXN0KHRoaXMuX3N0YXJ0UG9zKSA8IHRoaXMuX2NsaWNrVG9sZXJhbmNlKSkge1xuICAgICAgICAgIHZhciByID0gdGhpcy5fc3RhcnRQb3M7XG4gICAgICAgICAgdGhpcy5fbGFzdFBvcyA9IG8sIHRoaXMuX2JveCB8fCAodGhpcy5fYm94ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWJveHpvb21cIiwgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWNyb3NzaGFpclwiKSwgdGhpcy5fZmlyZUV2ZW50KFwiYm94em9vbXN0YXJ0XCIsIHQpKTtcbiAgICAgICAgICB2YXIgYSA9IE1hdGgubWluKHIueCwgby54KSxcbiAgICAgICAgICAgICAgbiA9IE1hdGgubWF4KHIueCwgby54KSxcbiAgICAgICAgICAgICAgcyA9IE1hdGgubWluKHIueSwgby55KSxcbiAgICAgICAgICAgICAgbCA9IE1hdGgubWF4KHIueSwgby55KTtcbiAgICAgICAgICBpLnNldFRyYW5zZm9ybSh0aGlzLl9ib3gsIFwidHJhbnNsYXRlKFwiICsgYSArIFwicHgsXCIgKyBzICsgXCJweClcIiksIHRoaXMuX2JveC5zdHlsZS53aWR0aCA9IG4gLSBhICsgXCJweFwiLCB0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gbCAtIHMgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBVby5wcm90b3R5cGUubW91c2V1cFdpbmRvdyA9IGZ1bmN0aW9uIChlLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgMCA9PT0gZS5idXR0b24pIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIG4gPSBvO1xuICAgICAgICBpZiAodGhpcy5yZXNldCgpLCBpLnN1cHByZXNzQ2xpY2soKSwgYS54ICE9PSBuLnggfHwgYS55ICE9PSBuLnkpIHJldHVybiB0aGlzLl9tYXAuZmlyZShuZXcgdC5FdmVudChcImJveHpvb21lbmRcIiwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgY2FtZXJhQW5pbWF0aW9uOiBmdW5jdGlvbiBjYW1lcmFBbmltYXRpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuZml0U2NyZWVuQ29vcmRpbmF0ZXMoYSwgbiwgci5fbWFwLmdldEJlYXJpbmcoKSwge1xuICAgICAgICAgICAgICBsaW5lYXI6ICEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwiYm94em9vbWNhbmNlbFwiLCBlKTtcbiAgICAgIH1cbiAgICB9LCBVby5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgJiYgMjcgPT09IHQua2V5Q29kZSAmJiAodGhpcy5yZXNldCgpLCB0aGlzLl9maXJlRXZlbnQoXCJib3h6b29tY2FuY2VsXCIsIHQpKTtcbiAgICB9LCBVby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWNyb3NzaGFpclwiKSwgdGhpcy5fYm94ICYmIChpLnJlbW92ZSh0aGlzLl9ib3gpLCB0aGlzLl9ib3ggPSBudWxsKSwgaS5lbmFibGVEcmFnKCksIGRlbGV0ZSB0aGlzLl9zdGFydFBvcywgZGVsZXRlIHRoaXMuX2xhc3RQb3M7XG4gICAgfSwgVW8ucHJvdG90eXBlLl9maXJlRXZlbnQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5maXJlKG5ldyB0LkV2ZW50KGUsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogaVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICB2YXIgWm8gPSBmdW5jdGlvbiBabyh0KSB7XG4gICAgICB0aGlzLnJlc2V0KCksIHRoaXMubnVtVG91Y2hlcyA9IHQubnVtVG91Y2hlcztcbiAgICB9O1xuXG4gICAgWm8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIHRoaXMuY2VudHJvaWQsIGRlbGV0ZSB0aGlzLnN0YXJ0VGltZSwgZGVsZXRlIHRoaXMudG91Y2hlcywgdGhpcy5hYm9ydGVkID0gITE7XG4gICAgfSwgWm8ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgKHRoaXMuY2VudHJvaWQgfHwgby5sZW5ndGggPiB0aGlzLm51bVRvdWNoZXMpICYmICh0aGlzLmFib3J0ZWQgPSAhMCksIHRoaXMuYWJvcnRlZCB8fCAodm9pZCAwID09PSB0aGlzLnN0YXJ0VGltZSAmJiAodGhpcy5zdGFydFRpbWUgPSBlLnRpbWVTdGFtcCksIG8ubGVuZ3RoID09PSB0aGlzLm51bVRvdWNoZXMgJiYgKHRoaXMuY2VudHJvaWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gbmV3IHQuUG9pbnQoMCwgMCksIG8gPSAwLCByID0gZTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICBpLl9hZGQocltvXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaS5kaXYoZS5sZW5ndGgpO1xuICAgICAgfShpKSwgdGhpcy50b3VjaGVzID0gTm8obywgaSkpKTtcbiAgICB9LCBaby5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICghdGhpcy5hYm9ydGVkICYmIHRoaXMuY2VudHJvaWQpIHtcbiAgICAgICAgdmFyIG8gPSBObyhpLCBlKTtcblxuICAgICAgICBmb3IgKHZhciByIGluIHRoaXMudG91Y2hlcykge1xuICAgICAgICAgIHZhciBhID0gb1tyXTtcbiAgICAgICAgICAoIWEgfHwgYS5kaXN0KHRoaXMudG91Y2hlc1tyXSkgPiAzMCkgJiYgKHRoaXMuYWJvcnRlZCA9ICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFpvLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAoKCF0aGlzLmNlbnRyb2lkIHx8IHQudGltZVN0YW1wIC0gdGhpcy5zdGFydFRpbWUgPiA1MDApICYmICh0aGlzLmFib3J0ZWQgPSAhMCksIDAgPT09IGkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvID0gIXRoaXMuYWJvcnRlZCAmJiB0aGlzLmNlbnRyb2lkO1xuICAgICAgICBpZiAodGhpcy5yZXNldCgpLCBvKSByZXR1cm4gbztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHFvID0gZnVuY3Rpb24gcW8odCkge1xuICAgICAgdGhpcy5zaW5nbGVUYXAgPSBuZXcgWm8odCksIHRoaXMubnVtVGFwcyA9IHQubnVtVGFwcywgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICBxby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxhc3RUaW1lID0gMSAvIDAsIGRlbGV0ZSB0aGlzLmxhc3RUYXAsIHRoaXMuY291bnQgPSAwLCB0aGlzLnNpbmdsZVRhcC5yZXNldCgpO1xuICAgIH0sIHFvLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuc2luZ2xlVGFwLnRvdWNoc3RhcnQodCwgZSwgaSk7XG4gICAgfSwgcW8ucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLnNpbmdsZVRhcC50b3VjaG1vdmUodCwgZSwgaSk7XG4gICAgfSwgcW8ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5zaW5nbGVUYXAudG91Y2hlbmQodCwgZSwgaSk7XG5cbiAgICAgIGlmIChvKSB7XG4gICAgICAgIHZhciByID0gdC50aW1lU3RhbXAgLSB0aGlzLmxhc3RUaW1lIDwgNTAwLFxuICAgICAgICAgICAgYSA9ICF0aGlzLmxhc3RUYXAgfHwgdGhpcy5sYXN0VGFwLmRpc3QobykgPCAzMDtcbiAgICAgICAgaWYgKHIgJiYgYSB8fCB0aGlzLnJlc2V0KCksIHRoaXMuY291bnQrKywgdGhpcy5sYXN0VGltZSA9IHQudGltZVN0YW1wLCB0aGlzLmxhc3RUYXAgPSBvLCB0aGlzLmNvdW50ID09PSB0aGlzLm51bVRhcHMpIHJldHVybiB0aGlzLnJlc2V0KCksIG87XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBqbyA9IGZ1bmN0aW9uIGpvKCkge1xuICAgICAgdGhpcy5fem9vbUluID0gbmV3IHFvKHtcbiAgICAgICAgbnVtVG91Y2hlczogMSxcbiAgICAgICAgbnVtVGFwczogMlxuICAgICAgfSksIHRoaXMuX3pvb21PdXQgPSBuZXcgcW8oe1xuICAgICAgICBudW1Ub3VjaGVzOiAyLFxuICAgICAgICBudW1UYXBzOiAxXG4gICAgICB9KSwgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICBqby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fem9vbUluLnJlc2V0KCksIHRoaXMuX3pvb21PdXQucmVzZXQoKTtcbiAgICB9LCBqby5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl96b29tSW4udG91Y2hzdGFydCh0LCBlLCBpKSwgdGhpcy5fem9vbU91dC50b3VjaHN0YXJ0KHQsIGUsIGkpO1xuICAgIH0sIGpvLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fem9vbUluLnRvdWNobW92ZSh0LCBlLCBpKSwgdGhpcy5fem9vbU91dC50b3VjaG1vdmUodCwgZSwgaSk7XG4gICAgfSwgam8ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgICByID0gdGhpcy5fem9vbUluLnRvdWNoZW5kKHQsIGUsIGkpLFxuICAgICAgICAgIGEgPSB0aGlzLl96b29tT3V0LnRvdWNoZW5kKHQsIGUsIGkpO1xuXG4gICAgICByZXR1cm4gciA/ICh0aGlzLl9hY3RpdmUgPSAhMCwgdC5wcmV2ZW50RGVmYXVsdCgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG8ucmVzZXQoKTtcbiAgICAgIH0sIDApLCB7XG4gICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gY2FtZXJhQW5pbWF0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lYXNlVG8oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHpvb206IGUuZ2V0Wm9vbSgpICsgMSxcbiAgICAgICAgICAgIGFyb3VuZDogZS51bnByb2plY3QocilcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogYSA/ICh0aGlzLl9hY3RpdmUgPSAhMCwgdC5wcmV2ZW50RGVmYXVsdCgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG8ucmVzZXQoKTtcbiAgICAgIH0sIDApLCB7XG4gICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gY2FtZXJhQW5pbWF0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lYXNlVG8oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHpvb206IGUuZ2V0Wm9vbSgpIC0gMSxcbiAgICAgICAgICAgIGFyb3VuZDogZS51bnByb2plY3QoYSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogdm9pZCAwO1xuICAgIH0sIGpvLnByb3RvdHlwZS50b3VjaGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LCBqby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIGpvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgam8ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIGpvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcblxuICAgIHZhciBWbyA9IHtcbiAgICAgIDA6IDEsXG4gICAgICAyOiAyXG4gICAgfSxcbiAgICAgICAgR28gPSBmdW5jdGlvbiBHbyh0KSB7XG4gICAgICB0aGlzLnJlc2V0KCksIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gdC5jbGlja1RvbGVyYW5jZSB8fCAxO1xuICAgIH07XG5cbiAgICBHby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fbW92ZWQgPSAhMSwgZGVsZXRlIHRoaXMuX2xhc3RQb2ludCwgZGVsZXRlIHRoaXMuX2V2ZW50QnV0dG9uO1xuICAgIH0sIEdvLnByb3RvdHlwZS5fY29ycmVjdEJ1dHRvbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgR28ucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9LCBHby5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICghdGhpcy5fbGFzdFBvaW50KSB7XG4gICAgICAgIHZhciBvID0gaS5tb3VzZUJ1dHRvbih0KTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJ1dHRvbih0LCBvKSAmJiAodGhpcy5fbGFzdFBvaW50ID0gZSwgdGhpcy5fZXZlbnRCdXR0b24gPSBvKTtcbiAgICAgIH1cbiAgICB9LCBHby5wcm90b3R5cGUubW91c2Vtb3ZlV2luZG93ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fbGFzdFBvaW50O1xuICAgICAgaWYgKGkpIGlmICh0LnByZXZlbnREZWZhdWx0KCksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gVm9bZV07XG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IHQuYnV0dG9ucyB8fCAodC5idXR0b25zICYgaSkgIT09IGk7XG4gICAgICB9KHQsIHRoaXMuX2V2ZW50QnV0dG9uKSkgdGhpcy5yZXNldCgpO2Vsc2UgaWYgKHRoaXMuX21vdmVkIHx8ICEoZS5kaXN0KGkpIDwgdGhpcy5fY2xpY2tUb2xlcmFuY2UpKSByZXR1cm4gdGhpcy5fbW92ZWQgPSAhMCwgdGhpcy5fbGFzdFBvaW50ID0gZSwgdGhpcy5fbW92ZShpLCBlKTtcbiAgICB9LCBHby5wcm90b3R5cGUubW91c2V1cFdpbmRvdyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9sYXN0UG9pbnQgJiYgaS5tb3VzZUJ1dHRvbih0KSA9PT0gdGhpcy5fZXZlbnRCdXR0b24gJiYgKHRoaXMuX21vdmVkICYmIGkuc3VwcHJlc3NDbGljaygpLCB0aGlzLnJlc2V0KCkpO1xuICAgIH0sIEdvLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITA7XG4gICAgfSwgR28ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICB9LCBHby5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSwgR28ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9O1xuXG4gICAgdmFyIFdvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdC5wcm90b3R5cGUubW91c2Vkb3duLmNhbGwodGhpcywgZSwgaSksIHRoaXMuX2xhc3RQb2ludCAmJiAodGhpcy5fYWN0aXZlID0gITApO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX2NvcnJlY3RCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gMCA9PT0gZSAmJiAhdC5jdHJsS2V5O1xuICAgICAgfSwgZS5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyb3VuZDogZSxcbiAgICAgICAgICBwYW5EZWx0YTogZS5zdWIodClcbiAgICAgICAgfTtcbiAgICAgIH0sIGU7XG4gICAgfShHbyksXG4gICAgICAgIFhvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX2NvcnJlY3RCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gMCA9PT0gZSAmJiB0LmN0cmxLZXkgfHwgMiA9PT0gZTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSAuOCAqIChlLnggLSB0LngpO1xuICAgICAgICBpZiAoaSkgcmV0dXJuIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgYmVhcmluZ0RlbHRhOiBpXG4gICAgICAgIH07XG4gICAgICB9LCBlLnByb3RvdHlwZS5jb250ZXh0bWVudSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIGU7XG4gICAgfShHbyksXG4gICAgICAgIEhvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX2NvcnJlY3RCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gMCA9PT0gZSAmJiB0LmN0cmxLZXkgfHwgMiA9PT0gZTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSAtLjUgKiAoZS55IC0gdC55KTtcbiAgICAgICAgaWYgKGkpIHJldHVybiB0aGlzLl9hY3RpdmUgPSAhMCwge1xuICAgICAgICAgIHBpdGNoRGVsdGE6IGlcbiAgICAgICAgfTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSwgZTtcbiAgICB9KEdvKSxcbiAgICAgICAgS28gPSBmdW5jdGlvbiBLbyh0KSB7XG4gICAgICB0aGlzLl9taW5Ub3VjaGVzID0gMSwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgPSB0LmNsaWNrVG9sZXJhbmNlIHx8IDEsIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgS28ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITEsIHRoaXMuX3RvdWNoZXMgPSB7fSwgdGhpcy5fc3VtID0gbmV3IHQuUG9pbnQoMCwgMCk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybSh0LCBlLCBpKTtcbiAgICB9LCBLby5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgIShpLmxlbmd0aCA8IHRoaXMuX21pblRvdWNoZXMpKSByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm0odCwgZSwgaSk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybSh0LCBlLCBpKSwgdGhpcy5fYWN0aXZlICYmIGkubGVuZ3RoIDwgdGhpcy5fbWluVG91Y2hlcyAmJiB0aGlzLnJlc2V0KCk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sIEtvLnByb3RvdHlwZS5fY2FsY3VsYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIG8ubGVuZ3RoID4gMCAmJiAodGhpcy5fYWN0aXZlID0gITApO1xuICAgICAgdmFyIHIgPSBObyhvLCBpKSxcbiAgICAgICAgICBhID0gbmV3IHQuUG9pbnQoMCwgMCksXG4gICAgICAgICAgbiA9IG5ldyB0LlBvaW50KDAsIDApLFxuICAgICAgICAgIHMgPSAwO1xuXG4gICAgICBmb3IgKHZhciBsIGluIHIpIHtcbiAgICAgICAgdmFyIGMgPSByW2xdLFxuICAgICAgICAgICAgdSA9IHRoaXMuX3RvdWNoZXNbbF07XG4gICAgICAgIHUgJiYgKGEuX2FkZChjKSwgbi5fYWRkKGMuc3ViKHUpKSwgcysrLCByW2xdID0gYyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl90b3VjaGVzID0gciwgIShzIDwgdGhpcy5fbWluVG91Y2hlcykgJiYgbi5tYWcoKSkge1xuICAgICAgICB2YXIgaCA9IG4uZGl2KHMpO1xuICAgICAgICBpZiAodGhpcy5fc3VtLl9hZGQoaCksICEodGhpcy5fc3VtLm1hZygpIDwgdGhpcy5fY2xpY2tUb2xlcmFuY2UpKSByZXR1cm4ge1xuICAgICAgICAgIGFyb3VuZDogYS5kaXYocyksXG4gICAgICAgICAgcGFuRGVsdGE6IGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBLby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIEtvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgS28ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIEtvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcblxuICAgIHZhciBZbyA9IGZ1bmN0aW9uIFlvKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBKbyh0LCBlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgaWYgKHRbb10uaWRlbnRpZmllciA9PT0gaSkgcmV0dXJuIGVbb107XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUW8odCwgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHQgLyBlKSAvIE1hdGguTE4yO1xuICAgIH1cblxuICAgIFlvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCBkZWxldGUgdGhpcy5fZmlyc3RUd29Ub3VjaGVzO1xuICAgIH0sIFlvLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodCkge30sIFlvLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fZmlyc3RUd29Ub3VjaGVzIHx8IGkubGVuZ3RoIDwgMiB8fCAodGhpcy5fZmlyc3RUd29Ub3VjaGVzID0gW2lbMF0uaWRlbnRpZmllciwgaVsxXS5pZGVudGlmaWVyXSwgdGhpcy5fc3RhcnQoW2VbMF0sIGVbMV1dKSk7XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAodGhpcy5fZmlyc3RUd29Ub3VjaGVzKSB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl9maXJzdFR3b1RvdWNoZXMsXG4gICAgICAgICAgICByID0gb1sxXSxcbiAgICAgICAgICAgIGEgPSBKbyhpLCBlLCBvWzBdKSxcbiAgICAgICAgICAgIG4gPSBKbyhpLCBlLCByKTtcblxuICAgICAgICBpZiAoYSAmJiBuKSB7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLl9hcm91bmRDZW50ZXIgPyBudWxsIDogYS5hZGQobikuZGl2KDIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tb3ZlKFthLCBuXSwgcywgdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBZby5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAodCwgZSwgbykge1xuICAgICAgaWYgKHRoaXMuX2ZpcnN0VHdvVG91Y2hlcykge1xuICAgICAgICB2YXIgciA9IHRoaXMuX2ZpcnN0VHdvVG91Y2hlcyxcbiAgICAgICAgICAgIGEgPSByWzFdLFxuICAgICAgICAgICAgbiA9IEpvKG8sIGUsIHJbMF0pLFxuICAgICAgICAgICAgcyA9IEpvKG8sIGUsIGEpO1xuICAgICAgICBuICYmIHMgfHwgKHRoaXMuX2FjdGl2ZSAmJiBpLnN1cHByZXNzQ2xpY2soKSwgdGhpcy5yZXNldCgpKTtcbiAgICAgIH1cbiAgICB9LCBZby5wcm90b3R5cGUudG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSwgWW8ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITAsIHRoaXMuX2Fyb3VuZENlbnRlciA9ICEhdCAmJiBcImNlbnRlclwiID09PSB0LmFyb3VuZDtcbiAgICB9LCBZby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIFlvLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBZby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG5cbiAgICB2YXIgJG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKSwgZGVsZXRlIHRoaXMuX2Rpc3RhbmNlLCBkZWxldGUgdGhpcy5fc3RhcnREaXN0YW5jZTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9IHRbMF0uZGlzdCh0WzFdKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9kaXN0YW5jZTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlID0gdFswXS5kaXN0KHRbMV0pLCB0aGlzLl9hY3RpdmUgfHwgIShNYXRoLmFicyhRbyh0aGlzLl9kaXN0YW5jZSwgdGhpcy5fc3RhcnREaXN0YW5jZSkpIDwgLjEpKSByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICB6b29tRGVsdGE6IFFvKHRoaXMuX2Rpc3RhbmNlLCBpKSxcbiAgICAgICAgICBwaW5jaEFyb3VuZDogZVxuICAgICAgICB9O1xuICAgICAgfSwgZTtcbiAgICB9KFlvKTtcblxuICAgIGZ1bmN0aW9uIHRyKHQsIGUpIHtcbiAgICAgIHJldHVybiAxODAgKiB0LmFuZ2xlV2l0aChlKSAvIE1hdGguUEk7XG4gICAgfVxuXG4gICAgdmFyIGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyksIGRlbGV0ZSB0aGlzLl9taW5EaWFtZXRlciwgZGVsZXRlIHRoaXMuX3N0YXJ0VmVjdG9yLCBkZWxldGUgdGhpcy5fdmVjdG9yO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRWZWN0b3IgPSB0aGlzLl92ZWN0b3IgPSB0WzBdLnN1Yih0WzFdKSwgdGhpcy5fbWluRGlhbWV0ZXIgPSB0WzBdLmRpc3QodFsxXSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fdmVjdG9yO1xuICAgICAgICBpZiAodGhpcy5fdmVjdG9yID0gdFswXS5zdWIodFsxXSksIHRoaXMuX2FjdGl2ZSB8fCAhdGhpcy5faXNCZWxvd1RocmVzaG9sZCh0aGlzLl92ZWN0b3IpKSByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICBiZWFyaW5nRGVsdGE6IHRyKHRoaXMuX3ZlY3RvciwgaSksXG4gICAgICAgICAgcGluY2hBcm91bmQ6IGVcbiAgICAgICAgfTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9pc0JlbG93VGhyZXNob2xkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fbWluRGlhbWV0ZXIgPSBNYXRoLm1pbih0aGlzLl9taW5EaWFtZXRlciwgdC5tYWcoKSk7XG4gICAgICAgIHZhciBlID0gMjUgLyAoTWF0aC5QSSAqIHRoaXMuX21pbkRpYW1ldGVyKSAqIDM2MCxcbiAgICAgICAgICAgIGkgPSB0cih0LCB0aGlzLl9zdGFydFZlY3Rvcik7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhpKSA8IGU7XG4gICAgICB9LCBlO1xuICAgIH0oWW8pO1xuXG4gICAgZnVuY3Rpb24gaXIodCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHQueSkgPiBNYXRoLmFicyh0LngpO1xuICAgIH1cblxuICAgIHZhciBvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0LnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpLCB0aGlzLl92YWxpZCA9IHZvaWQgMCwgZGVsZXRlIHRoaXMuX2ZpcnN0TW92ZSwgZGVsZXRlIHRoaXMuX2xhc3RQb2ludHM7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9sYXN0UG9pbnRzID0gdCwgaXIodFswXS5zdWIodFsxXSkpICYmICh0aGlzLl92YWxpZCA9ICExKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0WzBdLnN1Yih0aGlzLl9sYXN0UG9pbnRzWzBdKSxcbiAgICAgICAgICAgIHIgPSB0WzFdLnN1Yih0aGlzLl9sYXN0UG9pbnRzWzFdKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbGlkID0gdGhpcy5nZXN0dXJlQmVnaW5zVmVydGljYWxseShvLCByLCBpLnRpbWVTdGFtcCksIHRoaXMuX3ZhbGlkKSByZXR1cm4gdGhpcy5fbGFzdFBvaW50cyA9IHQsIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgcGl0Y2hEZWx0YTogKG8ueSArIHIueSkgLyAyICogLS41XG4gICAgICAgIH07XG4gICAgICB9LCBlLnByb3RvdHlwZS5nZXN0dXJlQmVnaW5zVmVydGljYWxseSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IHRoaXMuX3ZhbGlkKSByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gICAgICAgIHZhciBvID0gdC5tYWcoKSA+PSAyLFxuICAgICAgICAgICAgciA9IGUubWFnKCkgPj0gMjtcblxuICAgICAgICBpZiAobyB8fCByKSB7XG4gICAgICAgICAgaWYgKCFvIHx8ICFyKSByZXR1cm4gdm9pZCAwID09PSB0aGlzLl9maXJzdE1vdmUgJiYgKHRoaXMuX2ZpcnN0TW92ZSA9IGkpLCBpIC0gdGhpcy5fZmlyc3RNb3ZlIDwgMTAwICYmIHZvaWQgMDtcbiAgICAgICAgICB2YXIgYSA9IHQueSA+IDAgPT0gZS55ID4gMDtcbiAgICAgICAgICByZXR1cm4gaXIodCkgJiYgaXIoZSkgJiYgYTtcbiAgICAgICAgfVxuICAgICAgfSwgZTtcbiAgICB9KFlvKSxcbiAgICAgICAgcnIgPSB7XG4gICAgICBwYW5TdGVwOiAxMDAsXG4gICAgICBiZWFyaW5nU3RlcDogMTUsXG4gICAgICBwaXRjaFN0ZXA6IDEwXG4gICAgfSxcbiAgICAgICAgYXIgPSBmdW5jdGlvbiBhcigpIHtcbiAgICAgIHZhciB0ID0gcnI7XG4gICAgICB0aGlzLl9wYW5TdGVwID0gdC5wYW5TdGVwLCB0aGlzLl9iZWFyaW5nU3RlcCA9IHQuYmVhcmluZ1N0ZXAsIHRoaXMuX3BpdGNoU3RlcCA9IHQucGl0Y2hTdGVwLCB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITE7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5yKHQpIHtcbiAgICAgIHJldHVybiB0ICogKDIgLSB0KTtcbiAgICB9XG5cbiAgICBhci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMTtcbiAgICB9LCBhci5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXM7XG5cbiAgICAgIGlmICghKHQuYWx0S2V5IHx8IHQuY3RybEtleSB8fCB0Lm1ldGFLZXkpKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG8gPSAwLFxuICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICBhID0gMCxcbiAgICAgICAgICAgIG4gPSAwO1xuXG4gICAgICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICBjYXNlIDEwNzpcbiAgICAgICAgICBjYXNlIDE3MTpcbiAgICAgICAgICBjYXNlIDE4NzpcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OTpcbiAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICBjYXNlIDE3MzpcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIHQuc2hpZnRLZXkgPyBvID0gLTEgOiAodC5wcmV2ZW50RGVmYXVsdCgpLCBhID0gLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgdC5zaGlmdEtleSA/IG8gPSAxIDogKHQucHJldmVudERlZmF1bHQoKSwgYSA9IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgdC5zaGlmdEtleSA/IHIgPSAxIDogKHQucHJldmVudERlZmF1bHQoKSwgbiA9IC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIHQuc2hpZnRLZXkgPyByID0gLTEgOiAodC5wcmV2ZW50RGVmYXVsdCgpLCBuID0gMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb25EaXNhYmxlZCAmJiAobyA9IDAsIHIgPSAwKSwge1xuICAgICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gY2FtZXJhQW5pbWF0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciBsID0gcy5nZXRab29tKCk7XG4gICAgICAgICAgICBzLmVhc2VUbyh7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICAgIGVhc2VJZDogXCJrZXlib2FyZEhhbmRsZXJcIixcbiAgICAgICAgICAgICAgZWFzaW5nOiBucixcbiAgICAgICAgICAgICAgem9vbTogaSA/IE1hdGgucm91bmQobCkgKyBpICogKHQuc2hpZnRLZXkgPyAyIDogMSkgOiBsLFxuICAgICAgICAgICAgICBiZWFyaW5nOiBzLmdldEJlYXJpbmcoKSArIG8gKiBlLl9iZWFyaW5nU3RlcCxcbiAgICAgICAgICAgICAgcGl0Y2g6IHMuZ2V0UGl0Y2goKSArIHIgKiBlLl9waXRjaFN0ZXAsXG4gICAgICAgICAgICAgIG9mZnNldDogWy1hICogZS5fcGFuU3RlcCwgLW4gKiBlLl9wYW5TdGVwXSxcbiAgICAgICAgICAgICAgY2VudGVyOiBzLmdldENlbnRlcigpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBhci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIGFyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgYXIucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIGFyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSwgYXIucHJvdG90eXBlLmRpc2FibGVSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSAhMDtcbiAgICB9LCBhci5wcm90b3R5cGUuZW5hYmxlUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITE7XG4gICAgfTtcblxuICAgIHZhciBzciA9IGZ1bmN0aW9uIHNyKGUsIGkpIHtcbiAgICAgIHRoaXMuX21hcCA9IGUsIHRoaXMuX2VsID0gZS5nZXRDYW52YXNDb250YWluZXIoKSwgdGhpcy5faGFuZGxlciA9IGksIHRoaXMuX2RlbHRhID0gMCwgdGhpcy5fZGVmYXVsdFpvb21SYXRlID0gLjAxLCB0aGlzLl93aGVlbFpvb21SYXRlID0gMSAvIDQ1MCwgdC5iaW5kQWxsKFtcIl9vblRpbWVvdXRcIl0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBzci5wcm90b3R5cGUuc2V0Wm9vbVJhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZGVmYXVsdFpvb21SYXRlID0gdDtcbiAgICB9LCBzci5wcm90b3R5cGUuc2V0V2hlZWxab29tUmF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl93aGVlbFpvb21SYXRlID0gdDtcbiAgICB9LCBzci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBzci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9hY3RpdmUgfHwgdm9pZCAwICE9PSB0aGlzLl9maW5pc2hUaW1lb3V0O1xuICAgIH0sIHNyLnByb3RvdHlwZS5pc1pvb21pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl96b29taW5nO1xuICAgIH0sIHNyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQoKSB8fCAodGhpcy5fZW5hYmxlZCA9ICEwLCB0aGlzLl9hcm91bmRDZW50ZXIgPSB0ICYmIFwiY2VudGVyXCIgPT09IHQuYXJvdW5kKTtcbiAgICB9LCBzci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkKCkgJiYgKHRoaXMuX2VuYWJsZWQgPSAhMSk7XG4gICAgfSwgc3IucHJvdG90eXBlLndoZWVsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgIHZhciBpID0gZS5kZWx0YU1vZGUgPT09IHQud2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPyA0MCAqIGUuZGVsdGFZIDogZS5kZWx0YVksXG4gICAgICAgICAgICBvID0gdC5icm93c2VyLm5vdygpLFxuICAgICAgICAgICAgciA9IG8gLSAodGhpcy5fbGFzdFdoZWVsRXZlbnRUaW1lIHx8IDApO1xuICAgICAgICB0aGlzLl9sYXN0V2hlZWxFdmVudFRpbWUgPSBvLCAwICE9PSBpICYmIGkgJSA0LjAwMDI0NDE0MDYyNSA9PSAwID8gdGhpcy5fdHlwZSA9IFwid2hlZWxcIiA6IDAgIT09IGkgJiYgTWF0aC5hYnMoaSkgPCA0ID8gdGhpcy5fdHlwZSA9IFwidHJhY2twYWRcIiA6IHIgPiA0MDAgPyAodGhpcy5fdHlwZSA9IG51bGwsIHRoaXMuX2xhc3RWYWx1ZSA9IGksIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX29uVGltZW91dCwgNDAsIGUpKSA6IHRoaXMuX3R5cGUgfHwgKHRoaXMuX3R5cGUgPSBNYXRoLmFicyhyICogaSkgPCAyMDAgPyBcInRyYWNrcGFkXCIgOiBcIndoZWVsXCIsIHRoaXMuX3RpbWVvdXQgJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fdGltZW91dCA9IG51bGwsIGkgKz0gdGhpcy5fbGFzdFZhbHVlKSksIGUuc2hpZnRLZXkgJiYgaSAmJiAoaSAvPSA0KSwgdGhpcy5fdHlwZSAmJiAodGhpcy5fbGFzdFdoZWVsRXZlbnQgPSBlLCB0aGlzLl9kZWx0YSAtPSBpLCB0aGlzLl9hY3RpdmUgfHwgdGhpcy5fc3RhcnQoZSkpLCBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSwgc3IucHJvdG90eXBlLl9vblRpbWVvdXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fdHlwZSA9IFwid2hlZWxcIiwgdGhpcy5fZGVsdGEgLT0gdGhpcy5fbGFzdFZhbHVlLCB0aGlzLl9hY3RpdmUgfHwgdGhpcy5fc3RhcnQodCk7XG4gICAgfSwgc3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcy5fZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fZnJhbWVJZCAmJiAodGhpcy5fZnJhbWVJZCA9IG51bGwpLCB0aGlzLl9hY3RpdmUgPSAhMCwgdGhpcy5pc1pvb21pbmcoKSB8fCAodGhpcy5fem9vbWluZyA9ICEwKSwgdGhpcy5fZmluaXNoVGltZW91dCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX2ZpbmlzaFRpbWVvdXQpLCBkZWxldGUgdGhpcy5fZmluaXNoVGltZW91dCk7XG4gICAgICAgIHZhciBvID0gaS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX2Fyb3VuZCA9IHQuTG5nTGF0LmNvbnZlcnQodGhpcy5fYXJvdW5kQ2VudGVyID8gdGhpcy5fbWFwLmdldENlbnRlcigpIDogdGhpcy5fbWFwLnVucHJvamVjdChvKSksIHRoaXMuX2Fyb3VuZFBvaW50ID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5sb2NhdGlvblBvaW50KHRoaXMuX2Fyb3VuZCksIHRoaXMuX2ZyYW1lSWQgfHwgKHRoaXMuX2ZyYW1lSWQgPSAhMCwgdGhpcy5faGFuZGxlci5fdHJpZ2dlclJlbmRlckZyYW1lKCkpO1xuICAgICAgfVxuICAgIH0sIHNyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQgJiYgKHRoaXMuX2ZyYW1lSWQgPSBudWxsLCB0aGlzLmlzQWN0aXZlKCkpKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fbWFwLnRyYW5zZm9ybTtcblxuICAgICAgICBpZiAoMCAhPT0gdGhpcy5fZGVsdGEpIHtcbiAgICAgICAgICB2YXIgbyA9IFwid2hlZWxcIiA9PT0gdGhpcy5fdHlwZSAmJiBNYXRoLmFicyh0aGlzLl9kZWx0YSkgPiA0LjAwMDI0NDE0MDYyNSA/IHRoaXMuX3doZWVsWm9vbVJhdGUgOiB0aGlzLl9kZWZhdWx0Wm9vbVJhdGUsXG4gICAgICAgICAgICAgIHIgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnModGhpcy5fZGVsdGEgKiBvKSkpO1xuICAgICAgICAgIHRoaXMuX2RlbHRhIDwgMCAmJiAwICE9PSByICYmIChyID0gMSAvIHIpO1xuICAgICAgICAgIHZhciBhID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgdGhpcy5fdGFyZ2V0Wm9vbSA/IGkuem9vbVNjYWxlKHRoaXMuX3RhcmdldFpvb20pIDogaS5zY2FsZTtcbiAgICAgICAgICB0aGlzLl90YXJnZXRab29tID0gTWF0aC5taW4oaS5tYXhab29tLCBNYXRoLm1heChpLm1pblpvb20sIGkuc2NhbGVab29tKGEgKiByKSkpLCBcIndoZWVsXCIgPT09IHRoaXMuX3R5cGUgJiYgKHRoaXMuX3N0YXJ0Wm9vbSA9IGkuem9vbSwgdGhpcy5fZWFzaW5nID0gdGhpcy5fc21vb3RoT3V0RWFzaW5nKDIwMCkpLCB0aGlzLl9kZWx0YSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbixcbiAgICAgICAgICAgIHMgPSBcIm51bWJlclwiID09IHR5cGVvZiB0aGlzLl90YXJnZXRab29tID8gdGhpcy5fdGFyZ2V0Wm9vbSA6IGkuem9vbSxcbiAgICAgICAgICAgIGwgPSB0aGlzLl9zdGFydFpvb20sXG4gICAgICAgICAgICBjID0gdGhpcy5fZWFzaW5nLFxuICAgICAgICAgICAgdSA9ICExO1xuXG4gICAgICAgIGlmIChcIndoZWVsXCIgPT09IHRoaXMuX3R5cGUgJiYgbCAmJiBjKSB7XG4gICAgICAgICAgdmFyIGggPSBNYXRoLm1pbigodC5icm93c2VyLm5vdygpIC0gdGhpcy5fbGFzdFdoZWVsRXZlbnRUaW1lKSAvIDIwMCwgMSksXG4gICAgICAgICAgICAgIHAgPSBjKGgpO1xuICAgICAgICAgIG4gPSB0Lm51bWJlcihsLCBzLCBwKSwgaCA8IDEgPyB0aGlzLl9mcmFtZUlkIHx8ICh0aGlzLl9mcmFtZUlkID0gITApIDogdSA9ICEwO1xuICAgICAgICB9IGVsc2UgbiA9IHMsIHUgPSAhMDtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHUgJiYgKHRoaXMuX2FjdGl2ZSA9ICExLCB0aGlzLl9maW5pc2hUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS5fem9vbWluZyA9ICExLCBlLl9oYW5kbGVyLl90cmlnZ2VyUmVuZGVyRnJhbWUoKSwgZGVsZXRlIGUuX3RhcmdldFpvb20sIGRlbGV0ZSBlLl9maW5pc2hUaW1lb3V0O1xuICAgICAgICB9LCAyMDApKSwge1xuICAgICAgICAgIG5vSW5lcnRpYTogITAsXG4gICAgICAgICAgbmVlZHNSZW5kZXJGcmFtZTogIXUsXG4gICAgICAgICAgem9vbURlbHRhOiBuIC0gaS56b29tLFxuICAgICAgICAgIGFyb3VuZDogdGhpcy5fYXJvdW5kUG9pbnQsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdFdoZWVsRXZlbnRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBzci5wcm90b3R5cGUuX3Ntb290aE91dEVhc2luZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IHQuZWFzZTtcblxuICAgICAgaWYgKHRoaXMuX3ByZXZFYXNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5fcHJldkVhc2UsXG4gICAgICAgICAgICByID0gKHQuYnJvd3Nlci5ub3coKSAtIG8uc3RhcnQpIC8gby5kdXJhdGlvbixcbiAgICAgICAgICAgIGEgPSBvLmVhc2luZyhyICsgLjAxKSAtIG8uZWFzaW5nKHIpLFxuICAgICAgICAgICAgbiA9IC4yNyAvIE1hdGguc3FydChhICogYSArIDFlLTQpICogLjAxLFxuICAgICAgICAgICAgcyA9IE1hdGguc3FydCguMDcyOSAtIG4gKiBuKTtcbiAgICAgICAgaSA9IHQuYmV6aWVyKG4sIHMsIC4yNSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcmV2RWFzZSA9IHtcbiAgICAgICAgc3RhcnQ6IHQuYnJvd3Nlci5ub3coKSxcbiAgICAgICAgZHVyYXRpb246IGUsXG4gICAgICAgIGVhc2luZzogaVxuICAgICAgfSwgaTtcbiAgICB9LCBzci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMTtcbiAgICB9O1xuXG4gICAgdmFyIGxyID0gZnVuY3Rpb24gbHIodCwgZSkge1xuICAgICAgdGhpcy5fY2xpY2tab29tID0gdCwgdGhpcy5fdGFwWm9vbSA9IGU7XG4gICAgfTtcblxuICAgIGxyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jbGlja1pvb20uZW5hYmxlKCksIHRoaXMuX3RhcFpvb20uZW5hYmxlKCk7XG4gICAgfSwgbHIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jbGlja1pvb20uZGlzYWJsZSgpLCB0aGlzLl90YXBab29tLmRpc2FibGUoKTtcbiAgICB9LCBsci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NsaWNrWm9vbS5pc0VuYWJsZWQoKSAmJiB0aGlzLl90YXBab29tLmlzRW5hYmxlZCgpO1xuICAgIH0sIGxyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGlja1pvb20uaXNBY3RpdmUoKSB8fCB0aGlzLl90YXBab29tLmlzQWN0aXZlKCk7XG4gICAgfTtcblxuICAgIHZhciBjciA9IGZ1bmN0aW9uIGNyKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICBjci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMTtcbiAgICB9LCBjci5wcm90b3R5cGUuZGJsY2xpY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSwge1xuICAgICAgICBjYW1lcmFBbmltYXRpb246IGZ1bmN0aW9uIGNhbWVyYUFuaW1hdGlvbihpKSB7XG4gICAgICAgICAgaS5lYXNlVG8oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHpvb206IGkuZ2V0Wm9vbSgpICsgKHQuc2hpZnRLZXkgPyAtMSA6IDEpLFxuICAgICAgICAgICAgYXJvdW5kOiBpLnVucHJvamVjdChlKVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBjci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIGNyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgY3IucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIGNyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcblxuICAgIHZhciB1ciA9IGZ1bmN0aW9uIHVyKCkge1xuICAgICAgdGhpcy5fdGFwID0gbmV3IHFvKHtcbiAgICAgICAgbnVtVG91Y2hlczogMSxcbiAgICAgICAgbnVtVGFwczogMVxuICAgICAgfSksIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgdXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITEsIGRlbGV0ZSB0aGlzLl9zd2lwZVBvaW50LCBkZWxldGUgdGhpcy5fc3dpcGVUb3VjaCwgZGVsZXRlIHRoaXMuX3RhcFRpbWUsIHRoaXMuX3RhcC5yZXNldCgpO1xuICAgIH0sIHVyLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3N3aXBlUG9pbnQgfHwgKHRoaXMuX3RhcFRpbWUgJiYgdC50aW1lU3RhbXAgLSB0aGlzLl90YXBUaW1lID4gNTAwICYmIHRoaXMucmVzZXQoKSwgdGhpcy5fdGFwVGltZSA/IGkubGVuZ3RoID4gMCAmJiAodGhpcy5fc3dpcGVQb2ludCA9IGVbMF0sIHRoaXMuX3N3aXBlVG91Y2ggPSBpWzBdLmlkZW50aWZpZXIpIDogdGhpcy5fdGFwLnRvdWNoc3RhcnQodCwgZSwgaSkpO1xuICAgIH0sIHVyLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgaWYgKHRoaXMuX3RhcFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N3aXBlUG9pbnQpIHtcbiAgICAgICAgICBpZiAoaVswXS5pZGVudGlmaWVyICE9PSB0aGlzLl9zd2lwZVRvdWNoKSByZXR1cm47XG4gICAgICAgICAgdmFyIG8gPSBlWzBdLFxuICAgICAgICAgICAgICByID0gby55IC0gdGhpcy5fc3dpcGVQb2ludC55O1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zd2lwZVBvaW50ID0gbywgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9hY3RpdmUgPSAhMCwge1xuICAgICAgICAgICAgem9vbURlbHRhOiByIC8gMTI4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHRoaXMuX3RhcC50b3VjaG1vdmUodCwgZSwgaSk7XG4gICAgfSwgdXIucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3RhcFRpbWUgPyB0aGlzLl9zd2lwZVBvaW50ICYmIDAgPT09IGkubGVuZ3RoICYmIHRoaXMucmVzZXQoKSA6IHRoaXMuX3RhcC50b3VjaGVuZCh0LCBlLCBpKSAmJiAodGhpcy5fdGFwVGltZSA9IHQudGltZVN0YW1wKTtcbiAgICB9LCB1ci5wcm90b3R5cGUudG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSwgdXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCB1ci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIHVyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCB1ci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG5cbiAgICB2YXIgaHIgPSBmdW5jdGlvbiBocih0LCBlLCBpKSB7XG4gICAgICB0aGlzLl9lbCA9IHQsIHRoaXMuX21vdXNlUGFuID0gZSwgdGhpcy5fdG91Y2hQYW4gPSBpO1xuICAgIH07XG5cbiAgICBoci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2luZXJ0aWFPcHRpb25zID0gdCB8fCB7fSwgdGhpcy5fbW91c2VQYW4uZW5hYmxlKCksIHRoaXMuX3RvdWNoUGFuLmVuYWJsZSgpLCB0aGlzLl9lbC5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC10b3VjaC1kcmFnLXBhblwiKTtcbiAgICB9LCBoci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX21vdXNlUGFuLmRpc2FibGUoKSwgdGhpcy5fdG91Y2hQYW4uZGlzYWJsZSgpLCB0aGlzLl9lbC5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC10b3VjaC1kcmFnLXBhblwiKTtcbiAgICB9LCBoci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlUGFuLmlzRW5hYmxlZCgpICYmIHRoaXMuX3RvdWNoUGFuLmlzRW5hYmxlZCgpO1xuICAgIH0sIGhyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZVBhbi5pc0FjdGl2ZSgpIHx8IHRoaXMuX3RvdWNoUGFuLmlzQWN0aXZlKCk7XG4gICAgfTtcblxuICAgIHZhciBwciA9IGZ1bmN0aW9uIHByKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3BpdGNoV2l0aFJvdGF0ZSA9IHQucGl0Y2hXaXRoUm90YXRlLCB0aGlzLl9tb3VzZVJvdGF0ZSA9IGUsIHRoaXMuX21vdXNlUGl0Y2ggPSBpO1xuICAgIH07XG5cbiAgICBwci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VSb3RhdGUuZW5hYmxlKCksIHRoaXMuX3BpdGNoV2l0aFJvdGF0ZSAmJiB0aGlzLl9tb3VzZVBpdGNoLmVuYWJsZSgpO1xuICAgIH0sIHByLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VSb3RhdGUuZGlzYWJsZSgpLCB0aGlzLl9tb3VzZVBpdGNoLmRpc2FibGUoKTtcbiAgICB9LCBwci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlUm90YXRlLmlzRW5hYmxlZCgpICYmICghdGhpcy5fcGl0Y2hXaXRoUm90YXRlIHx8IHRoaXMuX21vdXNlUGl0Y2guaXNFbmFibGVkKCkpO1xuICAgIH0sIHByLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZVJvdGF0ZS5pc0FjdGl2ZSgpIHx8IHRoaXMuX21vdXNlUGl0Y2guaXNBY3RpdmUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGRyID0gZnVuY3Rpb24gZHIodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy5fZWwgPSB0LCB0aGlzLl90b3VjaFpvb20gPSBlLCB0aGlzLl90b3VjaFJvdGF0ZSA9IGksIHRoaXMuX3RhcERyYWdab29tID0gbywgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICExLCB0aGlzLl9lbmFibGVkID0gITA7XG4gICAgfTtcblxuICAgIGRyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fdG91Y2hab29tLmVuYWJsZSh0KSwgdGhpcy5fcm90YXRpb25EaXNhYmxlZCB8fCB0aGlzLl90b3VjaFJvdGF0ZS5lbmFibGUodCksIHRoaXMuX3RhcERyYWdab29tLmVuYWJsZSgpLCB0aGlzLl9lbC5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC10b3VjaC16b29tLXJvdGF0ZVwiKTtcbiAgICB9LCBkci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3RvdWNoWm9vbS5kaXNhYmxlKCksIHRoaXMuX3RvdWNoUm90YXRlLmRpc2FibGUoKSwgdGhpcy5fdGFwRHJhZ1pvb20uZGlzYWJsZSgpLCB0aGlzLl9lbC5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC10b3VjaC16b29tLXJvdGF0ZVwiKTtcbiAgICB9LCBkci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoWm9vbS5pc0VuYWJsZWQoKSAmJiAodGhpcy5fcm90YXRpb25EaXNhYmxlZCB8fCB0aGlzLl90b3VjaFJvdGF0ZS5pc0VuYWJsZWQoKSkgJiYgdGhpcy5fdGFwRHJhZ1pvb20uaXNFbmFibGVkKCk7XG4gICAgfSwgZHIucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoWm9vbS5pc0FjdGl2ZSgpIHx8IHRoaXMuX3RvdWNoUm90YXRlLmlzQWN0aXZlKCkgfHwgdGhpcy5fdGFwRHJhZ1pvb20uaXNBY3RpdmUoKTtcbiAgICB9LCBkci5wcm90b3R5cGUuZGlzYWJsZVJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICEwLCB0aGlzLl90b3VjaFJvdGF0ZS5kaXNhYmxlKCk7XG4gICAgfSwgZHIucHJvdG90eXBlLmVuYWJsZVJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICExLCB0aGlzLl90b3VjaFpvb20uaXNFbmFibGVkKCkgJiYgdGhpcy5fdG91Y2hSb3RhdGUuZW5hYmxlKCk7XG4gICAgfTtcblxuICAgIHZhciBfciA9IGZ1bmN0aW9uIF9yKHQpIHtcbiAgICAgIHJldHVybiB0Lnpvb20gfHwgdC5kcmFnIHx8IHQucGl0Y2ggfHwgdC5yb3RhdGU7XG4gICAgfSxcbiAgICAgICAgZnIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlO1xuICAgIH0odC5FdmVudCk7XG5cbiAgICBmdW5jdGlvbiBtcih0KSB7XG4gICAgICByZXR1cm4gdC5wYW5EZWx0YSAmJiB0LnBhbkRlbHRhLm1hZygpIHx8IHQuem9vbURlbHRhIHx8IHQuYmVhcmluZ0RlbHRhIHx8IHQucGl0Y2hEZWx0YTtcbiAgICB9XG5cbiAgICB2YXIgZ3IgPSBmdW5jdGlvbiBncihlLCBvKSB7XG4gICAgICB0aGlzLl9tYXAgPSBlLCB0aGlzLl9lbCA9IHRoaXMuX21hcC5nZXRDYW52YXNDb250YWluZXIoKSwgdGhpcy5faGFuZGxlcnMgPSBbXSwgdGhpcy5faGFuZGxlcnNCeUlkID0ge30sIHRoaXMuX2NoYW5nZXMgPSBbXSwgdGhpcy5faW5lcnRpYSA9IG5ldyBBbyhlKSwgdGhpcy5fYmVhcmluZ1NuYXAgPSBvLmJlYXJpbmdTbmFwLCB0aGlzLl9wcmV2aW91c0FjdGl2ZUhhbmRsZXJzID0ge30sIHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3MgPSB7fSwgdGhpcy5fYWRkRGVmYXVsdEhhbmRsZXJzKG8pLCB0LmJpbmRBbGwoW1wiaGFuZGxlRXZlbnRcIiwgXCJoYW5kbGVXaW5kb3dFdmVudFwiXSwgdGhpcyk7XG4gICAgICB2YXIgciA9IHRoaXMuX2VsO1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW1tyLCBcInRvdWNoc3RhcnRcIiwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfV0sIFtyLCBcInRvdWNobW92ZVwiLCB7XG4gICAgICAgIHBhc3NpdmU6ICExXG4gICAgICB9XSwgW3IsIFwidG91Y2hlbmRcIiwgdm9pZCAwXSwgW3IsIFwidG91Y2hjYW5jZWxcIiwgdm9pZCAwXSwgW3IsIFwibW91c2Vkb3duXCIsIHZvaWQgMF0sIFtyLCBcIm1vdXNlbW92ZVwiLCB2b2lkIDBdLCBbciwgXCJtb3VzZXVwXCIsIHZvaWQgMF0sIFt0LndpbmRvdy5kb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwge1xuICAgICAgICBjYXB0dXJlOiAhMFxuICAgICAgfV0sIFt0LndpbmRvdy5kb2N1bWVudCwgXCJtb3VzZXVwXCIsIHZvaWQgMF0sIFtyLCBcIm1vdXNlb3ZlclwiLCB2b2lkIDBdLCBbciwgXCJtb3VzZW91dFwiLCB2b2lkIDBdLCBbciwgXCJkYmxjbGlja1wiLCB2b2lkIDBdLCBbciwgXCJjbGlja1wiLCB2b2lkIDBdLCBbciwgXCJrZXlkb3duXCIsIHtcbiAgICAgICAgY2FwdHVyZTogITFcbiAgICAgIH1dLCBbciwgXCJrZXl1cFwiLCB2b2lkIDBdLCBbciwgXCJ3aGVlbFwiLCB7XG4gICAgICAgIHBhc3NpdmU6ICExXG4gICAgICB9XSwgW3IsIFwiY29udGV4dG1lbnVcIiwgdm9pZCAwXSwgW3Qud2luZG93LCBcImJsdXJcIiwgdm9pZCAwXV07XG5cbiAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gdGhpcy5fbGlzdGVuZXJzOyBhIDwgbi5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICB2YXIgcyA9IG5bYV0sXG4gICAgICAgICAgICBsID0gc1swXTtcbiAgICAgICAgaS5hZGRFdmVudExpc3RlbmVyKGwsIHNbMV0sIGwgPT09IHQud2luZG93LmRvY3VtZW50ID8gdGhpcy5oYW5kbGVXaW5kb3dFdmVudCA6IHRoaXMuaGFuZGxlRXZlbnQsIHNbMl0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBnci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCBvID0gdGhpcy5fbGlzdGVuZXJzOyBlIDwgby5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgciA9IG9bZV0sXG4gICAgICAgICAgICBhID0gclswXTtcbiAgICAgICAgaS5yZW1vdmVFdmVudExpc3RlbmVyKGEsIHJbMV0sIGEgPT09IHQud2luZG93LmRvY3VtZW50ID8gdGhpcy5oYW5kbGVXaW5kb3dFdmVudCA6IHRoaXMuaGFuZGxlRXZlbnQsIHJbMl0pO1xuICAgICAgfVxuICAgIH0sIGdyLnByb3RvdHlwZS5fYWRkRGVmYXVsdEhhbmRsZXJzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fbWFwLFxuICAgICAgICAgIGkgPSBlLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgICB0aGlzLl9hZGQoXCJtYXBFdmVudFwiLCBuZXcgT28oZSwgdCkpO1xuXG4gICAgICB2YXIgbyA9IGUuYm94Wm9vbSA9IG5ldyBVbyhlLCB0KTtcblxuICAgICAgdGhpcy5fYWRkKFwiYm94Wm9vbVwiLCBvKTtcblxuICAgICAgdmFyIHIgPSBuZXcgam8oKSxcbiAgICAgICAgICBhID0gbmV3IGNyKCk7XG4gICAgICBlLmRvdWJsZUNsaWNrWm9vbSA9IG5ldyBscihhLCByKSwgdGhpcy5fYWRkKFwidGFwWm9vbVwiLCByKSwgdGhpcy5fYWRkKFwiY2xpY2tab29tXCIsIGEpO1xuICAgICAgdmFyIG4gPSBuZXcgdXIoKTtcblxuICAgICAgdGhpcy5fYWRkKFwidGFwRHJhZ1pvb21cIiwgbik7XG5cbiAgICAgIHZhciBzID0gZS50b3VjaFBpdGNoID0gbmV3IG9yKCk7XG5cbiAgICAgIHRoaXMuX2FkZChcInRvdWNoUGl0Y2hcIiwgcyk7XG5cbiAgICAgIHZhciBsID0gbmV3IFhvKHQpLFxuICAgICAgICAgIGMgPSBuZXcgSG8odCk7XG4gICAgICBlLmRyYWdSb3RhdGUgPSBuZXcgcHIodCwgbCwgYyksIHRoaXMuX2FkZChcIm1vdXNlUm90YXRlXCIsIGwsIFtcIm1vdXNlUGl0Y2hcIl0pLCB0aGlzLl9hZGQoXCJtb3VzZVBpdGNoXCIsIGMsIFtcIm1vdXNlUm90YXRlXCJdKTtcbiAgICAgIHZhciB1ID0gbmV3IFdvKHQpLFxuICAgICAgICAgIGggPSBuZXcgS28odCk7XG4gICAgICBlLmRyYWdQYW4gPSBuZXcgaHIoaSwgdSwgaCksIHRoaXMuX2FkZChcIm1vdXNlUGFuXCIsIHUpLCB0aGlzLl9hZGQoXCJ0b3VjaFBhblwiLCBoLCBbXCJ0b3VjaFpvb21cIiwgXCJ0b3VjaFJvdGF0ZVwiXSk7XG4gICAgICB2YXIgcCA9IG5ldyBlcigpLFxuICAgICAgICAgIGQgPSBuZXcgJG8oKTtcbiAgICAgIGUudG91Y2hab29tUm90YXRlID0gbmV3IGRyKGksIGQsIHAsIG4pLCB0aGlzLl9hZGQoXCJ0b3VjaFJvdGF0ZVwiLCBwLCBbXCJ0b3VjaFBhblwiLCBcInRvdWNoWm9vbVwiXSksIHRoaXMuX2FkZChcInRvdWNoWm9vbVwiLCBkLCBbXCJ0b3VjaFBhblwiLCBcInRvdWNoUm90YXRlXCJdKTtcblxuICAgICAgdmFyIF8gPSBlLnNjcm9sbFpvb20gPSBuZXcgc3IoZSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2FkZChcInNjcm9sbFpvb21cIiwgXywgW1wibW91c2VQYW5cIl0pO1xuXG4gICAgICB2YXIgZiA9IGUua2V5Ym9hcmQgPSBuZXcgYXIoKTtcbiAgICAgIHRoaXMuX2FkZChcImtleWJvYXJkXCIsIGYpLCB0aGlzLl9hZGQoXCJibG9ja2FibGVNYXBFdmVudFwiLCBuZXcgRm8oZSkpO1xuXG4gICAgICBmb3IgKHZhciBtID0gMCwgZyA9IFtcImJveFpvb21cIiwgXCJkb3VibGVDbGlja1pvb21cIiwgXCJ0YXBEcmFnWm9vbVwiLCBcInRvdWNoUGl0Y2hcIiwgXCJkcmFnUm90YXRlXCIsIFwiZHJhZ1BhblwiLCBcInRvdWNoWm9vbVJvdGF0ZVwiLCBcInNjcm9sbFpvb21cIiwgXCJrZXlib2FyZFwiXTsgbSA8IGcubGVuZ3RoOyBtICs9IDEpIHtcbiAgICAgICAgdmFyIHYgPSBnW21dO1xuICAgICAgICB0LmludGVyYWN0aXZlICYmIHRbdl0gJiYgZVt2XS5lbmFibGUodFt2XSk7XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5faGFuZGxlcnMucHVzaCh7XG4gICAgICAgIGhhbmRsZXJOYW1lOiB0LFxuICAgICAgICBoYW5kbGVyOiBlLFxuICAgICAgICBhbGxvd2VkOiBpXG4gICAgICB9KSwgdGhpcy5faGFuZGxlcnNCeUlkW3RdID0gZTtcbiAgICB9LCBnci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0aW5nQ2FtZXJhKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCBpID0gdGhpcy5faGFuZGxlcnM7IGUgPCBpLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgaVtlXS5oYW5kbGVyLnJlc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbmVydGlhLmNsZWFyKCksIHRoaXMuX2ZpcmVFdmVudHMoe30sIHt9LCB0KSwgdGhpcy5fY2hhbmdlcyA9IFtdO1xuICAgICAgfVxuICAgIH0sIGdyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gdGhpcy5faGFuZGxlcnM7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgIGlmIChlW3RdLmhhbmRsZXIuaXNBY3RpdmUoKSkgcmV0dXJuICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZ3IucHJvdG90eXBlLmlzWm9vbWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2V2ZW50c0luUHJvZ3Jlc3Muem9vbSB8fCB0aGlzLl9tYXAuc2Nyb2xsWm9vbS5pc1pvb21pbmcoKTtcbiAgICB9LCBnci5wcm90b3R5cGUuaXNSb3RhdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2V2ZW50c0luUHJvZ3Jlc3Mucm90YXRlO1xuICAgIH0sIGdyLnByb3RvdHlwZS5pc01vdmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKF9yKHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3MpKSB8fCB0aGlzLmlzWm9vbWluZygpO1xuICAgIH0sIGdyLnByb3RvdHlwZS5fYmxvY2tlZEJ5QWN0aXZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gaW4gdCkge1xuICAgICAgICBpZiAobyAhPT0gaSAmJiAoIWUgfHwgZS5pbmRleE9mKG8pIDwgMCkpIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGdyLnByb3RvdHlwZS5oYW5kbGVXaW5kb3dFdmVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmhhbmRsZUV2ZW50KHQsIHQudHlwZSArIFwiV2luZG93XCIpO1xuICAgIH0sIGdyLnByb3RvdHlwZS5fZ2V0TWFwVG91Y2hlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIGkgPSAwLCBvID0gdDsgaSA8IG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHIgPSBvW2ldO1xuICAgICAgICB0aGlzLl9lbC5jb250YWlucyhyLnRhcmdldCkgJiYgZS5wdXNoKHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9LCBnci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKFwiYmx1clwiICE9PSB0LnR5cGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRpbmdDYW1lcmEgPSAhMDtcblxuICAgICAgICBmb3IgKHZhciBvID0gXCJyZW5kZXJGcmFtZVwiID09PSB0LnR5cGUgPyB2b2lkIDAgOiB0LCByID0ge1xuICAgICAgICAgIG5lZWRzUmVuZGVyRnJhbWU6ICExXG4gICAgICAgIH0sIGEgPSB7fSwgbiA9IHt9LCBzID0gdC50b3VjaGVzID8gdGhpcy5fZ2V0TWFwVG91Y2hlcyh0LnRvdWNoZXMpIDogdm9pZCAwLCBsID0gcyA/IGkudG91Y2hQb3ModGhpcy5fZWwsIHMpIDogaS5tb3VzZVBvcyh0aGlzLl9lbCwgdCksIGMgPSAwLCB1ID0gdGhpcy5faGFuZGxlcnM7IGMgPCB1Lmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgdmFyIGggPSB1W2NdLFxuICAgICAgICAgICAgICBwID0gaC5oYW5kbGVyTmFtZSxcbiAgICAgICAgICAgICAgZCA9IGguaGFuZGxlcixcbiAgICAgICAgICAgICAgXyA9IGguYWxsb3dlZDtcblxuICAgICAgICAgIGlmIChkLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrZWRCeUFjdGl2ZShuLCBfLCBwKSA/IGQucmVzZXQoKSA6IGRbZSB8fCB0LnR5cGVdICYmIChmID0gZFtlIHx8IHQudHlwZV0odCwgbCwgcyksIHRoaXMubWVyZ2VIYW5kbGVyUmVzdWx0KHIsIGEsIGYsIHAsIG8pLCBmICYmIGYubmVlZHNSZW5kZXJGcmFtZSAmJiB0aGlzLl90cmlnZ2VyUmVuZGVyRnJhbWUoKSksIChmIHx8IGQuaXNBY3RpdmUoKSkgJiYgKG5bcF0gPSBkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGcgaW4gdGhpcy5fcHJldmlvdXNBY3RpdmVIYW5kbGVycykge1xuICAgICAgICAgIG5bZ10gfHwgKG1bZ10gPSBvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQWN0aXZlSGFuZGxlcnMgPSBuLCAoT2JqZWN0LmtleXMobSkubGVuZ3RoIHx8IG1yKHIpKSAmJiAodGhpcy5fY2hhbmdlcy5wdXNoKFtyLCBhLCBtXSksIHRoaXMuX3RyaWdnZXJSZW5kZXJGcmFtZSgpKSwgKE9iamVjdC5rZXlzKG4pLmxlbmd0aCB8fCBtcihyKSkgJiYgdGhpcy5fbWFwLl9zdG9wKCEwKSwgdGhpcy5fdXBkYXRpbmdDYW1lcmEgPSAhMTtcbiAgICAgICAgdmFyIHYgPSByLmNhbWVyYUFuaW1hdGlvbjtcbiAgICAgICAgdiAmJiAodGhpcy5faW5lcnRpYS5jbGVhcigpLCB0aGlzLl9maXJlRXZlbnRzKHt9LCB7fSwgITApLCB0aGlzLl9jaGFuZ2VzID0gW10sIHYodGhpcy5fbWFwKSk7XG4gICAgICB9IGVsc2UgdGhpcy5zdG9wKCEwKTtcbiAgICB9LCBnci5wcm90b3R5cGUubWVyZ2VIYW5kbGVyUmVzdWx0ID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIHQuZXh0ZW5kKGUsIG8pO1xuICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICBoYW5kbGVyTmFtZTogcixcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvLm9yaWdpbmFsRXZlbnQgfHwgYVxuICAgICAgICB9O1xuICAgICAgICB2b2lkIDAgIT09IG8uem9vbURlbHRhICYmIChpLnpvb20gPSBuKSwgdm9pZCAwICE9PSBvLnBhbkRlbHRhICYmIChpLmRyYWcgPSBuKSwgdm9pZCAwICE9PSBvLnBpdGNoRGVsdGEgJiYgKGkucGl0Y2ggPSBuKSwgdm9pZCAwICE9PSBvLmJlYXJpbmdEZWx0YSAmJiAoaS5yb3RhdGUgPSBuKTtcbiAgICAgIH1cbiAgICB9LCBnci5wcm90b3R5cGUuX2FwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGUgPSB7fSwgaSA9IHt9LCBvID0ge30sIHIgPSAwLCBhID0gdGhpcy5fY2hhbmdlczsgciA8IGEubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSBhW3JdLFxuICAgICAgICAgICAgcyA9IG5bMF0sXG4gICAgICAgICAgICBsID0gblsxXSxcbiAgICAgICAgICAgIGMgPSBuWzJdO1xuICAgICAgICBzLnBhbkRlbHRhICYmIChlLnBhbkRlbHRhID0gKGUucGFuRGVsdGEgfHwgbmV3IHQuUG9pbnQoMCwgMCkpLl9hZGQocy5wYW5EZWx0YSkpLCBzLnpvb21EZWx0YSAmJiAoZS56b29tRGVsdGEgPSAoZS56b29tRGVsdGEgfHwgMCkgKyBzLnpvb21EZWx0YSksIHMuYmVhcmluZ0RlbHRhICYmIChlLmJlYXJpbmdEZWx0YSA9IChlLmJlYXJpbmdEZWx0YSB8fCAwKSArIHMuYmVhcmluZ0RlbHRhKSwgcy5waXRjaERlbHRhICYmIChlLnBpdGNoRGVsdGEgPSAoZS5waXRjaERlbHRhIHx8IDApICsgcy5waXRjaERlbHRhKSwgdm9pZCAwICE9PSBzLmFyb3VuZCAmJiAoZS5hcm91bmQgPSBzLmFyb3VuZCksIHZvaWQgMCAhPT0gcy5waW5jaEFyb3VuZCAmJiAoZS5waW5jaEFyb3VuZCA9IHMucGluY2hBcm91bmQpLCBzLm5vSW5lcnRpYSAmJiAoZS5ub0luZXJ0aWEgPSBzLm5vSW5lcnRpYSksIHQuZXh0ZW5kKGksIGwpLCB0LmV4dGVuZChvLCBjKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlTWFwVHJhbnNmb3JtKGUsIGksIG8pLCB0aGlzLl9jaGFuZ2VzID0gW107XG4gICAgfSwgZ3IucHJvdG90eXBlLl91cGRhdGVNYXBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9tYXAsXG4gICAgICAgICAgciA9IG8udHJhbnNmb3JtO1xuICAgICAgaWYgKCFtcih0KSkgcmV0dXJuIHRoaXMuX2ZpcmVFdmVudHMoZSwgaSwgITApO1xuICAgICAgdmFyIGEgPSB0LnBhbkRlbHRhLFxuICAgICAgICAgIG4gPSB0Lnpvb21EZWx0YSxcbiAgICAgICAgICBzID0gdC5iZWFyaW5nRGVsdGEsXG4gICAgICAgICAgbCA9IHQucGl0Y2hEZWx0YSxcbiAgICAgICAgICBjID0gdC5hcm91bmQsXG4gICAgICAgICAgdSA9IHQucGluY2hBcm91bmQ7XG4gICAgICB2b2lkIDAgIT09IHUgJiYgKGMgPSB1KSwgby5fc3RvcCghMCksIGMgPSBjIHx8IG8udHJhbnNmb3JtLmNlbnRlclBvaW50O1xuICAgICAgdmFyIGggPSByLnBvaW50TG9jYXRpb24oYSA/IGMuc3ViKGEpIDogYyk7XG4gICAgICBzICYmIChyLmJlYXJpbmcgKz0gcyksIGwgJiYgKHIucGl0Y2ggKz0gbCksIG4gJiYgKHIuem9vbSArPSBuKSwgci5zZXRMb2NhdGlvbkF0UG9pbnQoaCwgYyksIHRoaXMuX21hcC5fdXBkYXRlKCksIHQubm9JbmVydGlhIHx8IHRoaXMuX2luZXJ0aWEucmVjb3JkKHQpLCB0aGlzLl9maXJlRXZlbnRzKGUsIGksICEwKTtcbiAgICB9LCBnci5wcm90b3R5cGUuX2ZpcmVFdmVudHMgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICAgIGEgPSBfcih0aGlzLl9ldmVudHNJblByb2dyZXNzKSxcbiAgICAgICAgICBuID0gX3IoZSksXG4gICAgICAgICAgcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBsIGluIGUpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzSW5Qcm9ncmVzc1tsXSB8fCAoc1tsICsgXCJzdGFydFwiXSA9IGVbbF0ub3JpZ2luYWxFdmVudCksIHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3NbbF0gPSBlW2xdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBjIGluICFhICYmIG4gJiYgdGhpcy5fZmlyZUV2ZW50KFwibW92ZXN0YXJ0XCIsIG4ub3JpZ2luYWxFdmVudCksIHMpIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KGMsIHNbY10pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciB1IGluIG4gJiYgdGhpcy5fZmlyZUV2ZW50KFwibW92ZVwiLCBuLm9yaWdpbmFsRXZlbnQpLCBlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCh1LCBlW3VdLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCxcbiAgICAgICAgICBwID0ge307XG5cbiAgICAgIGZvciAodmFyIGQgaW4gdGhpcy5fZXZlbnRzSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgXyA9IHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3NbZF0sXG4gICAgICAgICAgICBmID0gXy5oYW5kbGVyTmFtZSxcbiAgICAgICAgICAgIG0gPSBfLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzQnlJZFtmXS5pc0FjdGl2ZSgpIHx8IChkZWxldGUgdGhpcy5fZXZlbnRzSW5Qcm9ncmVzc1tkXSwgcFtkICsgXCJlbmRcIl0gPSBoID0gaVtmXSB8fCBtKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZyBpbiBwKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudChnLCBwW2ddKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHYgPSBfcih0aGlzLl9ldmVudHNJblByb2dyZXNzKTtcblxuICAgICAgaWYgKG8gJiYgKGEgfHwgbikgJiYgIXYpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRpbmdDYW1lcmEgPSAhMDtcblxuICAgICAgICB2YXIgeSA9IHRoaXMuX2luZXJ0aWEuX29uTW92ZUVuZCh0aGlzLl9tYXAuZHJhZ1Bhbi5faW5lcnRpYU9wdGlvbnMpLFxuICAgICAgICAgICAgeCA9IGZ1bmN0aW9uIHgodCkge1xuICAgICAgICAgIHJldHVybiAwICE9PSB0ICYmIC1yLl9iZWFyaW5nU25hcCA8IHQgJiYgdCA8IHIuX2JlYXJpbmdTbmFwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHkgPyAoeCh5LmJlYXJpbmcgfHwgdGhpcy5fbWFwLmdldEJlYXJpbmcoKSkgJiYgKHkuYmVhcmluZyA9IDApLCB0aGlzLl9tYXAuZWFzZVRvKHksIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBoXG4gICAgICAgIH0pKSA6ICh0aGlzLl9tYXAuZmlyZShuZXcgdC5FdmVudChcIm1vdmVlbmRcIiwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGhcbiAgICAgICAgfSkpLCB4KHRoaXMuX21hcC5nZXRCZWFyaW5nKCkpICYmIHRoaXMuX21hcC5yZXNldE5vcnRoKCkpLCB0aGlzLl91cGRhdGluZ0NhbWVyYSA9ICExO1xuICAgICAgfVxuICAgIH0sIGdyLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyB0LkV2ZW50KGUsIGkgPyB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGlcbiAgICAgIH0gOiB7fSkpO1xuICAgIH0sIGdyLnByb3RvdHlwZS5fcmVxdWVzdEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC50cmlnZ2VyUmVwYWludCgpLCB0aGlzLl9tYXAuX3JlbmRlclRhc2tRdWV1ZS5hZGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZGVsZXRlIHQuX2ZyYW1lSWQsIHQuaGFuZGxlRXZlbnQobmV3IGZyKFwicmVuZGVyRnJhbWVcIiwge1xuICAgICAgICAgIHRpbWVTdGFtcDogZVxuICAgICAgICB9KSksIHQuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgfSk7XG4gICAgfSwgZ3IucHJvdG90eXBlLl90cmlnZ2VyUmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2b2lkIDAgPT09IHRoaXMuX2ZyYW1lSWQgJiYgKHRoaXMuX2ZyYW1lSWQgPSB0aGlzLl9yZXF1ZXN0RnJhbWUoKSk7XG4gICAgfTtcblxuICAgIHZhciB2ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmdW5jdGlvbiBpKGksIG8pIHtcbiAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLl9tb3ZpbmcgPSAhMSwgdGhpcy5fem9vbWluZyA9ICExLCB0aGlzLnRyYW5zZm9ybSA9IGksIHRoaXMuX2JlYXJpbmdTbmFwID0gby5iZWFyaW5nU25hcCwgdC5iaW5kQWxsKFtcIl9yZW5kZXJGcmFtZUNhbGxiYWNrXCJdLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IHQuTG5nTGF0KHRoaXMudHJhbnNmb3JtLmNlbnRlci5sbmcsIHRoaXMudHJhbnNmb3JtLmNlbnRlci5sYXQpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICBjZW50ZXI6IHRcbiAgICAgICAgfSwgZSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wYW5CeSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiBlID0gdC5Qb2ludC5jb252ZXJ0KGUpLm11bHQoLTEpLCB0aGlzLnBhblRvKHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdC5leHRlbmQoe1xuICAgICAgICAgIG9mZnNldDogZVxuICAgICAgICB9LCBpKSwgbyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wYW5UbyA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh0LmV4dGVuZCh7XG4gICAgICAgICAgY2VudGVyOiBlXG4gICAgICAgIH0sIGkpLCBvKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS56b29tO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmp1bXBUbyh7XG4gICAgICAgICAgem9vbTogdFxuICAgICAgICB9LCBlKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLnpvb21UbyA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh0LmV4dGVuZCh7XG4gICAgICAgICAgem9vbTogZVxuICAgICAgICB9LCBpKSwgbyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS56b29tSW4gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgKyAxLCB0LCBlKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLnpvb21PdXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgLSAxLCB0LCBlKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldEJlYXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5iZWFyaW5nO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0QmVhcmluZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmp1bXBUbyh7XG4gICAgICAgICAgYmVhcmluZzogdFxuICAgICAgICB9LCBlKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmdldFBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wYWRkaW5nO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0UGFkZGluZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmp1bXBUbyh7XG4gICAgICAgICAgcGFkZGluZzogdFxuICAgICAgICB9LCBlKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLnJvdGF0ZVRvID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZVRvKHQuZXh0ZW5kKHtcbiAgICAgICAgICBiZWFyaW5nOiBlXG4gICAgICAgIH0sIGkpLCBvKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlc2V0Tm9ydGggPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVUbygwLCB0LmV4dGVuZCh7XG4gICAgICAgICAgZHVyYXRpb246IDFlM1xuICAgICAgICB9LCBlKSwgaSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZXNldE5vcnRoUGl0Y2ggPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYXNlVG8odC5leHRlbmQoe1xuICAgICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgICAgcGl0Y2g6IDAsXG4gICAgICAgICAgZHVyYXRpb246IDFlM1xuICAgICAgICB9LCBlKSwgaSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zbmFwVG9Ob3J0aCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmdldEJlYXJpbmcoKSkgPCB0aGlzLl9iZWFyaW5nU25hcCA/IHRoaXMucmVzZXROb3J0aCh0LCBlKSA6IHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRQaXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdGNoO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0UGl0Y2ggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qdW1wVG8oe1xuICAgICAgICAgIHBpdGNoOiB0XG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY2FtZXJhRm9yQm91bmRzID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgZSA9IHQuTG5nTGF0Qm91bmRzLmNvbnZlcnQoZSk7XG4gICAgICAgIHZhciBvID0gaSAmJiBpLmJlYXJpbmcgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYUZvckJveEFuZEJlYXJpbmcoZS5nZXROb3J0aFdlc3QoKSwgZS5nZXRTb3V0aEVhc3QoKSwgbywgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fY2FtZXJhRm9yQm94QW5kQmVhcmluZyA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiAociA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICBwYWRkaW5nOiBhLFxuICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgIG1heFpvb206IHRoaXMudHJhbnNmb3JtLm1heFpvb21cbiAgICAgICAgfSwgcikpLnBhZGRpbmcpIHtcbiAgICAgICAgICB2YXIgbiA9IHIucGFkZGluZztcbiAgICAgICAgICByLnBhZGRpbmcgPSB7XG4gICAgICAgICAgICB0b3A6IG4sXG4gICAgICAgICAgICBib3R0b206IG4sXG4gICAgICAgICAgICByaWdodDogbixcbiAgICAgICAgICAgIGxlZnQ6IG5cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgci5wYWRkaW5nID0gdC5leHRlbmQoYSwgci5wYWRkaW5nKTtcblxuICAgICAgICB2YXIgcyA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgbCA9IHMucGFkZGluZyxcbiAgICAgICAgICAgIGMgPSBzLnByb2plY3QodC5MbmdMYXQuY29udmVydChlKSksXG4gICAgICAgICAgICB1ID0gcy5wcm9qZWN0KHQuTG5nTGF0LmNvbnZlcnQoaSkpLFxuICAgICAgICAgICAgaCA9IGMucm90YXRlKC1vICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgICBwID0gdS5yb3RhdGUoLW8gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgICAgIGQgPSBuZXcgdC5Qb2ludChNYXRoLm1heChoLngsIHAueCksIE1hdGgubWF4KGgueSwgcC55KSksXG4gICAgICAgICAgICBfID0gbmV3IHQuUG9pbnQoTWF0aC5taW4oaC54LCBwLngpLCBNYXRoLm1pbihoLnksIHAueSkpLFxuICAgICAgICAgICAgZiA9IGQuc3ViKF8pLFxuICAgICAgICAgICAgbSA9IChzLndpZHRoIC0gKGwubGVmdCArIGwucmlnaHQgKyByLnBhZGRpbmcubGVmdCArIHIucGFkZGluZy5yaWdodCkpIC8gZi54LFxuICAgICAgICAgICAgZyA9IChzLmhlaWdodCAtIChsLnRvcCArIGwuYm90dG9tICsgci5wYWRkaW5nLnRvcCArIHIucGFkZGluZy5ib3R0b20pKSAvIGYueTtcblxuICAgICAgICBpZiAoIShnIDwgMCB8fCBtIDwgMCkpIHtcbiAgICAgICAgICB2YXIgdiA9IE1hdGgubWluKHMuc2NhbGVab29tKHMuc2NhbGUgKiBNYXRoLm1pbihtLCBnKSksIHIubWF4Wm9vbSksXG4gICAgICAgICAgICAgIHkgPSBcIm51bWJlclwiID09IHR5cGVvZiByLm9mZnNldC54ID8gbmV3IHQuUG9pbnQoci5vZmZzZXQueCwgci5vZmZzZXQueSkgOiB0LlBvaW50LmNvbnZlcnQoci5vZmZzZXQpLFxuICAgICAgICAgICAgICB4ID0gbmV3IHQuUG9pbnQoKHIucGFkZGluZy5sZWZ0IC0gci5wYWRkaW5nLnJpZ2h0KSAvIDIsIChyLnBhZGRpbmcudG9wIC0gci5wYWRkaW5nLmJvdHRvbSkgLyAyKS5yb3RhdGUobyAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgICAgICBiID0geS5hZGQoeCkubXVsdChzLnNjYWxlIC8gcy56b29tU2NhbGUodikpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IHMudW5wcm9qZWN0KGMuYWRkKHUpLmRpdigyKS5zdWIoYikpLFxuICAgICAgICAgICAgem9vbTogdixcbiAgICAgICAgICAgIGJlYXJpbmc6IG9cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdC53YXJuT25jZShcIk1hcCBjYW5ub3QgZml0IHdpdGhpbiBjYW52YXMgd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLCBwYWRkaW5nLCBhbmQvb3Igb2Zmc2V0LlwiKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmZpdEJvdW5kcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXRJbnRlcm5hbCh0aGlzLmNhbWVyYUZvckJvdW5kcyh0LCBlKSwgZSwgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5maXRTY3JlZW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXRJbnRlcm5hbCh0aGlzLl9jYW1lcmFGb3JCb3hBbmRCZWFyaW5nKHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24odC5Qb2ludC5jb252ZXJ0KGUpKSwgdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0LlBvaW50LmNvbnZlcnQoaSkpLCBvLCByKSwgciwgYSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZml0SW50ZXJuYWwgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICByZXR1cm4gZSA/IChkZWxldGUgKGkgPSB0LmV4dGVuZChlLCBpKSkucGFkZGluZywgaS5saW5lYXIgPyB0aGlzLmVhc2VUbyhpLCBvKSA6IHRoaXMuZmx5VG8oaSwgbykpIDogdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmp1bXBUbyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB2YXIgbyA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgciA9ICExLFxuICAgICAgICAgICAgYSA9ICExLFxuICAgICAgICAgICAgbiA9ICExO1xuICAgICAgICByZXR1cm4gXCJ6b29tXCIgaW4gZSAmJiBvLnpvb20gIT09ICtlLnpvb20gJiYgKHIgPSAhMCwgby56b29tID0gK2Uuem9vbSksIHZvaWQgMCAhPT0gZS5jZW50ZXIgJiYgKG8uY2VudGVyID0gdC5MbmdMYXQuY29udmVydChlLmNlbnRlcikpLCBcImJlYXJpbmdcIiBpbiBlICYmIG8uYmVhcmluZyAhPT0gK2UuYmVhcmluZyAmJiAoYSA9ICEwLCBvLmJlYXJpbmcgPSArZS5iZWFyaW5nKSwgXCJwaXRjaFwiIGluIGUgJiYgby5waXRjaCAhPT0gK2UucGl0Y2ggJiYgKG4gPSAhMCwgby5waXRjaCA9ICtlLnBpdGNoKSwgbnVsbCA9PSBlLnBhZGRpbmcgfHwgby5pc1BhZGRpbmdFcXVhbChlLnBhZGRpbmcpIHx8IChvLnBhZGRpbmcgPSBlLnBhZGRpbmcpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJtb3Zlc3RhcnRcIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJtb3ZlXCIsIGkpKSwgciAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ6b29tc3RhcnRcIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJ6b29tXCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwiem9vbWVuZFwiLCBpKSksIGEgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicm90YXRlc3RhcnRcIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVcIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVlbmRcIiwgaSkpLCBuICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInBpdGNoc3RhcnRcIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJwaXRjaFwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcInBpdGNoZW5kXCIsIGkpKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZWVuZFwiLCBpKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5lYXNlVG8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N0b3AoITEsIGUuZWFzZUlkKSwgKCExID09PSAoZSA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgIGVhc2luZzogdC5lYXNlXG4gICAgICAgIH0sIGUpKS5hbmltYXRlIHx8ICFlLmVzc2VudGlhbCAmJiB0LmJyb3dzZXIucHJlZmVyc1JlZHVjZWRNb3Rpb24pICYmIChlLmR1cmF0aW9uID0gMCk7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIGEgPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIG4gPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHMgPSB0aGlzLmdldFBpdGNoKCksXG4gICAgICAgICAgICBsID0gdGhpcy5nZXRQYWRkaW5nKCksXG4gICAgICAgICAgICBjID0gXCJ6b29tXCIgaW4gZSA/ICtlLnpvb20gOiBhLFxuICAgICAgICAgICAgdSA9IFwiYmVhcmluZ1wiIGluIGUgPyB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKGUuYmVhcmluZywgbikgOiBuLFxuICAgICAgICAgICAgaCA9IFwicGl0Y2hcIiBpbiBlID8gK2UucGl0Y2ggOiBzLFxuICAgICAgICAgICAgcCA9IFwicGFkZGluZ1wiIGluIGUgPyBlLnBhZGRpbmcgOiByLnBhZGRpbmcsXG4gICAgICAgICAgICBkID0gdC5Qb2ludC5jb252ZXJ0KGUub2Zmc2V0KSxcbiAgICAgICAgICAgIF8gPSByLmNlbnRlclBvaW50LmFkZChkKSxcbiAgICAgICAgICAgIGYgPSByLnBvaW50TG9jYXRpb24oXyksXG4gICAgICAgICAgICBtID0gdC5MbmdMYXQuY29udmVydChlLmNlbnRlciB8fCBmKTtcblxuICAgICAgICB0aGlzLl9ub3JtYWxpemVDZW50ZXIobSk7XG5cbiAgICAgICAgdmFyIGcsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgeSA9IHIucHJvamVjdChmKSxcbiAgICAgICAgICAgIHggPSByLnByb2plY3QobSkuc3ViKHkpLFxuICAgICAgICAgICAgYiA9IHIuem9vbVNjYWxlKGMgLSBhKTtcbiAgICAgICAgZS5hcm91bmQgJiYgKGcgPSB0LkxuZ0xhdC5jb252ZXJ0KGUuYXJvdW5kKSwgdiA9IHIubG9jYXRpb25Qb2ludChnKSk7XG4gICAgICAgIHZhciB3ID0ge1xuICAgICAgICAgIG1vdmluZzogdGhpcy5fbW92aW5nLFxuICAgICAgICAgIHpvb21pbmc6IHRoaXMuX3pvb21pbmcsXG4gICAgICAgICAgcm90YXRpbmc6IHRoaXMuX3JvdGF0aW5nLFxuICAgICAgICAgIHBpdGNoaW5nOiB0aGlzLl9waXRjaGluZ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fem9vbWluZyA9IHRoaXMuX3pvb21pbmcgfHwgYyAhPT0gYSwgdGhpcy5fcm90YXRpbmcgPSB0aGlzLl9yb3RhdGluZyB8fCBuICE9PSB1LCB0aGlzLl9waXRjaGluZyA9IHRoaXMuX3BpdGNoaW5nIHx8IGggIT09IHMsIHRoaXMuX3BhZGRpbmcgPSAhci5pc1BhZGRpbmdFcXVhbChwKSwgdGhpcy5fZWFzZUlkID0gZS5lYXNlSWQsIHRoaXMuX3ByZXBhcmVFYXNlKGksIGUubm9Nb3ZlU3RhcnQsIHcpLCB0aGlzLl9lYXNlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKG8uX3pvb21pbmcgJiYgKHIuem9vbSA9IHQubnVtYmVyKGEsIGMsIGUpKSwgby5fcm90YXRpbmcgJiYgKHIuYmVhcmluZyA9IHQubnVtYmVyKG4sIHUsIGUpKSwgby5fcGl0Y2hpbmcgJiYgKHIucGl0Y2ggPSB0Lm51bWJlcihzLCBoLCBlKSksIG8uX3BhZGRpbmcgJiYgKHIuaW50ZXJwb2xhdGVQYWRkaW5nKGwsIHAsIGUpLCBfID0gci5jZW50ZXJQb2ludC5hZGQoZCkpLCBnKSByLnNldExvY2F0aW9uQXRQb2ludChnLCB2KTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gci56b29tU2NhbGUoci56b29tIC0gYSksXG4gICAgICAgICAgICAgICAgbSA9IGMgPiBhID8gTWF0aC5taW4oMiwgYikgOiBNYXRoLm1heCguNSwgYiksXG4gICAgICAgICAgICAgICAgdyA9IE1hdGgucG93KG0sIDEgLSBlKSxcbiAgICAgICAgICAgICAgICBUID0gci51bnByb2plY3QoeS5hZGQoeC5tdWx0KGUgKiB3KSkubXVsdChmKSk7XG4gICAgICAgICAgICByLnNldExvY2F0aW9uQXRQb2ludChyLnJlbmRlcldvcmxkQ29waWVzID8gVC53cmFwKCkgOiBULCBfKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvLl9maXJlTW92ZUV2ZW50cyhpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBvLl9hZnRlckVhc2UoaSwgdCk7XG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3ByZXBhcmVFYXNlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgdm9pZCAwID09PSBvICYmIChvID0ge30pLCB0aGlzLl9tb3ZpbmcgPSAhMCwgaSB8fCBvLm1vdmluZyB8fCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJtb3Zlc3RhcnRcIiwgZSkpLCB0aGlzLl96b29taW5nICYmICFvLnpvb21pbmcgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiem9vbXN0YXJ0XCIsIGUpKSwgdGhpcy5fcm90YXRpbmcgJiYgIW8ucm90YXRpbmcgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicm90YXRlc3RhcnRcIiwgZSkpLCB0aGlzLl9waXRjaGluZyAmJiAhby5waXRjaGluZyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJwaXRjaHN0YXJ0XCIsIGUpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9maXJlTW92ZUV2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm1vdmVcIiwgZSkpLCB0aGlzLl96b29taW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInpvb21cIiwgZSkpLCB0aGlzLl9yb3RhdGluZyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVcIiwgZSkpLCB0aGlzLl9waXRjaGluZyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJwaXRjaFwiLCBlKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fYWZ0ZXJFYXNlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lYXNlSWQgfHwgIWkgfHwgdGhpcy5fZWFzZUlkICE9PSBpKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2Vhc2VJZDtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuX3pvb21pbmcsXG4gICAgICAgICAgICAgIHIgPSB0aGlzLl9yb3RhdGluZyxcbiAgICAgICAgICAgICAgYSA9IHRoaXMuX3BpdGNoaW5nO1xuICAgICAgICAgIHRoaXMuX21vdmluZyA9ICExLCB0aGlzLl96b29taW5nID0gITEsIHRoaXMuX3JvdGF0aW5nID0gITEsIHRoaXMuX3BpdGNoaW5nID0gITEsIHRoaXMuX3BhZGRpbmcgPSAhMSwgbyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ6b29tZW5kXCIsIGUpKSwgciAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVlbmRcIiwgZSkpLCBhICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInBpdGNoZW5kXCIsIGUpKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZWVuZFwiLCBlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLmZseVRvID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuXG4gICAgICAgIGlmICghZS5lc3NlbnRpYWwgJiYgdC5icm93c2VyLnByZWZlcnNSZWR1Y2VkTW90aW9uKSB7XG4gICAgICAgICAgdmFyIHIgPSB0LnBpY2soZSwgW1wiY2VudGVyXCIsIFwiem9vbVwiLCBcImJlYXJpbmdcIiwgXCJwaXRjaFwiLCBcImFyb3VuZFwiXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHIsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wKCksIGUgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgc3BlZWQ6IDEuMixcbiAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICBlYXNpbmc6IHQuZWFzZVxuICAgICAgICB9LCBlKTtcblxuICAgICAgICB2YXIgYSA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgbiA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgcyA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgbCA9IHRoaXMuZ2V0UGl0Y2goKSxcbiAgICAgICAgICAgIGMgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgICAgIHUgPSBcInpvb21cIiBpbiBlID8gdC5jbGFtcCgrZS56b29tLCBhLm1pblpvb20sIGEubWF4Wm9vbSkgOiBuLFxuICAgICAgICAgICAgaCA9IFwiYmVhcmluZ1wiIGluIGUgPyB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKGUuYmVhcmluZywgcykgOiBzLFxuICAgICAgICAgICAgcCA9IFwicGl0Y2hcIiBpbiBlID8gK2UucGl0Y2ggOiBsLFxuICAgICAgICAgICAgZCA9IFwicGFkZGluZ1wiIGluIGUgPyBlLnBhZGRpbmcgOiBhLnBhZGRpbmcsXG4gICAgICAgICAgICBfID0gYS56b29tU2NhbGUodSAtIG4pLFxuICAgICAgICAgICAgZiA9IHQuUG9pbnQuY29udmVydChlLm9mZnNldCksXG4gICAgICAgICAgICBtID0gYS5jZW50ZXJQb2ludC5hZGQoZiksXG4gICAgICAgICAgICBnID0gYS5wb2ludExvY2F0aW9uKG0pLFxuICAgICAgICAgICAgdiA9IHQuTG5nTGF0LmNvbnZlcnQoZS5jZW50ZXIgfHwgZyk7XG5cbiAgICAgICAgdGhpcy5fbm9ybWFsaXplQ2VudGVyKHYpO1xuXG4gICAgICAgIHZhciB5ID0gYS5wcm9qZWN0KGcpLFxuICAgICAgICAgICAgeCA9IGEucHJvamVjdCh2KS5zdWIoeSksXG4gICAgICAgICAgICBiID0gZS5jdXJ2ZSxcbiAgICAgICAgICAgIHcgPSBNYXRoLm1heChhLndpZHRoLCBhLmhlaWdodCksXG4gICAgICAgICAgICBUID0gdyAvIF8sXG4gICAgICAgICAgICBFID0geC5tYWcoKTtcblxuICAgICAgICBpZiAoXCJtaW5ab29tXCIgaW4gZSkge1xuICAgICAgICAgIHZhciBJID0gdC5jbGFtcChNYXRoLm1pbihlLm1pblpvb20sIG4sIHUpLCBhLm1pblpvb20sIGEubWF4Wm9vbSksXG4gICAgICAgICAgICAgIFAgPSB3IC8gYS56b29tU2NhbGUoSSAtIG4pO1xuICAgICAgICAgIGIgPSBNYXRoLnNxcnQoUCAvIEUgKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBTID0gYiAqIGI7XG5cbiAgICAgICAgZnVuY3Rpb24gQyh0KSB7XG4gICAgICAgICAgdmFyIGUgPSAoVCAqIFQgLSB3ICogdyArICh0ID8gLTEgOiAxKSAqIFMgKiBTICogRSAqIEUpIC8gKDIgKiAodCA/IFQgOiB3KSAqIFMgKiBFKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KGUgKiBlICsgMSkgLSBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHoodCkge1xuICAgICAgICAgIHJldHVybiAoTWF0aC5leHAodCkgLSBNYXRoLmV4cCgtdCkpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEQodCkge1xuICAgICAgICAgIHJldHVybiAoTWF0aC5leHAodCkgKyBNYXRoLmV4cCgtdCkpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBBID0gQygwKSxcbiAgICAgICAgICAgIE0gPSBmdW5jdGlvbiBNKHQpIHtcbiAgICAgICAgICByZXR1cm4gRChBKSAvIEQoQSArIGIgKiB0KTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIEwgPSBmdW5jdGlvbiBMKHQpIHtcbiAgICAgICAgICByZXR1cm4gdyAqICgoRChBKSAqICh6KGUgPSBBICsgYiAqIHQpIC8gRChlKSkgLSB6KEEpKSAvIFMpIC8gRTtcbiAgICAgICAgICB2YXIgZTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIFIgPSAoQygxKSAtIEEpIC8gYjtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoRSkgPCAxZS02IHx8ICFpc0Zpbml0ZShSKSkge1xuICAgICAgICAgIGlmIChNYXRoLmFicyh3IC0gVCkgPCAxZS02KSByZXR1cm4gdGhpcy5lYXNlVG8oZSwgaSk7XG4gICAgICAgICAgdmFyIGsgPSBUIDwgdyA/IC0xIDogMTtcbiAgICAgICAgICBSID0gTWF0aC5hYnMoTWF0aC5sb2coVCAvIHcpKSAvIGIsIEwgPSBmdW5jdGlvbiBMKCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSwgTSA9IGZ1bmN0aW9uIE0odCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZXhwKGsgKiBiICogdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlLmR1cmF0aW9uID0gXCJkdXJhdGlvblwiIGluIGUgPyArZS5kdXJhdGlvbiA6IDFlMyAqIFIgLyAoXCJzY3JlZW5TcGVlZFwiIGluIGUgPyArZS5zY3JlZW5TcGVlZCAvIGIgOiArZS5zcGVlZCksIGUubWF4RHVyYXRpb24gJiYgZS5kdXJhdGlvbiA+IGUubWF4RHVyYXRpb24gJiYgKGUuZHVyYXRpb24gPSAwKSwgdGhpcy5fem9vbWluZyA9ICEwLCB0aGlzLl9yb3RhdGluZyA9IHMgIT09IGgsIHRoaXMuX3BpdGNoaW5nID0gcCAhPT0gbCwgdGhpcy5fcGFkZGluZyA9ICFhLmlzUGFkZGluZ0VxdWFsKGQpLCB0aGlzLl9wcmVwYXJlRWFzZShpLCAhMSksIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgciA9IGUgKiBSLFxuICAgICAgICAgICAgICBfID0gMSAvIE0ocik7XG5cbiAgICAgICAgICBhLnpvb20gPSAxID09PSBlID8gdSA6IG4gKyBhLnNjYWxlWm9vbShfKSwgby5fcm90YXRpbmcgJiYgKGEuYmVhcmluZyA9IHQubnVtYmVyKHMsIGgsIGUpKSwgby5fcGl0Y2hpbmcgJiYgKGEucGl0Y2ggPSB0Lm51bWJlcihsLCBwLCBlKSksIG8uX3BhZGRpbmcgJiYgKGEuaW50ZXJwb2xhdGVQYWRkaW5nKGMsIGQsIGUpLCBtID0gYS5jZW50ZXJQb2ludC5hZGQoZikpO1xuICAgICAgICAgIHZhciBnID0gMSA9PT0gZSA/IHYgOiBhLnVucHJvamVjdCh5LmFkZCh4Lm11bHQoTChyKSkpLm11bHQoXykpO1xuICAgICAgICAgIGEuc2V0TG9jYXRpb25BdFBvaW50KGEucmVuZGVyV29ybGRDb3BpZXMgPyBnLndyYXAoKSA6IGcsIG0pLCBvLl9maXJlTW92ZUV2ZW50cyhpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvLl9hZnRlckVhc2UoaSk7XG4gICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNFYXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2Vhc2VGcmFtZUlkO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3AoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vhc2VGcmFtZUlkICYmICh0aGlzLl9jYW5jZWxSZW5kZXJGcmFtZSh0aGlzLl9lYXNlRnJhbWVJZCksIGRlbGV0ZSB0aGlzLl9lYXNlRnJhbWVJZCwgZGVsZXRlIHRoaXMuX29uRWFzZUZyYW1lKSwgdGhpcy5fb25FYXNlRW5kKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9vbkVhc2VFbmQ7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX29uRWFzZUVuZCwgaS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgIG8gJiYgby5zdG9wKCExKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2Vhc2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAhMSA9PT0gby5hbmltYXRlIHx8IDAgPT09IG8uZHVyYXRpb24gPyAoZSgxKSwgaSgpKSA6ICh0aGlzLl9lYXNlU3RhcnQgPSB0LmJyb3dzZXIubm93KCksIHRoaXMuX2Vhc2VPcHRpb25zID0gbywgdGhpcy5fb25FYXNlRnJhbWUgPSBlLCB0aGlzLl9vbkVhc2VFbmQgPSBpLCB0aGlzLl9lYXNlRnJhbWVJZCA9IHRoaXMuX3JlcXVlc3RSZW5kZXJGcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNhbGxiYWNrKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcmVuZGVyRnJhbWVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLm1pbigodC5icm93c2VyLm5vdygpIC0gdGhpcy5fZWFzZVN0YXJ0KSAvIHRoaXMuX2Vhc2VPcHRpb25zLmR1cmF0aW9uLCAxKTtcbiAgICAgICAgdGhpcy5fb25FYXNlRnJhbWUodGhpcy5fZWFzZU9wdGlvbnMuZWFzaW5nKGUpKSwgZSA8IDEgPyB0aGlzLl9lYXNlRnJhbWVJZCA9IHRoaXMuX3JlcXVlc3RSZW5kZXJGcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNhbGxiYWNrKSA6IHRoaXMuc3RvcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX25vcm1hbGl6ZUJlYXJpbmcgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBlID0gdC53cmFwKGUsIC0xODAsIDE4MCk7XG4gICAgICAgIHZhciBvID0gTWF0aC5hYnMoZSAtIGkpO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZSAtIDM2MCAtIGkpIDwgbyAmJiAoZSAtPSAzNjApLCBNYXRoLmFicyhlICsgMzYwIC0gaSkgPCBvICYmIChlICs9IDM2MCksIGU7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fbm9ybWFsaXplQ2VudGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgICAgICBpZiAoZS5yZW5kZXJXb3JsZENvcGllcyAmJiAhZS5sbmdSYW5nZSkge1xuICAgICAgICAgIHZhciBpID0gdC5sbmcgLSBlLmNlbnRlci5sbmc7XG4gICAgICAgICAgdC5sbmcgKz0gaSA+IDE4MCA/IC0zNjAgOiBpIDwgLTE4MCA/IDM2MCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0sIGk7XG4gICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgICB5ciA9IGZ1bmN0aW9uIHlyKGUpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHt9KSwgdGhpcy5vcHRpb25zID0gZSwgdC5iaW5kQWxsKFtcIl90b2dnbGVBdHRyaWJ1dGlvblwiLCBcIl91cGRhdGVFZGl0TGlua1wiLCBcIl91cGRhdGVEYXRhXCIsIFwiX3VwZGF0ZUNvbXBhY3RcIl0sIHRoaXMpO1xuICAgIH07XG5cbiAgICB5ci5wcm90b3R5cGUuZ2V0RGVmYXVsdFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiYm90dG9tLXJpZ2h0XCI7XG4gICAgfSwgeXIucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5jb21wYWN0O1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IHQsIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1hdHRyaWJcIiksIHRoaXMuX2NvbXBhY3RCdXR0b24gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1hdHRyaWItYnV0dG9uXCIsIHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX2NvbXBhY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3RvZ2dsZUF0dHJpYnV0aW9uKSwgdGhpcy5fY29tcGFjdEJ1dHRvbi50eXBlID0gXCJidXR0b25cIiwgdGhpcy5fc2V0RWxlbWVudFRpdGxlKHRoaXMuX2NvbXBhY3RCdXR0b24sIFwiVG9nZ2xlQXR0cmlidXRpb25cIiksIHRoaXMuX2lubmVyQ29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWN0cmwtYXR0cmliLWlubmVyXCIsIHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX2lubmVyQ29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0XCIpLCBlICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jb21wYWN0XCIpLCB0aGlzLl91cGRhdGVBdHRyaWJ1dGlvbnMoKSwgdGhpcy5fdXBkYXRlRWRpdExpbmsoKSwgdGhpcy5fbWFwLm9uKFwic3R5bGVkYXRhXCIsIHRoaXMuX3VwZGF0ZURhdGEpLCB0aGlzLl9tYXAub24oXCJzb3VyY2VkYXRhXCIsIHRoaXMuX3VwZGF0ZURhdGEpLCB0aGlzLl9tYXAub24oXCJtb3ZlZW5kXCIsIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKSwgdm9pZCAwID09PSBlICYmICh0aGlzLl9tYXAub24oXCJyZXNpemVcIiwgdGhpcy5fdXBkYXRlQ29tcGFjdCksIHRoaXMuX3VwZGF0ZUNvbXBhY3QoKSksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LCB5ci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwic3R5bGVkYXRhXCIsIHRoaXMuX3VwZGF0ZURhdGEpLCB0aGlzLl9tYXAub2ZmKFwic291cmNlZGF0YVwiLCB0aGlzLl91cGRhdGVEYXRhKSwgdGhpcy5fbWFwLm9mZihcIm1vdmVlbmRcIiwgdGhpcy5fdXBkYXRlRWRpdExpbmspLCB0aGlzLl9tYXAub2ZmKFwicmVzaXplXCIsIHRoaXMuX3VwZGF0ZUNvbXBhY3QpLCB0aGlzLl9tYXAgPSB2b2lkIDAsIHRoaXMuX2F0dHJpYkhUTUwgPSB2b2lkIDA7XG4gICAgfSwgeXIucHJvdG90eXBlLl9zZXRFbGVtZW50VGl0bGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiQXR0cmlidXRpb25Db250cm9sLlwiICsgZSk7XG5cbiAgICAgIHQudGl0bGUgPSBpLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgaSk7XG4gICAgfSwgeXIucHJvdG90eXBlLl90b2dnbGVBdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJtYXBsaWJyZWdsLWNvbXBhY3Qtc2hvd1wiKSA/ICh0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY29tcGFjdC1zaG93XCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpKSA6ICh0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY29tcGFjdC1zaG93XCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIikpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5fdXBkYXRlRWRpdExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2VkaXRMaW5rO1xuICAgICAgZSB8fCAoZSA9IHRoaXMuX2VkaXRMaW5rID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIubWFwYm94LWltcHJvdmUtbWFwXCIpKTtcbiAgICAgIHZhciBpID0gW3tcbiAgICAgICAga2V5OiBcIm93bmVyXCIsXG4gICAgICAgIHZhbHVlOiB0aGlzLnN0eWxlT3duZXJcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlkXCIsXG4gICAgICAgIHZhbHVlOiB0aGlzLnN0eWxlSWRcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFjY2Vzc190b2tlblwiLFxuICAgICAgICB2YWx1ZTogdGhpcy5fbWFwLl9yZXF1ZXN0TWFuYWdlci5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgdC5jb25maWcuQUNDRVNTX1RPS0VOXG4gICAgICB9XTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIG8gPSBpLnJlZHVjZShmdW5jdGlvbiAodCwgZSwgbykge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlICYmICh0ICs9IGUua2V5ICsgXCI9XCIgKyBlLnZhbHVlICsgKG8gPCBpLmxlbmd0aCAtIDEgPyBcIiZcIiA6IFwiXCIpKSwgdDtcbiAgICAgICAgfSwgXCI/XCIpO1xuICAgICAgICBlLmhyZWYgPSB0LmNvbmZpZy5GRUVEQkFDS19VUkwgKyBcIi9cIiArIG8gKyAodGhpcy5fbWFwLl9oYXNoID8gdGhpcy5fbWFwLl9oYXNoLmdldEhhc2hTdHJpbmcoITApIDogXCJcIiksIGUucmVsID0gXCJub29wZW5lciBub2ZvbGxvd1wiLCB0aGlzLl9zZXRFbGVtZW50VGl0bGUoZSwgXCJNYXBGZWVkYmFja1wiKTtcbiAgICAgIH1cbiAgICB9LCB5ci5wcm90b3R5cGUuX3VwZGF0ZURhdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgIXQgfHwgXCJtZXRhZGF0YVwiICE9PSB0LnNvdXJjZURhdGFUeXBlICYmIFwidmlzaWJpbGl0eVwiICE9PSB0LnNvdXJjZURhdGFUeXBlICYmIFwic3R5bGVcIiAhPT0gdC5kYXRhVHlwZSB8fCAodGhpcy5fdXBkYXRlQXR0cmlidXRpb25zKCksIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKCkpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5fdXBkYXRlQXR0cmlidXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX21hcC5zdHlsZSkge1xuICAgICAgICB2YXIgdCA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VzdG9tQXR0cmlidXRpb24gJiYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmN1c3RvbUF0dHJpYnV0aW9uKSA/IHQgPSB0LmNvbmNhdCh0aGlzLm9wdGlvbnMuY3VzdG9tQXR0cmlidXRpb24ubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgPyBcIlwiIDogdDtcbiAgICAgICAgfSkpIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmN1c3RvbUF0dHJpYnV0aW9uICYmIHQucHVzaCh0aGlzLm9wdGlvbnMuY3VzdG9tQXR0cmlidXRpb24pKSwgdGhpcy5fbWFwLnN0eWxlLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuX21hcC5zdHlsZS5zdHlsZXNoZWV0O1xuICAgICAgICAgIHRoaXMuc3R5bGVPd25lciA9IGUub3duZXIsIHRoaXMuc3R5bGVJZCA9IGUuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IHRoaXMuX21hcC5zdHlsZS5zb3VyY2VDYWNoZXM7XG5cbiAgICAgICAgZm9yICh2YXIgbyBpbiBpKSB7XG4gICAgICAgICAgdmFyIHIgPSBpW29dO1xuXG4gICAgICAgICAgaWYgKHIudXNlZCkge1xuICAgICAgICAgICAgdmFyIGEgPSByLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgYS5hdHRyaWJ1dGlvbiAmJiB0LmluZGV4T2YoYS5hdHRyaWJ1dGlvbikgPCAwICYmIHQucHVzaChhLmF0dHJpYnV0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0LnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdC5sZW5ndGggLSBlLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuID0gKHQgPSB0LmZpbHRlcihmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGZvciAodmFyIG8gPSBpICsgMTsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgIGlmICh0W29dLmluZGV4T2YoZSkgPj0gMCkgcmV0dXJuICExO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSkpLmpvaW4oXCIgfCBcIik7XG4gICAgICAgIG4gIT09IHRoaXMuX2F0dHJpYkhUTUwgJiYgKHRoaXMuX2F0dHJpYkhUTUwgPSBuLCB0Lmxlbmd0aCA/ICh0aGlzLl9pbm5lckNvbnRhaW5lci5pbm5lckhUTUwgPSBuLCB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtYXR0cmliLWVtcHR5XCIpKSA6IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1hdHRyaWItZW1wdHlcIiksIHRoaXMuX2VkaXRMaW5rID0gbnVsbCk7XG4gICAgICB9XG4gICAgfSwgeXIucHJvdG90eXBlLl91cGRhdGVDb21wYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbWFwLmdldENhbnZhc0NvbnRhaW5lcigpLm9mZnNldFdpZHRoIDw9IDY0MCA/IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jb21wYWN0XCIpIDogdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWNvbXBhY3RcIiwgXCJtYXBsaWJyZWdsLWNvbXBhY3Qtc2hvd1wiKTtcbiAgICB9O1xuXG4gICAgdmFyIHhyID0gZnVuY3Rpb24geHIoKSB7XG4gICAgICB0LmJpbmRBbGwoW1wiX3VwZGF0ZUxvZ29cIl0sIHRoaXMpLCB0LmJpbmRBbGwoW1wiX3VwZGF0ZUNvbXBhY3RcIl0sIHRoaXMpO1xuICAgIH07XG5cbiAgICB4ci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwID0gdCwgdGhpcy5fY29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWN0cmxcIik7XG4gICAgICB2YXIgZSA9IGkuY3JlYXRlKFwiYVwiLCBcIm1hcGxpYnJlZ2wtY3RybC1sb2dvXCIpO1xuICAgICAgcmV0dXJuIGUudGFyZ2V0ID0gXCJfYmxhbmtcIiwgZS5yZWwgPSBcIm5vb3BlbmVyIG5vZm9sbG93XCIsIGUuaHJlZiA9IFwiaHR0cHM6Ly9tYXBsaWJyZS5vcmcvXCIsIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiTG9nb0NvbnRyb2wuVGl0bGVcIikpLCBlLnNldEF0dHJpYnV0ZShcInJlbFwiLCBcIm5vb3BlbmVyIG5vZm9sbG93XCIpLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHRoaXMuX21hcC5vbihcInNvdXJjZWRhdGFcIiwgdGhpcy5fdXBkYXRlTG9nbyksIHRoaXMuX3VwZGF0ZUxvZ28oKSwgdGhpcy5fbWFwLm9uKFwicmVzaXplXCIsIHRoaXMuX3VwZGF0ZUNvbXBhY3QpLCB0aGlzLl91cGRhdGVDb21wYWN0KCksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LCB4ci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwic291cmNlZGF0YVwiLCB0aGlzLl91cGRhdGVMb2dvKSwgdGhpcy5fbWFwLm9mZihcInJlc2l6ZVwiLCB0aGlzLl91cGRhdGVDb21wYWN0KTtcbiAgICB9LCB4ci5wcm90b3R5cGUuZ2V0RGVmYXVsdFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiYm90dG9tLWxlZnRcIjtcbiAgICB9LCB4ci5wcm90b3R5cGUuX3VwZGF0ZUxvZ28gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCAmJiBcIm1ldGFkYXRhXCIgIT09IHQuc291cmNlRGF0YVR5cGUgfHwgKHRoaXMuX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gdGhpcy5fbG9nb1JlcXVpcmVkKCkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIik7XG4gICAgfSwgeHIucHJvdG90eXBlLl9sb2dvUmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fbWFwLnN0eWxlKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5fbWFwLnN0eWxlLnNvdXJjZUNhY2hlcztcblxuICAgICAgICBmb3IgKHZhciBlIGluIHQpIHtcbiAgICAgICAgICBpZiAodFtlXS5nZXRTb3VyY2UoKS5tYXBib3hfbG9nbykgcmV0dXJuICEwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sIHhyLnByb3RvdHlwZS5fdXBkYXRlQ29tcGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY29udGFpbmVyLmNoaWxkcmVuO1xuXG4gICAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGUgPSB0WzBdO1xuICAgICAgICB0aGlzLl9tYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCkub2Zmc2V0V2lkdGggPCAyNTAgPyBlLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWNvbXBhY3RcIikgOiBlLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWNvbXBhY3RcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBiciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgdGhpcy5fcXVldWUgPSBbXSwgdGhpcy5faWQgPSAwLCB0aGlzLl9jbGVhcmVkID0gITEsIHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcgPSAhMTtcbiAgICB9O1xuXG4gICAgYnIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICsrdGhpcy5faWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICAgIGNhbGxiYWNrOiB0LFxuICAgICAgICBpZDogZSxcbiAgICAgICAgY2FuY2VsbGVkOiAhMVxuICAgICAgfSksIGU7XG4gICAgfSwgYnIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5fY3VycmVudGx5UnVubmluZywgaSA9IDAsIG8gPSBlID8gdGhpcy5fcXVldWUuY29uY2F0KGUpIDogdGhpcy5fcXVldWU7IGkgPCBvLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByID0gb1tpXTtcbiAgICAgICAgaWYgKHIuaWQgPT09IHQpIHJldHVybiB2b2lkIChyLmNhbmNlbGxlZCA9ICEwKTtcbiAgICAgIH1cbiAgICB9LCBici5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IDApO1xuICAgICAgdmFyIGUgPSB0aGlzLl9jdXJyZW50bHlSdW5uaW5nID0gdGhpcy5fcXVldWU7XG4gICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbyA9IGU7IGkgPCBvLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByID0gb1tpXTtcbiAgICAgICAgaWYgKCFyLmNhbmNlbGxlZCAmJiAoci5jYWxsYmFjayh0KSwgdGhpcy5fY2xlYXJlZCkpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhcmVkID0gITEsIHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcgPSAhMTtcbiAgICB9LCBici5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50bHlSdW5uaW5nICYmICh0aGlzLl9jbGVhcmVkID0gITApLCB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH07XG5cbiAgICB2YXIgd3IgPSB7XG4gICAgICBcIkF0dHJpYnV0aW9uQ29udHJvbC5Ub2dnbGVBdHRyaWJ1dGlvblwiOiBcIlRvZ2dsZSBhdHRyaWJ1dGlvblwiLFxuICAgICAgXCJBdHRyaWJ1dGlvbkNvbnRyb2wuTWFwRmVlZGJhY2tcIjogXCJNYXAgZmVlZGJhY2tcIixcbiAgICAgIFwiRnVsbHNjcmVlbkNvbnRyb2wuRW50ZXJcIjogXCJFbnRlciBmdWxsc2NyZWVuXCIsXG4gICAgICBcIkZ1bGxzY3JlZW5Db250cm9sLkV4aXRcIjogXCJFeGl0IGZ1bGxzY3JlZW5cIixcbiAgICAgIFwiR2VvbG9jYXRlQ29udHJvbC5GaW5kTXlMb2NhdGlvblwiOiBcIkZpbmQgbXkgbG9jYXRpb25cIixcbiAgICAgIFwiR2VvbG9jYXRlQ29udHJvbC5Mb2NhdGlvbk5vdEF2YWlsYWJsZVwiOiBcIkxvY2F0aW9uIG5vdCBhdmFpbGFibGVcIixcbiAgICAgIFwiTG9nb0NvbnRyb2wuVGl0bGVcIjogXCJNYXBib3ggbG9nb1wiLFxuICAgICAgXCJOYXZpZ2F0aW9uQ29udHJvbC5SZXNldEJlYXJpbmdcIjogXCJSZXNldCBiZWFyaW5nIHRvIG5vcnRoXCIsXG4gICAgICBcIk5hdmlnYXRpb25Db250cm9sLlpvb21JblwiOiBcIlpvb20gaW5cIixcbiAgICAgIFwiTmF2aWdhdGlvbkNvbnRyb2wuWm9vbU91dFwiOiBcIlpvb20gb3V0XCIsXG4gICAgICBcIlNjYWxlQ29udHJvbC5GZWV0XCI6IFwiZnRcIixcbiAgICAgIFwiU2NhbGVDb250cm9sLk1ldGVyc1wiOiBcIm1cIixcbiAgICAgIFwiU2NhbGVDb250cm9sLktpbG9tZXRlcnNcIjogXCJrbVwiLFxuICAgICAgXCJTY2FsZUNvbnRyb2wuTWlsZXNcIjogXCJtaVwiLFxuICAgICAgXCJTY2FsZUNvbnRyb2wuTmF1dGljYWxNaWxlc1wiOiBcIm5tXCJcbiAgICB9LFxuICAgICAgICBUciA9IHQud2luZG93LkhUTUxJbWFnZUVsZW1lbnQsXG4gICAgICAgIEVyID0gdC53aW5kb3cuSFRNTEVsZW1lbnQsXG4gICAgICAgIElyID0gdC53aW5kb3cuSW1hZ2VCaXRtYXAsXG4gICAgICAgIFByID0ge1xuICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICB6b29tOiAwLFxuICAgICAgYmVhcmluZzogMCxcbiAgICAgIHBpdGNoOiAwLFxuICAgICAgbWluWm9vbTogLTIsXG4gICAgICBtYXhab29tOiAyMixcbiAgICAgIG1pblBpdGNoOiAwLFxuICAgICAgbWF4UGl0Y2g6IDYwLFxuICAgICAgaW50ZXJhY3RpdmU6ICEwLFxuICAgICAgc2Nyb2xsWm9vbTogITAsXG4gICAgICBib3hab29tOiAhMCxcbiAgICAgIGRyYWdSb3RhdGU6ICEwLFxuICAgICAgZHJhZ1BhbjogITAsXG4gICAgICBrZXlib2FyZDogITAsXG4gICAgICBkb3VibGVDbGlja1pvb206ICEwLFxuICAgICAgdG91Y2hab29tUm90YXRlOiAhMCxcbiAgICAgIHRvdWNoUGl0Y2g6ICEwLFxuICAgICAgYmVhcmluZ1NuYXA6IDcsXG4gICAgICBjbGlja1RvbGVyYW5jZTogMyxcbiAgICAgIHBpdGNoV2l0aFJvdGF0ZTogITAsXG4gICAgICBoYXNoOiAhMSxcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogITAsXG4gICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiAhMSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogITEsXG4gICAgICB0cmFja1Jlc2l6ZTogITAsXG4gICAgICByZW5kZXJXb3JsZENvcGllczogITAsXG4gICAgICByZWZyZXNoRXhwaXJlZFRpbGVzOiAhMCxcbiAgICAgIG1heFRpbGVDYWNoZVNpemU6IG51bGwsXG4gICAgICBsb2NhbElkZW9ncmFwaEZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiLFxuICAgICAgdHJhbnNmb3JtUmVxdWVzdDogbnVsbCxcbiAgICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgICAgZmFkZUR1cmF0aW9uOiAzMDAsXG4gICAgICBjcm9zc1NvdXJjZUNvbGxpc2lvbnM6ICEwXG4gICAgfSxcbiAgICAgICAgU3IgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgaWYgKG51bGwgIT0gKGUgPSB0LmV4dGVuZCh7fSwgUHIsIGUpKS5taW5ab29tICYmIG51bGwgIT0gZS5tYXhab29tICYmIGUubWluWm9vbSA+IGUubWF4Wm9vbSkgdGhyb3cgbmV3IEVycm9yKFwibWF4Wm9vbSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBtaW5ab29tXCIpO1xuICAgICAgICBpZiAobnVsbCAhPSBlLm1pblBpdGNoICYmIG51bGwgIT0gZS5tYXhQaXRjaCAmJiBlLm1pblBpdGNoID4gZS5tYXhQaXRjaCkgdGhyb3cgbmV3IEVycm9yKFwibWF4UGl0Y2ggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluUGl0Y2hcIik7XG4gICAgICAgIGlmIChudWxsICE9IGUubWluUGl0Y2ggJiYgZS5taW5QaXRjaCA8IDApIHRocm93IG5ldyBFcnJvcihcIm1pblBpdGNoIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBcIik7XG4gICAgICAgIGlmIChudWxsICE9IGUubWF4UGl0Y2ggJiYgZS5tYXhQaXRjaCA+IDYwKSB0aHJvdyBuZXcgRXJyb3IoXCJtYXhQaXRjaCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2MFwiKTtcbiAgICAgICAgdmFyIHIgPSBuZXcgVG8oZS5taW5ab29tLCBlLm1heFpvb20sIGUubWluUGl0Y2gsIGUubWF4UGl0Y2gsIGUucmVuZGVyV29ybGRDb3BpZXMpO1xuXG4gICAgICAgIGlmIChvLmNhbGwodGhpcywgciwgZSksIHRoaXMuX2ludGVyYWN0aXZlID0gZS5pbnRlcmFjdGl2ZSwgdGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSA9IGUubWF4VGlsZUNhY2hlU2l6ZSwgdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IGUuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCwgdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsIHRoaXMuX2FudGlhbGlhcyA9IGUuYW50aWFsaWFzLCB0aGlzLl90cmFja1Jlc2l6ZSA9IGUudHJhY2tSZXNpemUsIHRoaXMuX2JlYXJpbmdTbmFwID0gZS5iZWFyaW5nU25hcCwgdGhpcy5fcmVmcmVzaEV4cGlyZWRUaWxlcyA9IGUucmVmcmVzaEV4cGlyZWRUaWxlcywgdGhpcy5fZmFkZUR1cmF0aW9uID0gZS5mYWRlRHVyYXRpb24sIHRoaXMuX2Nyb3NzU291cmNlQ29sbGlzaW9ucyA9IGUuY3Jvc3NTb3VyY2VDb2xsaXNpb25zLCB0aGlzLl9jcm9zc0ZhZGluZ0ZhY3RvciA9IDEsIHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyA9IGUuY29sbGVjdFJlc291cmNlVGltaW5nLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUgPSBuZXcgYnIoKSwgdGhpcy5fY29udHJvbHMgPSBbXSwgdGhpcy5fbWFwSWQgPSB0LnVuaXF1ZUlkKCksIHRoaXMuX2xvY2FsZSA9IHQuZXh0ZW5kKHt9LCB3ciwgZS5sb2NhbGUpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IGUuY2xpY2tUb2xlcmFuY2UsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gbmV3IHQuUmVxdWVzdE1hbmFnZXIoZS50cmFuc2Zvcm1SZXF1ZXN0LCBlLmFjY2Vzc1Rva2VuKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jb250YWluZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyID0gdC53aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS5jb250YWluZXIpLCAhdGhpcy5fY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgJ1wiICsgZS5jb250YWluZXIgKyBcIicgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIShlLmNvbnRhaW5lciBpbnN0YW5jZW9mIEVyKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlOiAnY29udGFpbmVyJyBtdXN0IGJlIGEgU3RyaW5nIG9yIEhUTUxFbGVtZW50LlwiKTtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBlLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLm1heEJvdW5kcyAmJiB0aGlzLnNldE1heEJvdW5kcyhlLm1heEJvdW5kcyksIHQuYmluZEFsbChbXCJfb25XaW5kb3dPbmxpbmVcIiwgXCJfb25XaW5kb3dSZXNpemVcIiwgXCJfb25NYXBTY3JvbGxcIiwgXCJfY29udGV4dExvc3RcIiwgXCJfY29udGV4dFJlc3RvcmVkXCJdLCB0aGlzKSwgdGhpcy5fc2V0dXBDb250YWluZXIoKSwgdGhpcy5fc2V0dXBQYWludGVyKCksIHZvaWQgMCA9PT0gdGhpcy5wYWludGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTC5cIik7XG4gICAgICAgIHRoaXMub24oXCJtb3ZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCExKTtcbiAgICAgICAgfSksIHRoaXMub24oXCJtb3ZlZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCExKTtcbiAgICAgICAgfSksIHRoaXMub24oXCJ6b29tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSksIHZvaWQgMCAhPT0gdC53aW5kb3cgJiYgKHQud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgdGhpcy5fb25XaW5kb3dPbmxpbmUsICExKSwgdC53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgITEpLCB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUsICExKSksIHRoaXMuaGFuZGxlcnMgPSBuZXcgZ3IodGhpcywgZSksIHRoaXMuX2hhc2ggPSBlLmhhc2ggJiYgbmV3IElvKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuaGFzaCAmJiBlLmhhc2ggfHwgdm9pZCAwKS5hZGRUbyh0aGlzKSwgdGhpcy5faGFzaCAmJiB0aGlzLl9oYXNoLl9vbkhhc2hDaGFuZ2UoKSB8fCAodGhpcy5qdW1wVG8oe1xuICAgICAgICAgIGNlbnRlcjogZS5jZW50ZXIsXG4gICAgICAgICAgem9vbTogZS56b29tLFxuICAgICAgICAgIGJlYXJpbmc6IGUuYmVhcmluZyxcbiAgICAgICAgICBwaXRjaDogZS5waXRjaFxuICAgICAgICB9KSwgZS5ib3VuZHMgJiYgKHRoaXMucmVzaXplKCksIHRoaXMuZml0Qm91bmRzKGUuYm91bmRzLCB0LmV4dGVuZCh7fSwgZS5maXRCb3VuZHNPcHRpb25zLCB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSkpKSksIHRoaXMucmVzaXplKCksIHRoaXMuX2xvY2FsSWRlb2dyYXBoRm9udEZhbWlseSA9IGUubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5LCBlLnN0eWxlICYmIHRoaXMuc2V0U3R5bGUoZS5zdHlsZSwge1xuICAgICAgICAgIGxvY2FsSWRlb2dyYXBoRm9udEZhbWlseTogZS5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHlcbiAgICAgICAgfSksIGUuYXR0cmlidXRpb25Db250cm9sICYmIHRoaXMuYWRkQ29udHJvbChuZXcgeXIoe1xuICAgICAgICAgIGN1c3RvbUF0dHJpYnV0aW9uOiBlLmN1c3RvbUF0dHJpYnV0aW9uXG4gICAgICAgIH0pKSwgdGhpcy5hZGRDb250cm9sKG5ldyB4cigpLCBlLmxvZ29Qb3NpdGlvbiksIHRoaXMub24oXCJzdHlsZS5sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpLnRyYW5zZm9ybS51bm1vZGlmaWVkICYmIGkuanVtcFRvKGkuc3R5bGUuc3R5bGVzaGVldCk7XG4gICAgICAgIH0pLCB0aGlzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGkuX3VwZGF0ZShcInN0eWxlXCIgPT09IGUuZGF0YVR5cGUpLCBpLmZpcmUobmV3IHQuRXZlbnQoZS5kYXRhVHlwZSArIFwiZGF0YVwiLCBlKSk7XG4gICAgICAgIH0pLCB0aGlzLm9uKFwiZGF0YWxvYWRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpLmZpcmUobmV3IHQuRXZlbnQoZS5kYXRhVHlwZSArIFwiZGF0YWxvYWRpbmdcIiwgZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbyAmJiAoci5fX3Byb3RvX18gPSBvKSwgKHIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvICYmIG8ucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSByO1xuICAgICAgdmFyIGEgPSB7XG4gICAgICAgIHNob3dUaWxlQm91bmRhcmllczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd1BhZGRpbmc6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd092ZXJkcmF3SW5zcGVjdG9yOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICByZXBhaW50OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLnByb3RvdHlwZS5fZ2V0TWFwSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBJZDtcbiAgICAgIH0sIHIucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBpICYmIChpID0gZS5nZXREZWZhdWx0UG9zaXRpb24gPyBlLmdldERlZmF1bHRQb3NpdGlvbigpIDogXCJ0b3AtcmlnaHRcIiksICFlIHx8ICFlLm9uQWRkKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCB0byBtYXAuYWRkQ29udHJvbCgpLiBBcmd1bWVudCBtdXN0IGJlIGEgY29udHJvbCB3aXRoIG9uQWRkIGFuZCBvblJlbW92ZSBtZXRob2RzLlwiKSkpO1xuICAgICAgICB2YXIgbyA9IGUub25BZGQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fY29udHJvbHMucHVzaChlKTtcblxuICAgICAgICB2YXIgciA9IHRoaXMuX2NvbnRyb2xQb3NpdGlvbnNbaV07XG4gICAgICAgIHJldHVybiAtMSAhPT0gaS5pbmRleE9mKFwiYm90dG9tXCIpID8gci5pbnNlcnRCZWZvcmUobywgci5maXJzdENoaWxkKSA6IHIuYXBwZW5kQ2hpbGQobyksIHRoaXM7XG4gICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlIHx8ICFlLm9uUmVtb3ZlKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCB0byBtYXAucmVtb3ZlQ29udHJvbCgpLiBBcmd1bWVudCBtdXN0IGJlIGEgY29udHJvbCB3aXRoIG9uQWRkIGFuZCBvblJlbW92ZSBtZXRob2RzLlwiKSkpO1xuXG4gICAgICAgIHZhciBpID0gdGhpcy5fY29udHJvbHMuaW5kZXhPZihlKTtcblxuICAgICAgICByZXR1cm4gaSA+IC0xICYmIHRoaXMuX2NvbnRyb2xzLnNwbGljZShpLCAxKSwgZS5vblJlbW92ZSh0aGlzKSwgdGhpcztcbiAgICAgIH0sIHIucHJvdG90eXBlLmhhc0NvbnRyb2wgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udHJvbHMuaW5kZXhPZih0KSA+IC0xO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9jb250YWluZXJEaW1lbnNpb25zKCksXG4gICAgICAgICAgICBvID0gaVswXSxcbiAgICAgICAgICAgIHIgPSBpWzFdO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6ZUNhbnZhcyhvLCByKSwgdGhpcy50cmFuc2Zvcm0ucmVzaXplKG8sIHIpLCB0aGlzLnBhaW50ZXIucmVzaXplKG8sIHIpO1xuICAgICAgICB2YXIgYSA9ICF0aGlzLl9tb3Zpbmc7XG4gICAgICAgIHJldHVybiBhICYmICh0aGlzLnN0b3AoKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZXN0YXJ0XCIsIGUpKS5maXJlKG5ldyB0LkV2ZW50KFwibW92ZVwiLCBlKSkpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyZXNpemVcIiwgZSkpLCBhICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm1vdmVlbmRcIiwgZSkpLCB0aGlzO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uZ2V0Qm91bmRzKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRNYXhCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5nZXRNYXhCb3VuZHMoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnNldE1heEJvdW5kcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5zZXRNYXhCb3VuZHModC5MbmdMYXRCb3VuZHMuY29udmVydChlKSksIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0TWluWm9vbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICgodCA9IG51bGwgPT0gdCA/IC0yIDogdCkgPj0gLTIgJiYgdCA8PSB0aGlzLnRyYW5zZm9ybS5tYXhab29tKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluWm9vbSA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLmdldFpvb20oKSA8IHQgJiYgdGhpcy5zZXRab29tKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5ab29tIG11c3QgYmUgYmV0d2VlbiAtMiBhbmQgdGhlIGN1cnJlbnQgbWF4Wm9vbSwgaW5jbHVzaXZlXCIpO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0TWluWm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1pblpvb207XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRNYXhab29tID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCh0ID0gbnVsbCA9PSB0ID8gMjIgOiB0KSA+PSB0aGlzLnRyYW5zZm9ybS5taW5ab29tKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbSA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLmdldFpvb20oKSA+IHQgJiYgdGhpcy5zZXRab29tKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhab29tIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IG1pblpvb21cIik7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnNldE1pblBpdGNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCh0ID0gbnVsbCA9PSB0ID8gMCA6IHQpIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibWluUGl0Y2ggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMFwiKTtcbiAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IHRoaXMudHJhbnNmb3JtLm1heFBpdGNoKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluUGl0Y2ggPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcy5nZXRQaXRjaCgpIDwgdCAmJiB0aGlzLnNldFBpdGNoKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5QaXRjaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgdGhlIGN1cnJlbnQgbWF4UGl0Y2gsIGluY2x1c2l2ZVwiKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldE1pblBpdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluUGl0Y2g7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRNYXhQaXRjaCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICgodCA9IG51bGwgPT0gdCA/IDYwIDogdCkgPiA2MCkgdGhyb3cgbmV3IEVycm9yKFwibWF4UGl0Y2ggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNjBcIik7XG4gICAgICAgIGlmICh0ID49IHRoaXMudHJhbnNmb3JtLm1pblBpdGNoKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4UGl0Y2ggPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcy5nZXRQaXRjaCgpID4gdCAmJiB0aGlzLnNldFBpdGNoKHQpLCB0aGlzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhQaXRjaCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBtaW5QaXRjaFwiKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldE1heFBpdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWF4UGl0Y2g7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRSZW5kZXJXb3JsZENvcGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlbmRlcldvcmxkQ29waWVzO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0UmVuZGVyV29ybGRDb3BpZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVuZGVyV29ybGRDb3BpZXMgPSB0LCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludCh0LkxuZ0xhdC5jb252ZXJ0KGUpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnVucHJvamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHQuUG9pbnQuY29udmVydChlKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc01vdmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmluZyB8fCB0aGlzLmhhbmRsZXJzLmlzTW92aW5nKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc1pvb21pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96b29taW5nIHx8IHRoaXMuaGFuZGxlcnMuaXNab29taW5nKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc1JvdGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpbmcgfHwgdGhpcy5oYW5kbGVycy5pc1JvdGF0aW5nKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fY3JlYXRlRGVsZWdhdGVkTGlzdGVuZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB2YXIgbyxcbiAgICAgICAgICAgIHIgPSB0aGlzO1xuXG4gICAgICAgIGlmIChcIm1vdXNlZW50ZXJcIiA9PT0gdCB8fCBcIm1vdXNlb3ZlclwiID09PSB0KSB7XG4gICAgICAgICAgdmFyIGEgPSAhMTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5ZXI6IGUsXG4gICAgICAgICAgICBsaXN0ZW5lcjogaSxcbiAgICAgICAgICAgIGRlbGVnYXRlczoge1xuICAgICAgICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIG1vdXNlbW92ZShvKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSByLmdldExheWVyKGUpID8gci5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoby5wb2ludCwge1xuICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBbZV1cbiAgICAgICAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICAgICAgICAgIG4ubGVuZ3RoID8gYSB8fCAoYSA9ICEwLCBpLmNhbGwociwgbmV3IFJvKHQsIHIsIG8ub3JpZ2luYWxFdmVudCwge1xuICAgICAgICAgICAgICAgICAgZmVhdHVyZXM6IG5cbiAgICAgICAgICAgICAgICB9KSkpIDogYSA9ICExO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gbW91c2VvdXQoKSB7XG4gICAgICAgICAgICAgICAgYSA9ICExO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcIm1vdXNlbGVhdmVcIiA9PT0gdCB8fCBcIm1vdXNlb3V0XCIgPT09IHQpIHtcbiAgICAgICAgICB2YXIgbiA9ICExO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXllcjogZSxcbiAgICAgICAgICAgIGxpc3RlbmVyOiBpLFxuICAgICAgICAgICAgZGVsZWdhdGVzOiB7XG4gICAgICAgICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKG8pIHtcbiAgICAgICAgICAgICAgICAoci5nZXRMYXllcihlKSA/IHIucXVlcnlSZW5kZXJlZEZlYXR1cmVzKG8ucG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyczogW2VdXG4gICAgICAgICAgICAgICAgfSkgOiBbXSkubGVuZ3RoID8gbiA9ICEwIDogbiAmJiAobiA9ICExLCBpLmNhbGwociwgbmV3IFJvKHQsIHIsIG8ub3JpZ2luYWxFdmVudCkpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIG1vdXNlb3V0KGUpIHtcbiAgICAgICAgICAgICAgICBuICYmIChuID0gITEsIGkuY2FsbChyLCBuZXcgUm8odCwgciwgZS5vcmlnaW5hbEV2ZW50KSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF5ZXI6IGUsXG4gICAgICAgICAgbGlzdGVuZXI6IGksXG4gICAgICAgICAgZGVsZWdhdGVzOiAobyA9IHt9LCBvW3RdID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBvID0gci5nZXRMYXllcihlKSA/IHIucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHQucG9pbnQsIHtcbiAgICAgICAgICAgICAgbGF5ZXJzOiBbZV1cbiAgICAgICAgICAgIH0pIDogW107XG4gICAgICAgICAgICBvLmxlbmd0aCAmJiAodC5mZWF0dXJlcyA9IG8sIGkuY2FsbChyLCB0KSwgZGVsZXRlIHQuZmVhdHVyZXMpO1xuICAgICAgICAgIH0sIG8pXG4gICAgICAgIH07XG4gICAgICB9LCByLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGkpIHJldHVybiBvLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIHQsIGUpO1xuXG4gICAgICAgIHZhciByID0gdGhpcy5fY3JlYXRlRGVsZWdhdGVkTGlzdGVuZXIodCwgZSwgaSk7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnMgPSB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnMgfHwge30sIHRoaXMuX2RlbGVnYXRlZExpc3RlbmVyc1t0XSA9IHRoaXMuX2RlbGVnYXRlZExpc3RlbmVyc1t0XSB8fCBbXSwgdGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzW3RdLnB1c2gociksIHIuZGVsZWdhdGVzKSB7XG4gICAgICAgICAgdGhpcy5vbihhLCByLmRlbGVnYXRlc1thXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIHIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBpKSByZXR1cm4gby5wcm90b3R5cGUub25jZS5jYWxsKHRoaXMsIHQsIGUpO1xuXG4gICAgICAgIHZhciByID0gdGhpcy5fY3JlYXRlRGVsZWdhdGVkTGlzdGVuZXIodCwgZSwgaSk7XG5cbiAgICAgICAgZm9yICh2YXIgYSBpbiByLmRlbGVnYXRlcykge1xuICAgICAgICAgIHRoaXMub25jZShhLCByLmRlbGVnYXRlc1thXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIHIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSA/IG8ucHJvdG90eXBlLm9mZi5jYWxsKHRoaXMsIHQsIGUpIDogKHRoaXMuX2RlbGVnYXRlZExpc3RlbmVycyAmJiB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnNbdF0gJiYgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gb1t0XSwgbiA9IDA7IG4gPCBhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGFbbl07XG5cbiAgICAgICAgICAgIGlmIChzLmxheWVyID09PSBlICYmIHMubGlzdGVuZXIgPT09IGkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbCBpbiBzLmRlbGVnYXRlcykge1xuICAgICAgICAgICAgICAgIHIub2ZmKGwsIHMuZGVsZWdhdGVzW2xdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBhLnNwbGljZShuLCAxKSwgcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0odGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzKSwgdGhpcyk7XG4gICAgICB9LCByLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGkgfHwgdm9pZCAwID09PSBlIHx8IGUgaW5zdGFuY2VvZiB0LlBvaW50IHx8IEFycmF5LmlzQXJyYXkoZSkgfHwgKGkgPSBlLCBlID0gdm9pZCAwKSwgaSA9IGkgfHwge30sIChlID0gZSB8fCBbWzAsIDBdLCBbdGhpcy50cmFuc2Zvcm0ud2lkdGgsIHRoaXMudHJhbnNmb3JtLmhlaWdodF1dKSBpbnN0YW5jZW9mIHQuUG9pbnQgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgZVswXSkgbyA9IFt0LlBvaW50LmNvbnZlcnQoZSldO2Vsc2Uge1xuICAgICAgICAgIHZhciByID0gdC5Qb2ludC5jb252ZXJ0KGVbMF0pLFxuICAgICAgICAgICAgICBhID0gdC5Qb2ludC5jb252ZXJ0KGVbMV0pO1xuICAgICAgICAgIG8gPSBbciwgbmV3IHQuUG9pbnQoYS54LCByLnkpLCBhLCBuZXcgdC5Qb2ludChyLngsIGEueSksIHJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhvLCBpLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5xdWVyeVNvdXJjZUZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUucXVlcnlTb3VyY2VGZWF0dXJlcyh0LCBlKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgcmV0dXJuICExICE9PSAoaSA9IHQuZXh0ZW5kKHt9LCB7XG4gICAgICAgICAgbG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5OiB0aGlzLl9sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHlcbiAgICAgICAgfSwgaSkpLmRpZmYgJiYgaS5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPT09IHRoaXMuX2xvY2FsSWRlb2dyYXBoRm9udEZhbWlseSAmJiB0aGlzLnN0eWxlICYmIGUgPyAodGhpcy5fZGlmZlN0eWxlKGUsIGkpLCB0aGlzKSA6ICh0aGlzLl9sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPSBpLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSwgdGhpcy5fdXBkYXRlU3R5bGUoZSwgaSkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0VHJhbnNmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWFuYWdlci5zZXRUcmFuc2Zvcm1SZXF1ZXN0KHQpLCB0aGlzO1xuICAgICAgfSwgci5wcm90b3R5cGUuX2dldFVJU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9sb2NhbGVbdF07XG4gICAgICAgIGlmIChudWxsID09IGUpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgVUkgc3RyaW5nICdcIiArIHQgKyBcIidcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSwgci5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUgJiYgKHRoaXMuc3R5bGUuc2V0RXZlbnRlZFBhcmVudChudWxsKSwgdGhpcy5zdHlsZS5fcmVtb3ZlKCkpLCB0ID8gKHRoaXMuc3R5bGUgPSBuZXcgamUodGhpcywgZSB8fCB7fSksIHRoaXMuc3R5bGUuc2V0RXZlbnRlZFBhcmVudCh0aGlzLCB7XG4gICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVcbiAgICAgICAgfSksIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyB0aGlzLnN0eWxlLmxvYWRVUkwodCkgOiB0aGlzLnN0eWxlLmxvYWRKU09OKHQpLCB0aGlzKSA6IChkZWxldGUgdGhpcy5zdHlsZSwgdGhpcyk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fbGF6eUluaXRFbXB0eVN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0eWxlIHx8ICh0aGlzLnN0eWxlID0gbmV3IGplKHRoaXMsIHt9KSwgdGhpcy5zdHlsZS5zZXRFdmVudGVkUGFyZW50KHRoaXMsIHtcbiAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZVxuICAgICAgICB9KSwgdGhpcy5zdHlsZS5sb2FkRW1wdHkoKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fZGlmZlN0eWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci5ub3JtYWxpemVTdHlsZVVSTChlKSxcbiAgICAgICAgICAgICAgYSA9IHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QociwgdC5SZXNvdXJjZVR5cGUuU3R5bGUpO1xuXG4gICAgICAgICAgdC5nZXRKU09OKGEsIGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICBlID8gby5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpIDogciAmJiBvLl91cGRhdGVEaWZmKHIsIGkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiB0aGlzLl91cGRhdGVEaWZmKGUsIGkpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX3VwZGF0ZURpZmYgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0U3RhdGUoZSkgJiYgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgIHQud2Fybk9uY2UoXCJVbmFibGUgdG8gcGVyZm9ybSBzdHlsZSBkaWZmOiBcIiArIChvLm1lc3NhZ2UgfHwgby5lcnJvciB8fCBvKSArIFwiLiAgUmVidWlsZGluZyB0aGUgc3R5bGUgZnJvbSBzY3JhdGNoLlwiKSwgdGhpcy5fdXBkYXRlU3R5bGUoZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkgcmV0dXJuIHRoaXMuc3R5bGUuc2VyaWFsaXplKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5pc1N0eWxlTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA/IHRoaXMuc3R5bGUubG9hZGVkKCkgOiB0Lndhcm5PbmNlKFwiVGhlcmUgaXMgbm8gc3R5bGUgYWRkZWQgdG8gdGhlIG1hcC5cIik7XG4gICAgICB9LCByLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF6eUluaXRFbXB0eVN0eWxlKCksIHRoaXMuc3R5bGUuYWRkU291cmNlKHQsIGUpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuaXNTb3VyY2VMb2FkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5zb3VyY2VDYWNoZXNbZV07XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGkpIHJldHVybiBpLmxvYWRlZCgpO1xuICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCBJRCAnXCIgKyBlICsgXCInXCIpKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5hcmVUaWxlc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUuc291cmNlQ2FjaGVzO1xuXG4gICAgICAgIGZvciAodmFyIGUgaW4gdCkge1xuICAgICAgICAgIHZhciBpID0gdFtlXS5fdGlsZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBvIGluIGkpIHtcbiAgICAgICAgICAgIHZhciByID0gaVtvXTtcbiAgICAgICAgICAgIGlmIChcImxvYWRlZFwiICE9PSByLnN0YXRlICYmIFwiZXJyb3JlZFwiICE9PSByLnN0YXRlKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSwgci5wcm90b3R5cGUuYWRkU291cmNlVHlwZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5hZGRTb3VyY2VUeXBlKHQsIGUsIGkpO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlU291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUucmVtb3ZlU291cmNlKHQpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0U291cmNlKHQpO1xuICAgICAgfSwgci5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSk7XG4gICAgICAgIHZhciByID0gby5waXhlbFJhdGlvO1xuICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSAxKTtcbiAgICAgICAgdmFyIGEgPSBvLnNkZjtcbiAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gITEpO1xuICAgICAgICB2YXIgbiA9IG8uc3RyZXRjaFgsXG4gICAgICAgICAgICBzID0gby5zdHJldGNoWSxcbiAgICAgICAgICAgIGwgPSBvLmNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xhenlJbml0RW1wdHlTdHlsZSgpLCBpIGluc3RhbmNlb2YgVHIgfHwgSXIgJiYgaSBpbnN0YW5jZW9mIElyKSB7XG4gICAgICAgICAgdmFyIGMgPSB0LmJyb3dzZXIuZ2V0SW1hZ2VEYXRhKGkpO1xuICAgICAgICAgIHRoaXMuc3R5bGUuYWRkSW1hZ2UoZSwge1xuICAgICAgICAgICAgZGF0YTogbmV3IHQuUkdCQUltYWdlKHtcbiAgICAgICAgICAgICAgd2lkdGg6IGMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogYy5oZWlnaHRcbiAgICAgICAgICAgIH0sIGMuZGF0YSksXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiByLFxuICAgICAgICAgICAgc3RyZXRjaFg6IG4sXG4gICAgICAgICAgICBzdHJldGNoWTogcyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGwsXG4gICAgICAgICAgICBzZGY6IGEsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaS53aWR0aCB8fCB2b2lkIDAgPT09IGkuaGVpZ2h0KSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gbWFwLmFkZEltYWdlKCkuIFRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhbiBgSFRNTEltYWdlRWxlbWVudGAsIGBJbWFnZURhdGFgLCBgSW1hZ2VCaXRtYXBgLCBvciBvYmplY3Qgd2l0aCBgd2lkdGhgLCBgaGVpZ2h0YCwgYW5kIGBkYXRhYCBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgZm9ybWF0IGFzIGBJbWFnZURhdGFgXCIpKSk7XG4gICAgICAgICAgdmFyIHUgPSBpO1xuICAgICAgICAgIHRoaXMuc3R5bGUuYWRkSW1hZ2UoZSwge1xuICAgICAgICAgICAgZGF0YTogbmV3IHQuUkdCQUltYWdlKHtcbiAgICAgICAgICAgICAgd2lkdGg6IGkud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaS5oZWlnaHRcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGkuZGF0YSkpLFxuICAgICAgICAgICAgcGl4ZWxSYXRpbzogcixcbiAgICAgICAgICAgIHN0cmV0Y2hYOiBuLFxuICAgICAgICAgICAgc3RyZXRjaFk6IHMsXG4gICAgICAgICAgICBjb250ZW50OiBsLFxuICAgICAgICAgICAgc2RmOiBhLFxuICAgICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgICAgIHVzZXJJbWFnZTogdVxuICAgICAgICAgIH0pLCB1Lm9uQWRkICYmIHUub25BZGQodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHIucHJvdG90eXBlLnVwZGF0ZUltYWdlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLnN0eWxlLmdldEltYWdlKGUpO1xuICAgICAgICBpZiAoIW8pIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbWFwIGhhcyBubyBpbWFnZSB3aXRoIHRoYXQgaWQuIElmIHlvdSBhcmUgYWRkaW5nIGEgbmV3IGltYWdlIHVzZSBgbWFwLmFkZEltYWdlKC4uLilgIGluc3RlYWQuXCIpKSk7XG4gICAgICAgIHZhciByID0gaSBpbnN0YW5jZW9mIFRyIHx8IElyICYmIGkgaW5zdGFuY2VvZiBJciA/IHQuYnJvd3Nlci5nZXRJbWFnZURhdGEoaSkgOiBpLFxuICAgICAgICAgICAgYSA9IHIud2lkdGgsXG4gICAgICAgICAgICBuID0gci5oZWlnaHQsXG4gICAgICAgICAgICBzID0gci5kYXRhO1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhIHx8IHZvaWQgMCA9PT0gbiA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIG1hcC51cGRhdGVJbWFnZSgpLiBUaGUgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYW4gYEhUTUxJbWFnZUVsZW1lbnRgLCBgSW1hZ2VEYXRhYCwgYEltYWdlQml0bWFwYCwgb3Igb2JqZWN0IHdpdGggYHdpZHRoYCwgYGhlaWdodGAsIGFuZCBgZGF0YWAgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIGZvcm1hdCBhcyBgSW1hZ2VEYXRhYFwiKSkpIDogYSAhPT0gby5kYXRhLndpZHRoIHx8IG4gIT09IG8uZGF0YS5oZWlnaHQgPyB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdXBkYXRlZCBpbWFnZSBtdXN0IGJlIHRoYXQgc2FtZSBhcyB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgaW1hZ2VcIikpKSA6IChvLmRhdGEucmVwbGFjZShzLCAhKGkgaW5zdGFuY2VvZiBUciB8fCBJciAmJiBpIGluc3RhbmNlb2YgSXIpKSwgdm9pZCB0aGlzLnN0eWxlLnVwZGF0ZUltYWdlKGUsIG8pKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmhhc0ltYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgPyAhIXRoaXMuc3R5bGUuZ2V0SW1hZ2UoZSkgOiAodGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBpbWFnZSBpZFwiKSkpLCAhMSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlSW1hZ2UodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB0LmdldEltYWdlKHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QoZSwgdC5SZXNvdXJjZVR5cGUuSW1hZ2UpLCBpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmxpc3RJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmxpc3RJbWFnZXMoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhenlJbml0RW1wdHlTdHlsZSgpLCB0aGlzLnN0eWxlLmFkZExheWVyKHQsIGUpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUubW92ZUxheWVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUubW92ZUxheWVyKHQsIGUpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5yZW1vdmVMYXllcih0KSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5ZXIodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRMYXllclpvb21SYW5nZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldExheWVyWm9vbVJhbmdlKHQsIGUsIGkpLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5zdHlsZS5zZXRGaWx0ZXIodCwgZSwgaSksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRGaWx0ZXIodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRQYWludFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5zdHlsZS5zZXRQYWludFByb3BlcnR5KHQsIGUsIGksIG8pLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgfSwgci5wcm90b3R5cGUuZ2V0UGFpbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldFBhaW50UHJvcGVydHkodCwgZSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5zZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHRoaXMuc3R5bGUuc2V0TGF5b3V0UHJvcGVydHkodCwgZSwgaSwgbyksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldExheW91dFByb3BlcnR5KHQsIGUpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0TGlnaHQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0ge30pLCB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5zZXRMaWdodCh0LCBlKSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLmdldExpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRMaWdodCgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0RmVhdHVyZVN0YXRlKHQsIGUpLCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnJlbW92ZUZlYXR1cmVTdGF0ZSh0LCBlKSwgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRGZWF0dXJlU3RhdGUodCk7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDYW52YXNDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNDb250YWluZXI7XG4gICAgICB9LCByLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgICB9LCByLnByb3RvdHlwZS5fY29udGFpbmVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSAwLFxuICAgICAgICAgICAgZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIgJiYgKHQgPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgNDAwLCBlID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAzMDApLCBbdCwgZV07XG4gICAgICB9LCByLnByb3RvdHlwZS5fc2V0dXBDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB0LmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLW1hcFwiKTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9jYW52YXNDb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGJveGdsLWNhbnZhcy1jb250YWluZXJcIiwgdCk7XG4gICAgICAgIHRoaXMuX2ludGVyYWN0aXZlICYmIGUuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtaW50ZXJhY3RpdmVcIiksIHRoaXMuX2NhbnZhcyA9IGkuY3JlYXRlKFwiY2FudmFzXCIsIFwibWFwbGlicmVnbC1jYW52YXNcIiwgZSksIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLl9jb250ZXh0TG9zdCwgITEpLCB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuX2NvbnRleHRSZXN0b3JlZCwgITEpLCB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpLCB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk1hcFwiKSwgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJyZWdpb25cIik7XG5cbiAgICAgICAgdmFyIG8gPSB0aGlzLl9jb250YWluZXJEaW1lbnNpb25zKCk7XG5cbiAgICAgICAgdGhpcy5fcmVzaXplQ2FudmFzKG9bMF0sIG9bMV0pO1xuXG4gICAgICAgIHZhciByID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jb250cm9sLWNvbnRhaW5lclwiLCB0KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLl9jb250cm9sUG9zaXRpb25zID0ge307XG4gICAgICAgIFtcInRvcC1sZWZ0XCIsIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgXCJib3R0b20tcmlnaHRcIl0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGFbdF0gPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybC1cIiArIHQsIHIpO1xuICAgICAgICB9KSwgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5fb25NYXBTY3JvbGwsICExKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9yZXNpemVDYW52YXMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB2YXIgbyA9IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IG8gKiBlLCB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gbyAqIGksIHRoaXMuX2NhbnZhcy5zdHlsZS53aWR0aCA9IGUgKyBcInB4XCIsIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBpICsgXCJweFwiO1xuICAgICAgfSwgci5wcm90b3R5cGUuX3NldHVwUGFpbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSB0LmV4dGVuZCh7fSwgZS53ZWJHTENvbnRleHRBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCxcbiAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRoaXMuX3ByZXNlcnZlRHJhd2luZ0J1ZmZlcixcbiAgICAgICAgICBhbnRpYWxpYXM6IHRoaXMuX2FudGlhbGlhcyB8fCAhMVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIG8gPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIGkpIHx8IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIGkpO1xuXG4gICAgICAgIG8gPyAodGhpcy5wYWludGVyID0gbmV3IHlvKG8sIHRoaXMudHJhbnNmb3JtKSwgdC53ZWJwU3VwcG9ydGVkLnRlc3RTdXBwb3J0KG8pKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMXCIpKSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fY29udGV4dExvc3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZyYW1lICYmICh0aGlzLl9mcmFtZS5jYW5jZWwoKSwgdGhpcy5fZnJhbWUgPSBudWxsKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwid2ViZ2xjb250ZXh0bG9zdFwiLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICB9KSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fY29udGV4dFJlc3RvcmVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fc2V0dXBQYWludGVyKCksIHRoaXMucmVzaXplKCksIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICB9KSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fb25NYXBTY3JvbGwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodC50YXJnZXQgPT09IHRoaXMuX2NvbnRhaW5lcikgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgPSAwLCB0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDAsICExO1xuICAgICAgfSwgci5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX3N0eWxlRGlydHkgJiYgIXRoaXMuX3NvdXJjZXNEaXJ0eSAmJiAhIXRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5sb2FkZWQoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA/ICh0aGlzLl9zdHlsZURpcnR5ID0gdGhpcy5fc3R5bGVEaXJ0eSB8fCB0LCB0aGlzLl9zb3VyY2VzRGlydHkgPSAhMCwgdGhpcy50cmlnZ2VyUmVwYWludCgpLCB0aGlzKSA6IHRoaXM7XG4gICAgICB9LCByLnByb3RvdHlwZS5fcmVxdWVzdFJlbmRlckZyYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUuYWRkKHQpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX2NhbmNlbFJlbmRlckZyYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFza1F1ZXVlLnJlbW92ZSh0KTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG8gPSB0aGlzLFxuICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICBhID0gdGhpcy5wYWludGVyLmNvbnRleHQuZXh0VGltZXJRdWVyeTtcblxuICAgICAgICBpZiAodGhpcy5saXN0ZW5zKFwiZ3B1LXRpbWluZy1mcmFtZVwiKSAmJiAoaSA9IGEuY3JlYXRlUXVlcnlFWFQoKSwgYS5iZWdpblF1ZXJ5RVhUKGEuVElNRV9FTEFQU0VEX0VYVCwgaSksIHIgPSB0LmJyb3dzZXIubm93KCkpLCB0aGlzLnBhaW50ZXIuY29udGV4dC5zZXREaXJ0eSgpLCB0aGlzLnBhaW50ZXIuc2V0QmFzZVN0YXRlKCksIHRoaXMuX3JlbmRlclRhc2tRdWV1ZS5ydW4oZSksICF0aGlzLl9yZW1vdmVkKSB7XG4gICAgICAgICAgdmFyIG4gPSAhMTtcblxuICAgICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuX3N0eWxlRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSAhMTtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy50cmFuc2Zvcm0uem9vbSxcbiAgICAgICAgICAgICAgICBsID0gdC5icm93c2VyLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS56b29tSGlzdG9yeS51cGRhdGUocywgbCk7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyB0LkV2YWx1YXRpb25QYXJhbWV0ZXJzKHMsIHtcbiAgICAgICAgICAgICAgbm93OiBsLFxuICAgICAgICAgICAgICBmYWRlRHVyYXRpb246IHRoaXMuX2ZhZGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgem9vbUhpc3Rvcnk6IHRoaXMuc3R5bGUuem9vbUhpc3RvcnksXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuc3R5bGUuZ2V0VHJhbnNpdGlvbigpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB1ID0gYy5jcm9zc0ZhZGluZ0ZhY3RvcigpO1xuICAgICAgICAgICAgMSA9PT0gdSAmJiB1ID09PSB0aGlzLl9jcm9zc0ZhZGluZ0ZhY3RvciB8fCAobiA9ICEwLCB0aGlzLl9jcm9zc0ZhZGluZ0ZhY3RvciA9IHUpLCB0aGlzLnN0eWxlLnVwZGF0ZShjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zb3VyY2VzRGlydHkgJiYgKHRoaXMuX3NvdXJjZXNEaXJ0eSA9ICExLCB0aGlzLnN0eWxlLl91cGRhdGVTb3VyY2VzKHRoaXMudHJhbnNmb3JtKSksIHRoaXMuX3BsYWNlbWVudERpcnR5ID0gdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLl91cGRhdGVQbGFjZW1lbnQodGhpcy5wYWludGVyLnRyYW5zZm9ybSwgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMsIHRoaXMuX2ZhZGVEdXJhdGlvbiwgdGhpcy5fY3Jvc3NTb3VyY2VDb2xsaXNpb25zKSwgdGhpcy5wYWludGVyLnJlbmRlcih0aGlzLnN0eWxlLCB7XG4gICAgICAgICAgICBzaG93VGlsZUJvdW5kYXJpZXM6IHRoaXMuc2hvd1RpbGVCb3VuZGFyaWVzLFxuICAgICAgICAgICAgc2hvd092ZXJkcmF3SW5zcGVjdG9yOiB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IsXG4gICAgICAgICAgICByb3RhdGluZzogdGhpcy5pc1JvdGF0aW5nKCksXG4gICAgICAgICAgICB6b29taW5nOiB0aGlzLmlzWm9vbWluZygpLFxuICAgICAgICAgICAgbW92aW5nOiB0aGlzLmlzTW92aW5nKCksXG4gICAgICAgICAgICBmYWRlRHVyYXRpb246IHRoaXMuX2ZhZGVEdXJhdGlvbixcbiAgICAgICAgICAgIHNob3dQYWRkaW5nOiB0aGlzLnNob3dQYWRkaW5nLFxuICAgICAgICAgICAgZ3B1VGltaW5nOiAhIXRoaXMubGlzdGVucyhcImdwdS10aW1pbmctbGF5ZXJcIilcbiAgICAgICAgICB9KSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicmVuZGVyXCIpKSwgdGhpcy5sb2FkZWQoKSAmJiAhdGhpcy5fbG9hZGVkICYmICh0aGlzLl9sb2FkZWQgPSAhMCwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibG9hZFwiKSkpLCB0aGlzLnN0eWxlICYmICh0aGlzLnN0eWxlLmhhc1RyYW5zaXRpb25zKCkgfHwgbikgJiYgKHRoaXMuX3N0eWxlRGlydHkgPSAhMCksIHRoaXMuc3R5bGUgJiYgIXRoaXMuX3BsYWNlbWVudERpcnR5ICYmIHRoaXMuc3R5bGUuX3JlbGVhc2VTeW1ib2xGYWRlVGlsZXMoKSwgdGhpcy5saXN0ZW5zKFwiZ3B1LXRpbWluZy1mcmFtZVwiKSkge1xuICAgICAgICAgICAgdmFyIGggPSB0LmJyb3dzZXIubm93KCkgLSByO1xuICAgICAgICAgICAgYS5lbmRRdWVyeUVYVChhLlRJTUVfRUxBUFNFRF9FWFQsIGkpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBhLmdldFF1ZXJ5T2JqZWN0RVhUKGksIGEuUVVFUllfUkVTVUxUX0VYVCkgLyAxZTY7XG4gICAgICAgICAgICAgIGEuZGVsZXRlUXVlcnlFWFQoaSksIG8uZmlyZShuZXcgdC5FdmVudChcImdwdS10aW1pbmctZnJhbWVcIiwge1xuICAgICAgICAgICAgICAgIGNwdVRpbWU6IGgsXG4gICAgICAgICAgICAgICAgZ3B1VGltZTogZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMubGlzdGVucyhcImdwdS10aW1pbmctbGF5ZXJcIikpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYWludGVyLmNvbGxlY3RHcHVUaW1lcnMoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgZSA9IG8ucGFpbnRlci5xdWVyeUdwdVRpbWVycyhwKTtcbiAgICAgICAgICAgICAgby5maXJlKG5ldyB0LkV2ZW50KFwiZ3B1LXRpbWluZy1sYXllclwiLCB7XG4gICAgICAgICAgICAgICAgbGF5ZXJUaW1lczogZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGQgPSB0aGlzLl9zb3VyY2VzRGlydHkgfHwgdGhpcy5fc3R5bGVEaXJ0eSB8fCB0aGlzLl9wbGFjZW1lbnREaXJ0eTtcbiAgICAgICAgICByZXR1cm4gZCB8fCB0aGlzLl9yZXBhaW50ID8gdGhpcy50cmlnZ2VyUmVwYWludCgpIDogIXRoaXMuaXNNb3ZpbmcoKSAmJiB0aGlzLmxvYWRlZCgpICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImlkbGVcIikpLCAhdGhpcy5fbG9hZGVkIHx8IHRoaXMuX2Z1bGx5TG9hZGVkIHx8IGQgfHwgKHRoaXMuX2Z1bGx5TG9hZGVkID0gITApLCB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhc2ggJiYgdGhpcy5faGFzaC5yZW1vdmUoKTtcblxuICAgICAgICBmb3IgKHZhciBlID0gMCwgaSA9IHRoaXMuX2NvbnRyb2xzOyBlIDwgaS5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICAgIGlbZV0ub25SZW1vdmUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250cm9scyA9IFtdLCB0aGlzLl9mcmFtZSAmJiAodGhpcy5fZnJhbWUuY2FuY2VsKCksIHRoaXMuX2ZyYW1lID0gbnVsbCksIHRoaXMuX3JlbmRlclRhc2tRdWV1ZS5jbGVhcigpLCB0aGlzLnBhaW50ZXIuZGVzdHJveSgpLCB0aGlzLmhhbmRsZXJzLmRlc3Ryb3koKSwgZGVsZXRlIHRoaXMuaGFuZGxlcnMsIHRoaXMuc2V0U3R5bGUobnVsbCksIHZvaWQgMCAhPT0gdC53aW5kb3cgJiYgKHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUsICExKSwgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplLCAhMSksIHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgdGhpcy5fb25XaW5kb3dPbmxpbmUsICExKSk7XG4gICAgICAgIHZhciBvID0gdGhpcy5wYWludGVyLmNvbnRleHQuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgICAgICBvICYmIG8ubG9zZUNvbnRleHQoKSwgQ3IodGhpcy5fY2FudmFzQ29udGFpbmVyKSwgQ3IodGhpcy5fY29udHJvbENvbnRhaW5lciksIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1tYXBcIiksIHRoaXMuX3JlbW92ZWQgPSAhMCwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicmVtb3ZlXCIpKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLnRyaWdnZXJSZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3R5bGUgJiYgIXRoaXMuX2ZyYW1lICYmICh0aGlzLl9mcmFtZSA9IHQuYnJvd3Nlci5mcmFtZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGUuX2ZyYW1lID0gbnVsbCwgZS5fcmVuZGVyKHQpO1xuICAgICAgICB9KSk7XG4gICAgICB9LCByLnByb3RvdHlwZS5fb25XaW5kb3dPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSwgci5wcm90b3R5cGUuX29uV2luZG93UmVzaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tSZXNpemUgJiYgdGhpcy5yZXNpemUoe1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgfSkuX3VwZGF0ZSgpO1xuICAgICAgfSwgYS5zaG93VGlsZUJvdW5kYXJpZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93VGlsZUJvdW5kYXJpZXM7XG4gICAgICB9LCBhLnNob3dUaWxlQm91bmRhcmllcy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zaG93VGlsZUJvdW5kYXJpZXMgIT09IHQgJiYgKHRoaXMuX3Nob3dUaWxlQm91bmRhcmllcyA9IHQsIHRoaXMuX3VwZGF0ZSgpKTtcbiAgICAgIH0sIGEuc2hvd1BhZGRpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93UGFkZGluZztcbiAgICAgIH0sIGEuc2hvd1BhZGRpbmcuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc2hvd1BhZGRpbmcgIT09IHQgJiYgKHRoaXMuX3Nob3dQYWRkaW5nID0gdCwgdGhpcy5fdXBkYXRlKCkpO1xuICAgICAgfSwgYS5zaG93Q29sbGlzaW9uQm94ZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXM7XG4gICAgICB9LCBhLnNob3dDb2xsaXNpb25Cb3hlcy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXMgIT09IHQgJiYgKHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcyA9IHQsIHQgPyB0aGlzLnN0eWxlLl9nZW5lcmF0ZUNvbGxpc2lvbkJveGVzKCkgOiB0aGlzLl91cGRhdGUoKSk7XG4gICAgICB9LCBhLnNob3dPdmVyZHJhd0luc3BlY3Rvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvcjtcbiAgICAgIH0sIGEuc2hvd092ZXJkcmF3SW5zcGVjdG9yLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvciAhPT0gdCAmJiAodGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID0gdCwgdGhpcy5fdXBkYXRlKCkpO1xuICAgICAgfSwgYS5yZXBhaW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcmVwYWludDtcbiAgICAgIH0sIGEucmVwYWludC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9yZXBhaW50ICE9PSB0ICYmICh0aGlzLl9yZXBhaW50ID0gdCwgdGhpcy50cmlnZ2VyUmVwYWludCgpKTtcbiAgICAgIH0sIGEudmVydGljZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl92ZXJ0aWNlcztcbiAgICAgIH0sIGEudmVydGljZXMuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSB0LCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0sIHIucHJvdG90eXBlLl9zZXRDYWNoZUxpbWl0cyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIHQuc2V0Q2FjaGVMaW1pdHMoZSwgaSk7XG4gICAgICB9LCBhLnZlcnNpb24uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdC52ZXJzaW9uO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoci5wcm90b3R5cGUsIGEpLCByO1xuICAgIH0odnIpO1xuXG4gICAgZnVuY3Rpb24gQ3IodCkge1xuICAgICAgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KTtcbiAgICB9XG5cbiAgICB2YXIgenIgPSB7XG4gICAgICBzaG93Q29tcGFzczogITAsXG4gICAgICBzaG93Wm9vbTogITAsXG4gICAgICB2aXN1YWxpemVQaXRjaDogITFcbiAgICB9LFxuICAgICAgICBEciA9IGZ1bmN0aW9uIERyKGUpIHtcbiAgICAgIHZhciBvID0gdGhpcztcbiAgICAgIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCB6ciwgZSksIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKSwgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSksIHRoaXMub3B0aW9ucy5zaG93Wm9vbSAmJiAodC5iaW5kQWxsKFtcIl9zZXRCdXR0b25UaXRsZVwiLCBcIl91cGRhdGVab29tQnV0dG9uc1wiXSwgdGhpcyksIHRoaXMuX3pvb21JbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcIm1hcGxpYnJlZ2wtY3RybC16b29tLWluXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBvLl9tYXAuem9vbUluKHt9LCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogdFxuICAgICAgICB9KTtcbiAgICAgIH0pLCBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBsaWJyZWdsLWN0cmwtaWNvblwiLCB0aGlzLl96b29tSW5CdXR0b24pLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcIm1hcGxpYnJlZ2wtY3RybC16b29tLW91dFwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gby5fbWFwLnpvb21PdXQoe30sIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgIH0pO1xuICAgICAgfSksIGkuY3JlYXRlKFwic3BhblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1pY29uXCIsIHRoaXMuX3pvb21PdXRCdXR0b24pLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSksIHRoaXMub3B0aW9ucy5zaG93Q29tcGFzcyAmJiAodC5iaW5kQWxsKFtcIl9yb3RhdGVDb21wYXNzQXJyb3dcIl0sIHRoaXMpLCB0aGlzLl9jb21wYXNzID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwibWFwbGlicmVnbC1jdHJsLWNvbXBhc3NcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgby5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoID8gby5fbWFwLnJlc2V0Tm9ydGhQaXRjaCh7fSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgfSkgOiBvLl9tYXAucmVzZXROb3J0aCh7fSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgfSk7XG4gICAgICB9KSwgdGhpcy5fY29tcGFzc0ljb24gPSBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBsaWJyZWdsLWN0cmwtaWNvblwiLCB0aGlzLl9jb21wYXNzKSwgdGhpcy5fY29tcGFzc0ljb24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApKTtcbiAgICB9O1xuXG4gICAgRHIucHJvdG90eXBlLl91cGRhdGVab29tQnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICBlID0gdCA9PT0gdGhpcy5fbWFwLmdldE1heFpvb20oKSxcbiAgICAgICAgICBpID0gdCA9PT0gdGhpcy5fbWFwLmdldE1pblpvb20oKTtcblxuICAgICAgdGhpcy5fem9vbUluQnV0dG9uLmRpc2FibGVkID0gZSwgdGhpcy5fem9vbU91dEJ1dHRvbi5kaXNhYmxlZCA9IGksIHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIGUudG9TdHJpbmcoKSksIHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBpLnRvU3RyaW5nKCkpO1xuICAgIH0sIERyLnByb3RvdHlwZS5fcm90YXRlQ29tcGFzc0Fycm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMudmlzdWFsaXplUGl0Y2ggPyBcInNjYWxlKFwiICsgMSAvIE1hdGgucG93KE1hdGguY29zKHRoaXMuX21hcC50cmFuc2Zvcm0ucGl0Y2ggKiAoTWF0aC5QSSAvIDE4MCkpLCAuNSkgKyBcIikgcm90YXRlWChcIiArIHRoaXMuX21hcC50cmFuc2Zvcm0ucGl0Y2ggKyBcImRlZykgcm90YXRlWihcIiArIHRoaXMuX21hcC50cmFuc2Zvcm0uYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkgKyBcImRlZylcIiA6IFwicm90YXRlKFwiICsgdGhpcy5fbWFwLnRyYW5zZm9ybS5hbmdsZSAqICgxODAgLyBNYXRoLlBJKSArIFwiZGVnKVwiO1xuICAgICAgdGhpcy5fY29tcGFzc0ljb24uc3R5bGUudHJhbnNmb3JtID0gdDtcbiAgICB9LCBEci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IHQsIHRoaXMub3B0aW9ucy5zaG93Wm9vbSAmJiAodGhpcy5fc2V0QnV0dG9uVGl0bGUodGhpcy5fem9vbUluQnV0dG9uLCBcIlpvb21JblwiKSwgdGhpcy5fc2V0QnV0dG9uVGl0bGUodGhpcy5fem9vbU91dEJ1dHRvbiwgXCJab29tT3V0XCIpLCB0aGlzLl9tYXAub24oXCJ6b29tXCIsIHRoaXMuX3VwZGF0ZVpvb21CdXR0b25zKSwgdGhpcy5fdXBkYXRlWm9vbUJ1dHRvbnMoKSksIHRoaXMub3B0aW9ucy5zaG93Q29tcGFzcyAmJiAodGhpcy5fc2V0QnV0dG9uVGl0bGUodGhpcy5fY29tcGFzcywgXCJSZXNldEJlYXJpbmdcIiksIHRoaXMub3B0aW9ucy52aXN1YWxpemVQaXRjaCAmJiB0aGlzLl9tYXAub24oXCJwaXRjaFwiLCB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3cpLCB0aGlzLl9tYXAub24oXCJyb3RhdGVcIiwgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KSwgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KCksIHRoaXMuX2hhbmRsZXIgPSBuZXcgQXIodGhpcy5fbWFwLCB0aGlzLl9jb21wYXNzLCB0aGlzLm9wdGlvbnMudmlzdWFsaXplUGl0Y2gpKSwgdGhpcy5fY29udGFpbmVyO1xuICAgIH0sIERyLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGkucmVtb3ZlKHRoaXMuX2NvbnRhaW5lciksIHRoaXMub3B0aW9ucy5zaG93Wm9vbSAmJiB0aGlzLl9tYXAub2ZmKFwiem9vbVwiLCB0aGlzLl91cGRhdGVab29tQnV0dG9ucyksIHRoaXMub3B0aW9ucy5zaG93Q29tcGFzcyAmJiAodGhpcy5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoICYmIHRoaXMuX21hcC5vZmYoXCJwaXRjaFwiLCB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3cpLCB0aGlzLl9tYXAub2ZmKFwicm90YXRlXCIsIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdyksIHRoaXMuX2hhbmRsZXIub2ZmKCksIGRlbGV0ZSB0aGlzLl9oYW5kbGVyKSwgZGVsZXRlIHRoaXMuX21hcDtcbiAgICB9LCBEci5wcm90b3R5cGUuX2NyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgbyA9IGkuY3JlYXRlKFwiYnV0dG9uXCIsIHQsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICByZXR1cm4gby50eXBlID0gXCJidXR0b25cIiwgby5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSksIG87XG4gICAgfSwgRHIucHJvdG90eXBlLl9zZXRCdXR0b25UaXRsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJOYXZpZ2F0aW9uQ29udHJvbC5cIiArIGUpO1xuXG4gICAgICB0LnRpdGxlID0gaSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGkpO1xuICAgIH07XG5cbiAgICB2YXIgQXIgPSBmdW5jdGlvbiBBcihlLCBvLCByKSB7XG4gICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSAhMSksIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gMTAsIHRoaXMuZWxlbWVudCA9IG8sIHRoaXMubW91c2VSb3RhdGUgPSBuZXcgWG8oe1xuICAgICAgICBjbGlja1RvbGVyYW5jZTogZS5kcmFnUm90YXRlLl9tb3VzZVJvdGF0ZS5fY2xpY2tUb2xlcmFuY2VcbiAgICAgIH0pLCB0aGlzLm1hcCA9IGUsIHIgJiYgKHRoaXMubW91c2VQaXRjaCA9IG5ldyBIbyh7XG4gICAgICAgIGNsaWNrVG9sZXJhbmNlOiBlLmRyYWdSb3RhdGUuX21vdXNlUGl0Y2guX2NsaWNrVG9sZXJhbmNlXG4gICAgICB9KSksIHQuYmluZEFsbChbXCJtb3VzZWRvd25cIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCIsIFwidG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIsIFwicmVzZXRcIl0sIHRoaXMpLCBpLmFkZEV2ZW50TGlzdGVuZXIobywgXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZWRvd24pLCBpLmFkZEV2ZW50TGlzdGVuZXIobywgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMudG91Y2hzdGFydCwge1xuICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgfSksIGkuYWRkRXZlbnRMaXN0ZW5lcihvLCBcInRvdWNobW92ZVwiLCB0aGlzLnRvdWNobW92ZSksIGkuYWRkRXZlbnRMaXN0ZW5lcihvLCBcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpLCBpLmFkZEV2ZW50TGlzdGVuZXIobywgXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLnJlc2V0KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTXIoZSwgaSwgbykge1xuICAgICAgaWYgKGUgPSBuZXcgdC5MbmdMYXQoZS5sbmcsIGUubGF0KSwgaSkge1xuICAgICAgICB2YXIgciA9IG5ldyB0LkxuZ0xhdChlLmxuZyAtIDM2MCwgZS5sYXQpLFxuICAgICAgICAgICAgYSA9IG5ldyB0LkxuZ0xhdChlLmxuZyArIDM2MCwgZS5sYXQpLFxuICAgICAgICAgICAgbiA9IG8ubG9jYXRpb25Qb2ludChlKS5kaXN0U3FyKGkpO1xuICAgICAgICBvLmxvY2F0aW9uUG9pbnQocikuZGlzdFNxcihpKSA8IG4gPyBlID0gciA6IG8ubG9jYXRpb25Qb2ludChhKS5kaXN0U3FyKGkpIDwgbiAmJiAoZSA9IGEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgTWF0aC5hYnMoZS5sbmcgLSBvLmNlbnRlci5sbmcpID4gMTgwOykge1xuICAgICAgICB2YXIgcyA9IG8ubG9jYXRpb25Qb2ludChlKTtcbiAgICAgICAgaWYgKHMueCA+PSAwICYmIHMueSA+PSAwICYmIHMueCA8PSBvLndpZHRoICYmIHMueSA8PSBvLmhlaWdodCkgYnJlYWs7XG4gICAgICAgIGUubG5nID4gby5jZW50ZXIubG5nID8gZS5sbmcgLT0gMzYwIDogZS5sbmcgKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBBci5wcm90b3R5cGUuZG93biA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLm1vdXNlUm90YXRlLm1vdXNlZG93bih0LCBlKSwgdGhpcy5tb3VzZVBpdGNoICYmIHRoaXMubW91c2VQaXRjaC5tb3VzZWRvd24odCwgZSksIGkuZGlzYWJsZURyYWcoKTtcbiAgICB9LCBBci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMubWFwLFxuICAgICAgICAgIG8gPSB0aGlzLm1vdXNlUm90YXRlLm1vdXNlbW92ZVdpbmRvdyh0LCBlKTtcblxuICAgICAgaWYgKG8gJiYgby5iZWFyaW5nRGVsdGEgJiYgaS5zZXRCZWFyaW5nKGkuZ2V0QmVhcmluZygpICsgby5iZWFyaW5nRGVsdGEpLCB0aGlzLm1vdXNlUGl0Y2gpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm1vdXNlUGl0Y2gubW91c2Vtb3ZlV2luZG93KHQsIGUpO1xuICAgICAgICByICYmIHIucGl0Y2hEZWx0YSAmJiBpLnNldFBpdGNoKGkuZ2V0UGl0Y2goKSArIHIucGl0Y2hEZWx0YSk7XG4gICAgICB9XG4gICAgfSwgQXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5lbGVtZW50O1xuICAgICAgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgIH0pLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaG1vdmVcIiwgdGhpcy50b3VjaG1vdmUpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIFwidG91Y2hjYW5jZWxcIiwgdGhpcy5yZXNldCksIHRoaXMub2ZmVGVtcCgpO1xuICAgIH0sIEFyLnByb3RvdHlwZS5vZmZUZW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaS5lbmFibGVEcmFnKCksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LndpbmRvdywgXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodC53aW5kb3csIFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXApO1xuICAgIH0sIEFyLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5kb3duKHQuZXh0ZW5kKHt9LCBlLCB7XG4gICAgICAgIGN0cmxLZXk6ICEwLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSksIGkubW91c2VQb3ModGhpcy5lbGVtZW50LCBlKSksIGkuYWRkRXZlbnRMaXN0ZW5lcih0LndpbmRvdywgXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpLCBpLmFkZEV2ZW50TGlzdGVuZXIodC53aW5kb3csIFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXApO1xuICAgIH0sIEFyLnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5tb3ZlKHQsIGkubW91c2VQb3ModGhpcy5lbGVtZW50LCB0KSk7XG4gICAgfSwgQXIucHJvdG90eXBlLm1vdXNldXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5tb3VzZVJvdGF0ZS5tb3VzZXVwV2luZG93KHQpLCB0aGlzLm1vdXNlUGl0Y2ggJiYgdGhpcy5tb3VzZVBpdGNoLm1vdXNldXBXaW5kb3codCksIHRoaXMub2ZmVGVtcCgpO1xuICAgIH0sIEFyLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIDEgIT09IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPyB0aGlzLnJlc2V0KCkgOiAodGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9sYXN0UG9zID0gaS50b3VjaFBvcyh0aGlzLmVsZW1lbnQsIHQudGFyZ2V0VG91Y2hlcylbMF0sIHRoaXMuZG93bih7XG4gICAgICAgIHR5cGU6IFwibW91c2Vkb3duXCIsXG4gICAgICAgIGJ1dHRvbjogMCxcbiAgICAgICAgY3RybEtleTogITAsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9zdGFydFBvcykpO1xuICAgIH0sIEFyLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgMSAhPT0gdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA/IHRoaXMucmVzZXQoKSA6ICh0aGlzLl9sYXN0UG9zID0gaS50b3VjaFBvcyh0aGlzLmVsZW1lbnQsIHQudGFyZ2V0VG91Y2hlcylbMF0sIHRoaXMubW92ZSh7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9sYXN0UG9zKSk7XG4gICAgfSwgQXIucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIDAgPT09IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggJiYgdGhpcy5fc3RhcnRQb3MgJiYgdGhpcy5fbGFzdFBvcyAmJiB0aGlzLl9zdGFydFBvcy5kaXN0KHRoaXMuX2xhc3RQb3MpIDwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgJiYgdGhpcy5lbGVtZW50LmNsaWNrKCksIHRoaXMucmVzZXQoKTtcbiAgICB9LCBBci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1vdXNlUm90YXRlLnJlc2V0KCksIHRoaXMubW91c2VQaXRjaCAmJiB0aGlzLm1vdXNlUGl0Y2gucmVzZXQoKSwgZGVsZXRlIHRoaXMuX3N0YXJ0UG9zLCBkZWxldGUgdGhpcy5fbGFzdFBvcywgdGhpcy5vZmZUZW1wKCk7XG4gICAgfTtcbiAgICB2YXIgTHIgPSB7XG4gICAgICBjZW50ZXI6IFwidHJhbnNsYXRlKC01MCUsLTUwJSlcIixcbiAgICAgIHRvcDogXCJ0cmFuc2xhdGUoLTUwJSwwKVwiLFxuICAgICAgXCJ0b3AtbGVmdFwiOiBcInRyYW5zbGF0ZSgwLDApXCIsXG4gICAgICBcInRvcC1yaWdodFwiOiBcInRyYW5zbGF0ZSgtMTAwJSwwKVwiLFxuICAgICAgYm90dG9tOiBcInRyYW5zbGF0ZSgtNTAlLC0xMDAlKVwiLFxuICAgICAgXCJib3R0b20tbGVmdFwiOiBcInRyYW5zbGF0ZSgwLC0xMDAlKVwiLFxuICAgICAgXCJib3R0b20tcmlnaHRcIjogXCJ0cmFuc2xhdGUoLTEwMCUsLTEwMCUpXCIsXG4gICAgICBsZWZ0OiBcInRyYW5zbGF0ZSgwLC01MCUpXCIsXG4gICAgICByaWdodDogXCJ0cmFuc2xhdGUoLTEwMCUsLTUwJSlcIlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBScih0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHQuY2xhc3NMaXN0O1xuXG4gICAgICBmb3IgKHZhciByIGluIExyKSB7XG4gICAgICAgIG8ucmVtb3ZlKFwibWFwbGlicmVnbC1cIiArIGkgKyBcIi1hbmNob3ItXCIgKyByKTtcbiAgICAgIH1cblxuICAgICAgby5hZGQoXCJtYXBsaWJyZWdsLVwiICsgaSArIFwiLWFuY2hvci1cIiArIGUpO1xuICAgIH1cblxuICAgIHZhciBrcixcbiAgICAgICAgQnIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gbyhvLCByKSB7XG4gICAgICAgIGlmIChlLmNhbGwodGhpcyksIChvIGluc3RhbmNlb2YgdC53aW5kb3cuSFRNTEVsZW1lbnQgfHwgcikgJiYgKG8gPSB0LmV4dGVuZCh7XG4gICAgICAgICAgZWxlbWVudDogb1xuICAgICAgICB9LCByKSksIHQuYmluZEFsbChbXCJfdXBkYXRlXCIsIFwiX29uTW92ZVwiLCBcIl9vblVwXCIsIFwiX2FkZERyYWdIYW5kbGVyXCIsIFwiX29uTWFwQ2xpY2tcIiwgXCJfb25LZXlQcmVzc1wiXSwgdGhpcyksIHRoaXMuX2FuY2hvciA9IG8gJiYgby5hbmNob3IgfHwgXCJjZW50ZXJcIiwgdGhpcy5fY29sb3IgPSBvICYmIG8uY29sb3IgfHwgXCIjM0ZCMUNFXCIsIHRoaXMuX3NjYWxlID0gbyAmJiBvLnNjYWxlIHx8IDEsIHRoaXMuX2RyYWdnYWJsZSA9IG8gJiYgby5kcmFnZ2FibGUgfHwgITEsIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gbyAmJiBvLmNsaWNrVG9sZXJhbmNlIHx8IDAsIHRoaXMuX2lzRHJhZ2dpbmcgPSAhMSwgdGhpcy5fc3RhdGUgPSBcImluYWN0aXZlXCIsIHRoaXMuX3JvdGF0aW9uID0gbyAmJiBvLnJvdGF0aW9uIHx8IDAsIHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50ID0gbyAmJiBvLnJvdGF0aW9uQWxpZ25tZW50IHx8IFwiYXV0b1wiLCB0aGlzLl9waXRjaEFsaWdubWVudCA9IG8gJiYgby5waXRjaEFsaWdubWVudCAmJiBcImF1dG9cIiAhPT0gby5waXRjaEFsaWdubWVudCA/IG8ucGl0Y2hBbGlnbm1lbnQgOiB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCwgbyAmJiBvLmVsZW1lbnQpIHRoaXMuX2VsZW1lbnQgPSBvLmVsZW1lbnQsIHRoaXMuX29mZnNldCA9IHQuUG9pbnQuY29udmVydChvICYmIG8ub2Zmc2V0IHx8IFswLCAwXSk7ZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdE1hcmtlciA9ICEwLCB0aGlzLl9lbGVtZW50ID0gaS5jcmVhdGUoXCJkaXZcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk1hcCBtYXJrZXJcIik7XG4gICAgICAgICAgdmFyIGEgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRpc3BsYXlcIiwgXCJibG9ja1wiKSwgYS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBcIjQxcHhcIiksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBcIjI3cHhcIiksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ2aWV3Qm94XCIsIFwiMCAwIDI3IDQxXCIpO1xuICAgICAgICAgIHZhciBuID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgICBuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlXCIsIFwibm9uZVwiKSwgbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS13aWR0aFwiLCBcIjFcIiksIG4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKSwgbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgICAgICAgdmFyIHMgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgIHMuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuICAgICAgICAgIHZhciBsID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgICBsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDMuMCwgMjkuMClcIiksIGwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiIzAwMDAwMFwiKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwLCB1ID0gW3tcbiAgICAgICAgICAgIHJ4OiBcIjEwLjVcIixcbiAgICAgICAgICAgIHJ5OiBcIjUuMjUwMDIyNzNcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHJ4OiBcIjEwLjVcIixcbiAgICAgICAgICAgIHJ5OiBcIjUuMjUwMDIyNzNcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHJ4OiBcIjkuNVwiLFxuICAgICAgICAgICAgcnk6IFwiNC43NzI3NTAwN1wiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcng6IFwiOC41XCIsXG4gICAgICAgICAgICByeTogXCI0LjI5NTQ5OTM2XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICByeDogXCI3LjVcIixcbiAgICAgICAgICAgIHJ5OiBcIjMuODE4MjIzMDhcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHJ4OiBcIjYuNVwiLFxuICAgICAgICAgICAgcnk6IFwiMy4zNDA5NDY3OVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcng6IFwiNS41XCIsXG4gICAgICAgICAgICByeTogXCIyLjg2MzY3MDUxXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICByeDogXCI0LjVcIixcbiAgICAgICAgICAgIHJ5OiBcIjIuMzg2MzY4NjRcIlxuICAgICAgICAgIH1dOyBjIDwgdS5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGggPSB1W2NdLFxuICAgICAgICAgICAgICAgIHAgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJlbGxpcHNlXCIpO1xuICAgICAgICAgICAgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9wYWNpdHlcIiwgXCIwLjA0XCIpLCBwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgXCIxMC41XCIpLCBwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3lcIiwgXCI1LjgwMDI5MDA4XCIpLCBwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwicnhcIiwgaC5yeCksIHAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyeVwiLCBoLnJ5KSwgbC5hcHBlbmRDaGlsZChwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgZC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgdGhpcy5fY29sb3IpO1xuXG4gICAgICAgICAgdmFyIF8gPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuXG4gICAgICAgICAgXy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgXCJNMjcsMTMuNSBDMjcsMTkuMDc0NjQ0IDIwLjI1MDAwMSwyNy4wMDAwMDIgMTQuNzUsMzQuNTAwMDAyIEMxNC4wMTY2NjUsMzUuNTAwMDA0IDEyLjk4MzMzNSwzNS41MDAwMDQgMTIuMjUsMzQuNTAwMDAyIEM2Ljc0OTk5OTMsMjcuMDAwMDAyIDAsMTkuMjIyNTYyIDAsMTMuNSBDMCw2LjA0NDE1NTkgNi4wNDQxNTU5LDAgMTMuNSwwIEMyMC45NTU4NDQsMCAyNyw2LjA0NDE1NTkgMjcsMTMuNSBaXCIpLCBkLmFwcGVuZENoaWxkKF8pO1xuICAgICAgICAgIHZhciBmID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgICBmLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwib3BhY2l0eVwiLCBcIjAuMjVcIiksIGYuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiIzAwMDAwMFwiKTtcbiAgICAgICAgICB2YXIgbSA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgICAgICAgbS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgXCJNMTMuNSwwIEM2LjA0NDE1NTksMCAwLDYuMDQ0MTU1OSAwLDEzLjUgQzAsMTkuMjIyNTYyIDYuNzQ5OTk5MywyNyAxMi4yNSwzNC41IEMxMywzNS41MjI3MjcgMTQuMDE2NjY0LDM1LjUwMDAwNCAxNC43NSwzNC41IEMyMC4yNTAwMDEsMjcgMjcsMTkuMDc0NjQ0IDI3LDEzLjUgQzI3LDYuMDQ0MTU1OSAyMC45NTU4NDQsMCAxMy41LDAgWiBNMTMuNSwxIEMyMC40MTU0MDQsMSAyNiw2LjU4NDU5NiAyNiwxMy41IEMyNiwxNS44OTg2NTcgMjQuNDk1NTg0LDE5LjE4MTQzMSAyMi4yMjA3MDMsMjIuNzM4MjgxIEMxOS45NDU4MjMsMjYuMjk1MTMyIDE2LjcwNTExOSwzMC4xNDIxNjcgMTMuOTQzMzU5LDMzLjkwODIwMyBDMTMuNzQzNDQ1LDM0LjE4MDgxNCAxMy42MTI3MTUsMzQuMzIyNzM4IDEzLjUsMzQuNDQxNDA2IEMxMy4zODcyODUsMzQuMzIyNzM4IDEzLjI1NjU1NSwzNC4xODA4MTQgMTMuMDU2NjQxLDMzLjkwODIwMyBDMTAuMjg0NDgxLDMwLjEyNzk4NSA3LjQxNDg2ODQsMjYuMzE0MTU5IDUuMDE1NjI1LDIyLjc3MzQzOCBDMi42MTYzODE2LDE5LjIzMjcxNSAxLDE1Ljk1MzUzOCAxLDEzLjUgQzEsNi41ODQ1OTYgNi41ODQ1OTYsMSAxMy41LDEgWlwiKSwgZi5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgICB2YXIgZyA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSg2LjAsIDcuMClcIiksIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiI0ZGRkZGRlwiKTtcbiAgICAgICAgICB2YXIgdiA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgdi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSg4LjAsIDguMClcIik7XG4gICAgICAgICAgdmFyIHkgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIik7XG4gICAgICAgICAgeS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCIjMDAwMDAwXCIpLCB5LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwib3BhY2l0eVwiLCBcIjAuMjVcIiksIHkuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeFwiLCBcIjUuNVwiKSwgeS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIFwiNS41XCIpLCB5LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiclwiLCBcIjUuNDk5OTk2MlwiKTtcbiAgICAgICAgICB2YXIgeCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcbiAgICAgICAgICB4LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIiNGRkZGRkZcIiksIHguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeFwiLCBcIjUuNVwiKSwgeC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIFwiNS41XCIpLCB4LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiclwiLCBcIjUuNDk5OTk2MlwiKSwgdi5hcHBlbmRDaGlsZCh5KSwgdi5hcHBlbmRDaGlsZCh4KSwgcy5hcHBlbmRDaGlsZChsKSwgcy5hcHBlbmRDaGlsZChkKSwgcy5hcHBlbmRDaGlsZChmKSwgcy5hcHBlbmRDaGlsZChnKSwgcy5hcHBlbmRDaGlsZCh2KSwgYS5hcHBlbmRDaGlsZChzKSwgYS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCA0MSAqIHRoaXMuX3NjYWxlICsgXCJweFwiKSwgYS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIDI3ICogdGhpcy5fc2NhbGUgKyBcInB4XCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKGEpLCB0aGlzLl9vZmZzZXQgPSB0LlBvaW50LmNvbnZlcnQobyAmJiBvLm9mZnNldCB8fCBbMCwgLTE0XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1tYXJrZXJcIiksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSksIFJyKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2FuY2hvciwgXCJtYXJrZXJcIiksIHRoaXMuX3BvcHVwID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGUgJiYgKG8uX19wcm90b19fID0gZSksIChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbywgby5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKSwgdGhpcy5fbWFwID0gdCwgdC5nZXRDYW52YXNDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSwgdC5vbihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdC5vbihcIm1vdmVlbmRcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5zZXREcmFnZ2FibGUodGhpcy5fZHJhZ2dhYmxlKSwgdGhpcy5fdXBkYXRlKCksIHRoaXMuX21hcC5vbihcImNsaWNrXCIsIHRoaXMuX29uTWFwQ2xpY2spLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwICYmICh0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIiwgdGhpcy5fb25NYXBDbGljayksIHRoaXMuX21hcC5vZmYoXCJtb3ZlXCIsIHRoaXMuX3VwZGF0ZSksIHRoaXMuX21hcC5vZmYoXCJtb3ZlZW5kXCIsIHRoaXMuX3VwZGF0ZSksIHRoaXMuX21hcC5vZmYoXCJtb3VzZWRvd25cIiwgdGhpcy5fYWRkRHJhZ0hhbmRsZXIpLCB0aGlzLl9tYXAub2ZmKFwidG91Y2hzdGFydFwiLCB0aGlzLl9hZGREcmFnSGFuZGxlciksIHRoaXMuX21hcC5vZmYoXCJtb3VzZXVwXCIsIHRoaXMuX29uVXApLCB0aGlzLl9tYXAub2ZmKFwidG91Y2hlbmRcIiwgdGhpcy5fb25VcCksIHRoaXMuX21hcC5vZmYoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fbWFwLm9mZihcInRvdWNobW92ZVwiLCB0aGlzLl9vbk1vdmUpLCBkZWxldGUgdGhpcy5fbWFwKSwgaS5yZW1vdmUodGhpcy5fZWxlbWVudCksIHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLnJlbW92ZSgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0TG5nTGF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG5nTGF0O1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0TG5nTGF0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdCA9IHQuTG5nTGF0LmNvbnZlcnQoZSksIHRoaXMuX3BvcyA9IG51bGwsIHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLnNldExuZ0xhdCh0aGlzLl9sbmdMYXQpLCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0UG9wdXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy5fcG9wdXAgJiYgKHRoaXMuX3BvcHVwLnJlbW92ZSgpLCB0aGlzLl9wb3B1cCA9IG51bGwsIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIHRoaXMuX29uS2V5UHJlc3MpLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4IHx8IHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidGFiaW5kZXhcIikpLCB0KSB7XG4gICAgICAgICAgaWYgKCEoXCJvZmZzZXRcIiBpbiB0Lm9wdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgZSA9IE1hdGguc3FydChNYXRoLnBvdygxMy41LCAyKSAvIDIpO1xuICAgICAgICAgICAgdC5vcHRpb25zLm9mZnNldCA9IHRoaXMuX2RlZmF1bHRNYXJrZXIgPyB7XG4gICAgICAgICAgICAgIHRvcDogWzAsIDBdLFxuICAgICAgICAgICAgICBcInRvcC1sZWZ0XCI6IFswLCAwXSxcbiAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogWzAsIDBdLFxuICAgICAgICAgICAgICBib3R0b206IFswLCAtMzguMV0sXG4gICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogW2UsIC0xICogKDI0LjYgKyBlKV0sXG4gICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IFstZSwgLTEgKiAoMjQuNiArIGUpXSxcbiAgICAgICAgICAgICAgbGVmdDogWzEzLjUsIC0yNC42XSxcbiAgICAgICAgICAgICAgcmlnaHQ6IFstMTMuNSwgLTI0LjZdXG4gICAgICAgICAgICB9IDogdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3BvcHVwID0gdCwgdGhpcy5fbG5nTGF0ICYmIHRoaXMuX3BvcHVwLnNldExuZ0xhdCh0aGlzLl9sbmdMYXQpLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSwgdGhpcy5fb3JpZ2luYWxUYWJJbmRleCB8fCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9vbktleVByZXNzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LmNvZGUsXG4gICAgICAgICAgICBpID0gdC5jaGFyQ29kZSB8fCB0LmtleUNvZGU7XG4gICAgICAgIFwiU3BhY2VcIiAhPT0gZSAmJiBcIkVudGVyXCIgIT09IGUgJiYgMzIgIT09IGkgJiYgMTMgIT09IGkgfHwgdGhpcy50b2dnbGVQb3B1cCgpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uTWFwQ2xpY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICBpID0gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcG9wdXAgJiYgKGUgPT09IGkgfHwgaS5jb250YWlucyhlKSkgJiYgdGhpcy50b2dnbGVQb3B1cCgpO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0UG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cDtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnRvZ2dsZVBvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuX3BvcHVwO1xuICAgICAgICByZXR1cm4gdCA/ICh0LmlzT3BlbigpID8gdC5yZW1vdmUoKSA6IHQuYWRkVG8odGhpcy5fbWFwKSwgdGhpcykgOiB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICB0aGlzLl9tYXAudHJhbnNmb3JtLnJlbmRlcldvcmxkQ29waWVzICYmICh0aGlzLl9sbmdMYXQgPSBNcih0aGlzLl9sbmdMYXQsIHRoaXMuX3BvcywgdGhpcy5fbWFwLnRyYW5zZm9ybSkpLCB0aGlzLl9wb3MgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sbmdMYXQpLl9hZGQodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICB2YXIgZSA9IFwiXCI7XG4gICAgICAgICAgXCJ2aWV3cG9ydFwiID09PSB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCB8fCBcImF1dG9cIiA9PT0gdGhpcy5fcm90YXRpb25BbGlnbm1lbnQgPyBlID0gXCJyb3RhdGVaKFwiICsgdGhpcy5fcm90YXRpb24gKyBcImRlZylcIiA6IFwibWFwXCIgPT09IHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50ICYmIChlID0gXCJyb3RhdGVaKFwiICsgKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5fbWFwLmdldEJlYXJpbmcoKSkgKyBcImRlZylcIik7XG4gICAgICAgICAgdmFyIG8gPSBcIlwiO1xuICAgICAgICAgIFwidmlld3BvcnRcIiA9PT0gdGhpcy5fcGl0Y2hBbGlnbm1lbnQgfHwgXCJhdXRvXCIgPT09IHRoaXMuX3BpdGNoQWxpZ25tZW50ID8gbyA9IFwicm90YXRlWCgwZGVnKVwiIDogXCJtYXBcIiA9PT0gdGhpcy5fcGl0Y2hBbGlnbm1lbnQgJiYgKG8gPSBcInJvdGF0ZVgoXCIgKyB0aGlzLl9tYXAuZ2V0UGl0Y2goKSArIFwiZGVnKVwiKSwgdCAmJiBcIm1vdmVlbmRcIiAhPT0gdC50eXBlIHx8ICh0aGlzLl9wb3MgPSB0aGlzLl9wb3Mucm91bmQoKSksIGkuc2V0VHJhbnNmb3JtKHRoaXMuX2VsZW1lbnQsIExyW3RoaXMuX2FuY2hvcl0gKyBcIiB0cmFuc2xhdGUoXCIgKyB0aGlzLl9wb3MueCArIFwicHgsIFwiICsgdGhpcy5fcG9zLnkgKyBcInB4KSBcIiArIG8gKyBcIiBcIiArIGUpO1xuICAgICAgICB9XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRPZmZzZXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID0gdC5Qb2ludC5jb252ZXJ0KGUpLCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlIHx8IHRoaXMuX21hcC5fY2xpY2tUb2xlcmFuY2U7XG4gICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGUucG9pbnQuZGlzdCh0aGlzLl9wb2ludGVyZG93blBvcykgPj0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgJiYgKHRoaXMuX3BvcyA9IGUucG9pbnQuc3ViKHRoaXMuX3Bvc2l0aW9uRGVsdGEpLCB0aGlzLl9sbmdMYXQgPSB0aGlzLl9tYXAudW5wcm9qZWN0KHRoaXMuX3BvcyksIHRoaXMuc2V0TG5nTGF0KHRoaXMuX2xuZ0xhdCksIHRoaXMuX2VsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiLCBcInBlbmRpbmdcIiA9PT0gdGhpcy5fc3RhdGUgJiYgKHRoaXMuX3N0YXRlID0gXCJhY3RpdmVcIiwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZHJhZ3N0YXJ0XCIpKSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRyYWdcIikpKTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9vblVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIiwgdGhpcy5fcG9zaXRpb25EZWx0YSA9IG51bGwsIHRoaXMuX3BvaW50ZXJkb3duUG9zID0gbnVsbCwgdGhpcy5faXNEcmFnZ2luZyA9ICExLCB0aGlzLl9tYXAub2ZmKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW92ZSksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgXCJhY3RpdmVcIiA9PT0gdGhpcy5fc3RhdGUgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZHJhZ2VuZFwiKSksIHRoaXMuX3N0YXRlID0gXCJpbmFjdGl2ZVwiO1xuICAgICAgfSwgby5wcm90b3R5cGUuX2FkZERyYWdIYW5kbGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jb250YWlucyh0Lm9yaWdpbmFsRXZlbnQudGFyZ2V0KSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9wb3NpdGlvbkRlbHRhID0gdC5wb2ludC5zdWIodGhpcy5fcG9zKS5hZGQodGhpcy5fb2Zmc2V0KSwgdGhpcy5fcG9pbnRlcmRvd25Qb3MgPSB0LnBvaW50LCB0aGlzLl9zdGF0ZSA9IFwicGVuZGluZ1wiLCB0aGlzLl9tYXAub24oXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fbWFwLm9uKFwidG91Y2htb3ZlXCIsIHRoaXMuX29uTW92ZSksIHRoaXMuX21hcC5vbmNlKFwibW91c2V1cFwiLCB0aGlzLl9vblVwKSwgdGhpcy5fbWFwLm9uY2UoXCJ0b3VjaGVuZFwiLCB0aGlzLl9vblVwKSk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ2dhYmxlID0gISF0LCB0aGlzLl9tYXAgJiYgKHQgPyAodGhpcy5fbWFwLm9uKFwibW91c2Vkb3duXCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSwgdGhpcy5fbWFwLm9uKFwidG91Y2hzdGFydFwiLCB0aGlzLl9hZGREcmFnSGFuZGxlcikpIDogKHRoaXMuX21hcC5vZmYoXCJtb3VzZWRvd25cIiwgdGhpcy5fYWRkRHJhZ0hhbmRsZXIpLCB0aGlzLl9tYXAub2ZmKFwidG91Y2hzdGFydFwiLCB0aGlzLl9hZGREcmFnSGFuZGxlcikpKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmlzRHJhZ2dhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ2dhYmxlO1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb24gPSB0IHx8IDAsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnNldFJvdGF0aW9uQWxpZ25tZW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50ID0gdCB8fCBcImF1dG9cIiwgdGhpcy5fdXBkYXRlKCksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRSb3RhdGlvbkFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50O1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0UGl0Y2hBbGlnbm1lbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2hBbGlnbm1lbnQgPSB0ICYmIFwiYXV0b1wiICE9PSB0ID8gdCA6IHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50LCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmdldFBpdGNoQWxpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2hBbGlnbm1lbnQ7XG4gICAgICB9LCBvO1xuICAgIH0odC5FdmVudGVkKSxcbiAgICAgICAgT3IgPSB7XG4gICAgICBwb3NpdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiAhMSxcbiAgICAgICAgbWF4aW11bUFnZTogMCxcbiAgICAgICAgdGltZW91dDogNmUzXG4gICAgICB9LFxuICAgICAgZml0Qm91bmRzT3B0aW9uczoge1xuICAgICAgICBtYXhab29tOiAxNVxuICAgICAgfSxcbiAgICAgIHRyYWNrVXNlckxvY2F0aW9uOiAhMSxcbiAgICAgIHNob3dBY2N1cmFjeUNpcmNsZTogITAsXG4gICAgICBzaG93VXNlckxvY2F0aW9uOiAhMFxuICAgIH0sXG4gICAgICAgIEZyID0gMCxcbiAgICAgICAgVXIgPSAhMSxcbiAgICAgICAgTnIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gbyhpKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIE9yLCBpKSwgdC5iaW5kQWxsKFtcIl9vblN1Y2Nlc3NcIiwgXCJfb25FcnJvclwiLCBcIl9vblpvb21cIiwgXCJfZmluaXNoXCIsIFwiX3NldHVwVUlcIiwgXCJfdXBkYXRlQ2FtZXJhXCIsIFwiX3VwZGF0ZU1hcmtlclwiXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlICYmIChvLl9fcHJvdG9fXyA9IGUpLCAoby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IG8sIG8ucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAgPSBlLCB0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybCBtYXBsaWJyZWdsLWN0cmwtZ3JvdXBcIiksIG8gPSB0aGlzLl9zZXR1cFVJLCB2b2lkIDAgIT09IGtyID8gbyhrcikgOiB2b2lkIDAgIT09IHQud2luZG93Lm5hdmlnYXRvci5wZXJtaXNzaW9ucyA/IHQud2luZG93Lm5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XG4gICAgICAgICAgbmFtZTogXCJnZW9sb2NhdGlvblwiXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBvKGtyID0gXCJkZW5pZWRcIiAhPT0gdC5zdGF0ZSk7XG4gICAgICAgIH0pIDogbyhrciA9ICEhdC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uKSwgdGhpcy5fY29udGFpbmVyO1xuICAgICAgfSwgby5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZvaWQgMCAhPT0gdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEICYmICh0LndpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQpLCB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQgPSB2b2lkIDApLCB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIgJiYgdGhpcy5fdXNlckxvY2F0aW9uRG90TWFya2VyLnJlbW92ZSgpLCB0aGlzLm9wdGlvbnMuc2hvd0FjY3VyYWN5Q2lyY2xlICYmIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyICYmIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyLnJlbW92ZSgpLCBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwiem9vbVwiLCB0aGlzLl9vblpvb20pLCB0aGlzLl9tYXAgPSB2b2lkIDAsIEZyID0gMCwgVXIgPSAhMTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9pc091dE9mTWFwTWF4Qm91bmRzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9tYXAuZ2V0TWF4Qm91bmRzKCksXG4gICAgICAgICAgICBpID0gdC5jb29yZHM7XG5cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkubG9uZ2l0dWRlIDwgZS5nZXRXZXN0KCkgfHwgaS5sb25naXR1ZGUgPiBlLmdldEVhc3QoKSB8fCBpLmxhdGl0dWRlIDwgZS5nZXRTb3V0aCgpIHx8IGkubGF0aXR1ZGUgPiBlLmdldE5vcnRoKCkpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX3NldEVycm9yU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgXCJXQUlUSU5HX0FDVElWRVwiOlxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0VSUk9SXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0VSUk9SXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORFwiOlxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQkFDS0dST1VORF9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9LCBvLnByb3RvdHlwZS5fb25TdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pc091dE9mTWFwTWF4Qm91bmRzKGUpKSByZXR1cm4gdGhpcy5fc2V0RXJyb3JTdGF0ZSgpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJvdXRvZm1heGJvdW5kc1wiLCBlKSksIHRoaXMuX3VwZGF0ZU1hcmtlcigpLCB2b2lkIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIHN3aXRjaCAodGhpcy5fbGFzdEtub3duUG9zaXRpb24gPSBlLCB0aGlzLl93YXRjaFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiV0FJVElOR19BQ1RJVkVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9FUlJPUlwiOlxuICAgICAgICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJBQ1RJVkVfTE9DS1wiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJCQUNLR1JPVU5EXCI6XG4gICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJCQUNLR1JPVU5EXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZC1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIFwiT0ZGXCIgIT09IHRoaXMuX3dhdGNoU3RhdGUgJiYgdGhpcy5fdXBkYXRlTWFya2VyKGUpLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgXCJBQ1RJVkVfTE9DS1wiICE9PSB0aGlzLl93YXRjaFN0YXRlIHx8IHRoaXMuX3VwZGF0ZUNhbWVyYShlKSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5fZG90RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC11c2VyLWxvY2F0aW9uLWRvdC1zdGFsZVwiKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZ2VvbG9jYXRlXCIsIGUpKSwgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGVDYW1lcmEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSA9IG5ldyB0LkxuZ0xhdChlLmNvb3Jkcy5sb25naXR1ZGUsIGUuY29vcmRzLmxhdGl0dWRlKSxcbiAgICAgICAgICAgIG8gPSBlLmNvb3Jkcy5hY2N1cmFjeSxcbiAgICAgICAgICAgIHIgPSB0aGlzLl9tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgYSA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICBiZWFyaW5nOiByXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5maXRCb3VuZHNPcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9tYXAuZml0Qm91bmRzKGkudG9Cb3VuZHMobyksIGEsIHtcbiAgICAgICAgICBnZW9sb2NhdGVTb3VyY2U6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfSwgby5wcm90b3R5cGUuX3VwZGF0ZU1hcmtlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgdmFyIGkgPSBuZXcgdC5MbmdMYXQoZS5jb29yZHMubG9uZ2l0dWRlLCBlLmNvb3Jkcy5sYXRpdHVkZSk7XG4gICAgICAgICAgdGhpcy5fYWNjdXJhY3lDaXJjbGVNYXJrZXIuc2V0TG5nTGF0KGkpLmFkZFRvKHRoaXMuX21hcCksIHRoaXMuX3VzZXJMb2NhdGlvbkRvdE1hcmtlci5zZXRMbmdMYXQoaSkuYWRkVG8odGhpcy5fbWFwKSwgdGhpcy5fYWNjdXJhY3kgPSBlLmNvb3Jkcy5hY2N1cmFjeSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5vcHRpb25zLnNob3dBY2N1cmFjeUNpcmNsZSAmJiB0aGlzLl91cGRhdGVDaXJjbGVSYWRpdXMoKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuX3VzZXJMb2NhdGlvbkRvdE1hcmtlci5yZW1vdmUoKSwgdGhpcy5fYWNjdXJhY3lDaXJjbGVNYXJrZXIucmVtb3ZlKCk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fdXBkYXRlQ2lyY2xlUmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuX21hcC5fY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsXG4gICAgICAgICAgICBlID0gdGhpcy5fbWFwLnVucHJvamVjdChbMCwgdF0pLFxuICAgICAgICAgICAgaSA9IHRoaXMuX21hcC51bnByb2plY3QoWzEsIHRdKSxcbiAgICAgICAgICAgIG8gPSBlLmRpc3RhbmNlVG8oaSksXG4gICAgICAgICAgICByID0gTWF0aC5jZWlsKDIgKiB0aGlzLl9hY2N1cmFjeSAvIG8pO1xuXG4gICAgICAgIHRoaXMuX2NpcmNsZUVsZW1lbnQuc3R5bGUud2lkdGggPSByICsgXCJweFwiLCB0aGlzLl9jaXJjbGVFbGVtZW50LnN0eWxlLmhlaWdodCA9IHIgKyBcInB4XCI7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fb25ab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLm9wdGlvbnMuc2hvd0FjY3VyYWN5Q2lyY2xlICYmIHRoaXMuX3VwZGF0ZUNpcmNsZVJhZGl1cygpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbikgaWYgKDEgPT09IGUuY29kZSkge1xuICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiT0ZGXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5kaXNhYmxlZCA9ICEwO1xuXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJHZW9sb2NhdGVDb250cm9sLkxvY2F0aW9uTm90QXZhaWxhYmxlXCIpO1xuXG4gICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSBpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBpKSwgdm9pZCAwICE9PSB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQgJiYgdGhpcy5fY2xlYXJXYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoMyA9PT0gZS5jb2RlICYmIFVyKSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX3NldEVycm9yU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJPRkZcIiAhPT0gdGhpcy5fd2F0Y2hTdGF0ZSAmJiB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLl9kb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tZG90LXN0YWxlXCIpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJlcnJvclwiLCBlKSksIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICB9LCBvLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCksIHRoaXMuX3RpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9zZXR1cFVJID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbiA9IGkuY3JlYXRlKFwiYnV0dG9uXCIsIFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZVwiLCB0aGlzLl9jb250YWluZXIpLCBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBsaWJyZWdsLWN0cmwtaWNvblwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24pLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCAhMSA9PT0gZSkge1xuICAgICAgICAgIHQud2Fybk9uY2UoXCJHZW9sb2NhdGlvbiBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUgc28gdGhlIEdlb2xvY2F0ZUNvbnRyb2wgd2lsbCBiZSBkaXNhYmxlZC5cIik7XG5cbiAgICAgICAgICB2YXIgciA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJHZW9sb2NhdGVDb250cm9sLkxvY2F0aW9uTm90QXZhaWxhYmxlXCIpO1xuXG4gICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmRpc2FibGVkID0gITAsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi50aXRsZSA9IHIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIkdlb2xvY2F0ZUNvbnRyb2wuRmluZE15TG9jYXRpb25cIik7XG5cbiAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSBhLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiAodGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpLCB0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmICh0aGlzLl9kb3RFbGVtZW50ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tZG90XCIpLCB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIgPSBuZXcgQnIodGhpcy5fZG90RWxlbWVudCksIHRoaXMuX2NpcmNsZUVsZW1lbnQgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtdXNlci1sb2NhdGlvbi1hY2N1cmFjeS1jaXJjbGVcIiksIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyID0gbmV3IEJyKHtcbiAgICAgICAgICBlbGVtZW50OiB0aGlzLl9jaXJjbGVFbGVtZW50LFxuICAgICAgICAgIHBpdGNoQWxpZ25tZW50OiBcIm1hcFwiXG4gICAgICAgIH0pLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgKHRoaXMuX3dhdGNoU3RhdGUgPSBcIk9GRlwiKSwgdGhpcy5fbWFwLm9uKFwiem9vbVwiLCB0aGlzLl9vblpvb20pKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzKSksIHRoaXMuX3NldHVwID0gITAsIHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiB0aGlzLl9tYXAub24oXCJtb3Zlc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLmdlb2xvY2F0ZVNvdXJjZSB8fCBcIkFDVElWRV9MT0NLXCIgIT09IG8uX3dhdGNoU3RhdGUgfHwgZS5vcmlnaW5hbEV2ZW50ICYmIFwicmVzaXplXCIgPT09IGUub3JpZ2luYWxFdmVudC50eXBlIHx8IChvLl93YXRjaFN0YXRlID0gXCJCQUNLR1JPVU5EXCIsIG8uX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCBvLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCBvLmZpcmUobmV3IHQuRXZlbnQoXCJ0cmFja3VzZXJsb2NhdGlvbmVuZFwiKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2V0dXApIHJldHVybiB0Lndhcm5PbmNlKFwiR2VvbG9jYXRlIGNvbnRyb2wgdHJpZ2dlcmVkIGJlZm9yZSBhZGRlZCB0byBhIG1hcFwiKSwgITE7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbikge1xuICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJXQUlUSU5HX0FDVElWRVwiLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ0cmFja3VzZXJsb2NhdGlvbnN0YXJ0XCIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJXQUlUSU5HX0FDVElWRVwiOlxuICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9MT0NLXCI6XG4gICAgICAgICAgICBjYXNlIFwiQUNUSVZFX0VSUk9SXCI6XG4gICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICAgICAgICBGci0tLCBVciA9ICExLCB0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZC1lcnJvclwiKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25lbmRcIikpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkJBQ0tHUk9VTkRcIjpcbiAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0xPQ0tcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIiksIHRoaXMuX2xhc3RLbm93blBvc2l0aW9uICYmIHRoaXMuX3VwZGF0ZUNhbWVyYSh0aGlzLl9sYXN0S25vd25Qb3NpdGlvbiksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInRyYWNrdXNlcmxvY2F0aW9uc3RhcnRcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcIldBSVRJTkdfQUNUSVZFXCI6XG4gICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9MT0NLXCI6XG4gICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfRVJST1JcIjpcbiAgICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORFwiOlxuICAgICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKTtcblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkJBQ0tHUk9VTkRfRVJST1JcIjpcbiAgICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kLWVycm9yXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcIk9GRlwiID09PSB0aGlzLl93YXRjaFN0YXRlICYmIHZvaWQgMCAhPT0gdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEKSB0aGlzLl9jbGVhcldhdGNoKCk7ZWxzZSBpZiAodm9pZCAwID09PSB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQpIHtcbiAgICAgICAgICAgIHZhciBlO1xuICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIpLCArK0ZyID4gMSA/IChlID0ge1xuICAgICAgICAgICAgICBtYXhpbXVtQWdlOiA2ZTUsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDBcbiAgICAgICAgICAgIH0sIFVyID0gITApIDogKGUgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25PcHRpb25zLCBVciA9ICExKSwgdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEID0gdC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24odGhpcy5fb25TdWNjZXNzLCB0aGlzLl9vbkVycm9yLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB0LndpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHRoaXMuX29uU3VjY2VzcywgdGhpcy5fb25FcnJvciwgdGhpcy5vcHRpb25zLnBvc2l0aW9uT3B0aW9ucyksIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fZmluaXNoLCAxZTQpO1xuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9jbGVhcldhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0LndpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQpLCB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQgPSB2b2lkIDAsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIiksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIHRoaXMuX3VwZGF0ZU1hcmtlcihudWxsKTtcbiAgICAgIH0sIG87XG4gICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgICBaciA9IHtcbiAgICAgIG1heFdpZHRoOiAxMDAsXG4gICAgICB1bml0OiBcIm1ldHJpY1wiXG4gICAgfSxcbiAgICAgICAgcXIgPSBmdW5jdGlvbiBxcihlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgWnIsIGUpLCB0LmJpbmRBbGwoW1wiX29uTW92ZVwiLCBcInNldFVuaXRcIl0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBqcih0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IGkgJiYgaS5tYXhXaWR0aCB8fCAxMDAsXG4gICAgICAgICAgciA9IHQuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgLyAyLFxuICAgICAgICAgIGEgPSB0LnVucHJvamVjdChbMCwgcl0pLFxuICAgICAgICAgIG4gPSB0LnVucHJvamVjdChbbywgcl0pLFxuICAgICAgICAgIHMgPSBhLmRpc3RhbmNlVG8obik7XG5cbiAgICAgIGlmIChpICYmIFwiaW1wZXJpYWxcIiA9PT0gaS51bml0KSB7XG4gICAgICAgIHZhciBsID0gMy4yODA4ICogcztcbiAgICAgICAgbCA+IDUyODAgPyBWcihlLCBvLCBsIC8gNTI4MCwgdC5fZ2V0VUlTdHJpbmcoXCJTY2FsZUNvbnRyb2wuTWlsZXNcIikpIDogVnIoZSwgbywgbCwgdC5fZ2V0VUlTdHJpbmcoXCJTY2FsZUNvbnRyb2wuRmVldFwiKSk7XG4gICAgICB9IGVsc2UgaSAmJiBcIm5hdXRpY2FsXCIgPT09IGkudW5pdCA/IFZyKGUsIG8sIHMgLyAxODUyLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5OYXV0aWNhbE1pbGVzXCIpKSA6IHMgPj0gMWUzID8gVnIoZSwgbywgcyAvIDFlMywgdC5fZ2V0VUlTdHJpbmcoXCJTY2FsZUNvbnRyb2wuS2lsb21ldGVyc1wiKSkgOiBWcihlLCBvLCBzLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5NZXRlcnNcIikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFZyKHQsIGUsIGksIG8pIHtcbiAgICAgIHZhciByLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbixcbiAgICAgICAgICBzID0gKHIgPSBpLCAoYSA9IE1hdGgucG93KDEwLCAoXCJcIiArIE1hdGguZmxvb3IocikpLmxlbmd0aCAtIDEpKSAqIChuID0gKG4gPSByIC8gYSkgPj0gMTAgPyAxMCA6IG4gPj0gNSA/IDUgOiBuID49IDMgPyAzIDogbiA+PSAyID8gMiA6IG4gPj0gMSA/IDEgOiBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IE1hdGgucG93KDEwLCBNYXRoLmNlaWwoLU1hdGgubG9nKHQpIC8gTWF0aC5MTjEwKSk7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHQgKiBlKSAvIGU7XG4gICAgICB9KG4pKSk7XG4gICAgICB0LnN0eWxlLndpZHRoID0gZSAqIChzIC8gaSkgKyBcInB4XCIsIHQuaW5uZXJIVE1MID0gcyArIFwiJm5ic3A7XCIgKyBvO1xuICAgIH1cblxuICAgIHFyLnByb3RvdHlwZS5nZXREZWZhdWx0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJib3R0b20tbGVmdFwiO1xuICAgIH0sIHFyLnByb3RvdHlwZS5fb25Nb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAganIodGhpcy5fbWFwLCB0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgfSwgcXIucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAgPSB0LCB0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybCBtYXBsaWJyZWdsLWN0cmwtc2NhbGVcIiwgdC5nZXRDb250YWluZXIoKSksIHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fb25Nb3ZlKCksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LCBxci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl9vbk1vdmUpLCB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgfSwgcXIucHJvdG90eXBlLnNldFVuaXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVuaXQgPSB0LCBqcih0aGlzLl9tYXAsIHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIEdyID0gZnVuY3Rpb24gR3IoZSkge1xuICAgICAgdGhpcy5fZnVsbHNjcmVlbiA9ICExLCBlICYmIGUuY29udGFpbmVyICYmIChlLmNvbnRhaW5lciBpbnN0YW5jZW9mIHQud2luZG93LkhUTUxFbGVtZW50ID8gdGhpcy5fY29udGFpbmVyID0gZS5jb250YWluZXIgOiB0Lndhcm5PbmNlKFwiRnVsbCBzY3JlZW4gY29udHJvbCAnY29udGFpbmVyJyBtdXN0IGJlIGEgRE9NIGVsZW1lbnQuXCIpKSwgdC5iaW5kQWxsKFtcIl9vbkNsaWNrRnVsbHNjcmVlblwiLCBcIl9jaGFuZ2VJY29uXCJdLCB0aGlzKSwgXCJvbmZ1bGxzY3JlZW5jaGFuZ2VcIiBpbiB0LndpbmRvdy5kb2N1bWVudCA/IHRoaXMuX2Z1bGxzY3JlZW5jaGFuZ2UgPSBcImZ1bGxzY3JlZW5jaGFuZ2VcIiA6IFwib25tb3pmdWxsc2NyZWVuY2hhbmdlXCIgaW4gdC53aW5kb3cuZG9jdW1lbnQgPyB0aGlzLl9mdWxsc2NyZWVuY2hhbmdlID0gXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIgOiBcIm9ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiIGluIHQud2luZG93LmRvY3VtZW50ID8gdGhpcy5fZnVsbHNjcmVlbmNoYW5nZSA9IFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiIDogXCJvbm1zZnVsbHNjcmVlbmNoYW5nZVwiIGluIHQud2luZG93LmRvY3VtZW50ICYmICh0aGlzLl9mdWxsc2NyZWVuY2hhbmdlID0gXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIik7XG4gICAgfTtcblxuICAgIEdyLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwID0gZSwgdGhpcy5fY29udGFpbmVyIHx8ICh0aGlzLl9jb250YWluZXIgPSB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkpLCB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWN0cmwgbWFwbGlicmVnbC1jdHJsLWdyb3VwXCIpLCB0aGlzLl9jaGVja0Z1bGxzY3JlZW5TdXBwb3J0KCkgPyB0aGlzLl9zZXR1cFVJKCkgOiAodGhpcy5fY29udHJvbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHQud2Fybk9uY2UoXCJUaGlzIGRldmljZSBkb2VzIG5vdCBzdXBwb3J0IGZ1bGxzY3JlZW4gbW9kZS5cIikpLCB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xuICAgIH0sIEdyLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGkucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpLCB0aGlzLl9tYXAgPSBudWxsLCB0LndpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2Z1bGxzY3JlZW5jaGFuZ2UsIHRoaXMuX2NoYW5nZUljb24pO1xuICAgIH0sIEdyLnByb3RvdHlwZS5fY2hlY2tGdWxsc2NyZWVuU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhISh0LndpbmRvdy5kb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fCB0LndpbmRvdy5kb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fCB0LndpbmRvdy5kb2N1bWVudC5tc0Z1bGxzY3JlZW5FbmFibGVkIHx8IHQud2luZG93LmRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkKTtcbiAgICB9LCBHci5wcm90b3R5cGUuX3NldHVwVUkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1mdWxsc2NyZWVuXCIsIHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xuICAgICAgaS5jcmVhdGUoXCJzcGFuXCIsIFwibWFwbGlicmVnbC1jdHJsLWljb25cIiwgZSkuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCBlLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl91cGRhdGVUaXRsZSgpLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrRnVsbHNjcmVlbiksIHQud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZnVsbHNjcmVlbmNoYW5nZSwgdGhpcy5fY2hhbmdlSWNvbik7XG4gICAgfSwgR3IucHJvdG90eXBlLl91cGRhdGVUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fZ2V0VGl0bGUoKTtcblxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHQpLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLnRpdGxlID0gdDtcbiAgICB9LCBHci5wcm90b3R5cGUuX2dldFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcodGhpcy5faXNGdWxsc2NyZWVuKCkgPyBcIkZ1bGxzY3JlZW5Db250cm9sLkV4aXRcIiA6IFwiRnVsbHNjcmVlbkNvbnRyb2wuRW50ZXJcIik7XG4gICAgfSwgR3IucHJvdG90eXBlLl9pc0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnVsbHNjcmVlbjtcbiAgICB9LCBHci5wcm90b3R5cGUuX2NoYW5nZUljb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAodC53aW5kb3cuZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgdC53aW5kb3cuZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgdC53aW5kb3cuZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgdC53aW5kb3cuZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCkgPT09IHRoaXMuX2NvbnRhaW5lciAhPT0gdGhpcy5fZnVsbHNjcmVlbiAmJiAodGhpcy5fZnVsbHNjcmVlbiA9ICF0aGlzLl9mdWxsc2NyZWVuLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJtYXBsaWJyZWdsLWN0cmwtc2hyaW5rXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJtYXBsaWJyZWdsLWN0cmwtZnVsbHNjcmVlblwiKSwgdGhpcy5fdXBkYXRlVGl0bGUoKSk7XG4gICAgfSwgR3IucHJvdG90eXBlLl9vbkNsaWNrRnVsbHNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2lzRnVsbHNjcmVlbigpID8gdC53aW5kb3cuZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4gPyB0LndpbmRvdy5kb2N1bWVudC5leGl0RnVsbHNjcmVlbigpIDogdC53aW5kb3cuZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbiA/IHQud2luZG93LmRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKSA6IHQud2luZG93LmRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4gPyB0LndpbmRvdy5kb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCkgOiB0LndpbmRvdy5kb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuICYmIHQud2luZG93LmRvY3VtZW50LndlYmtpdENhbmNlbEZ1bGxTY3JlZW4oKSA6IHRoaXMuX2NvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbiA/IHRoaXMuX2NvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbigpIDogdGhpcy5fY29udGFpbmVyLm1velJlcXVlc3RGdWxsU2NyZWVuID8gdGhpcy5fY29udGFpbmVyLm1velJlcXVlc3RGdWxsU2NyZWVuKCkgOiB0aGlzLl9jb250YWluZXIubXNSZXF1ZXN0RnVsbHNjcmVlbiA/IHRoaXMuX2NvbnRhaW5lci5tc1JlcXVlc3RGdWxsc2NyZWVuKCkgOiB0aGlzLl9jb250YWluZXIud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gJiYgdGhpcy5fY29udGFpbmVyLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgfTtcblxuICAgIHZhciBXciA9IHtcbiAgICAgIGNsb3NlQnV0dG9uOiAhMCxcbiAgICAgIGNsb3NlT25DbGljazogITAsXG4gICAgICBmb2N1c0FmdGVyT3BlbjogITAsXG4gICAgICBjbGFzc05hbWU6IFwiXCIsXG4gICAgICBtYXhXaWR0aDogXCIyNDBweFwiXG4gICAgfSxcbiAgICAgICAgWHIgPSBbXCJhW2hyZWZdXCIsIFwiW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PSctMSddKVwiLCBcIltjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSdmYWxzZSddKVwiLCBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIiwgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIiwgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCJdLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgSHIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gbyhpKSB7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoT2JqZWN0LmNyZWF0ZShXciksIGkpLCB0LmJpbmRBbGwoW1wiX3VwZGF0ZVwiLCBcIl9vbkNsb3NlXCIsIFwicmVtb3ZlXCIsIFwiX29uTW91c2VNb3ZlXCIsIFwiX29uTW91c2VVcFwiLCBcIl9vbkRyYWdcIl0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZSAmJiAoby5fX3Byb3RvX18gPSBlKSwgKG8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBvLCBvLnByb3RvdHlwZS5hZGRUbyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAgJiYgdGhpcy5yZW1vdmUoKSwgdGhpcy5fbWFwID0gZSwgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiB0aGlzLl9tYXAub24oXCJjbGlja1wiLCB0aGlzLl9vbkNsb3NlKSwgdGhpcy5vcHRpb25zLmNsb3NlT25Nb3ZlICYmIHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fb25DbG9zZSksIHRoaXMuX21hcC5vbihcInJlbW92ZVwiLCB0aGlzLnJlbW92ZSksIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9mb2N1c0ZpcnN0RWxlbWVudCgpLCB0aGlzLl90cmFja1BvaW50ZXIgPyAodGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKSwgdGhpcy5fbWFwLm9uKFwibW91c2V1cFwiLCB0aGlzLl9vbk1vdXNlVXApLCB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiksIHRoaXMuX21hcC5fY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXRyYWNrLXBvaW50ZXJcIikpIDogdGhpcy5fbWFwLm9uKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJvcGVuXCIpKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbWFwO1xuICAgICAgfSwgby5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudCAmJiBpLnJlbW92ZSh0aGlzLl9jb250ZW50KSwgdGhpcy5fY29udGFpbmVyICYmIChpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCBkZWxldGUgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwICYmICh0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl9vbkNsb3NlKSwgdGhpcy5fbWFwLm9mZihcImNsaWNrXCIsIHRoaXMuX29uQ2xvc2UpLCB0aGlzLl9tYXAub2ZmKFwicmVtb3ZlXCIsIHRoaXMucmVtb3ZlKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSksIHRoaXMuX21hcC5vZmYoXCJtb3VzZXVwXCIsIHRoaXMuX29uTW91c2VVcCksIHRoaXMuX21hcC5vZmYoXCJkcmFnXCIsIHRoaXMuX29uRHJhZyksIGRlbGV0ZSB0aGlzLl9tYXApLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJjbG9zZVwiKSksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRMbmdMYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sbmdMYXQ7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRMbmdMYXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG5nTGF0ID0gdC5MbmdMYXQuY29udmVydChlKSwgdGhpcy5fcG9zID0gbnVsbCwgdGhpcy5fdHJhY2tQb2ludGVyID0gITEsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9tYXAgJiYgKHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSksIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtcG9wdXAtdHJhY2stcG9pbnRlclwiKSwgdGhpcy5fbWFwLl9jYW52YXNDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtdHJhY2stcG9pbnRlclwiKSksIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS50cmFja1BvaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja1BvaW50ZXIgPSAhMCwgdGhpcy5fcG9zID0gbnVsbCwgdGhpcy5fdXBkYXRlKCksIHRoaXMuX21hcCAmJiAodGhpcy5fbWFwLm9mZihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKSwgdGhpcy5fbWFwLm9uKFwiZHJhZ1wiLCB0aGlzLl9vbkRyYWcpLCB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiksIHRoaXMuX21hcC5fY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXRyYWNrLXBvaW50ZXJcIikpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRET01Db250ZW50KHQud2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUpKTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLnNldEhUTUwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG8gPSB0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICByID0gdC53aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJvZHlcIik7XG5cbiAgICAgICAgZm9yIChyLmlubmVySFRNTCA9IGU7IGkgPSByLmZpcnN0Q2hpbGQ7KSB7XG4gICAgICAgICAgby5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNldERPTUNvbnRlbnQobyk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5nZXRNYXhXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuc3R5bGUubWF4V2lkdGg7XG4gICAgICB9LCBvLnByb3RvdHlwZS5zZXRNYXhXaWR0aCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWF4V2lkdGggPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLnNldERPTUNvbnRlbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudCkgZm9yICg7IHRoaXMuX2NvbnRlbnQuaGFzQ2hpbGROb2RlcygpOykge1xuICAgICAgICAgIHRoaXMuX2NvbnRlbnQuZmlyc3RDaGlsZCAmJiB0aGlzLl9jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLl9jb250ZW50ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXBvcHVwLWNvbnRlbnRcIiwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQuYXBwZW5kQ2hpbGQodCksIHRoaXMuX2NyZWF0ZUNsb3NlQnV0dG9uKCksIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9mb2N1c0ZpcnN0RWxlbWVudCgpLCB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHQpO1xuICAgICAgfSwgby5wcm90b3R5cGUucmVtb3ZlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHQpO1xuICAgICAgfSwgby5wcm90b3R5cGUuc2V0T2Zmc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vZmZzZXQgPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLnRvZ2dsZUNsYXNzTmFtZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHJldHVybiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZSh0KTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl9jcmVhdGVDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uICYmICh0aGlzLl9jbG9zZUJ1dHRvbiA9IGkuY3JlYXRlKFwiYnV0dG9uXCIsIFwibWFwbGlicmVnbC1wb3B1cC1jbG9zZS1idXR0b25cIiwgdGhpcy5fY29udGVudCksIHRoaXMuX2Nsb3NlQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl9jbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2UgcG9wdXBcIiksIHRoaXMuX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IFwiJiMyMTU7XCIsIHRoaXMuX2Nsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsb3NlKSk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHQucG9pbnQpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHQucG9pbnQpO1xuICAgICAgfSwgby5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0LnBvaW50KTtcbiAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCAmJiAodGhpcy5fbG5nTGF0IHx8IHRoaXMuX3RyYWNrUG9pbnRlcikgJiYgdGhpcy5fY29udGVudCAmJiAodGhpcy5fY29udGFpbmVyIHx8ICh0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtcG9wdXBcIiwgdGhpcy5fbWFwLmdldENvbnRhaW5lcigpKSwgdGhpcy5fdGlwID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXBvcHVwLXRpcFwiLCB0aGlzLl9jb250YWluZXIpLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY29udGVudCksIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgJiYgdGhpcy5vcHRpb25zLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBvLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0KTtcbiAgICAgICAgfSksIHRoaXMuX3RyYWNrUG9pbnRlciAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtcG9wdXAtdHJhY2stcG9pbnRlclwiKSksIHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiB0aGlzLl9jb250YWluZXIuc3R5bGUubWF4V2lkdGggIT09IHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiAodGhpcy5fY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gdGhpcy5vcHRpb25zLm1heFdpZHRoKSwgdGhpcy5fbWFwLnRyYW5zZm9ybS5yZW5kZXJXb3JsZENvcGllcyAmJiAhdGhpcy5fdHJhY2tQb2ludGVyICYmICh0aGlzLl9sbmdMYXQgPSBNcih0aGlzLl9sbmdMYXQsIHRoaXMuX3BvcywgdGhpcy5fbWFwLnRyYW5zZm9ybSkpLCAhdGhpcy5fdHJhY2tQb2ludGVyIHx8IGUpKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9wb3MgPSB0aGlzLl90cmFja1BvaW50ZXIgJiYgZSA/IGUgOiB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sbmdMYXQpLFxuICAgICAgICAgICAgICBhID0gdGhpcy5vcHRpb25zLmFuY2hvcixcbiAgICAgICAgICAgICAgbiA9IGZ1bmN0aW9uIGUoaSkge1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KC41ICogTWF0aC5wb3coaSwgMikpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY2VudGVyOiBuZXcgdC5Qb2ludCgwLCAwKSxcbiAgICAgICAgICAgICAgICAgIHRvcDogbmV3IHQuUG9pbnQoMCwgaSksXG4gICAgICAgICAgICAgICAgICBcInRvcC1sZWZ0XCI6IG5ldyB0LlBvaW50KG8sIG8pLFxuICAgICAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogbmV3IHQuUG9pbnQoLW8sIG8pLFxuICAgICAgICAgICAgICAgICAgYm90dG9tOiBuZXcgdC5Qb2ludCgwLCAtaSksXG4gICAgICAgICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IG5ldyB0LlBvaW50KG8sIC1vKSxcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IG5ldyB0LlBvaW50KC1vLCAtbyksXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBuZXcgdC5Qb2ludChpLCAwKSxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXcgdC5Qb2ludCgtaSwgMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGkgaW5zdGFuY2VvZiB0LlBvaW50IHx8IEFycmF5LmlzQXJyYXkoaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHQuUG9pbnQuY29udmVydChpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY2VudGVyOiByLFxuICAgICAgICAgICAgICAgICAgdG9wOiByLFxuICAgICAgICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiByLFxuICAgICAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogcixcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogcixcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogcixcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiByLFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IHQuUG9pbnQuY29udmVydChpLmNlbnRlciB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIHRvcDogdC5Qb2ludC5jb252ZXJ0KGkudG9wIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiB0LlBvaW50LmNvbnZlcnQoaVtcInRvcC1sZWZ0XCJdIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogdC5Qb2ludC5jb252ZXJ0KGlbXCJ0b3AtcmlnaHRcIl0gfHwgWzAsIDBdKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHQuUG9pbnQuY29udmVydChpLmJvdHRvbSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogdC5Qb2ludC5jb252ZXJ0KGlbXCJib3R0b20tbGVmdFwiXSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHQuUG9pbnQuY29udmVydChpW1wiYm90dG9tLXJpZ2h0XCJdIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgbGVmdDogdC5Qb2ludC5jb252ZXJ0KGkubGVmdCB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0LlBvaW50LmNvbnZlcnQoaS5yaWdodCB8fCBbMCwgMF0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlKG5ldyB0LlBvaW50KDAsIDApKTtcbiAgICAgICAgICB9KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xuXG4gICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICB2YXIgcyxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgcyA9IHIueSArIG4uYm90dG9tLnkgPCBjID8gW1widG9wXCJdIDogci55ID4gdGhpcy5fbWFwLnRyYW5zZm9ybS5oZWlnaHQgLSBjID8gW1wiYm90dG9tXCJdIDogW10sIHIueCA8IGwgLyAyID8gcy5wdXNoKFwibGVmdFwiKSA6IHIueCA+IHRoaXMuX21hcC50cmFuc2Zvcm0ud2lkdGggLSBsIC8gMiAmJiBzLnB1c2goXCJyaWdodFwiKSwgYSA9IDAgPT09IHMubGVuZ3RoID8gXCJib3R0b21cIiA6IHMuam9pbihcIi1cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHUgPSByLmFkZChuW2FdKS5yb3VuZCgpO1xuICAgICAgICAgIGkuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgTHJbYV0gKyBcIiB0cmFuc2xhdGUoXCIgKyB1LnggKyBcInB4LFwiICsgdS55ICsgXCJweClcIiksIFJyKHRoaXMuX2NvbnRhaW5lciwgYSwgXCJwb3B1cFwiKTtcbiAgICAgICAgfVxuICAgICAgfSwgby5wcm90b3R5cGUuX2ZvY3VzRmlyc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvY3VzQWZ0ZXJPcGVuICYmIHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoWHIpO1xuXG4gICAgICAgICAgdCAmJiB0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIG8ucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfSwgbztcbiAgICB9KHQuRXZlbnRlZCksXG4gICAgICAgIEtyID0ge1xuICAgICAgdmVyc2lvbjogdC52ZXJzaW9uLFxuICAgICAgc3VwcG9ydGVkOiBlLFxuICAgICAgc2V0UlRMVGV4dFBsdWdpbjogdC5zZXRSVExUZXh0UGx1Z2luLFxuICAgICAgZ2V0UlRMVGV4dFBsdWdpblN0YXR1czogdC5nZXRSVExUZXh0UGx1Z2luU3RhdHVzLFxuICAgICAgTWFwOiBTcixcbiAgICAgIE5hdmlnYXRpb25Db250cm9sOiBEcixcbiAgICAgIEdlb2xvY2F0ZUNvbnRyb2w6IE5yLFxuICAgICAgQXR0cmlidXRpb25Db250cm9sOiB5cixcbiAgICAgIFNjYWxlQ29udHJvbDogcXIsXG4gICAgICBGdWxsc2NyZWVuQ29udHJvbDogR3IsXG4gICAgICBQb3B1cDogSHIsXG4gICAgICBNYXJrZXI6IEJyLFxuICAgICAgU3R5bGU6IGplLFxuICAgICAgTG5nTGF0OiB0LkxuZ0xhdCxcbiAgICAgIExuZ0xhdEJvdW5kczogdC5MbmdMYXRCb3VuZHMsXG4gICAgICBQb2ludDogdC5Qb2ludCxcbiAgICAgIE1lcmNhdG9yQ29vcmRpbmF0ZTogdC5NZXJjYXRvckNvb3JkaW5hdGUsXG4gICAgICBFdmVudGVkOiB0LkV2ZW50ZWQsXG4gICAgICBjb25maWc6IHQuY29uZmlnLFxuICAgICAgcHJld2FybTogZnVuY3Rpb24gcHJld2FybSgpIHtcbiAgICAgICAgRnQoKS5hY3F1aXJlKFJ0KTtcbiAgICAgIH0sXG4gICAgICBjbGVhclByZXdhcm1lZFJlc291cmNlczogZnVuY3Rpb24gY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXMoKSB7XG4gICAgICAgIHZhciB0ID0gQnQ7XG4gICAgICAgIHQgJiYgKHQuaXNQcmVsb2FkZWQoKSAmJiAxID09PSB0Lm51bUFjdGl2ZSgpID8gKHQucmVsZWFzZShSdCksIEJ0ID0gbnVsbCkgOiBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgY2xlYXIgV2ViV29ya2VycyBzaW5jZSB0aGVyZSBhcmUgYWN0aXZlIE1hcCBpbnN0YW5jZXMgdGhhdCBzdGlsbCByZWZlcmVuY2UgaXQuIFRoZSBwcmUtd2FybWVkIFdlYldvcmtlciBwb29sIGNhbiBvbmx5IGJlIGNsZWFyZWQgd2hlbiBhbGwgbWFwIGluc3RhbmNlcyBoYXZlIGJlZW4gcmVtb3ZlZCB3aXRoIG1hcC5yZW1vdmUoKVwiKSk7XG4gICAgICB9LFxuXG4gICAgICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0LmNvbmZpZy5BQ0NFU1NfVE9LRU47XG4gICAgICB9LFxuXG4gICAgICBzZXQgYWNjZXNzVG9rZW4oZSkge1xuICAgICAgICB0LmNvbmZpZy5BQ0NFU1NfVE9LRU4gPSBlO1xuICAgICAgfSxcblxuICAgICAgZ2V0IGJhc2VBcGlVcmwoKSB7XG4gICAgICAgIHJldHVybiB0LmNvbmZpZy5BUElfVVJMO1xuICAgICAgfSxcblxuICAgICAgc2V0IGJhc2VBcGlVcmwoZSkge1xuICAgICAgICB0LmNvbmZpZy5BUElfVVJMID0gZTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCB3b3JrZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIGt0LndvcmtlckNvdW50O1xuICAgICAgfSxcblxuICAgICAgc2V0IHdvcmtlckNvdW50KHQpIHtcbiAgICAgICAga3Qud29ya2VyQ291bnQgPSB0O1xuICAgICAgfSxcblxuICAgICAgZ2V0IG1heFBhcmFsbGVsSW1hZ2VSZXF1ZXN0cygpIHtcbiAgICAgICAgcmV0dXJuIHQuY29uZmlnLk1BWF9QQVJBTExFTF9JTUFHRV9SRVFVRVNUUztcbiAgICAgIH0sXG5cbiAgICAgIHNldCBtYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMoZSkge1xuICAgICAgICB0LmNvbmZpZy5NQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFMgPSBlO1xuICAgICAgfSxcblxuICAgICAgY2xlYXJTdG9yYWdlOiBmdW5jdGlvbiBjbGVhclN0b3JhZ2UoZSkge1xuICAgICAgICB0LmNsZWFyVGlsZUNhY2hlKGUpO1xuICAgICAgfSxcbiAgICAgIHdvcmtlclVybDogXCJcIixcbiAgICAgIGFkZFByb3RvY29sOiBmdW5jdGlvbiBhZGRQcm90b2NvbChlLCBpKSB7XG4gICAgICAgIHQuY29uZmlnLlJFR0lTVEVSRURfUFJPVE9DT0xTW2VdID0gaTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVQcm90b2NvbDogZnVuY3Rpb24gcmVtb3ZlUHJvdG9jb2woZSkge1xuICAgICAgICBkZWxldGUgdC5jb25maWcuUkVHSVNURVJFRF9QUk9UT0NPTFNbZV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBLcjtcbiAgfSk7IC8vXG5cbiAgcmV0dXJuIG1hcGxpYnJlZ2w7XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9910\n')}}]);