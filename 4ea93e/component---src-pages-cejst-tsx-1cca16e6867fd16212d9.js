(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[281],{3873:function(module){eval("/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2019, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  var limit = function limit(x, min, max) {\n    if (min === void 0) min = 0;\n    if (max === void 0) max = 1;\n    return x < min ? min : x > max ? max : x;\n  };\n\n  var clip_rgb = function clip_rgb(rgb) {\n    rgb._clipped = false;\n    rgb._unclipped = rgb.slice(0);\n\n    for (var i = 0; i <= 3; i++) {\n      if (i < 3) {\n        if (rgb[i] < 0 || rgb[i] > 255) {\n          rgb._clipped = true;\n        }\n\n        rgb[i] = limit(rgb[i], 0, 255);\n      } else if (i === 3) {\n        rgb[i] = limit(rgb[i], 0, 1);\n      }\n    }\n\n    return rgb;\n  }; // ported from jQuery's $.type\n\n\n  var classToType = {};\n\n  for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\n    var name = list[i];\n    classToType[\"[object \" + name + \"]\"] = name.toLowerCase();\n  }\n\n  var type = function type(obj) {\n    return classToType[Object.prototype.toString.call(obj)] || \"object\";\n  };\n\n  var unpack = function unpack(args, keyOrder) {\n    if (keyOrder === void 0) keyOrder = null; // if called with more than 3 arguments, we return the arguments\n\n    if (args.length >= 3) {\n      return Array.prototype.slice.call(args);\n    } // with less than 3 args we check if first arg is object\n    // and use the keyOrder string to extract and sort properties\n\n\n    if (type(args[0]) == 'object' && keyOrder) {\n      return keyOrder.split('').filter(function (k) {\n        return args[0][k] !== undefined;\n      }).map(function (k) {\n        return args[0][k];\n      });\n    } // otherwise we just return the first argument\n    // (which we suppose is an array of args)\n\n\n    return args[0];\n  };\n\n  var last = function last(args) {\n    if (args.length < 2) {\n      return null;\n    }\n\n    var l = args.length - 1;\n\n    if (type(args[l]) == 'string') {\n      return args[l].toLowerCase();\n    }\n\n    return null;\n  };\n\n  var PI = Math.PI;\n  var utils = {\n    clip_rgb: clip_rgb,\n    limit: limit,\n    type: type,\n    unpack: unpack,\n    last: last,\n    PI: PI,\n    TWOPI: PI * 2,\n    PITHIRD: PI / 3,\n    DEG2RAD: PI / 180,\n    RAD2DEG: 180 / PI\n  };\n  var input = {\n    format: {},\n    autodetect: []\n  };\n  var last$1 = utils.last;\n  var clip_rgb$1 = utils.clip_rgb;\n  var type$1 = utils.type;\n\n  var Color = function Color() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var me = this;\n\n    if (type$1(args[0]) === 'object' && args[0].constructor && args[0].constructor === this.constructor) {\n      // the argument is already a Color instance\n      return args[0];\n    } // last argument could be the mode\n\n\n    var mode = last$1(args);\n    var autodetect = false;\n\n    if (!mode) {\n      autodetect = true;\n\n      if (!input.sorted) {\n        input.autodetect = input.autodetect.sort(function (a, b) {\n          return b.p - a.p;\n        });\n        input.sorted = true;\n      } // auto-detect format\n\n\n      for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n        var chk = list[i];\n        mode = chk.test.apply(chk, args);\n\n        if (mode) {\n          break;\n        }\n      }\n    }\n\n    if (input.format[mode]) {\n      var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));\n      me._rgb = clip_rgb$1(rgb);\n    } else {\n      throw new Error('unknown format: ' + args);\n    } // add alpha channel\n\n\n    if (me._rgb.length === 3) {\n      me._rgb.push(1);\n    }\n  };\n\n  Color.prototype.toString = function toString() {\n    if (type$1(this.hex) == 'function') {\n      return this.hex();\n    }\n\n    return \"[\" + this._rgb.join(',') + \"]\";\n  };\n\n  var Color_1 = Color;\n\n  var chroma = function chroma() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(chroma.Color, [null].concat(args)))();\n  };\n\n  chroma.Color = Color_1;\n  chroma.version = '2.1.2';\n  var chroma_1 = chroma;\n  var unpack$1 = utils.unpack;\n  var max = Math.max;\n\n  var rgb2cmyk = function rgb2cmyk() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$1(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    r = r / 255;\n    g = g / 255;\n    b = b / 255;\n    var k = 1 - max(r, max(g, b));\n    var f = k < 1 ? 1 / (1 - k) : 0;\n    var c = (1 - r - k) * f;\n    var m = (1 - g - k) * f;\n    var y = (1 - b - k) * f;\n    return [c, m, y, k];\n  };\n\n  var rgb2cmyk_1 = rgb2cmyk;\n  var unpack$2 = utils.unpack;\n\n  var cmyk2rgb = function cmyk2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$2(args, 'cmyk');\n    var c = args[0];\n    var m = args[1];\n    var y = args[2];\n    var k = args[3];\n    var alpha = args.length > 4 ? args[4] : 1;\n\n    if (k === 1) {\n      return [0, 0, 0, alpha];\n    }\n\n    return [c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r\n    m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g\n    y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b\n    alpha];\n  };\n\n  var cmyk2rgb_1 = cmyk2rgb;\n  var unpack$3 = utils.unpack;\n  var type$2 = utils.type;\n\n  Color_1.prototype.cmyk = function () {\n    return rgb2cmyk_1(this._rgb);\n  };\n\n  chroma_1.cmyk = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['cmyk'])))();\n  };\n\n  input.format.cmyk = cmyk2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$3(args, 'cmyk');\n\n      if (type$2(args) === 'array' && args.length === 4) {\n        return 'cmyk';\n      }\n    }\n  });\n  var unpack$4 = utils.unpack;\n  var last$2 = utils.last;\n\n  var rnd = function rnd(a) {\n    return Math.round(a * 100) / 100;\n  };\n  /*\n   * supported arguments:\n   * - hsl2css(h,s,l)\n   * - hsl2css(h,s,l,a)\n   * - hsl2css([h,s,l], mode)\n   * - hsl2css([h,s,l,a], mode)\n   * - hsl2css({h,s,l,a}, mode)\n   */\n\n\n  var hsl2css = function hsl2css() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var hsla = unpack$4(args, 'hsla');\n    var mode = last$2(args) || 'lsa';\n    hsla[0] = rnd(hsla[0] || 0);\n    hsla[1] = rnd(hsla[1] * 100) + '%';\n    hsla[2] = rnd(hsla[2] * 100) + '%';\n\n    if (mode === 'hsla' || hsla.length > 3 && hsla[3] < 1) {\n      hsla[3] = hsla.length > 3 ? hsla[3] : 1;\n      mode = 'hsla';\n    } else {\n      hsla.length = 3;\n    }\n\n    return mode + \"(\" + hsla.join(',') + \")\";\n  };\n\n  var hsl2css_1 = hsl2css;\n  var unpack$5 = utils.unpack;\n  /*\n   * supported arguments:\n   * - rgb2hsl(r,g,b)\n   * - rgb2hsl(r,g,b,a)\n   * - rgb2hsl([r,g,b])\n   * - rgb2hsl([r,g,b,a])\n   * - rgb2hsl({r,g,b,a})\n   */\n\n  var rgb2hsl = function rgb2hsl() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$5(args, 'rgba');\n    var r = args[0];\n    var g = args[1];\n    var b = args[2];\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var l = (max + min) / 2;\n    var s, h;\n\n    if (max === min) {\n      s = 0;\n      h = Number.NaN;\n    } else {\n      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n    }\n\n    if (r == max) {\n      h = (g - b) / (max - min);\n    } else if (g == max) {\n      h = 2 + (b - r) / (max - min);\n    } else if (b == max) {\n      h = 4 + (r - g) / (max - min);\n    }\n\n    h *= 60;\n\n    if (h < 0) {\n      h += 360;\n    }\n\n    if (args.length > 3 && args[3] !== undefined) {\n      return [h, s, l, args[3]];\n    }\n\n    return [h, s, l];\n  };\n\n  var rgb2hsl_1 = rgb2hsl;\n  var unpack$6 = utils.unpack;\n  var last$3 = utils.last;\n  var round = Math.round;\n  /*\n   * supported arguments:\n   * - rgb2css(r,g,b)\n   * - rgb2css(r,g,b,a)\n   * - rgb2css([r,g,b], mode)\n   * - rgb2css([r,g,b,a], mode)\n   * - rgb2css({r,g,b,a}, mode)\n   */\n\n  var rgb2css = function rgb2css() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgba = unpack$6(args, 'rgba');\n    var mode = last$3(args) || 'rgb';\n\n    if (mode.substr(0, 3) == 'hsl') {\n      return hsl2css_1(rgb2hsl_1(rgba), mode);\n    }\n\n    rgba[0] = round(rgba[0]);\n    rgba[1] = round(rgba[1]);\n    rgba[2] = round(rgba[2]);\n\n    if (mode === 'rgba' || rgba.length > 3 && rgba[3] < 1) {\n      rgba[3] = rgba.length > 3 ? rgba[3] : 1;\n      mode = 'rgba';\n    }\n\n    return mode + \"(\" + rgba.slice(0, mode === 'rgb' ? 3 : 4).join(',') + \")\";\n  };\n\n  var rgb2css_1 = rgb2css;\n  var unpack$7 = utils.unpack;\n  var round$1 = Math.round;\n\n  var hsl2rgb = function hsl2rgb() {\n    var assign;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$7(args, 'hsl');\n    var h = args[0];\n    var s = args[1];\n    var l = args[2];\n    var r, g, b;\n\n    if (s === 0) {\n      r = g = b = l * 255;\n    } else {\n      var t3 = [0, 0, 0];\n      var c = [0, 0, 0];\n      var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var t1 = 2 * l - t2;\n      var h_ = h / 360;\n      t3[0] = h_ + 1 / 3;\n      t3[1] = h_;\n      t3[2] = h_ - 1 / 3;\n\n      for (var i = 0; i < 3; i++) {\n        if (t3[i] < 0) {\n          t3[i] += 1;\n        }\n\n        if (t3[i] > 1) {\n          t3[i] -= 1;\n        }\n\n        if (6 * t3[i] < 1) {\n          c[i] = t1 + (t2 - t1) * 6 * t3[i];\n        } else if (2 * t3[i] < 1) {\n          c[i] = t2;\n        } else if (3 * t3[i] < 2) {\n          c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;\n        } else {\n          c[i] = t1;\n        }\n      }\n\n      assign = [round$1(c[0] * 255), round$1(c[1] * 255), round$1(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2];\n    }\n\n    if (args.length > 3) {\n      // keep alpha channel\n      return [r, g, b, args[3]];\n    }\n\n    return [r, g, b, 1];\n  };\n\n  var hsl2rgb_1 = hsl2rgb;\n  var RE_RGB = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n  var RE_RGBA = /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var RE_RGB_PCT = /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var RE_RGBA_PCT = /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var RE_HSL = /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var RE_HSLA = /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var round$2 = Math.round;\n\n  var css2rgb = function css2rgb(css) {\n    css = css.toLowerCase().trim();\n    var m;\n\n    if (input.format.named) {\n      try {\n        return input.format.named(css);\n      } catch (e) {// eslint-disable-next-line\n      }\n    } // rgb(250,20,0)\n\n\n    if (m = css.match(RE_RGB)) {\n      var rgb = m.slice(1, 4);\n\n      for (var i = 0; i < 3; i++) {\n        rgb[i] = +rgb[i];\n      }\n\n      rgb[3] = 1; // default alpha\n\n      return rgb;\n    } // rgba(250,20,0,0.4)\n\n\n    if (m = css.match(RE_RGBA)) {\n      var rgb$1 = m.slice(1, 5);\n\n      for (var i$1 = 0; i$1 < 4; i$1++) {\n        rgb$1[i$1] = +rgb$1[i$1];\n      }\n\n      return rgb$1;\n    } // rgb(100%,0%,0%)\n\n\n    if (m = css.match(RE_RGB_PCT)) {\n      var rgb$2 = m.slice(1, 4);\n\n      for (var i$2 = 0; i$2 < 3; i$2++) {\n        rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\n      }\n\n      rgb$2[3] = 1; // default alpha\n\n      return rgb$2;\n    } // rgba(100%,0%,0%,0.4)\n\n\n    if (m = css.match(RE_RGBA_PCT)) {\n      var rgb$3 = m.slice(1, 5);\n\n      for (var i$3 = 0; i$3 < 3; i$3++) {\n        rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\n      }\n\n      rgb$3[3] = +rgb$3[3];\n      return rgb$3;\n    } // hsl(0,100%,50%)\n\n\n    if (m = css.match(RE_HSL)) {\n      var hsl = m.slice(1, 4);\n      hsl[1] *= 0.01;\n      hsl[2] *= 0.01;\n      var rgb$4 = hsl2rgb_1(hsl);\n      rgb$4[3] = 1;\n      return rgb$4;\n    } // hsla(0,100%,50%,0.5)\n\n\n    if (m = css.match(RE_HSLA)) {\n      var hsl$1 = m.slice(1, 4);\n      hsl$1[1] *= 0.01;\n      hsl$1[2] *= 0.01;\n      var rgb$5 = hsl2rgb_1(hsl$1);\n      rgb$5[3] = +m[4]; // default alpha = 1\n\n      return rgb$5;\n    }\n  };\n\n  css2rgb.test = function (s) {\n    return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);\n  };\n\n  var css2rgb_1 = css2rgb;\n  var type$3 = utils.type;\n\n  Color_1.prototype.css = function (mode) {\n    return rgb2css_1(this._rgb, mode);\n  };\n\n  chroma_1.css = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['css'])))();\n  };\n\n  input.format.css = css2rgb_1;\n  input.autodetect.push({\n    p: 5,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\n        return 'css';\n      }\n    }\n  });\n  var unpack$8 = utils.unpack;\n\n  input.format.gl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgb = unpack$8(args, 'rgba');\n    rgb[0] *= 255;\n    rgb[1] *= 255;\n    rgb[2] *= 255;\n    return rgb;\n  };\n\n  chroma_1.gl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['gl'])))();\n  };\n\n  Color_1.prototype.gl = function () {\n    var rgb = this._rgb;\n    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];\n  };\n\n  var unpack$9 = utils.unpack;\n\n  var rgb2hcg = function rgb2hcg() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$9(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var c = delta * 100 / 255;\n\n    var _g = min / (255 - delta) * 100;\n\n    var h;\n\n    if (delta === 0) {\n      h = Number.NaN;\n    } else {\n      if (r === max) {\n        h = (g - b) / delta;\n      }\n\n      if (g === max) {\n        h = 2 + (b - r) / delta;\n      }\n\n      if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    }\n\n    return [h, c, _g];\n  };\n\n  var rgb2hcg_1 = rgb2hcg;\n  var unpack$a = utils.unpack;\n  var floor = Math.floor;\n  /*\n   * this is basically just HSV with some minor tweaks\n   *\n   * hue.. [0..360]\n   * chroma .. [0..1]\n   * grayness .. [0..1]\n   */\n\n  var hcg2rgb = function hcg2rgb() {\n    var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$a(args, 'hcg');\n    var h = args[0];\n    var c = args[1];\n    var _g = args[2];\n    var r, g, b;\n    _g = _g * 255;\n\n    var _c = c * 255;\n\n    if (c === 0) {\n      r = g = b = _g;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n\n      if (h > 360) {\n        h -= 360;\n      }\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      h /= 60;\n      var i = floor(h);\n      var f = h - i;\n      var p = _g * (1 - c);\n      var q = p + _c * (1 - f);\n      var t = p + _c * f;\n      var v = p + _c;\n\n      switch (i) {\n        case 0:\n          assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];\n          break;\n\n        case 1:\n          assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];\n          break;\n\n        case 2:\n          assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];\n          break;\n\n        case 3:\n          assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];\n          break;\n\n        case 4:\n          assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];\n          break;\n\n        case 5:\n          assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];\n          break;\n      }\n    }\n\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var hcg2rgb_1 = hcg2rgb;\n  var unpack$b = utils.unpack;\n  var type$4 = utils.type;\n\n  Color_1.prototype.hcg = function () {\n    return rgb2hcg_1(this._rgb);\n  };\n\n  chroma_1.hcg = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hcg'])))();\n  };\n\n  input.format.hcg = hcg2rgb_1;\n  input.autodetect.push({\n    p: 1,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$b(args, 'hcg');\n\n      if (type$4(args) === 'array' && args.length === 3) {\n        return 'hcg';\n      }\n    }\n  });\n  var unpack$c = utils.unpack;\n  var last$4 = utils.last;\n  var round$3 = Math.round;\n\n  var rgb2hex = function rgb2hex() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$c(args, 'rgba');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var a = ref[3];\n    var mode = last$4(args) || 'auto';\n\n    if (a === undefined) {\n      a = 1;\n    }\n\n    if (mode === 'auto') {\n      mode = a < 1 ? 'rgba' : 'rgb';\n    }\n\n    r = round$3(r);\n    g = round$3(g);\n    b = round$3(b);\n    var u = r << 16 | g << 8 | b;\n    var str = \"000000\" + u.toString(16); //#.toUpperCase();\n\n    str = str.substr(str.length - 6);\n    var hxa = '0' + round$3(a * 255).toString(16);\n    hxa = hxa.substr(hxa.length - 2);\n\n    switch (mode.toLowerCase()) {\n      case 'rgba':\n        return \"#\" + str + hxa;\n\n      case 'argb':\n        return \"#\" + hxa + str;\n\n      default:\n        return \"#\" + str;\n    }\n  };\n\n  var rgb2hex_1 = rgb2hex;\n  var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n  var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n  var hex2rgb = function hex2rgb(hex) {\n    if (hex.match(RE_HEX)) {\n      // remove optional leading #\n      if (hex.length === 4 || hex.length === 7) {\n        hex = hex.substr(1);\n      } // expand short-notation to full six-digit\n\n\n      if (hex.length === 3) {\n        hex = hex.split('');\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n      }\n\n      var u = parseInt(hex, 16);\n      var r = u >> 16;\n      var g = u >> 8 & 0xFF;\n      var b = u & 0xFF;\n      return [r, g, b, 1];\n    } // match rgba hex format, eg #FF000077\n\n\n    if (hex.match(RE_HEXA)) {\n      if (hex.length === 5 || hex.length === 9) {\n        // remove optional leading #\n        hex = hex.substr(1);\n      } // expand short-notation to full eight-digit\n\n\n      if (hex.length === 4) {\n        hex = hex.split('');\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n      }\n\n      var u$1 = parseInt(hex, 16);\n      var r$1 = u$1 >> 24 & 0xFF;\n      var g$1 = u$1 >> 16 & 0xFF;\n      var b$1 = u$1 >> 8 & 0xFF;\n      var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\n      return [r$1, g$1, b$1, a];\n    } // we used to check for css colors here\n    // if _input.css? and rgb = _input.css hex\n    //     return rgb\n\n\n    throw new Error(\"unknown hex color: \" + hex);\n  };\n\n  var hex2rgb_1 = hex2rgb;\n  var type$5 = utils.type;\n\n  Color_1.prototype.hex = function (mode) {\n    return rgb2hex_1(this._rgb, mode);\n  };\n\n  chroma_1.hex = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hex'])))();\n  };\n\n  input.format.hex = hex2rgb_1;\n  input.autodetect.push({\n    p: 4,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$5(h) === 'string' && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {\n        return 'hex';\n      }\n    }\n  });\n  var unpack$d = utils.unpack;\n  var TWOPI = utils.TWOPI;\n  var min = Math.min;\n  var sqrt = Math.sqrt;\n  var acos = Math.acos;\n\n  var rgb2hsi = function rgb2hsi() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n    */\n\n\n    var ref = unpack$d(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var h;\n    var min_ = min(r, g, b);\n    var i = (r + g + b) / 3;\n    var s = i > 0 ? 1 - min_ / i : 0;\n\n    if (s === 0) {\n      h = NaN;\n    } else {\n      h = (r - g + (r - b)) / 2;\n      h /= sqrt((r - g) * (r - g) + (r - b) * (g - b));\n      h = acos(h);\n\n      if (b > g) {\n        h = TWOPI - h;\n      }\n\n      h /= TWOPI;\n    }\n\n    return [h * 360, s, i];\n  };\n\n  var rgb2hsi_1 = rgb2hsi;\n  var unpack$e = utils.unpack;\n  var limit$1 = utils.limit;\n  var TWOPI$1 = utils.TWOPI;\n  var PITHIRD = utils.PITHIRD;\n  var cos = Math.cos;\n  /*\n   * hue [0..360]\n   * saturation [0..1]\n   * intensity [0..1]\n   */\n\n  var hsi2rgb = function hsi2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n    */\n\n\n    args = unpack$e(args, 'hsi');\n    var h = args[0];\n    var s = args[1];\n    var i = args[2];\n    var r, g, b;\n\n    if (isNaN(h)) {\n      h = 0;\n    }\n\n    if (isNaN(s)) {\n      s = 0;\n    } // normalize hue\n\n\n    if (h > 360) {\n      h -= 360;\n    }\n\n    if (h < 0) {\n      h += 360;\n    }\n\n    h /= 360;\n\n    if (h < 1 / 3) {\n      b = (1 - s) / 3;\n      r = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      g = 1 - (b + r);\n    } else if (h < 2 / 3) {\n      h -= 1 / 3;\n      r = (1 - s) / 3;\n      g = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      b = 1 - (r + g);\n    } else {\n      h -= 2 / 3;\n      g = (1 - s) / 3;\n      b = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      r = 1 - (g + b);\n    }\n\n    r = limit$1(i * r * 3);\n    g = limit$1(i * g * 3);\n    b = limit$1(i * b * 3);\n    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];\n  };\n\n  var hsi2rgb_1 = hsi2rgb;\n  var unpack$f = utils.unpack;\n  var type$6 = utils.type;\n\n  Color_1.prototype.hsi = function () {\n    return rgb2hsi_1(this._rgb);\n  };\n\n  chroma_1.hsi = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsi'])))();\n  };\n\n  input.format.hsi = hsi2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$f(args, 'hsi');\n\n      if (type$6(args) === 'array' && args.length === 3) {\n        return 'hsi';\n      }\n    }\n  });\n  var unpack$g = utils.unpack;\n  var type$7 = utils.type;\n\n  Color_1.prototype.hsl = function () {\n    return rgb2hsl_1(this._rgb);\n  };\n\n  chroma_1.hsl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsl'])))();\n  };\n\n  input.format.hsl = hsl2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$g(args, 'hsl');\n\n      if (type$7(args) === 'array' && args.length === 3) {\n        return 'hsl';\n      }\n    }\n  });\n  var unpack$h = utils.unpack;\n  var min$1 = Math.min;\n  var max$1 = Math.max;\n  /*\n   * supported arguments:\n   * - rgb2hsv(r,g,b)\n   * - rgb2hsv([r,g,b])\n   * - rgb2hsv({r,g,b})\n   */\n\n  var rgb2hsl$1 = function rgb2hsl$1() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$h(args, 'rgb');\n    var r = args[0];\n    var g = args[1];\n    var b = args[2];\n    var min_ = min$1(r, g, b);\n    var max_ = max$1(r, g, b);\n    var delta = max_ - min_;\n    var h, s, v;\n    v = max_ / 255.0;\n\n    if (max_ === 0) {\n      h = Number.NaN;\n      s = 0;\n    } else {\n      s = delta / max_;\n\n      if (r === max_) {\n        h = (g - b) / delta;\n      }\n\n      if (g === max_) {\n        h = 2 + (b - r) / delta;\n      }\n\n      if (b === max_) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    }\n\n    return [h, s, v];\n  };\n\n  var rgb2hsv = rgb2hsl$1;\n  var unpack$i = utils.unpack;\n  var floor$1 = Math.floor;\n\n  var hsv2rgb = function hsv2rgb() {\n    var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$i(args, 'hsv');\n    var h = args[0];\n    var s = args[1];\n    var v = args[2];\n    var r, g, b;\n    v *= 255;\n\n    if (s === 0) {\n      r = g = b = v;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n\n      if (h > 360) {\n        h -= 360;\n      }\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      h /= 60;\n      var i = floor$1(h);\n      var f = h - i;\n      var p = v * (1 - s);\n      var q = v * (1 - s * f);\n      var t = v * (1 - s * (1 - f));\n\n      switch (i) {\n        case 0:\n          assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];\n          break;\n\n        case 1:\n          assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];\n          break;\n\n        case 2:\n          assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];\n          break;\n\n        case 3:\n          assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];\n          break;\n\n        case 4:\n          assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];\n          break;\n\n        case 5:\n          assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];\n          break;\n      }\n    }\n\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var hsv2rgb_1 = hsv2rgb;\n  var unpack$j = utils.unpack;\n  var type$8 = utils.type;\n\n  Color_1.prototype.hsv = function () {\n    return rgb2hsv(this._rgb);\n  };\n\n  chroma_1.hsv = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsv'])))();\n  };\n\n  input.format.hsv = hsv2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$j(args, 'hsv');\n\n      if (type$8(args) === 'array' && args.length === 3) {\n        return 'hsv';\n      }\n    }\n  });\n  var labConstants = {\n    // Corresponds roughly to RGB brighter/darker\n    Kn: 18,\n    // D65 standard referent\n    Xn: 0.950470,\n    Yn: 1,\n    Zn: 1.088830,\n    t0: 0.137931034,\n    // 4 / 29\n    t1: 0.206896552,\n    // 6 / 29\n    t2: 0.12841855,\n    // 3 * t1 * t1\n    t3: 0.008856452 // t1 * t1 * t1\n\n  };\n  var unpack$k = utils.unpack;\n  var pow = Math.pow;\n\n  var rgb2lab = function rgb2lab() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$k(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var ref$1 = rgb2xyz(r, g, b);\n    var x = ref$1[0];\n    var y = ref$1[1];\n    var z = ref$1[2];\n    var l = 116 * y - 16;\n    return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\n  };\n\n  var rgb_xyz = function rgb_xyz(r) {\n    if ((r /= 255) <= 0.04045) {\n      return r / 12.92;\n    }\n\n    return pow((r + 0.055) / 1.055, 2.4);\n  };\n\n  var xyz_lab = function xyz_lab(t) {\n    if (t > labConstants.t3) {\n      return pow(t, 1 / 3);\n    }\n\n    return t / labConstants.t2 + labConstants.t0;\n  };\n\n  var rgb2xyz = function rgb2xyz(r, g, b) {\n    r = rgb_xyz(r);\n    g = rgb_xyz(g);\n    b = rgb_xyz(b);\n    var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\n    var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\n    var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\n    return [x, y, z];\n  };\n\n  var rgb2lab_1 = rgb2lab;\n  var unpack$l = utils.unpack;\n  var pow$1 = Math.pow;\n  /*\n   * L* [0..100]\n   * a [-100..100]\n   * b [-100..100]\n   */\n\n  var lab2rgb = function lab2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$l(args, 'lab');\n    var l = args[0];\n    var a = args[1];\n    var b = args[2];\n    var x, y, z, r, g, b_;\n    y = (l + 16) / 116;\n    x = isNaN(a) ? y : y + a / 500;\n    z = isNaN(b) ? y : y - b / 200;\n    y = labConstants.Yn * lab_xyz(y);\n    x = labConstants.Xn * lab_xyz(x);\n    z = labConstants.Zn * lab_xyz(z);\n    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z); // D65 -> sRGB\n\n    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n    b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n    return [r, g, b_, args.length > 3 ? args[3] : 1];\n  };\n\n  var xyz_rgb = function xyz_rgb(r) {\n    return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055);\n  };\n\n  var lab_xyz = function lab_xyz(t) {\n    return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0);\n  };\n\n  var lab2rgb_1 = lab2rgb;\n  var unpack$m = utils.unpack;\n  var type$9 = utils.type;\n\n  Color_1.prototype.lab = function () {\n    return rgb2lab_1(this._rgb);\n  };\n\n  chroma_1.lab = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['lab'])))();\n  };\n\n  input.format.lab = lab2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$m(args, 'lab');\n\n      if (type$9(args) === 'array' && args.length === 3) {\n        return 'lab';\n      }\n    }\n  });\n  var unpack$n = utils.unpack;\n  var RAD2DEG = utils.RAD2DEG;\n  var sqrt$1 = Math.sqrt;\n  var atan2 = Math.atan2;\n  var round$4 = Math.round;\n\n  var lab2lch = function lab2lch() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$n(args, 'lab');\n    var l = ref[0];\n    var a = ref[1];\n    var b = ref[2];\n    var c = sqrt$1(a * a + b * b);\n    var h = (atan2(b, a) * RAD2DEG + 360) % 360;\n\n    if (round$4(c * 10000) === 0) {\n      h = Number.NaN;\n    }\n\n    return [l, c, h];\n  };\n\n  var lab2lch_1 = lab2lch;\n  var unpack$o = utils.unpack;\n\n  var rgb2lch = function rgb2lch() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$o(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var ref$1 = rgb2lab_1(r, g, b);\n    var l = ref$1[0];\n    var a = ref$1[1];\n    var b_ = ref$1[2];\n    return lab2lch_1(l, a, b_);\n  };\n\n  var rgb2lch_1 = rgb2lch;\n  var unpack$p = utils.unpack;\n  var DEG2RAD = utils.DEG2RAD;\n  var sin = Math.sin;\n  var cos$1 = Math.cos;\n\n  var lch2lab = function lch2lab() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n     A saturation multiplier was added by Gregor Aisch\n    */\n\n\n    var ref = unpack$p(args, 'lch');\n    var l = ref[0];\n    var c = ref[1];\n    var h = ref[2];\n\n    if (isNaN(h)) {\n      h = 0;\n    }\n\n    h = h * DEG2RAD;\n    return [l, cos$1(h) * c, sin(h) * c];\n  };\n\n  var lch2lab_1 = lch2lab;\n  var unpack$q = utils.unpack;\n\n  var lch2rgb = function lch2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$q(args, 'lch');\n    var l = args[0];\n    var c = args[1];\n    var h = args[2];\n    var ref = lch2lab_1(l, c, h);\n    var L = ref[0];\n    var a = ref[1];\n    var b_ = ref[2];\n    var ref$1 = lab2rgb_1(L, a, b_);\n    var r = ref$1[0];\n    var g = ref$1[1];\n    var b = ref$1[2];\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var lch2rgb_1 = lch2rgb;\n  var unpack$r = utils.unpack;\n\n  var hcl2rgb = function hcl2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var hcl = unpack$r(args, 'hcl').reverse();\n    return lch2rgb_1.apply(void 0, hcl);\n  };\n\n  var hcl2rgb_1 = hcl2rgb;\n  var unpack$s = utils.unpack;\n  var type$a = utils.type;\n\n  Color_1.prototype.lch = function () {\n    return rgb2lch_1(this._rgb);\n  };\n\n  Color_1.prototype.hcl = function () {\n    return rgb2lch_1(this._rgb).reverse();\n  };\n\n  chroma_1.lch = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['lch'])))();\n  };\n\n  chroma_1.hcl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hcl'])))();\n  };\n\n  input.format.lch = lch2rgb_1;\n  input.format.hcl = hcl2rgb_1;\n  ['lch', 'hcl'].forEach(function (m) {\n    return input.autodetect.push({\n      p: 2,\n      test: function test() {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) {\n          args[len] = arguments[len];\n        }\n\n        args = unpack$s(args, m);\n\n        if (type$a(args) === 'array' && args.length === 3) {\n          return m;\n        }\n      }\n    });\n  });\n  /**\n  \tX11 color names\n   \thttp://www.w3.org/TR/css3-color/#svg-color\n  */\n\n  var w3cx11 = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflower: '#6495ed',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    laserlemon: '#ffff54',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrod: '#fafad2',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    maroon2: '#7f0000',\n    maroon3: '#b03060',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    purple2: '#7f007f',\n    purple3: '#a020f0',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32'\n  };\n  var w3cx11_1 = w3cx11;\n  var type$b = utils.type;\n\n  Color_1.prototype.name = function () {\n    var hex = rgb2hex_1(this._rgb, 'rgb');\n\n    for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\n      var n = list[i];\n\n      if (w3cx11_1[n] === hex) {\n        return n.toLowerCase();\n      }\n    }\n\n    return hex;\n  };\n\n  input.format.named = function (name) {\n    name = name.toLowerCase();\n\n    if (w3cx11_1[name]) {\n      return hex2rgb_1(w3cx11_1[name]);\n    }\n\n    throw new Error('unknown color name: ' + name);\n  };\n\n  input.autodetect.push({\n    p: 5,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\n        return 'named';\n      }\n    }\n  });\n  var unpack$t = utils.unpack;\n\n  var rgb2num = function rgb2num() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$t(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    return (r << 16) + (g << 8) + b;\n  };\n\n  var rgb2num_1 = rgb2num;\n  var type$c = utils.type;\n\n  var num2rgb = function num2rgb(num) {\n    if (type$c(num) == \"number\" && num >= 0 && num <= 0xFFFFFF) {\n      var r = num >> 16;\n      var g = num >> 8 & 0xFF;\n      var b = num & 0xFF;\n      return [r, g, b, 1];\n    }\n\n    throw new Error(\"unknown num color: \" + num);\n  };\n\n  var num2rgb_1 = num2rgb;\n  var type$d = utils.type;\n\n  Color_1.prototype.num = function () {\n    return rgb2num_1(this._rgb);\n  };\n\n  chroma_1.num = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['num'])))();\n  };\n\n  input.format.num = num2rgb_1;\n  input.autodetect.push({\n    p: 5,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\n        return 'num';\n      }\n    }\n  });\n  var unpack$u = utils.unpack;\n  var type$e = utils.type;\n  var round$5 = Math.round;\n\n  Color_1.prototype.rgb = function (rnd) {\n    if (rnd === void 0) rnd = true;\n\n    if (rnd === false) {\n      return this._rgb.slice(0, 3);\n    }\n\n    return this._rgb.slice(0, 3).map(round$5);\n  };\n\n  Color_1.prototype.rgba = function (rnd) {\n    if (rnd === void 0) rnd = true;\n    return this._rgb.slice(0, 4).map(function (v, i) {\n      return i < 3 ? rnd === false ? v : round$5(v) : v;\n    });\n  };\n\n  chroma_1.rgb = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['rgb'])))();\n  };\n\n  input.format.rgb = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgba = unpack$u(args, 'rgba');\n\n    if (rgba[3] === undefined) {\n      rgba[3] = 1;\n    }\n\n    return rgba;\n  };\n\n  input.autodetect.push({\n    p: 3,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$u(args, 'rgba');\n\n      if (type$e(args) === 'array' && (args.length === 3 || args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\n        return 'rgb';\n      }\n    }\n  });\n  /*\n   * Based on implementation by Neil Bartlett\n   * https://github.com/neilbartlett/color-temperature\n   */\n\n  var log = Math.log;\n\n  var temperature2rgb = function temperature2rgb(kelvin) {\n    var temp = kelvin / 100;\n    var r, g, b;\n\n    if (temp < 66) {\n      r = 255;\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);\n      b = 255;\n    }\n\n    return [r, g, b, 1];\n  };\n\n  var temperature2rgb_1 = temperature2rgb;\n  /*\n   * Based on implementation by Neil Bartlett\n   * https://github.com/neilbartlett/color-temperature\n   **/\n\n  var unpack$v = utils.unpack;\n  var round$6 = Math.round;\n\n  var rgb2temperature = function rgb2temperature() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgb = unpack$v(args, 'rgb');\n    var r = rgb[0],\n        b = rgb[2];\n    var minTemp = 1000;\n    var maxTemp = 40000;\n    var eps = 0.4;\n    var temp;\n\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      var rgb$1 = temperature2rgb_1(temp);\n\n      if (rgb$1[2] / rgb$1[0] >= b / r) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n\n    return round$6(temp);\n  };\n\n  var rgb2temperature_1 = rgb2temperature;\n\n  Color_1.prototype.temp = Color_1.prototype.kelvin = Color_1.prototype.temperature = function () {\n    return rgb2temperature_1(this._rgb);\n  };\n\n  chroma_1.temp = chroma_1.kelvin = chroma_1.temperature = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['temp'])))();\n  };\n\n  input.format.temp = input.format.kelvin = input.format.temperature = temperature2rgb_1;\n  var type$f = utils.type;\n\n  Color_1.prototype.alpha = function (a, mutate) {\n    if (mutate === void 0) mutate = false;\n\n    if (a !== undefined && type$f(a) === 'number') {\n      if (mutate) {\n        this._rgb[3] = a;\n        return this;\n      }\n\n      return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n    }\n\n    return this._rgb[3];\n  };\n\n  Color_1.prototype.clipped = function () {\n    return this._rgb._clipped || false;\n  };\n\n  Color_1.prototype.darken = function (amount) {\n    if (amount === void 0) amount = 1;\n    var me = this;\n    var lab = me.lab();\n    lab[0] -= labConstants.Kn * amount;\n    return new Color_1(lab, 'lab').alpha(me.alpha(), true);\n  };\n\n  Color_1.prototype.brighten = function (amount) {\n    if (amount === void 0) amount = 1;\n    return this.darken(-amount);\n  };\n\n  Color_1.prototype.darker = Color_1.prototype.darken;\n  Color_1.prototype.brighter = Color_1.prototype.brighten;\n\n  Color_1.prototype.get = function (mc) {\n    var ref = mc.split('.');\n    var mode = ref[0];\n    var channel = ref[1];\n    var src = this[mode]();\n\n    if (channel) {\n      var i = mode.indexOf(channel);\n\n      if (i > -1) {\n        return src[i];\n      }\n\n      throw new Error(\"unknown channel \" + channel + \" in mode \" + mode);\n    } else {\n      return src;\n    }\n  };\n\n  var type$g = utils.type;\n  var pow$2 = Math.pow;\n  var EPS = 1e-7;\n  var MAX_ITER = 20;\n\n  Color_1.prototype.luminance = function (lum) {\n    if (lum !== undefined && type$g(lum) === 'number') {\n      if (lum === 0) {\n        // return pure black\n        return new Color_1([0, 0, 0, this._rgb[3]], 'rgb');\n      }\n\n      if (lum === 1) {\n        // return pure white\n        return new Color_1([255, 255, 255, this._rgb[3]], 'rgb');\n      } // compute new color using...\n\n\n      var cur_lum = this.luminance();\n      var mode = 'rgb';\n      var max_iter = MAX_ITER;\n\n      var test = function test(low, high) {\n        var mid = low.interpolate(high, 0.5, mode);\n        var lm = mid.luminance();\n\n        if (Math.abs(lum - lm) < EPS || !max_iter--) {\n          // close enough\n          return mid;\n        }\n\n        return lm > lum ? test(low, mid) : test(mid, high);\n      };\n\n      var rgb = (cur_lum > lum ? test(new Color_1([0, 0, 0]), this) : test(this, new Color_1([255, 255, 255]))).rgb();\n      return new Color_1(rgb.concat([this._rgb[3]]));\n    }\n\n    return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));\n  };\n\n  var rgb2luminance = function rgb2luminance(r, g, b) {\n    // relative luminance\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    r = luminance_x(r);\n    g = luminance_x(g);\n    b = luminance_x(b);\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n  };\n\n  var luminance_x = function luminance_x(x) {\n    x /= 255;\n    return x <= 0.03928 ? x / 12.92 : pow$2((x + 0.055) / 1.055, 2.4);\n  };\n\n  var interpolator = {};\n  var type$h = utils.type;\n\n  var mix = function mix(col1, col2, f) {\n    if (f === void 0) f = 0.5;\n    var rest = [],\n        len = arguments.length - 3;\n\n    while (len-- > 0) {\n      rest[len] = arguments[len + 3];\n    }\n\n    var mode = rest[0] || 'lrgb';\n\n    if (!interpolator[mode] && !rest.length) {\n      // fall back to the first supported mode\n      mode = Object.keys(interpolator)[0];\n    }\n\n    if (!interpolator[mode]) {\n      throw new Error(\"interpolation mode \" + mode + \" is not defined\");\n    }\n\n    if (type$h(col1) !== 'object') {\n      col1 = new Color_1(col1);\n    }\n\n    if (type$h(col2) !== 'object') {\n      col2 = new Color_1(col2);\n    }\n\n    return interpolator[mode](col1, col2, f).alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\n  };\n\n  Color_1.prototype.mix = Color_1.prototype.interpolate = function (col2, f) {\n    if (f === void 0) f = 0.5;\n    var rest = [],\n        len = arguments.length - 2;\n\n    while (len-- > 0) {\n      rest[len] = arguments[len + 2];\n    }\n\n    return mix.apply(void 0, [this, col2, f].concat(rest));\n  };\n\n  Color_1.prototype.premultiply = function (mutate) {\n    if (mutate === void 0) mutate = false;\n    var rgb = this._rgb;\n    var a = rgb[3];\n\n    if (mutate) {\n      this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];\n      return this;\n    } else {\n      return new Color_1([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');\n    }\n  };\n\n  Color_1.prototype.saturate = function (amount) {\n    if (amount === void 0) amount = 1;\n    var me = this;\n    var lch = me.lch();\n    lch[1] += labConstants.Kn * amount;\n\n    if (lch[1] < 0) {\n      lch[1] = 0;\n    }\n\n    return new Color_1(lch, 'lch').alpha(me.alpha(), true);\n  };\n\n  Color_1.prototype.desaturate = function (amount) {\n    if (amount === void 0) amount = 1;\n    return this.saturate(-amount);\n  };\n\n  var type$i = utils.type;\n\n  Color_1.prototype.set = function (mc, value, mutate) {\n    if (mutate === void 0) mutate = false;\n    var ref = mc.split('.');\n    var mode = ref[0];\n    var channel = ref[1];\n    var src = this[mode]();\n\n    if (channel) {\n      var i = mode.indexOf(channel);\n\n      if (i > -1) {\n        if (type$i(value) == 'string') {\n          switch (value.charAt(0)) {\n            case '+':\n              src[i] += +value;\n              break;\n\n            case '-':\n              src[i] += +value;\n              break;\n\n            case '*':\n              src[i] *= +value.substr(1);\n              break;\n\n            case '/':\n              src[i] /= +value.substr(1);\n              break;\n\n            default:\n              src[i] = +value;\n          }\n        } else if (type$i(value) === 'number') {\n          src[i] = value;\n        } else {\n          throw new Error(\"unsupported value for Color.set\");\n        }\n\n        var out = new Color_1(src, mode);\n\n        if (mutate) {\n          this._rgb = out._rgb;\n          return this;\n        }\n\n        return out;\n      }\n\n      throw new Error(\"unknown channel \" + channel + \" in mode \" + mode);\n    } else {\n      return src;\n    }\n  };\n\n  var rgb$1 = function rgb$1(col1, col2, f) {\n    var xyz0 = col1._rgb;\n    var xyz1 = col2._rgb;\n    return new Color_1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), 'rgb');\n  }; // register interpolator\n\n\n  interpolator.rgb = rgb$1;\n  var sqrt$2 = Math.sqrt;\n  var pow$3 = Math.pow;\n\n  var lrgb = function lrgb(col1, col2, f) {\n    var ref = col1._rgb;\n    var x1 = ref[0];\n    var y1 = ref[1];\n    var z1 = ref[2];\n    var ref$1 = col2._rgb;\n    var x2 = ref$1[0];\n    var y2 = ref$1[1];\n    var z2 = ref$1[2];\n    return new Color_1(sqrt$2(pow$3(x1, 2) * (1 - f) + pow$3(x2, 2) * f), sqrt$2(pow$3(y1, 2) * (1 - f) + pow$3(y2, 2) * f), sqrt$2(pow$3(z1, 2) * (1 - f) + pow$3(z2, 2) * f), 'rgb');\n  }; // register interpolator\n\n\n  interpolator.lrgb = lrgb;\n\n  var lab$1 = function lab$1(col1, col2, f) {\n    var xyz0 = col1.lab();\n    var xyz1 = col2.lab();\n    return new Color_1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), 'lab');\n  }; // register interpolator\n\n\n  interpolator.lab = lab$1;\n\n  var _hsx = function _hsx(col1, col2, f, m) {\n    var assign, assign$1;\n    var xyz0, xyz1;\n\n    if (m === 'hsl') {\n      xyz0 = col1.hsl();\n      xyz1 = col2.hsl();\n    } else if (m === 'hsv') {\n      xyz0 = col1.hsv();\n      xyz1 = col2.hsv();\n    } else if (m === 'hcg') {\n      xyz0 = col1.hcg();\n      xyz1 = col2.hcg();\n    } else if (m === 'hsi') {\n      xyz0 = col1.hsi();\n      xyz1 = col2.hsi();\n    } else if (m === 'lch' || m === 'hcl') {\n      m = 'hcl';\n      xyz0 = col1.hcl();\n      xyz1 = col2.hcl();\n    }\n\n    var hue0, hue1, sat0, sat1, lbv0, lbv1;\n\n    if (m.substr(0, 1) === 'h') {\n      assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];\n      assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];\n    }\n\n    var sat, hue, lbv, dh;\n\n    if (!isNaN(hue0) && !isNaN(hue1)) {\n      // both colors have hue\n      if (hue1 > hue0 && hue1 - hue0 > 180) {\n        dh = hue1 - (hue0 + 360);\n      } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n        dh = hue1 + 360 - hue0;\n      } else {\n        dh = hue1 - hue0;\n      }\n\n      hue = hue0 + f * dh;\n    } else if (!isNaN(hue0)) {\n      hue = hue0;\n\n      if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') {\n        sat = sat0;\n      }\n    } else if (!isNaN(hue1)) {\n      hue = hue1;\n\n      if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') {\n        sat = sat1;\n      }\n    } else {\n      hue = Number.NaN;\n    }\n\n    if (sat === undefined) {\n      sat = sat0 + f * (sat1 - sat0);\n    }\n\n    lbv = lbv0 + f * (lbv1 - lbv0);\n    return new Color_1([hue, sat, lbv], m);\n  };\n\n  var lch$1 = function lch$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'lch');\n  }; // register interpolator\n\n\n  interpolator.lch = lch$1;\n  interpolator.hcl = lch$1;\n\n  var num$1 = function num$1(col1, col2, f) {\n    var c1 = col1.num();\n    var c2 = col2.num();\n    return new Color_1(c1 + f * (c2 - c1), 'num');\n  }; // register interpolator\n\n\n  interpolator.num = num$1;\n\n  var hcg$1 = function hcg$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hcg');\n  }; // register interpolator\n\n\n  interpolator.hcg = hcg$1;\n\n  var hsi$1 = function hsi$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsi');\n  }; // register interpolator\n\n\n  interpolator.hsi = hsi$1;\n\n  var hsl$1 = function hsl$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsl');\n  }; // register interpolator\n\n\n  interpolator.hsl = hsl$1;\n\n  var hsv$1 = function hsv$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsv');\n  }; // register interpolator\n\n\n  interpolator.hsv = hsv$1;\n  var clip_rgb$2 = utils.clip_rgb;\n  var pow$4 = Math.pow;\n  var sqrt$3 = Math.sqrt;\n  var PI$1 = Math.PI;\n  var cos$2 = Math.cos;\n  var sin$1 = Math.sin;\n  var atan2$1 = Math.atan2;\n\n  var average = function average(colors, mode, weights) {\n    if (mode === void 0) mode = 'lrgb';\n    if (weights === void 0) weights = null;\n    var l = colors.length;\n\n    if (!weights) {\n      weights = Array.from(new Array(l)).map(function () {\n        return 1;\n      });\n    } // normalize weights\n\n\n    var k = l / weights.reduce(function (a, b) {\n      return a + b;\n    });\n    weights.forEach(function (w, i) {\n      weights[i] *= k;\n    }); // convert colors to Color objects\n\n    colors = colors.map(function (c) {\n      return new Color_1(c);\n    });\n\n    if (mode === 'lrgb') {\n      return _average_lrgb(colors, weights);\n    }\n\n    var first = colors.shift();\n    var xyz = first.get(mode);\n    var cnt = [];\n    var dx = 0;\n    var dy = 0; // initial color\n\n    for (var i = 0; i < xyz.length; i++) {\n      xyz[i] = (xyz[i] || 0) * weights[0];\n      cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n\n      if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n        var A = xyz[i] / 180 * PI$1;\n        dx += cos$2(A) * weights[0];\n        dy += sin$1(A) * weights[0];\n      }\n    }\n\n    var alpha = first.alpha() * weights[0];\n    colors.forEach(function (c, ci) {\n      var xyz2 = c.get(mode);\n      alpha += c.alpha() * weights[ci + 1];\n\n      for (var i = 0; i < xyz.length; i++) {\n        if (!isNaN(xyz2[i])) {\n          cnt[i] += weights[ci + 1];\n\n          if (mode.charAt(i) === 'h') {\n            var A = xyz2[i] / 180 * PI$1;\n            dx += cos$2(A) * weights[ci + 1];\n            dy += sin$1(A) * weights[ci + 1];\n          } else {\n            xyz[i] += xyz2[i] * weights[ci + 1];\n          }\n        }\n      }\n    });\n\n    for (var i$1 = 0; i$1 < xyz.length; i$1++) {\n      if (mode.charAt(i$1) === 'h') {\n        var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\n\n        while (A$1 < 0) {\n          A$1 += 360;\n        }\n\n        while (A$1 >= 360) {\n          A$1 -= 360;\n        }\n\n        xyz[i$1] = A$1;\n      } else {\n        xyz[i$1] = xyz[i$1] / cnt[i$1];\n      }\n    }\n\n    alpha /= l;\n    return new Color_1(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);\n  };\n\n  var _average_lrgb = function _average_lrgb(colors, weights) {\n    var l = colors.length;\n    var xyz = [0, 0, 0, 0];\n\n    for (var i = 0; i < colors.length; i++) {\n      var col = colors[i];\n      var f = weights[i] / l;\n      var rgb = col._rgb;\n      xyz[0] += pow$4(rgb[0], 2) * f;\n      xyz[1] += pow$4(rgb[1], 2) * f;\n      xyz[2] += pow$4(rgb[2], 2) * f;\n      xyz[3] += rgb[3] * f;\n    }\n\n    xyz[0] = sqrt$3(xyz[0]);\n    xyz[1] = sqrt$3(xyz[1]);\n    xyz[2] = sqrt$3(xyz[2]);\n\n    if (xyz[3] > 0.9999999) {\n      xyz[3] = 1;\n    }\n\n    return new Color_1(clip_rgb$2(xyz));\n  }; // minimal multi-purpose interface\n  // @requires utils color analyze\n\n\n  var type$j = utils.type;\n  var pow$5 = Math.pow;\n\n  var scale = function scale(colors) {\n    // constructor\n    var _mode = 'rgb';\n\n    var _nacol = chroma_1('#ccc');\n\n    var _spread = 0; // const _fixed = false;\n\n    var _domain = [0, 1];\n    var _pos = [];\n    var _padding = [0, 0];\n    var _classes = false;\n    var _colors = [];\n    var _out = false;\n    var _min = 0;\n    var _max = 1;\n    var _correctLightness = false;\n    var _colorCache = {};\n    var _useCache = true;\n    var _gamma = 1; // private methods\n\n    var setColors = function setColors(colors) {\n      colors = colors || ['#fff', '#000'];\n\n      if (colors && type$j(colors) === 'string' && chroma_1.brewer && chroma_1.brewer[colors.toLowerCase()]) {\n        colors = chroma_1.brewer[colors.toLowerCase()];\n      }\n\n      if (type$j(colors) === 'array') {\n        // handle single color\n        if (colors.length === 1) {\n          colors = [colors[0], colors[0]];\n        } // make a copy of the colors\n\n\n        colors = colors.slice(0); // convert to chroma classes\n\n        for (var c = 0; c < colors.length; c++) {\n          colors[c] = chroma_1(colors[c]);\n        } // auto-fill color position\n\n\n        _pos.length = 0;\n\n        for (var c$1 = 0; c$1 < colors.length; c$1++) {\n          _pos.push(c$1 / (colors.length - 1));\n        }\n      }\n\n      resetCache();\n      return _colors = colors;\n    };\n\n    var getClass = function getClass(value) {\n      if (_classes != null) {\n        var n = _classes.length - 1;\n        var i = 0;\n\n        while (i < n && value >= _classes[i]) {\n          i++;\n        }\n\n        return i - 1;\n      }\n\n      return 0;\n    };\n\n    var tMapLightness = function tMapLightness(t) {\n      return t;\n    };\n\n    var tMapDomain = function tMapDomain(t) {\n      return t;\n    }; // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n\n    var getColor = function getColor(val, bypassMap) {\n      var col, t;\n\n      if (bypassMap == null) {\n        bypassMap = false;\n      }\n\n      if (isNaN(val) || val === null) {\n        return _nacol;\n      }\n\n      if (!bypassMap) {\n        if (_classes && _classes.length > 2) {\n          // find the class\n          var c = getClass(val);\n          t = c / (_classes.length - 2);\n        } else if (_max !== _min) {\n          // just interpolate between min/max\n          t = (val - _min) / (_max - _min);\n        } else {\n          t = 1;\n        }\n      } else {\n        t = val;\n      } // domain map\n\n\n      t = tMapDomain(t);\n\n      if (!bypassMap) {\n        t = tMapLightness(t); // lightness correction\n      }\n\n      if (_gamma !== 1) {\n        t = pow$5(t, _gamma);\n      }\n\n      t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n      t = Math.min(1, Math.max(0, t));\n      var k = Math.floor(t * 10000);\n\n      if (_useCache && _colorCache[k]) {\n        col = _colorCache[k];\n      } else {\n        if (type$j(_colors) === 'array') {\n          //for i in [0.._pos.length-1]\n          for (var i = 0; i < _pos.length; i++) {\n            var p = _pos[i];\n\n            if (t <= p) {\n              col = _colors[i];\n              break;\n            }\n\n            if (t >= p && i === _pos.length - 1) {\n              col = _colors[i];\n              break;\n            }\n\n            if (t > p && t < _pos[i + 1]) {\n              t = (t - p) / (_pos[i + 1] - p);\n              col = chroma_1.interpolate(_colors[i], _colors[i + 1], t, _mode);\n              break;\n            }\n          }\n        } else if (type$j(_colors) === 'function') {\n          col = _colors(t);\n        }\n\n        if (_useCache) {\n          _colorCache[k] = col;\n        }\n      }\n\n      return col;\n    };\n\n    var resetCache = function resetCache() {\n      return _colorCache = {};\n    };\n\n    setColors(colors); // public interface\n\n    var f = function f(v) {\n      var c = chroma_1(getColor(v));\n\n      if (_out && c[_out]) {\n        return c[_out]();\n      } else {\n        return c;\n      }\n    };\n\n    f.classes = function (classes) {\n      if (classes != null) {\n        if (type$j(classes) === 'array') {\n          _classes = classes;\n          _domain = [classes[0], classes[classes.length - 1]];\n        } else {\n          var d = chroma_1.analyze(_domain);\n\n          if (classes === 0) {\n            _classes = [d.min, d.max];\n          } else {\n            _classes = chroma_1.limits(d, 'e', classes);\n          }\n        }\n\n        return f;\n      }\n\n      return _classes;\n    };\n\n    f.domain = function (domain) {\n      if (!arguments.length) {\n        return _domain;\n      }\n\n      _min = domain[0];\n      _max = domain[domain.length - 1];\n      _pos = [];\n      var k = _colors.length;\n\n      if (domain.length === k && _min !== _max) {\n        // update positions\n        for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n          var d = list[i];\n\n          _pos.push((d - _min) / (_max - _min));\n        }\n      } else {\n        for (var c = 0; c < k; c++) {\n          _pos.push(c / (k - 1));\n        }\n\n        if (domain.length > 2) {\n          // set domain map\n          var tOut = domain.map(function (d, i) {\n            return i / (domain.length - 1);\n          });\n          var tBreaks = domain.map(function (d) {\n            return (d - _min) / (_max - _min);\n          });\n\n          if (!tBreaks.every(function (val, i) {\n            return tOut[i] === val;\n          })) {\n            tMapDomain = function tMapDomain(t) {\n              if (t <= 0 || t >= 1) {\n                return t;\n              }\n\n              var i = 0;\n\n              while (t >= tBreaks[i + 1]) {\n                i++;\n              }\n\n              var f = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n              var out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n              return out;\n            };\n          }\n        }\n      }\n\n      _domain = [_min, _max];\n      return f;\n    };\n\n    f.mode = function (_m) {\n      if (!arguments.length) {\n        return _mode;\n      }\n\n      _mode = _m;\n      resetCache();\n      return f;\n    };\n\n    f.range = function (colors, _pos) {\n      setColors(colors, _pos);\n      return f;\n    };\n\n    f.out = function (_o) {\n      _out = _o;\n      return f;\n    };\n\n    f.spread = function (val) {\n      if (!arguments.length) {\n        return _spread;\n      }\n\n      _spread = val;\n      return f;\n    };\n\n    f.correctLightness = function (v) {\n      if (v == null) {\n        v = true;\n      }\n\n      _correctLightness = v;\n      resetCache();\n\n      if (_correctLightness) {\n        tMapLightness = function tMapLightness(t) {\n          var L0 = getColor(0, true).lab()[0];\n          var L1 = getColor(1, true).lab()[0];\n          var pol = L0 > L1;\n          var L_actual = getColor(t, true).lab()[0];\n          var L_ideal = L0 + (L1 - L0) * t;\n          var L_diff = L_actual - L_ideal;\n          var t0 = 0;\n          var t1 = 1;\n          var max_iter = 20;\n\n          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n            (function () {\n              if (pol) {\n                L_diff *= -1;\n              }\n\n              if (L_diff < 0) {\n                t0 = t;\n                t += (t1 - t) * 0.5;\n              } else {\n                t1 = t;\n                t += (t0 - t) * 0.5;\n              }\n\n              L_actual = getColor(t, true).lab()[0];\n              return L_diff = L_actual - L_ideal;\n            })();\n          }\n\n          return t;\n        };\n      } else {\n        tMapLightness = function tMapLightness(t) {\n          return t;\n        };\n      }\n\n      return f;\n    };\n\n    f.padding = function (p) {\n      if (p != null) {\n        if (type$j(p) === 'number') {\n          p = [p, p];\n        }\n\n        _padding = p;\n        return f;\n      } else {\n        return _padding;\n      }\n    };\n\n    f.colors = function (numColors, out) {\n      // If no arguments are given, return the original colors that were provided\n      if (arguments.length < 2) {\n        out = 'hex';\n      }\n\n      var result = [];\n\n      if (arguments.length === 0) {\n        result = _colors.slice(0);\n      } else if (numColors === 1) {\n        result = [f(0.5)];\n      } else if (numColors > 1) {\n        var dm = _domain[0];\n        var dd = _domain[1] - dm;\n        result = __range__(0, numColors, false).map(function (i) {\n          return f(dm + i / (numColors - 1) * dd);\n        });\n      } else {\n        // returns all colors based on the defined classes\n        colors = [];\n        var samples = [];\n\n        if (_classes && _classes.length > 2) {\n          for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n          }\n        } else {\n          samples = _domain;\n        }\n\n        result = samples.map(function (v) {\n          return f(v);\n        });\n      }\n\n      if (chroma_1[out]) {\n        result = result.map(function (c) {\n          return c[out]();\n        });\n      }\n\n      return result;\n    };\n\n    f.cache = function (c) {\n      if (c != null) {\n        _useCache = c;\n        return f;\n      } else {\n        return _useCache;\n      }\n    };\n\n    f.gamma = function (g) {\n      if (g != null) {\n        _gamma = g;\n        return f;\n      } else {\n        return _gamma;\n      }\n    };\n\n    f.nodata = function (d) {\n      if (d != null) {\n        _nacol = chroma_1(d);\n        return f;\n      } else {\n        return _nacol;\n      }\n    };\n\n    return f;\n  };\n\n  function __range__(left, right, inclusive) {\n    var range = [];\n    var ascending = left < right;\n    var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n    for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n      range.push(i);\n    }\n\n    return range;\n  } //\n  // interpolates between a set of colors uzing a bezier spline\n  //\n  // @requires utils lab\n\n\n  var bezier = function bezier(colors) {\n    var assign, assign$1, assign$2;\n    var I, lab0, lab1, lab2;\n    colors = colors.map(function (c) {\n      return new Color_1(c);\n    });\n\n    if (colors.length === 2) {\n      // linear interpolation\n      assign = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign[0], lab1 = assign[1];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return lab0[i] + t * (lab1[i] - lab0[i]);\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 3) {\n      // quadratic bezier interpolation\n      assign$1 = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return (1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i];\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 4) {\n      // cubic bezier interpolation\n      var lab3;\n      assign$2 = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return (1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i];\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 5) {\n      var I0 = bezier(colors.slice(0, 3));\n      var I1 = bezier(colors.slice(2, 5));\n\n      I = function I(t) {\n        if (t < 0.5) {\n          return I0(t * 2);\n        } else {\n          return I1((t - 0.5) * 2);\n        }\n      };\n    }\n\n    return I;\n  };\n\n  var bezier_1 = function bezier_1(colors) {\n    var f = bezier(colors);\n\n    f.scale = function () {\n      return scale(f);\n    };\n\n    return f;\n  };\n  /*\n   * interpolates between a set of colors uzing a bezier spline\n   * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n   */\n\n\n  var blend = function blend(bottom, top, mode) {\n    if (!blend[mode]) {\n      throw new Error('unknown blend mode ' + mode);\n    }\n\n    return blend[mode](bottom, top);\n  };\n\n  var blend_f = function blend_f(f) {\n    return function (bottom, top) {\n      var c0 = chroma_1(top).rgb();\n      var c1 = chroma_1(bottom).rgb();\n      return chroma_1.rgb(f(c0, c1));\n    };\n  };\n\n  var each = function each(f) {\n    return function (c0, c1) {\n      var out = [];\n      out[0] = f(c0[0], c1[0]);\n      out[1] = f(c0[1], c1[1]);\n      out[2] = f(c0[2], c1[2]);\n      return out;\n    };\n  };\n\n  var normal = function normal(a) {\n    return a;\n  };\n\n  var multiply = function multiply(a, b) {\n    return a * b / 255;\n  };\n\n  var darken$1 = function darken$1(a, b) {\n    return a > b ? b : a;\n  };\n\n  var lighten = function lighten(a, b) {\n    return a > b ? a : b;\n  };\n\n  var screen = function screen(a, b) {\n    return 255 * (1 - (1 - a / 255) * (1 - b / 255));\n  };\n\n  var overlay = function overlay(a, b) {\n    return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\n  };\n\n  var burn = function burn(a, b) {\n    return 255 * (1 - (1 - b / 255) / (a / 255));\n  };\n\n  var dodge = function dodge(a, b) {\n    if (a === 255) {\n      return 255;\n    }\n\n    a = 255 * (b / 255) / (1 - a / 255);\n    return a > 255 ? 255 : a;\n  }; // # add = (a,b) ->\n  // #     if (a + b > 255) then 255 else a + b\n\n\n  blend.normal = blend_f(each(normal));\n  blend.multiply = blend_f(each(multiply));\n  blend.screen = blend_f(each(screen));\n  blend.overlay = blend_f(each(overlay));\n  blend.darken = blend_f(each(darken$1));\n  blend.lighten = blend_f(each(lighten));\n  blend.dodge = blend_f(each(dodge));\n  blend.burn = blend_f(each(burn)); // blend.add = blend_f(each(add));\n\n  var blend_1 = blend; // cubehelix interpolation\n  // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n  // http://astron-soc.in/bulletin/11June/289392011.pdf\n\n  var type$k = utils.type;\n  var clip_rgb$3 = utils.clip_rgb;\n  var TWOPI$2 = utils.TWOPI;\n  var pow$6 = Math.pow;\n  var sin$2 = Math.sin;\n  var cos$3 = Math.cos;\n\n  var cubehelix = function cubehelix(start, rotations, hue, gamma, lightness) {\n    if (start === void 0) start = 300;\n    if (rotations === void 0) rotations = -1.5;\n    if (hue === void 0) hue = 1;\n    if (gamma === void 0) gamma = 1;\n    if (lightness === void 0) lightness = [0, 1];\n    var dh = 0,\n        dl;\n\n    if (type$k(lightness) === 'array') {\n      dl = lightness[1] - lightness[0];\n    } else {\n      dl = 0;\n      lightness = [lightness, lightness];\n    }\n\n    var f = function f(fract) {\n      var a = TWOPI$2 * ((start + 120) / 360 + rotations * fract);\n      var l = pow$6(lightness[0] + dl * fract, gamma);\n      var h = dh !== 0 ? hue[0] + fract * dh : hue;\n      var amp = h * l * (1 - l) / 2;\n      var cos_a = cos$3(a);\n      var sin_a = sin$2(a);\n      var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n      var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n      var b = l + amp * (+1.97294 * cos_a);\n      return chroma_1(clip_rgb$3([r * 255, g * 255, b * 255, 1]));\n    };\n\n    f.start = function (s) {\n      if (s == null) {\n        return start;\n      }\n\n      start = s;\n      return f;\n    };\n\n    f.rotations = function (r) {\n      if (r == null) {\n        return rotations;\n      }\n\n      rotations = r;\n      return f;\n    };\n\n    f.gamma = function (g) {\n      if (g == null) {\n        return gamma;\n      }\n\n      gamma = g;\n      return f;\n    };\n\n    f.hue = function (h) {\n      if (h == null) {\n        return hue;\n      }\n\n      hue = h;\n\n      if (type$k(hue) === 'array') {\n        dh = hue[1] - hue[0];\n\n        if (dh === 0) {\n          hue = hue[1];\n        }\n      } else {\n        dh = 0;\n      }\n\n      return f;\n    };\n\n    f.lightness = function (h) {\n      if (h == null) {\n        return lightness;\n      }\n\n      if (type$k(h) === 'array') {\n        lightness = h;\n        dl = h[1] - h[0];\n      } else {\n        lightness = [h, h];\n        dl = 0;\n      }\n\n      return f;\n    };\n\n    f.scale = function () {\n      return chroma_1.scale(f);\n    };\n\n    f.hue(hue);\n    return f;\n  };\n\n  var digits = '0123456789abcdef';\n  var floor$2 = Math.floor;\n  var random = Math.random;\n\n  var random_1 = function random_1() {\n    var code = '#';\n\n    for (var i = 0; i < 6; i++) {\n      code += digits.charAt(floor$2(random() * 16));\n    }\n\n    return new Color_1(code, 'hex');\n  };\n\n  var log$1 = Math.log;\n  var pow$7 = Math.pow;\n  var floor$3 = Math.floor;\n  var abs = Math.abs;\n\n  var analyze = function analyze(data, key) {\n    if (key === void 0) key = null;\n    var r = {\n      min: Number.MAX_VALUE,\n      max: Number.MAX_VALUE * -1,\n      sum: 0,\n      values: [],\n      count: 0\n    };\n\n    if (type(data) === 'object') {\n      data = Object.values(data);\n    }\n\n    data.forEach(function (val) {\n      if (key && type(val) === 'object') {\n        val = val[key];\n      }\n\n      if (val !== undefined && val !== null && !isNaN(val)) {\n        r.values.push(val);\n        r.sum += val;\n\n        if (val < r.min) {\n          r.min = val;\n        }\n\n        if (val > r.max) {\n          r.max = val;\n        }\n\n        r.count += 1;\n      }\n    });\n    r.domain = [r.min, r.max];\n\n    r.limits = function (mode, num) {\n      return limits(r, mode, num);\n    };\n\n    return r;\n  };\n\n  var limits = function limits(data, mode, num) {\n    if (mode === void 0) mode = 'equal';\n    if (num === void 0) num = 7;\n\n    if (type(data) == 'array') {\n      data = analyze(data);\n    }\n\n    var min = data.min;\n    var max = data.max;\n    var values = data.values.sort(function (a, b) {\n      return a - b;\n    });\n\n    if (num === 1) {\n      return [min, max];\n    }\n\n    var limits = [];\n\n    if (mode.substr(0, 1) === 'c') {\n      // continuous\n      limits.push(min);\n      limits.push(max);\n    }\n\n    if (mode.substr(0, 1) === 'e') {\n      // equal interval\n      limits.push(min);\n\n      for (var i = 1; i < num; i++) {\n        limits.push(min + i / num * (max - min));\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n      // log scale\n      if (min <= 0) {\n        throw new Error('Logarithmic scales are only possible for values > 0');\n      }\n\n      var min_log = Math.LOG10E * log$1(min);\n      var max_log = Math.LOG10E * log$1(max);\n      limits.push(min);\n\n      for (var i$1 = 1; i$1 < num; i$1++) {\n        limits.push(pow$7(10, min_log + i$1 / num * (max_log - min_log)));\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n      // quantile scale\n      limits.push(min);\n\n      for (var i$2 = 1; i$2 < num; i$2++) {\n        var p = (values.length - 1) * i$2 / num;\n        var pb = floor$3(p);\n\n        if (pb === p) {\n          limits.push(values[pb]);\n        } else {\n          // p > pb\n          var pr = p - pb;\n          limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n        }\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n      // k-means clustering\n\n      /*\n      implementation based on\n      http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n      simplified for 1-d input values\n      */\n      var cluster;\n      var n = values.length;\n      var assignments = new Array(n);\n      var clusterSizes = new Array(num);\n      var repeat = true;\n      var nb_iters = 0;\n      var centroids = null; // get seed values\n\n      centroids = [];\n      centroids.push(min);\n\n      for (var i$3 = 1; i$3 < num; i$3++) {\n        centroids.push(min + i$3 / num * (max - min));\n      }\n\n      centroids.push(max);\n\n      while (repeat) {\n        // assignment step\n        for (var j = 0; j < num; j++) {\n          clusterSizes[j] = 0;\n        }\n\n        for (var i$4 = 0; i$4 < n; i$4++) {\n          var value = values[i$4];\n          var mindist = Number.MAX_VALUE;\n          var best = void 0;\n\n          for (var j$1 = 0; j$1 < num; j$1++) {\n            var dist = abs(centroids[j$1] - value);\n\n            if (dist < mindist) {\n              mindist = dist;\n              best = j$1;\n            }\n\n            clusterSizes[best]++;\n            assignments[i$4] = best;\n          }\n        } // update centroids step\n\n\n        var newCentroids = new Array(num);\n\n        for (var j$2 = 0; j$2 < num; j$2++) {\n          newCentroids[j$2] = null;\n        }\n\n        for (var i$5 = 0; i$5 < n; i$5++) {\n          cluster = assignments[i$5];\n\n          if (newCentroids[cluster] === null) {\n            newCentroids[cluster] = values[i$5];\n          } else {\n            newCentroids[cluster] += values[i$5];\n          }\n        }\n\n        for (var j$3 = 0; j$3 < num; j$3++) {\n          newCentroids[j$3] *= 1 / clusterSizes[j$3];\n        } // check convergence\n\n\n        repeat = false;\n\n        for (var j$4 = 0; j$4 < num; j$4++) {\n          if (newCentroids[j$4] !== centroids[j$4]) {\n            repeat = true;\n            break;\n          }\n        }\n\n        centroids = newCentroids;\n        nb_iters++;\n\n        if (nb_iters > 200) {\n          repeat = false;\n        }\n      } // finished k-means clustering\n      // the next part is borrowed from gabrielflor.it\n\n\n      var kClusters = {};\n\n      for (var j$5 = 0; j$5 < num; j$5++) {\n        kClusters[j$5] = [];\n      }\n\n      for (var i$6 = 0; i$6 < n; i$6++) {\n        cluster = assignments[i$6];\n        kClusters[cluster].push(values[i$6]);\n      }\n\n      var tmpKMeansBreaks = [];\n\n      for (var j$6 = 0; j$6 < num; j$6++) {\n        tmpKMeansBreaks.push(kClusters[j$6][0]);\n        tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);\n      }\n\n      tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) {\n        return a - b;\n      });\n      limits.push(tmpKMeansBreaks[0]);\n\n      for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {\n        var v = tmpKMeansBreaks[i$7];\n\n        if (!isNaN(v) && limits.indexOf(v) === -1) {\n          limits.push(v);\n        }\n      }\n    }\n\n    return limits;\n  };\n\n  var analyze_1 = {\n    analyze: analyze,\n    limits: limits\n  };\n\n  var contrast = function contrast(a, b) {\n    // WCAG contrast ratio\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var l1 = a.luminance();\n    var l2 = b.luminance();\n    return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n  };\n\n  var sqrt$4 = Math.sqrt;\n  var atan2$2 = Math.atan2;\n  var abs$1 = Math.abs;\n  var cos$4 = Math.cos;\n  var PI$2 = Math.PI;\n\n  var deltaE = function deltaE(a, b, L, C) {\n    if (L === void 0) L = 1;\n    if (C === void 0) C = 1; // Delta E (CMC)\n    // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\n\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var ref = Array.from(a.lab());\n    var L1 = ref[0];\n    var a1 = ref[1];\n    var b1 = ref[2];\n    var ref$1 = Array.from(b.lab());\n    var L2 = ref$1[0];\n    var a2 = ref$1[1];\n    var b2 = ref$1[2];\n    var c1 = sqrt$4(a1 * a1 + b1 * b1);\n    var c2 = sqrt$4(a2 * a2 + b2 * b2);\n    var sl = L1 < 16.0 ? 0.511 : 0.040975 * L1 / (1.0 + 0.01765 * L1);\n    var sc = 0.0638 * c1 / (1.0 + 0.0131 * c1) + 0.638;\n    var h1 = c1 < 0.000001 ? 0.0 : atan2$2(b1, a1) * 180.0 / PI$2;\n\n    while (h1 < 0) {\n      h1 += 360;\n    }\n\n    while (h1 >= 360) {\n      h1 -= 360;\n    }\n\n    var t = h1 >= 164.0 && h1 <= 345.0 ? 0.56 + abs$1(0.2 * cos$4(PI$2 * (h1 + 168.0) / 180.0)) : 0.36 + abs$1(0.4 * cos$4(PI$2 * (h1 + 35.0) / 180.0));\n    var c4 = c1 * c1 * c1 * c1;\n    var f = sqrt$4(c4 / (c4 + 1900.0));\n    var sh = sc * (f * t + 1.0 - f);\n    var delL = L1 - L2;\n    var delC = c1 - c2;\n    var delA = a1 - a2;\n    var delB = b1 - b2;\n    var dH2 = delA * delA + delB * delB - delC * delC;\n    var v1 = delL / (L * sl);\n    var v2 = delC / (C * sc);\n    var v3 = sh;\n    return sqrt$4(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));\n  }; // simple Euclidean distance\n\n\n  var distance = function distance(a, b, mode) {\n    if (mode === void 0) mode = 'lab'; // Delta E (CIE 1976)\n    // see http://www.brucelindbloom.com/index.html?Equations.html\n\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var l1 = a.get(mode);\n    var l2 = b.get(mode);\n    var sum_sq = 0;\n\n    for (var i in l1) {\n      var d = (l1[i] || 0) - (l2[i] || 0);\n      sum_sq += d * d;\n    }\n\n    return Math.sqrt(sum_sq);\n  };\n\n  var valid = function valid() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    try {\n      new (Function.prototype.bind.apply(Color_1, [null].concat(args)))();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // some pre-defined color scales:\n\n\n  var scales = {\n    cool: function cool() {\n      return scale([chroma_1.hsl(180, 1, .9), chroma_1.hsl(250, .7, .4)]);\n    },\n    hot: function hot() {\n      return scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');\n    }\n  };\n  /**\n      ColorBrewer colors for chroma.js\n       Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n      Pennsylvania State University.\n       Licensed under the Apache License, Version 2.0 (the \"License\");\n      you may not use this file except in compliance with the License.\n      You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n       Unless required by applicable law or agreed to in writing, software distributed\n      under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n      CONDITIONS OF ANY KIND, either express or implied. See the License for the\n      specific language governing permissions and limitations under the License.\n  */\n\n  var colorbrewer = {\n    // sequential\n    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n    Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n    // diverging\n    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n    // qualitative\n    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n  }; // add lowercase aliases for case-insensitive matches\n\n  for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\n    var key = list$1[i$1];\n    colorbrewer[key.toLowerCase()] = colorbrewer[key];\n  }\n\n  var colorbrewer_1 = colorbrewer; // feel free to comment out anything to rollup\n  // a smaller chroma.js built\n  // io --\x3e convert colors\n  // operators --\x3e modify existing Colors\n  // interpolators\n  // generators -- > create new colors\n\n  chroma_1.average = average;\n  chroma_1.bezier = bezier_1;\n  chroma_1.blend = blend_1;\n  chroma_1.cubehelix = cubehelix;\n  chroma_1.mix = chroma_1.interpolate = mix;\n  chroma_1.random = random_1;\n  chroma_1.scale = scale; // other utility methods\n\n  chroma_1.analyze = analyze_1.analyze;\n  chroma_1.contrast = contrast;\n  chroma_1.deltaE = deltaE;\n  chroma_1.distance = distance;\n  chroma_1.limits = analyze_1.limits;\n  chroma_1.valid = valid; // scale\n\n  chroma_1.scales = scales; // colors\n\n  chroma_1.colors = w3cx11_1;\n  chroma_1.brewer = colorbrewer_1;\n  var chroma_js = chroma_1;\n  return chroma_js;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9jaHJvbWEtanMvY2hyb21hLmpzP2JmNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBNEQsZ0NBQWdDLENBQXdGO0FBQ3RMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQSxxSEFBcUgsaUJBQWlCO0FBQ3RJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxFQUFFLGFBQWEsRUFBRTtBQUNqRCxpQ0FBaUMsRUFBRSxhQUFhLEVBQUU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxpQkFBaUI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkMsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUEseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsdUJBQXVCLDhCQUE4QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMzg3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY2hyb21hLmpzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjb2xvciBjb252ZXJzaW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE5LCBHcmVnb3IgQWlzY2hcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIFRoZSBuYW1lIEdyZWdvciBBaXNjaCBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHUkVHT1IgQUlTQ0ggT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxuICogQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gKiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBjaHJvbWEuanMgaW5jbHVkZXMgY29sb3JzIGZyb20gY29sb3JicmV3ZXIyLm9yZywgd2hpY2ggYXJlIHJlbGVhc2VkIHVuZGVyXG4gKiB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLFxuICogYW5kIFRoZSBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCxcbiAqIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIE5hbWVkIGNvbG9ycyBhcmUgdGFrZW4gZnJvbSBYMTEgQ29sb3IgTmFtZXMuXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAqXG4gKiBAcHJlc2VydmVcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiBnbG9iYWwuY2hyb21hID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGxpbWl0ID0gZnVuY3Rpb24gbGltaXQoeCwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApIG1pbiA9IDA7XG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKSBtYXggPSAxO1xuICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeCA+IG1heCA/IG1heCA6IHg7XG4gIH07XG5cbiAgdmFyIGNsaXBfcmdiID0gZnVuY3Rpb24gY2xpcF9yZ2IocmdiKSB7XG4gICAgcmdiLl9jbGlwcGVkID0gZmFsc2U7XG4gICAgcmdiLl91bmNsaXBwZWQgPSByZ2Iuc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgIGlmIChpIDwgMykge1xuICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHtcbiAgICAgICAgICByZ2IuX2NsaXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmdiW2ldID0gbGltaXQocmdiW2ldLCAwLCAyNTUpO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYjtcbiAgfTsgLy8gcG9ydGVkIGZyb20galF1ZXJ5J3MgJC50eXBlXG5cblxuICB2YXIgY2xhc3NUb1R5cGUgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IFsnQm9vbGVhbicsICdOdW1iZXInLCAnU3RyaW5nJywgJ0Z1bmN0aW9uJywgJ0FycmF5JywgJ0RhdGUnLCAnUmVnRXhwJywgJ1VuZGVmaW5lZCcsICdOdWxsJ107IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuICAgIGNsYXNzVG9UeXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZ1bmN0aW9uIHR5cGUob2JqKSB7XG4gICAgcmV0dXJuIGNsYXNzVG9UeXBlW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiO1xuICB9O1xuXG4gIHZhciB1bnBhY2sgPSBmdW5jdGlvbiB1bnBhY2soYXJncywga2V5T3JkZXIpIHtcbiAgICBpZiAoa2V5T3JkZXIgPT09IHZvaWQgMCkga2V5T3JkZXIgPSBudWxsOyAvLyBpZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gMyBhcmd1bWVudHMsIHdlIHJldHVybiB0aGUgYXJndW1lbnRzXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIH0gLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAvLyBhbmQgdXNlIHRoZSBrZXlPcmRlciBzdHJpbmcgdG8gZXh0cmFjdCBhbmQgc29ydCBwcm9wZXJ0aWVzXG5cblxuICAgIGlmICh0eXBlKGFyZ3NbMF0pID09ICdvYmplY3QnICYmIGtleU9yZGVyKSB7XG4gICAgICByZXR1cm4ga2V5T3JkZXIuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdW2tdO1xuICAgICAgfSk7XG4gICAgfSAvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgLy8gKHdoaWNoIHdlIHN1cHBvc2UgaXMgYW4gYXJyYXkgb2YgYXJncylcblxuXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH07XG5cbiAgdmFyIGxhc3QgPSBmdW5jdGlvbiBsYXN0KGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0eXBlKGFyZ3NbbF0pID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXJnc1tsXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBQSSA9IE1hdGguUEk7XG4gIHZhciB1dGlscyA9IHtcbiAgICBjbGlwX3JnYjogY2xpcF9yZ2IsXG4gICAgbGltaXQ6IGxpbWl0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdW5wYWNrOiB1bnBhY2ssXG4gICAgbGFzdDogbGFzdCxcbiAgICBQSTogUEksXG4gICAgVFdPUEk6IFBJICogMixcbiAgICBQSVRISVJEOiBQSSAvIDMsXG4gICAgREVHMlJBRDogUEkgLyAxODAsXG4gICAgUkFEMkRFRzogMTgwIC8gUElcbiAgfTtcbiAgdmFyIGlucHV0ID0ge1xuICAgIGZvcm1hdDoge30sXG4gICAgYXV0b2RldGVjdDogW11cbiAgfTtcbiAgdmFyIGxhc3QkMSA9IHV0aWxzLmxhc3Q7XG4gIHZhciBjbGlwX3JnYiQxID0gdXRpbHMuY2xpcF9yZ2I7XG4gIHZhciB0eXBlJDEgPSB1dGlscy50eXBlO1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZiAodHlwZSQxKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgPT09IHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIC8vIHRoZSBhcmd1bWVudCBpcyBhbHJlYWR5IGEgQ29sb3IgaW5zdGFuY2VcbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH0gLy8gbGFzdCBhcmd1bWVudCBjb3VsZCBiZSB0aGUgbW9kZVxuXG5cbiAgICB2YXIgbW9kZSA9IGxhc3QkMShhcmdzKTtcbiAgICB2YXIgYXV0b2RldGVjdCA9IGZhbHNlO1xuXG4gICAgaWYgKCFtb2RlKSB7XG4gICAgICBhdXRvZGV0ZWN0ID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpbnB1dC5zb3J0ZWQpIHtcbiAgICAgICAgaW5wdXQuYXV0b2RldGVjdCA9IGlucHV0LmF1dG9kZXRlY3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBiLnAgLSBhLnA7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5zb3J0ZWQgPSB0cnVlO1xuICAgICAgfSAvLyBhdXRvLWRldGVjdCBmb3JtYXRcblxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGlucHV0LmF1dG9kZXRlY3Q7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGsgPSBsaXN0W2ldO1xuICAgICAgICBtb2RlID0gY2hrLnRlc3QuYXBwbHkoY2hrLCBhcmdzKTtcblxuICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgdmFyIHJnYiA9IGlucHV0LmZvcm1hdFttb2RlXS5hcHBseShudWxsLCBhdXRvZGV0ZWN0ID8gYXJncyA6IGFyZ3Muc2xpY2UoMCwgLTEpKTtcbiAgICAgIG1lLl9yZ2IgPSBjbGlwX3JnYiQxKHJnYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmb3JtYXQ6ICcgKyBhcmdzKTtcbiAgICB9IC8vIGFkZCBhbHBoYSBjaGFubmVsXG5cblxuICAgIGlmIChtZS5fcmdiLmxlbmd0aCA9PT0gMykge1xuICAgICAgbWUuX3JnYi5wdXNoKDEpO1xuICAgIH1cbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodHlwZSQxKHRoaXMuaGV4KSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZXgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLl9yZ2Iuam9pbignLCcpICsgXCJdXCI7XG4gIH07XG5cbiAgdmFyIENvbG9yXzEgPSBDb2xvcjtcblxuICB2YXIgY2hyb21hID0gZnVuY3Rpb24gY2hyb21hKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGNocm9tYS5Db2xvciwgW251bGxdLmNvbmNhdChhcmdzKSkpKCk7XG4gIH07XG5cbiAgY2hyb21hLkNvbG9yID0gQ29sb3JfMTtcbiAgY2hyb21hLnZlcnNpb24gPSAnMi4xLjInO1xuICB2YXIgY2hyb21hXzEgPSBjaHJvbWE7XG4gIHZhciB1bnBhY2skMSA9IHV0aWxzLnVucGFjaztcbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuXG4gIHZhciByZ2IyY215ayA9IGZ1bmN0aW9uIHJnYjJjbXlrKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciByZWYgPSB1bnBhY2skMShhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgciA9IHIgLyAyNTU7XG4gICAgZyA9IGcgLyAyNTU7XG4gICAgYiA9IGIgLyAyNTU7XG4gICAgdmFyIGsgPSAxIC0gbWF4KHIsIG1heChnLCBiKSk7XG4gICAgdmFyIGYgPSBrIDwgMSA/IDEgLyAoMSAtIGspIDogMDtcbiAgICB2YXIgYyA9ICgxIC0gciAtIGspICogZjtcbiAgICB2YXIgbSA9ICgxIC0gZyAtIGspICogZjtcbiAgICB2YXIgeSA9ICgxIC0gYiAtIGspICogZjtcbiAgICByZXR1cm4gW2MsIG0sIHksIGtdO1xuICB9O1xuXG4gIHZhciByZ2IyY215a18xID0gcmdiMmNteWs7XG4gIHZhciB1bnBhY2skMiA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgY215azJyZ2IgPSBmdW5jdGlvbiBjbXlrMnJnYigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDIoYXJncywgJ2NteWsnKTtcbiAgICB2YXIgYyA9IGFyZ3NbMF07XG4gICAgdmFyIG0gPSBhcmdzWzFdO1xuICAgIHZhciB5ID0gYXJnc1syXTtcbiAgICB2YXIgayA9IGFyZ3NbM107XG4gICAgdmFyIGFscGhhID0gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IDE7XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCBhbHBoYV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjID49IDEgPyAwIDogMjU1ICogKDEgLSBjKSAqICgxIC0gayksIC8vIHJcbiAgICBtID49IDEgPyAwIDogMjU1ICogKDEgLSBtKSAqICgxIC0gayksIC8vIGdcbiAgICB5ID49IDEgPyAwIDogMjU1ICogKDEgLSB5KSAqICgxIC0gayksIC8vIGJcbiAgICBhbHBoYV07XG4gIH07XG5cbiAgdmFyIGNteWsycmdiXzEgPSBjbXlrMnJnYjtcbiAgdmFyIHVucGFjayQzID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSQyID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyY215a18xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnY215ayddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmNteWsgPSBjbXlrMnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gdW5wYWNrJDMoYXJncywgJ2NteWsnKTtcblxuICAgICAgaWYgKHR5cGUkMihhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ2NteWsnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skNCA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGxhc3QkMiA9IHV0aWxzLmxhc3Q7XG5cbiAgdmFyIHJuZCA9IGZ1bmN0aW9uIHJuZChhKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqIDEwMCkgLyAxMDA7XG4gIH07XG4gIC8qXG4gICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICogLSBoc2wyY3NzKGgscyxsLGEpXG4gICAqIC0gaHNsMmNzcyhbaCxzLGxdLCBtb2RlKVxuICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgKiAtIGhzbDJjc3Moe2gscyxsLGF9LCBtb2RlKVxuICAgKi9cblxuXG4gIHZhciBoc2wyY3NzID0gZnVuY3Rpb24gaHNsMmNzcygpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgaHNsYSA9IHVucGFjayQ0KGFyZ3MsICdoc2xhJyk7XG4gICAgdmFyIG1vZGUgPSBsYXN0JDIoYXJncykgfHwgJ2xzYSc7XG4gICAgaHNsYVswXSA9IHJuZChoc2xhWzBdIHx8IDApO1xuICAgIGhzbGFbMV0gPSBybmQoaHNsYVsxXSAqIDEwMCkgKyAnJSc7XG4gICAgaHNsYVsyXSA9IHJuZChoc2xhWzJdICogMTAwKSArICclJztcblxuICAgIGlmIChtb2RlID09PSAnaHNsYScgfHwgaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM10gPCAxKSB7XG4gICAgICBoc2xhWzNdID0gaHNsYS5sZW5ndGggPiAzID8gaHNsYVszXSA6IDE7XG4gICAgICBtb2RlID0gJ2hzbGEnO1xuICAgIH0gZWxzZSB7XG4gICAgICBoc2xhLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGUgKyBcIihcIiArIGhzbGEuam9pbignLCcpICsgXCIpXCI7XG4gIH07XG5cbiAgdmFyIGhzbDJjc3NfMSA9IGhzbDJjc3M7XG4gIHZhciB1bnBhY2skNSA9IHV0aWxzLnVucGFjaztcbiAgLypcbiAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICogLSByZ2IyaHNsKHIsZyxiKVxuICAgKiAtIHJnYjJoc2wocixnLGIsYSlcbiAgICogLSByZ2IyaHNsKFtyLGcsYl0pXG4gICAqIC0gcmdiMmhzbChbcixnLGIsYV0pXG4gICAqIC0gcmdiMmhzbCh7cixnLGIsYX0pXG4gICAqL1xuXG4gIHZhciByZ2IyaHNsID0gZnVuY3Rpb24gcmdiMmhzbCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDUoYXJncywgJ3JnYmEnKTtcbiAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgIHZhciBiID0gYXJnc1syXTtcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIHZhciBzLCBoO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBzID0gMDtcbiAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gbCA8IDAuNSA/IChtYXggLSBtaW4pIC8gKG1heCArIG1pbikgOiAobWF4IC0gbWluKSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICB9XG5cbiAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gKG1heCAtIG1pbik7XG4gICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gKG1heCAtIG1pbik7XG4gICAgfSBlbHNlIGlmIChiID09IG1heCkge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gKG1heCAtIG1pbik7XG4gICAgfVxuXG4gICAgaCAqPSA2MDtcblxuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAzNjA7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMyAmJiBhcmdzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYXJnc1szXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfTtcblxuICB2YXIgcmdiMmhzbF8xID0gcmdiMmhzbDtcbiAgdmFyIHVucGFjayQ2ID0gdXRpbHMudW5wYWNrO1xuICB2YXIgbGFzdCQzID0gdXRpbHMubGFzdDtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgLypcbiAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICogLSByZ2IyY3NzKHIsZyxiKVxuICAgKiAtIHJnYjJjc3MocixnLGIsYSlcbiAgICogLSByZ2IyY3NzKFtyLGcsYl0sIG1vZGUpXG4gICAqIC0gcmdiMmNzcyhbcixnLGIsYV0sIG1vZGUpXG4gICAqIC0gcmdiMmNzcyh7cixnLGIsYX0sIG1vZGUpXG4gICAqL1xuXG4gIHZhciByZ2IyY3NzID0gZnVuY3Rpb24gcmdiMmNzcygpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgcmdiYSA9IHVucGFjayQ2KGFyZ3MsICdyZ2JhJyk7XG4gICAgdmFyIG1vZGUgPSBsYXN0JDMoYXJncykgfHwgJ3JnYic7XG5cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT0gJ2hzbCcpIHtcbiAgICAgIHJldHVybiBoc2wyY3NzXzEocmdiMmhzbF8xKHJnYmEpLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZ2JhWzBdID0gcm91bmQocmdiYVswXSk7XG4gICAgcmdiYVsxXSA9IHJvdW5kKHJnYmFbMV0pO1xuICAgIHJnYmFbMl0gPSByb3VuZChyZ2JhWzJdKTtcblxuICAgIGlmIChtb2RlID09PSAncmdiYScgfHwgcmdiYS5sZW5ndGggPiAzICYmIHJnYmFbM10gPCAxKSB7XG4gICAgICByZ2JhWzNdID0gcmdiYS5sZW5ndGggPiAzID8gcmdiYVszXSA6IDE7XG4gICAgICBtb2RlID0gJ3JnYmEnO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlICsgXCIoXCIgKyByZ2JhLnNsaWNlKDAsIG1vZGUgPT09ICdyZ2InID8gMyA6IDQpLmpvaW4oJywnKSArIFwiKVwiO1xuICB9O1xuXG4gIHZhciByZ2IyY3NzXzEgPSByZ2IyY3NzO1xuICB2YXIgdW5wYWNrJDcgPSB1dGlscy51bnBhY2s7XG4gIHZhciByb3VuZCQxID0gTWF0aC5yb3VuZDtcblxuICB2YXIgaHNsMnJnYiA9IGZ1bmN0aW9uIGhzbDJyZ2IoKSB7XG4gICAgdmFyIGFzc2lnbjtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDcoYXJncywgJ2hzbCcpO1xuICAgIHZhciBoID0gYXJnc1swXTtcbiAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgdmFyIGwgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGwgKiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0MyA9IFswLCAwLCAwXTtcbiAgICAgIHZhciBjID0gWzAsIDAsIDBdO1xuICAgICAgdmFyIHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgIHZhciB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICB2YXIgaF8gPSBoIC8gMzYwO1xuICAgICAgdDNbMF0gPSBoXyArIDEgLyAzO1xuICAgICAgdDNbMV0gPSBoXztcbiAgICAgIHQzWzJdID0gaF8gLSAxIC8gMztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgaWYgKHQzW2ldIDwgMCkge1xuICAgICAgICAgIHQzW2ldICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodDNbaV0gPiAxKSB7XG4gICAgICAgICAgdDNbaV0gLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICg2ICogdDNbaV0gPCAxKSB7XG4gICAgICAgICAgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldO1xuICAgICAgICB9IGVsc2UgaWYgKDIgKiB0M1tpXSA8IDEpIHtcbiAgICAgICAgICBjW2ldID0gdDI7XG4gICAgICAgIH0gZWxzZSBpZiAoMyAqIHQzW2ldIDwgMikge1xuICAgICAgICAgIGNbaV0gPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzW2ldKSAqIDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY1tpXSA9IHQxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFzc2lnbiA9IFtyb3VuZCQxKGNbMF0gKiAyNTUpLCByb3VuZCQxKGNbMV0gKiAyNTUpLCByb3VuZCQxKGNbMl0gKiAyNTUpXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgIHJldHVybiBbciwgZywgYiwgYXJnc1szXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgfTtcblxuICB2YXIgaHNsMnJnYl8xID0gaHNsMnJnYjtcbiAgdmFyIFJFX1JHQiA9IC9ecmdiXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKlxcKSQvO1xuICB2YXIgUkVfUkdCQSA9IC9ecmdiYVxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgdmFyIFJFX1JHQl9QQ1QgPSAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIFJFX1JHQkFfUENUID0gL15yZ2JhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuICB2YXIgUkVfSFNMID0gL15oc2xcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIFJFX0hTTEEgPSAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgdmFyIHJvdW5kJDIgPSBNYXRoLnJvdW5kO1xuXG4gIHZhciBjc3MycmdiID0gZnVuY3Rpb24gY3NzMnJnYihjc3MpIHtcbiAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgdmFyIG07XG5cbiAgICBpZiAoaW5wdXQuZm9ybWF0Lm5hbWVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZm9ybWF0Lm5hbWVkKGNzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB9XG4gICAgfSAvLyByZ2IoMjUwLDIwLDApXG5cblxuICAgIGlmIChtID0gY3NzLm1hdGNoKFJFX1JHQikpIHtcbiAgICAgIHZhciByZ2IgPSBtLnNsaWNlKDEsIDQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZ2JbaV0gPSArcmdiW2ldO1xuICAgICAgfVxuXG4gICAgICByZ2JbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG5cbiAgICAgIHJldHVybiByZ2I7XG4gICAgfSAvLyByZ2JhKDI1MCwyMCwwLDAuNClcblxuXG4gICAgaWYgKG0gPSBjc3MubWF0Y2goUkVfUkdCQSkpIHtcbiAgICAgIHZhciByZ2IkMSA9IG0uc2xpY2UoMSwgNSk7XG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDQ7IGkkMSsrKSB7XG4gICAgICAgIHJnYiQxW2kkMV0gPSArcmdiJDFbaSQxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJnYiQxO1xuICAgIH0gLy8gcmdiKDEwMCUsMCUsMCUpXG5cblxuICAgIGlmIChtID0gY3NzLm1hdGNoKFJFX1JHQl9QQ1QpKSB7XG4gICAgICB2YXIgcmdiJDIgPSBtLnNsaWNlKDEsIDQpO1xuXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCAzOyBpJDIrKykge1xuICAgICAgICByZ2IkMltpJDJdID0gcm91bmQkMihyZ2IkMltpJDJdICogMi41NSk7XG4gICAgICB9XG5cbiAgICAgIHJnYiQyWzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuXG4gICAgICByZXR1cm4gcmdiJDI7XG4gICAgfSAvLyByZ2JhKDEwMCUsMCUsMCUsMC40KVxuXG5cbiAgICBpZiAobSA9IGNzcy5tYXRjaChSRV9SR0JBX1BDVCkpIHtcbiAgICAgIHZhciByZ2IkMyA9IG0uc2xpY2UoMSwgNSk7XG5cbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IDM7IGkkMysrKSB7XG4gICAgICAgIHJnYiQzW2kkM10gPSByb3VuZCQyKHJnYiQzW2kkM10gKiAyLjU1KTtcbiAgICAgIH1cblxuICAgICAgcmdiJDNbM10gPSArcmdiJDNbM107XG4gICAgICByZXR1cm4gcmdiJDM7XG4gICAgfSAvLyBoc2woMCwxMDAlLDUwJSlcblxuXG4gICAgaWYgKG0gPSBjc3MubWF0Y2goUkVfSFNMKSkge1xuICAgICAgdmFyIGhzbCA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICBoc2xbMV0gKj0gMC4wMTtcbiAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgdmFyIHJnYiQ0ID0gaHNsMnJnYl8xKGhzbCk7XG4gICAgICByZ2IkNFszXSA9IDE7XG4gICAgICByZXR1cm4gcmdiJDQ7XG4gICAgfSAvLyBoc2xhKDAsMTAwJSw1MCUsMC41KVxuXG5cbiAgICBpZiAobSA9IGNzcy5tYXRjaChSRV9IU0xBKSkge1xuICAgICAgdmFyIGhzbCQxID0gbS5zbGljZSgxLCA0KTtcbiAgICAgIGhzbCQxWzFdICo9IDAuMDE7XG4gICAgICBoc2wkMVsyXSAqPSAwLjAxO1xuICAgICAgdmFyIHJnYiQ1ID0gaHNsMnJnYl8xKGhzbCQxKTtcbiAgICAgIHJnYiQ1WzNdID0gK21bNF07IC8vIGRlZmF1bHQgYWxwaGEgPSAxXG5cbiAgICAgIHJldHVybiByZ2IkNTtcbiAgICB9XG4gIH07XG5cbiAgY3NzMnJnYi50ZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gUkVfUkdCLnRlc3QocykgfHwgUkVfUkdCQS50ZXN0KHMpIHx8IFJFX1JHQl9QQ1QudGVzdChzKSB8fCBSRV9SR0JBX1BDVC50ZXN0KHMpIHx8IFJFX0hTTC50ZXN0KHMpIHx8IFJFX0hTTEEudGVzdChzKTtcbiAgfTtcblxuICB2YXIgY3NzMnJnYl8xID0gY3NzMnJnYjtcbiAgdmFyIHR5cGUkMyA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICByZXR1cm4gcmdiMmNzc18xKHRoaXMuX3JnYiwgbW9kZSk7XG4gIH07XG5cbiAgY2hyb21hXzEuY3NzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydjc3MnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5jc3MgPSBjc3MycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogNSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KGgpIHtcbiAgICAgIHZhciByZXN0ID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW4tLSA+IDApIHtcbiAgICAgICAgcmVzdFtsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkMyhoKSA9PT0gJ3N0cmluZycgJiYgY3NzMnJnYl8xLnRlc3QoaCkpIHtcbiAgICAgICAgcmV0dXJuICdjc3MnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skOCA9IHV0aWxzLnVucGFjaztcblxuICBpbnB1dC5mb3JtYXQuZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IHVucGFjayQ4KGFyZ3MsICdyZ2JhJyk7XG4gICAgcmdiWzBdICo9IDI1NTtcbiAgICByZ2JbMV0gKj0gMjU1O1xuICAgIHJnYlsyXSAqPSAyNTU7XG4gICAgcmV0dXJuIHJnYjtcbiAgfTtcblxuICBjaHJvbWFfMS5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnZ2wnXSkpKSgpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmdsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUsIHJnYlsxXSAvIDI1NSwgcmdiWzJdIC8gMjU1LCByZ2JbM11dO1xuICB9O1xuXG4gIHZhciB1bnBhY2skOSA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMmhjZyA9IGZ1bmN0aW9uIHJnYjJoY2coKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayQ5KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICB2YXIgYyA9IGRlbHRhICogMTAwIC8gMjU1O1xuXG4gICAgdmFyIF9nID0gbWluIC8gKDI1NSAtIGRlbHRhKSAqIDEwMDtcblxuICAgIHZhciBoO1xuXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA9PT0gbWF4KSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoICo9IDYwO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBjLCBfZ107XG4gIH07XG5cbiAgdmFyIHJnYjJoY2dfMSA9IHJnYjJoY2c7XG4gIHZhciB1bnBhY2skYSA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgLypcbiAgICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICAgKlxuICAgKiBodWUuLiBbMC4uMzYwXVxuICAgKiBjaHJvbWEgLi4gWzAuLjFdXG4gICAqIGdyYXluZXNzIC4uIFswLi4xXVxuICAgKi9cblxuICB2YXIgaGNnMnJnYiA9IGZ1bmN0aW9uIGhjZzJyZ2IoKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skYShhcmdzLCAnaGNnJyk7XG4gICAgdmFyIGggPSBhcmdzWzBdO1xuICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICB2YXIgX2cgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuICAgIF9nID0gX2cgKiAyNTU7XG5cbiAgICB2YXIgX2MgPSBjICogMjU1O1xuXG4gICAgaWYgKGMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IF9nO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaCA9PT0gMzYwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCA+IDM2MCkge1xuICAgICAgICBoIC09IDM2MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBoIC89IDYwO1xuICAgICAgdmFyIGkgPSBmbG9vcihoKTtcbiAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICB2YXIgcCA9IF9nICogKDEgLSBjKTtcbiAgICAgIHZhciBxID0gcCArIF9jICogKDEgLSBmKTtcbiAgICAgIHZhciB0ID0gcCArIF9jICogZjtcbiAgICAgIHZhciB2ID0gcCArIF9jO1xuXG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYXNzaWduJDEgPSBbcSwgdiwgcF0sIHIgPSBhc3NpZ24kMVswXSwgZyA9IGFzc2lnbiQxWzFdLCBiID0gYXNzaWduJDFbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGFzc2lnbiQyID0gW3AsIHYsIHRdLCByID0gYXNzaWduJDJbMF0sIGcgPSBhc3NpZ24kMlsxXSwgYiA9IGFzc2lnbiQyWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgYXNzaWduJDQgPSBbdCwgcCwgdl0sIHIgPSBhc3NpZ24kNFswXSwgZyA9IGFzc2lnbiQ0WzFdLCBiID0gYXNzaWduJDRbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGFzc2lnbiQ1ID0gW3YsIHAsIHFdLCByID0gYXNzaWduJDVbMF0sIGcgPSBhc3NpZ24kNVsxXSwgYiA9IGFzc2lnbiQ1WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICB9O1xuXG4gIHZhciBoY2cycmdiXzEgPSBoY2cycmdiO1xuICB2YXIgdW5wYWNrJGIgPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDQgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhjZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhjZ18xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoY2cnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oY2cgPSBoY2cycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skYihhcmdzLCAnaGNnJyk7XG5cbiAgICAgIGlmICh0eXBlJDQoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoY2cnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skYyA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGxhc3QkNCA9IHV0aWxzLmxhc3Q7XG4gIHZhciByb3VuZCQzID0gTWF0aC5yb3VuZDtcblxuICB2YXIgcmdiMmhleCA9IGZ1bmN0aW9uIHJnYjJoZXgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRjKGFyZ3MsICdyZ2JhJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGEgPSByZWZbM107XG4gICAgdmFyIG1vZGUgPSBsYXN0JDQoYXJncykgfHwgJ2F1dG8nO1xuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdhdXRvJykge1xuICAgICAgbW9kZSA9IGEgPCAxID8gJ3JnYmEnIDogJ3JnYic7XG4gICAgfVxuXG4gICAgciA9IHJvdW5kJDMocik7XG4gICAgZyA9IHJvdW5kJDMoZyk7XG4gICAgYiA9IHJvdW5kJDMoYik7XG4gICAgdmFyIHUgPSByIDw8IDE2IHwgZyA8PCA4IHwgYjtcbiAgICB2YXIgc3RyID0gXCIwMDAwMDBcIiArIHUudG9TdHJpbmcoMTYpOyAvLyMudG9VcHBlckNhc2UoKTtcblxuICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDYpO1xuICAgIHZhciBoeGEgPSAnMCcgKyByb3VuZCQzKGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICBoeGEgPSBoeGEuc3Vic3RyKGh4YS5sZW5ndGggLSAyKTtcblxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgc3RyICsgaHhhO1xuXG4gICAgICBjYXNlICdhcmdiJzpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgaHhhICsgc3RyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCIjXCIgKyBzdHI7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZ2IyaGV4XzEgPSByZ2IyaGV4O1xuICB2YXIgUkVfSEVYID0gL14jPyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkLztcbiAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gIHZhciBoZXgycmdiID0gZnVuY3Rpb24gaGV4MnJnYihoZXgpIHtcbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWCkpIHtcbiAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgIH0gLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgc2l4LWRpZ2l0XG5cblxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgaGV4ID0gaGV4WzBdICsgaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgdmFyIHIgPSB1ID4+IDE2O1xuICAgICAgdmFyIGcgPSB1ID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSB1ICYgMHhGRjtcbiAgICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gICAgfSAvLyBtYXRjaCByZ2JhIGhleCBmb3JtYXQsIGVnICNGRjAwMDA3N1xuXG5cbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWEEpKSB7XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNSB8fCBoZXgubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgIH0gLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgZWlnaHQtZGlnaXRcblxuXG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICBoZXggPSBoZXhbMF0gKyBoZXhbMF0gKyBoZXhbMV0gKyBoZXhbMV0gKyBoZXhbMl0gKyBoZXhbMl0gKyBoZXhbM10gKyBoZXhbM107XG4gICAgICB9XG5cbiAgICAgIHZhciB1JDEgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgIHZhciByJDEgPSB1JDEgPj4gMjQgJiAweEZGO1xuICAgICAgdmFyIGckMSA9IHUkMSA+PiAxNiAmIDB4RkY7XG4gICAgICB2YXIgYiQxID0gdSQxID4+IDggJiAweEZGO1xuICAgICAgdmFyIGEgPSBNYXRoLnJvdW5kKCh1JDEgJiAweEZGKSAvIDB4RkYgKiAxMDApIC8gMTAwO1xuICAgICAgcmV0dXJuIFtyJDEsIGckMSwgYiQxLCBhXTtcbiAgICB9IC8vIHdlIHVzZWQgdG8gY2hlY2sgZm9yIGNzcyBjb2xvcnMgaGVyZVxuICAgIC8vIGlmIF9pbnB1dC5jc3M/IGFuZCByZ2IgPSBfaW5wdXQuY3NzIGhleFxuICAgIC8vICAgICByZXR1cm4gcmdiXG5cblxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gaGV4IGNvbG9yOiBcIiArIGhleCk7XG4gIH07XG5cbiAgdmFyIGhleDJyZ2JfMSA9IGhleDJyZ2I7XG4gIHZhciB0eXBlJDUgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIHJnYjJoZXhfMSh0aGlzLl9yZ2IsIG1vZGUpO1xuICB9O1xuXG4gIGNocm9tYV8xLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnaGV4J10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQuaGV4ID0gaGV4MnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDQsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdChoKSB7XG4gICAgICB2YXIgcmVzdCA9IFtdLFxuICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICAgIHJlc3RbbGVuXSA9IGFyZ3VtZW50c1tsZW4gKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJDUoaCkgPT09ICdzdHJpbmcnICYmIFszLCA0LCA1LCA2LCA3LCA4LCA5XS5pbmRleE9mKGgubGVuZ3RoKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnaGV4JztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgdW5wYWNrJGQgPSB1dGlscy51bnBhY2s7XG4gIHZhciBUV09QSSA9IHV0aWxzLlRXT1BJO1xuICB2YXIgbWluID0gTWF0aC5taW47XG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgYWNvcyA9IE1hdGguYWNvcztcblxuICB2YXIgcmdiMmhzaSA9IGZ1bmN0aW9uIHJnYjJoc2koKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9yZ2IyaHNpLmNwcFxuICAgICovXG5cblxuICAgIHZhciByZWYgPSB1bnBhY2skZChhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgdmFyIGg7XG4gICAgdmFyIG1pbl8gPSBtaW4ociwgZywgYik7XG4gICAgdmFyIGkgPSAociArIGcgKyBiKSAvIDM7XG4gICAgdmFyIHMgPSBpID4gMCA/IDEgLSBtaW5fIC8gaSA6IDA7XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgaCA9IE5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IChyIC0gZyArIChyIC0gYikpIC8gMjtcbiAgICAgIGggLz0gc3FydCgociAtIGcpICogKHIgLSBnKSArIChyIC0gYikgKiAoZyAtIGIpKTtcbiAgICAgIGggPSBhY29zKGgpO1xuXG4gICAgICBpZiAoYiA+IGcpIHtcbiAgICAgICAgaCA9IFRXT1BJIC0gaDtcbiAgICAgIH1cblxuICAgICAgaCAvPSBUV09QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2ggKiAzNjAsIHMsIGldO1xuICB9O1xuXG4gIHZhciByZ2IyaHNpXzEgPSByZ2IyaHNpO1xuICB2YXIgdW5wYWNrJGUgPSB1dGlscy51bnBhY2s7XG4gIHZhciBsaW1pdCQxID0gdXRpbHMubGltaXQ7XG4gIHZhciBUV09QSSQxID0gdXRpbHMuVFdPUEk7XG4gIHZhciBQSVRISVJEID0gdXRpbHMuUElUSElSRDtcbiAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAvKlxuICAgKiBodWUgWzAuLjM2MF1cbiAgICogc2F0dXJhdGlvbiBbMC4uMV1cbiAgICogaW50ZW5zaXR5IFswLi4xXVxuICAgKi9cblxuICB2YXIgaHNpMnJnYiA9IGZ1bmN0aW9uIGhzaTJyZ2IoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9oc2kycmdiLmNwcFxuICAgICovXG5cblxuICAgIGFyZ3MgPSB1bnBhY2skZShhcmdzLCAnaHNpJyk7XG4gICAgdmFyIGggPSBhcmdzWzBdO1xuICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICB2YXIgaSA9IGFyZ3NbMl07XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAoaXNOYU4oaCkpIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihzKSkge1xuICAgICAgcyA9IDA7XG4gICAgfSAvLyBub3JtYWxpemUgaHVlXG5cblxuICAgIGlmIChoID4gMzYwKSB7XG4gICAgICBoIC09IDM2MDtcbiAgICB9XG5cbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMzYwO1xuICAgIH1cblxuICAgIGggLz0gMzYwO1xuXG4gICAgaWYgKGggPCAxIC8gMykge1xuICAgICAgYiA9ICgxIC0gcykgLyAzO1xuICAgICAgciA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgZyA9IDEgLSAoYiArIHIpO1xuICAgIH0gZWxzZSBpZiAoaCA8IDIgLyAzKSB7XG4gICAgICBoIC09IDEgLyAzO1xuICAgICAgciA9ICgxIC0gcykgLyAzO1xuICAgICAgZyA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgYiA9IDEgLSAociArIGcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoIC09IDIgLyAzO1xuICAgICAgZyA9ICgxIC0gcykgLyAzO1xuICAgICAgYiA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgciA9IDEgLSAoZyArIGIpO1xuICAgIH1cblxuICAgIHIgPSBsaW1pdCQxKGkgKiByICogMyk7XG4gICAgZyA9IGxpbWl0JDEoaSAqIGcgKiAzKTtcbiAgICBiID0gbGltaXQkMShpICogYiAqIDMpO1xuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICB9O1xuXG4gIHZhciBoc2kycmdiXzEgPSBoc2kycmdiO1xuICB2YXIgdW5wYWNrJGYgPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDYgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhzaSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhzaV8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaHNpID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoc2knXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oc2kgPSBoc2kycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skZihhcmdzLCAnaHNpJyk7XG5cbiAgICAgIGlmICh0eXBlJDYoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoc2knO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skZyA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHR5cGUkNyA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHNsXzEodGhpcy5fcmdiKTtcbiAgfTtcblxuICBjaHJvbWFfMS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ2hzbCddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmhzbCA9IGhzbDJyZ2JfMTtcbiAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAyLFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IHVucGFjayRnKGFyZ3MsICdoc2wnKTtcblxuICAgICAgaWYgKHR5cGUkNyhhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ2hzbCc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHVucGFjayRoID0gdXRpbHMudW5wYWNrO1xuICB2YXIgbWluJDEgPSBNYXRoLm1pbjtcbiAgdmFyIG1heCQxID0gTWF0aC5tYXg7XG4gIC8qXG4gICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAqIC0gcmdiMmhzdihyLGcsYilcbiAgICogLSByZ2IyaHN2KFtyLGcsYl0pXG4gICAqIC0gcmdiMmhzdih7cixnLGJ9KVxuICAgKi9cblxuICB2YXIgcmdiMmhzbCQxID0gZnVuY3Rpb24gcmdiMmhzbCQxKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skaChhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICB2YXIgYiA9IGFyZ3NbMl07XG4gICAgdmFyIG1pbl8gPSBtaW4kMShyLCBnLCBiKTtcbiAgICB2YXIgbWF4XyA9IG1heCQxKHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heF8gLSBtaW5fO1xuICAgIHZhciBoLCBzLCB2O1xuICAgIHYgPSBtYXhfIC8gMjU1LjA7XG5cbiAgICBpZiAobWF4XyA9PT0gMCkge1xuICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4XztcblxuICAgICAgaWYgKHIgPT09IG1heF8pIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGcgPT09IG1heF8pIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiID09PSBtYXhfKSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoICo9IDYwO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCB2XTtcbiAgfTtcblxuICB2YXIgcmdiMmhzdiA9IHJnYjJoc2wkMTtcbiAgdmFyIHVucGFjayRpID0gdXRpbHMudW5wYWNrO1xuICB2YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIGhzdjJyZ2IgPSBmdW5jdGlvbiBoc3YycmdiKCkge1xuICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMiwgYXNzaWduJDMsIGFzc2lnbiQ0LCBhc3NpZ24kNTtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJGkoYXJncywgJ2hzdicpO1xuICAgIHZhciBoID0gYXJnc1swXTtcbiAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgdmFyIHYgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuICAgIHYgKj0gMjU1O1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoID09PSAzNjApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoID4gMzYwKSB7XG4gICAgICAgIGggLT0gMzYwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG5cbiAgICAgIGggLz0gNjA7XG4gICAgICB2YXIgaSA9IGZsb29yJDEoaCk7XG4gICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgdmFyIHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gIH07XG5cbiAgdmFyIGhzdjJyZ2JfMSA9IGhzdjJyZ2I7XG4gIHZhciB1bnBhY2skaiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHR5cGUkOCA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHN2KHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoc3YnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oc3YgPSBoc3YycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skaihhcmdzLCAnaHN2Jyk7XG5cbiAgICAgIGlmICh0eXBlJDgoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBsYWJDb25zdGFudHMgPSB7XG4gICAgLy8gQ29ycmVzcG9uZHMgcm91Z2hseSB0byBSR0IgYnJpZ2h0ZXIvZGFya2VyXG4gICAgS246IDE4LFxuICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgIFhuOiAwLjk1MDQ3MCxcbiAgICBZbjogMSxcbiAgICBabjogMS4wODg4MzAsXG4gICAgdDA6IDAuMTM3OTMxMDM0LFxuICAgIC8vIDQgLyAyOVxuICAgIHQxOiAwLjIwNjg5NjU1MixcbiAgICAvLyA2IC8gMjlcbiAgICB0MjogMC4xMjg0MTg1NSxcbiAgICAvLyAzICogdDEgKiB0MVxuICAgIHQzOiAwLjAwODg1NjQ1MiAvLyB0MSAqIHQxICogdDFcblxuICB9O1xuICB2YXIgdW5wYWNrJGsgPSB1dGlscy51bnBhY2s7XG4gIHZhciBwb3cgPSBNYXRoLnBvdztcblxuICB2YXIgcmdiMmxhYiA9IGZ1bmN0aW9uIHJnYjJsYWIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRrKGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSByZ2IyeHl6KHIsIGcsIGIpO1xuICAgIHZhciB4ID0gcmVmJDFbMF07XG4gICAgdmFyIHkgPSByZWYkMVsxXTtcbiAgICB2YXIgeiA9IHJlZiQxWzJdO1xuICAgIHZhciBsID0gMTE2ICogeSAtIDE2O1xuICAgIHJldHVybiBbbCA8IDAgPyAwIDogbCwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KV07XG4gIH07XG5cbiAgdmFyIHJnYl94eXogPSBmdW5jdGlvbiByZ2JfeHl6KHIpIHtcbiAgICBpZiAoKHIgLz0gMjU1KSA8PSAwLjA0MDQ1KSB7XG4gICAgICByZXR1cm4gciAvIDEyLjkyO1xuICAgIH1cblxuICAgIHJldHVybiBwb3coKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcblxuICB2YXIgeHl6X2xhYiA9IGZ1bmN0aW9uIHh5el9sYWIodCkge1xuICAgIGlmICh0ID4gbGFiQ29uc3RhbnRzLnQzKSB7XG4gICAgICByZXR1cm4gcG93KHQsIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdCAvIGxhYkNvbnN0YW50cy50MiArIGxhYkNvbnN0YW50cy50MDtcbiAgfTtcblxuICB2YXIgcmdiMnh5eiA9IGZ1bmN0aW9uIHJnYjJ4eXoociwgZywgYikge1xuICAgIHIgPSByZ2JfeHl6KHIpO1xuICAgIGcgPSByZ2JfeHl6KGcpO1xuICAgIGIgPSByZ2JfeHl6KGIpO1xuICAgIHZhciB4ID0geHl6X2xhYigoMC40MTI0NTY0ICogciArIDAuMzU3NTc2MSAqIGcgKyAwLjE4MDQzNzUgKiBiKSAvIGxhYkNvbnN0YW50cy5Ybik7XG4gICAgdmFyIHkgPSB4eXpfbGFiKCgwLjIxMjY3MjkgKiByICsgMC43MTUxNTIyICogZyArIDAuMDcyMTc1MCAqIGIpIC8gbGFiQ29uc3RhbnRzLlluKTtcbiAgICB2YXIgeiA9IHh5el9sYWIoKDAuMDE5MzMzOSAqIHIgKyAwLjExOTE5MjAgKiBnICsgMC45NTAzMDQxICogYikgLyBsYWJDb25zdGFudHMuWm4pO1xuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH07XG5cbiAgdmFyIHJnYjJsYWJfMSA9IHJnYjJsYWI7XG4gIHZhciB1bnBhY2skbCA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHBvdyQxID0gTWF0aC5wb3c7XG4gIC8qXG4gICAqIEwqIFswLi4xMDBdXG4gICAqIGEgWy0xMDAuLjEwMF1cbiAgICogYiBbLTEwMC4uMTAwXVxuICAgKi9cblxuICB2YXIgbGFiMnJnYiA9IGZ1bmN0aW9uIGxhYjJyZ2IoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgYXJncyA9IHVucGFjayRsKGFyZ3MsICdsYWInKTtcbiAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgdmFyIGEgPSBhcmdzWzFdO1xuICAgIHZhciBiID0gYXJnc1syXTtcbiAgICB2YXIgeCwgeSwgeiwgciwgZywgYl87XG4gICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgIHggPSBpc05hTihhKSA/IHkgOiB5ICsgYSAvIDUwMDtcbiAgICB6ID0gaXNOYU4oYikgPyB5IDogeSAtIGIgLyAyMDA7XG4gICAgeSA9IGxhYkNvbnN0YW50cy5ZbiAqIGxhYl94eXooeSk7XG4gICAgeCA9IGxhYkNvbnN0YW50cy5YbiAqIGxhYl94eXooeCk7XG4gICAgeiA9IGxhYkNvbnN0YW50cy5abiAqIGxhYl94eXooeik7XG4gICAgciA9IHh5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KTsgLy8gRDY1IC0+IHNSR0JcblxuICAgIGcgPSB4eXpfcmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopO1xuICAgIGJfID0geHl6X3JnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopO1xuICAgIHJldHVybiBbciwgZywgYl8sIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgfTtcblxuICB2YXIgeHl6X3JnYiA9IGZ1bmN0aW9uIHh5el9yZ2Iocikge1xuICAgIHJldHVybiAyNTUgKiAociA8PSAwLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBwb3ckMShyLCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgfTtcblxuICB2YXIgbGFiX3h5eiA9IGZ1bmN0aW9uIGxhYl94eXoodCkge1xuICAgIHJldHVybiB0ID4gbGFiQ29uc3RhbnRzLnQxID8gdCAqIHQgKiB0IDogbGFiQ29uc3RhbnRzLnQyICogKHQgLSBsYWJDb25zdGFudHMudDApO1xuICB9O1xuXG4gIHZhciBsYWIycmdiXzEgPSBsYWIycmdiO1xuICB2YXIgdW5wYWNrJG0gPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDkgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmxhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxhYl8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEubGFiID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydsYWInXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5sYWIgPSBsYWIycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skbShhcmdzLCAnbGFiJyk7XG5cbiAgICAgIGlmICh0eXBlJDkoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdsYWInO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skbiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIFJBRDJERUcgPSB1dGlscy5SQUQyREVHO1xuICB2YXIgc3FydCQxID0gTWF0aC5zcXJ0O1xuICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICB2YXIgcm91bmQkNCA9IE1hdGgucm91bmQ7XG5cbiAgdmFyIGxhYjJsY2ggPSBmdW5jdGlvbiBsYWIybGNoKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciByZWYgPSB1bnBhY2skbihhcmdzLCAnbGFiJyk7XG4gICAgdmFyIGwgPSByZWZbMF07XG4gICAgdmFyIGEgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGMgPSBzcXJ0JDEoYSAqIGEgKyBiICogYik7XG4gICAgdmFyIGggPSAoYXRhbjIoYiwgYSkgKiBSQUQyREVHICsgMzYwKSAlIDM2MDtcblxuICAgIGlmIChyb3VuZCQ0KGMgKiAxMDAwMCkgPT09IDApIHtcbiAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH1cblxuICAgIHJldHVybiBbbCwgYywgaF07XG4gIH07XG5cbiAgdmFyIGxhYjJsY2hfMSA9IGxhYjJsY2g7XG4gIHZhciB1bnBhY2skbyA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMmxjaCA9IGZ1bmN0aW9uIHJnYjJsY2goKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRvKGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSByZ2IybGFiXzEociwgZywgYik7XG4gICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICB2YXIgYSA9IHJlZiQxWzFdO1xuICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgIHJldHVybiBsYWIybGNoXzEobCwgYSwgYl8pO1xuICB9O1xuXG4gIHZhciByZ2IybGNoXzEgPSByZ2IybGNoO1xuICB2YXIgdW5wYWNrJHAgPSB1dGlscy51bnBhY2s7XG4gIHZhciBERUcyUkFEID0gdXRpbHMuREVHMlJBRDtcbiAgdmFyIHNpbiA9IE1hdGguc2luO1xuICB2YXIgY29zJDEgPSBNYXRoLmNvcztcblxuICB2YXIgbGNoMmxhYiA9IGZ1bmN0aW9uIGxjaDJsYWIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgQ29udmVydCBmcm9tIGEgcXVhbGl0YXRpdmUgcGFyYW1ldGVyIGggYW5kIGEgcXVhbnRpdGF0aXZlIHBhcmFtZXRlciBsIHRvIGEgMjQtYml0IHBpeGVsLlxuICAgIFRoZXNlIGZvcm11bGFzIHdlcmUgaW52ZW50ZWQgYnkgRGF2aWQgRGFscnltcGxlIHRvIG9idGFpbiBtYXhpbXVtIGNvbnRyYXN0IHdpdGhvdXQgZ29pbmdcbiAgICBvdXQgb2YgZ2FtdXQgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGluIHRoZSByYW5nZSAwLTEuXG4gICAgIEEgc2F0dXJhdGlvbiBtdWx0aXBsaWVyIHdhcyBhZGRlZCBieSBHcmVnb3IgQWlzY2hcbiAgICAqL1xuXG5cbiAgICB2YXIgcmVmID0gdW5wYWNrJHAoYXJncywgJ2xjaCcpO1xuICAgIHZhciBsID0gcmVmWzBdO1xuICAgIHZhciBjID0gcmVmWzFdO1xuICAgIHZhciBoID0gcmVmWzJdO1xuXG4gICAgaWYgKGlzTmFOKGgpKSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICBoID0gaCAqIERFRzJSQUQ7XG4gICAgcmV0dXJuIFtsLCBjb3MkMShoKSAqIGMsIHNpbihoKSAqIGNdO1xuICB9O1xuXG4gIHZhciBsY2gybGFiXzEgPSBsY2gybGFiO1xuICB2YXIgdW5wYWNrJHEgPSB1dGlscy51bnBhY2s7XG5cbiAgdmFyIGxjaDJyZ2IgPSBmdW5jdGlvbiBsY2gycmdiKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skcShhcmdzLCAnbGNoJyk7XG4gICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgdmFyIHJlZiA9IGxjaDJsYWJfMShsLCBjLCBoKTtcbiAgICB2YXIgTCA9IHJlZlswXTtcbiAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICB2YXIgYl8gPSByZWZbMl07XG4gICAgdmFyIHJlZiQxID0gbGFiMnJnYl8xKEwsIGEsIGJfKTtcbiAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgdmFyIGIgPSByZWYkMVsyXTtcbiAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgfTtcblxuICB2YXIgbGNoMnJnYl8xID0gbGNoMnJnYjtcbiAgdmFyIHVucGFjayRyID0gdXRpbHMudW5wYWNrO1xuXG4gIHZhciBoY2wycmdiID0gZnVuY3Rpb24gaGNsMnJnYigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgaGNsID0gdW5wYWNrJHIoYXJncywgJ2hjbCcpLnJldmVyc2UoKTtcbiAgICByZXR1cm4gbGNoMnJnYl8xLmFwcGx5KHZvaWQgMCwgaGNsKTtcbiAgfTtcblxuICB2YXIgaGNsMnJnYl8xID0gaGNsMnJnYjtcbiAgdmFyIHVucGFjayRzID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSRhID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5sY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJsY2hfMSh0aGlzLl9yZ2IpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxjaF8xKHRoaXMuX3JnYikucmV2ZXJzZSgpO1xuICB9O1xuXG4gIGNocm9tYV8xLmxjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnbGNoJ10pKSkoKTtcbiAgfTtcblxuICBjaHJvbWFfMS5oY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ2hjbCddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmxjaCA9IGxjaDJyZ2JfMTtcbiAgaW5wdXQuZm9ybWF0LmhjbCA9IGhjbDJyZ2JfMTtcbiAgWydsY2gnLCAnaGNsJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgcDogMixcbiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRzKGFyZ3MsIG0pO1xuXG4gICAgICAgIGlmICh0eXBlJGEoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gIFx0WDExIGNvbG9yIG5hbWVzXG4gICBcdGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAqL1xuXG4gIHZhciB3M2N4MTEgPSB7XG4gICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgYXF1YTogJyMwMGZmZmYnLFxuICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JyxcbiAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgIGJsdWU6ICcjMDAwMGZmJyxcbiAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICBidXJseXdvb2Q6ICcjZGViODg3JyxcbiAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgY2hvY29sYXRlOiAnI2QyNjkxZScsXG4gICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICBjb3JuZmxvd2VyOiAnIzY0OTVlZCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcbiAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxuICAgIGNyaW1zb246ICcjZGMxNDNjJyxcbiAgICBjeWFuOiAnIzAwZmZmZicsXG4gICAgZGFya2JsdWU6ICcjMDAwMDhiJyxcbiAgICBkYXJrY3lhbjogJyMwMDhiOGInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJyxcbiAgICBkYXJrZ3JheTogJyNhOWE5YTknLFxuICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLFxuICAgIGRhcmtncmV5OiAnI2E5YTlhOScsXG4gICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsXG4gICAgZGFya3JlZDogJyM4YjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJyxcbiAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJyxcbiAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLFxuICAgIGRhcmtzbGF0ZWdyZXk6ICcjMmY0ZjRmJyxcbiAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsXG4gICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLFxuICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsXG4gICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcbiAgICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogJyM2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJyxcbiAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLFxuICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsXG4gICAgZnVjaHNpYTogJyNmZjAwZmYnLFxuICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLFxuICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJyxcbiAgICBnb2xkOiAnI2ZmZDcwMCcsXG4gICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsXG4gICAgZ3JheTogJyM4MDgwODAnLFxuICAgIGdyZWVuOiAnIzAwODAwMCcsXG4gICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJyxcbiAgICBncmV5OiAnIzgwODA4MCcsXG4gICAgaG9uZXlkZXc6ICcjZjBmZmYwJyxcbiAgICBob3RwaW5rOiAnI2ZmNjliNCcsXG4gICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgaW5kaWdvOiAnIzRiMDA4MicsXG4gICAgaXZvcnk6ICcjZmZmZmYwJyxcbiAgICBraGFraTogJyNmMGU2OGMnLFxuICAgIGxhc2VybGVtb246ICcjZmZmZjU0JyxcbiAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLFxuICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JyxcbiAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcbiAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJyxcbiAgICBsaWdodGJsdWU6ICcjYWRkOGU2JyxcbiAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsXG4gICAgbGlnaHRnb2xkZW5yb2Q6ICcjZmFmYWQyJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLFxuICAgIGxpZ2h0Z3JheTogJyNkM2QzZDMnLFxuICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJyxcbiAgICBsaWdodGdyZXk6ICcjZDNkM2QzJyxcbiAgICBsaWdodHBpbms6ICcjZmZiNmMxJyxcbiAgICBsaWdodHNhbG1vbjogJyNmZmEwN2EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJyxcbiAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJyxcbiAgICBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLFxuICAgIGxpZ2h0c2xhdGVncmV5OiAnIzc3ODg5OScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcbiAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxuICAgIGxpbWU6ICcjMDBmZjAwJyxcbiAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcbiAgICBsaW5lbjogJyNmYWYwZTYnLFxuICAgIG1hZ2VudGE6ICcjZmYwMGZmJyxcbiAgICBtYXJvb246ICcjODAwMDAwJyxcbiAgICBtYXJvb24yOiAnIzdmMDAwMCcsXG4gICAgbWFyb29uMzogJyNiMDMwNjAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJyxcbiAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXG4gICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXG4gICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkYicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJyxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxuICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLFxuICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxuICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXG4gICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJyxcbiAgICBuYXZ5OiAnIzAwMDA4MCcsXG4gICAgb2xkbGFjZTogJyNmZGY1ZTYnLFxuICAgIG9saXZlOiAnIzgwODAwMCcsXG4gICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsXG4gICAgb3JhbmdlOiAnI2ZmYTUwMCcsXG4gICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXG4gICAgb3JjaGlkOiAnI2RhNzBkNicsXG4gICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLFxuICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJyxcbiAgICBwYWxldmlvbGV0cmVkOiAnI2RiNzA5MycsXG4gICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLFxuICAgIHBlYWNocHVmZjogJyNmZmRhYjknLFxuICAgIHBlcnU6ICcjY2Q4NTNmJyxcbiAgICBwaW5rOiAnI2ZmYzBjYicsXG4gICAgcGx1bTogJyNkZGEwZGQnLFxuICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JyxcbiAgICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgICBwdXJwbGUyOiAnIzdmMDA3ZicsXG4gICAgcHVycGxlMzogJyNhMDIwZjAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICcjNjYzMzk5JyxcbiAgICByZWQ6ICcjZmYwMDAwJyxcbiAgICByb3N5YnJvd246ICcjYmM4ZjhmJyxcbiAgICByb3lhbGJsdWU6ICcjNDE2OWUxJyxcbiAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLFxuICAgIHNhbG1vbjogJyNmYTgwNzInLFxuICAgIHNhbmR5YnJvd246ICcjZjRhNDYwJyxcbiAgICBzZWFncmVlbjogJyMyZThiNTcnLFxuICAgIHNlYXNoZWxsOiAnI2ZmZjVlZScsXG4gICAgc2llbm5hOiAnI2EwNTIyZCcsXG4gICAgc2lsdmVyOiAnI2MwYzBjMCcsXG4gICAgc2t5Ymx1ZTogJyM4N2NlZWInLFxuICAgIHNsYXRlYmx1ZTogJyM2YTVhY2QnLFxuICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLFxuICAgIHNsYXRlZ3JleTogJyM3MDgwOTAnLFxuICAgIHNub3c6ICcjZmZmYWZhJyxcbiAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLFxuICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLFxuICAgIHRhbjogJyNkMmI0OGMnLFxuICAgIHRlYWw6ICcjMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsXG4gICAgdG9tYXRvOiAnI2ZmNjM0NycsXG4gICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsXG4gICAgdmlvbGV0OiAnI2VlODJlZScsXG4gICAgd2hlYXQ6ICcjZjVkZWIzJyxcbiAgICB3aGl0ZTogJyNmZmZmZmYnLFxuICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JyxcbiAgICB5ZWxsb3c6ICcjZmZmZjAwJyxcbiAgICB5ZWxsb3dncmVlbjogJyM5YWNkMzInXG4gIH07XG4gIHZhciB3M2N4MTFfMSA9IHczY3gxMTtcbiAgdmFyIHR5cGUkYiA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGV4ID0gcmdiMmhleF8xKHRoaXMuX3JnYiwgJ3JnYicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh3M2N4MTFfMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbiA9IGxpc3RbaV07XG5cbiAgICAgIGlmICh3M2N4MTFfMVtuXSA9PT0gaGV4KSB7XG4gICAgICAgIHJldHVybiBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQubmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodzNjeDExXzFbbmFtZV0pIHtcbiAgICAgIHJldHVybiBoZXgycmdiXzEodzNjeDExXzFbbmFtZV0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb2xvciBuYW1lOiAnICsgbmFtZSk7XG4gIH07XG5cbiAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiA1LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoaCkge1xuICAgICAgdmFyIHJlc3QgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgICByZXN0W2xlbl0gPSBhcmd1bWVudHNbbGVuICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRiKGgpID09PSAnc3RyaW5nJyAmJiB3M2N4MTFfMVtoLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHJldHVybiAnbmFtZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skdCA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMm51bSA9IGZ1bmN0aW9uIHJnYjJudW0oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayR0KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xuICB9O1xuXG4gIHZhciByZ2IybnVtXzEgPSByZ2IybnVtO1xuICB2YXIgdHlwZSRjID0gdXRpbHMudHlwZTtcblxuICB2YXIgbnVtMnJnYiA9IGZ1bmN0aW9uIG51bTJyZ2IobnVtKSB7XG4gICAgaWYgKHR5cGUkYyhudW0pID09IFwibnVtYmVyXCIgJiYgbnVtID49IDAgJiYgbnVtIDw9IDB4RkZGRkZGKSB7XG4gICAgICB2YXIgciA9IG51bSA+PiAxNjtcbiAgICAgIHZhciBnID0gbnVtID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSBudW0gJiAweEZGO1xuICAgICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG51bSBjb2xvcjogXCIgKyBudW0pO1xuICB9O1xuXG4gIHZhciBudW0ycmdiXzEgPSBudW0ycmdiO1xuICB2YXIgdHlwZSRkID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5udW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJudW1fMSh0aGlzLl9yZ2IpO1xuICB9O1xuXG4gIGNocm9tYV8xLm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnbnVtJ10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQubnVtID0gbnVtMnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDUsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZSRkKGFyZ3NbMF0pID09PSAnbnVtYmVyJyAmJiBhcmdzWzBdID49IDAgJiYgYXJnc1swXSA8PSAweEZGRkZGRikge1xuICAgICAgICByZXR1cm4gJ251bSc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHVucGFjayR1ID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSRlID0gdXRpbHMudHlwZTtcbiAgdmFyIHJvdW5kJDUgPSBNYXRoLnJvdW5kO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uIChybmQpIHtcbiAgICBpZiAocm5kID09PSB2b2lkIDApIHJuZCA9IHRydWU7XG5cbiAgICBpZiAocm5kID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDMpLm1hcChyb3VuZCQ1KTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5yZ2JhID0gZnVuY3Rpb24gKHJuZCkge1xuICAgIGlmIChybmQgPT09IHZvaWQgMCkgcm5kID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDQpLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIGkgPCAzID8gcm5kID09PSBmYWxzZSA/IHYgOiByb3VuZCQ1KHYpIDogdjtcbiAgICB9KTtcbiAgfTtcblxuICBjaHJvbWFfMS5yZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ3JnYiddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgcmdiYSA9IHVucGFjayR1KGFyZ3MsICdyZ2JhJyk7XG5cbiAgICBpZiAocmdiYVszXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZ2JhWzNdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmdiYTtcbiAgfTtcblxuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDMsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gdW5wYWNrJHUoYXJncywgJ3JnYmEnKTtcblxuICAgICAgaWYgKHR5cGUkZShhcmdzKSA9PT0gJ2FycmF5JyAmJiAoYXJncy5sZW5ndGggPT09IDMgfHwgYXJncy5sZW5ndGggPT09IDQgJiYgdHlwZSRlKGFyZ3NbM10pID09ICdudW1iZXInICYmIGFyZ3NbM10gPj0gMCAmJiBhcmdzWzNdIDw9IDEpKSB7XG4gICAgICAgIHJldHVybiAncmdiJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKlxuICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICovXG5cbiAgdmFyIGxvZyA9IE1hdGgubG9nO1xuXG4gIHZhciB0ZW1wZXJhdHVyZTJyZ2IgPSBmdW5jdGlvbiB0ZW1wZXJhdHVyZTJyZ2Ioa2VsdmluKSB7XG4gICAgdmFyIHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICByID0gMjU1O1xuICAgICAgZyA9IC0xNTUuMjU0ODU1NjI3MDkxNzkgLSAwLjQ0NTk2OTUwNDY5NTc5MTMzICogKGcgPSB0ZW1wIC0gMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2coZyk7XG4gICAgICBiID0gdGVtcCA8IDIwID8gMCA6IC0yNTQuNzY5MzUxODQxMjA5MDIgKyAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAgLSAxMCkgKyAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2coYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAzNTEuOTc2OTA1NjY4MDU2OTMgKyAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcCAtIDU1KSAtIDQwLjI1MzY2MzA5MzMyMTI3ICogbG9nKHIpO1xuICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcCAtIDUwKSAtIDI4LjA4NTI5NjM1MDc5NTcgKiBsb2coZyk7XG4gICAgICBiID0gMjU1O1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gIH07XG5cbiAgdmFyIHRlbXBlcmF0dXJlMnJnYl8xID0gdGVtcGVyYXR1cmUycmdiO1xuICAvKlxuICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICoqL1xuXG4gIHZhciB1bnBhY2skdiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHJvdW5kJDYgPSBNYXRoLnJvdW5kO1xuXG4gIHZhciByZ2IydGVtcGVyYXR1cmUgPSBmdW5jdGlvbiByZ2IydGVtcGVyYXR1cmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IHVucGFjayR2KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJnYlswXSxcbiAgICAgICAgYiA9IHJnYlsyXTtcbiAgICB2YXIgbWluVGVtcCA9IDEwMDA7XG4gICAgdmFyIG1heFRlbXAgPSA0MDAwMDtcbiAgICB2YXIgZXBzID0gMC40O1xuICAgIHZhciB0ZW1wO1xuXG4gICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgIHZhciByZ2IkMSA9IHRlbXBlcmF0dXJlMnJnYl8xKHRlbXApO1xuXG4gICAgICBpZiAocmdiJDFbMl0gLyByZ2IkMVswXSA+PSBiIC8gcikge1xuICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3VuZCQ2KHRlbXApO1xuICB9O1xuXG4gIHZhciByZ2IydGVtcGVyYXR1cmVfMSA9IHJnYjJ0ZW1wZXJhdHVyZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS50ZW1wID0gQ29sb3JfMS5wcm90b3R5cGUua2VsdmluID0gQ29sb3JfMS5wcm90b3R5cGUudGVtcGVyYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJ0ZW1wZXJhdHVyZV8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEudGVtcCA9IGNocm9tYV8xLmtlbHZpbiA9IGNocm9tYV8xLnRlbXBlcmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWyd0ZW1wJ10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQudGVtcCA9IGlucHV0LmZvcm1hdC5rZWx2aW4gPSBpbnB1dC5mb3JtYXQudGVtcGVyYXR1cmUgPSB0ZW1wZXJhdHVyZTJyZ2JfMTtcbiAgdmFyIHR5cGUkZiA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbiAoYSwgbXV0YXRlKSB7XG4gICAgaWYgKG11dGF0ZSA9PT0gdm9pZCAwKSBtdXRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgdHlwZSRmKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICB0aGlzLl9yZ2JbM10gPSBhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFt0aGlzLl9yZ2JbMF0sIHRoaXMuX3JnYlsxXSwgdGhpcy5fcmdiWzJdLCBhXSwgJ3JnYicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZ2JbM107XG4gIH07XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuY2xpcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkIHx8IGZhbHNlO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIGFtb3VudCA9IDE7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbGFiID0gbWUubGFiKCk7XG4gICAgbGFiWzBdIC09IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcbiAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gIH07XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW4gPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSBhbW91bnQgPSAxO1xuICAgIHJldHVybiB0aGlzLmRhcmtlbigtYW1vdW50KTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZXIgPSBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZW47XG4gIENvbG9yXzEucHJvdG90eXBlLmJyaWdodGVyID0gQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW47XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG1jKSB7XG4gICAgdmFyIHJlZiA9IG1jLnNwbGl0KCcuJyk7XG4gICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgdmFyIHNyYyA9IHRoaXNbbW9kZV0oKTtcblxuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICByZXR1cm4gc3JjW2ldO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdHlwZSRnID0gdXRpbHMudHlwZTtcbiAgdmFyIHBvdyQyID0gTWF0aC5wb3c7XG4gIHZhciBFUFMgPSAxZS03O1xuICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5sdW1pbmFuY2UgPSBmdW5jdGlvbiAobHVtKSB7XG4gICAgaWYgKGx1bSAhPT0gdW5kZWZpbmVkICYmIHR5cGUkZyhsdW0pID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGx1bSA9PT0gMCkge1xuICAgICAgICAvLyByZXR1cm4gcHVyZSBibGFja1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzAsIDAsIDAsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGx1bSA9PT0gMSkge1xuICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzI1NSwgMjU1LCAyNTUsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgIH0gLy8gY29tcHV0ZSBuZXcgY29sb3IgdXNpbmcuLi5cblxuXG4gICAgICB2YXIgY3VyX2x1bSA9IHRoaXMubHVtaW5hbmNlKCk7XG4gICAgICB2YXIgbW9kZSA9ICdyZ2InO1xuICAgICAgdmFyIG1heF9pdGVyID0gTUFYX0lURVI7XG5cbiAgICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gdGVzdChsb3csIGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICB2YXIgbG0gPSBtaWQubHVtaW5hbmNlKCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGx1bSAtIGxtKSA8IEVQUyB8fCAhbWF4X2l0ZXItLSkge1xuICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZ2IgPSAoY3VyX2x1bSA+IGx1bSA/IHRlc3QobmV3IENvbG9yXzEoWzAsIDAsIDBdKSwgdGhpcykgOiB0ZXN0KHRoaXMsIG5ldyBDb2xvcl8xKFsyNTUsIDI1NSwgMjU1XSkpKS5yZ2IoKTtcbiAgICAgIHJldHVybiBuZXcgQ29sb3JfMShyZ2IuY29uY2F0KFt0aGlzLl9yZ2JbM11dKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UuYXBwbHkodm9pZCAwLCB0aGlzLl9yZ2Iuc2xpY2UoMCwgMykpO1xuICB9O1xuXG4gIHZhciByZ2IybHVtaW5hbmNlID0gZnVuY3Rpb24gcmdiMmx1bWluYW5jZShyLCBnLCBiKSB7XG4gICAgLy8gcmVsYXRpdmUgbHVtaW5hbmNlXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICByID0gbHVtaW5hbmNlX3gocik7XG4gICAgZyA9IGx1bWluYW5jZV94KGcpO1xuICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuICB9O1xuXG4gIHZhciBsdW1pbmFuY2VfeCA9IGZ1bmN0aW9uIGx1bWluYW5jZV94KHgpIHtcbiAgICB4IC89IDI1NTtcbiAgICByZXR1cm4geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogcG93JDIoKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcblxuICB2YXIgaW50ZXJwb2xhdG9yID0ge307XG4gIHZhciB0eXBlJGggPSB1dGlscy50eXBlO1xuXG4gIHZhciBtaXggPSBmdW5jdGlvbiBtaXgoY29sMSwgY29sMiwgZikge1xuICAgIGlmIChmID09PSB2b2lkIDApIGYgPSAwLjU7XG4gICAgdmFyIHJlc3QgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDM7XG5cbiAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICByZXN0W2xlbl0gPSBhcmd1bWVudHNbbGVuICsgM107XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSByZXN0WzBdIHx8ICdscmdiJztcblxuICAgIGlmICghaW50ZXJwb2xhdG9yW21vZGVdICYmICFyZXN0Lmxlbmd0aCkge1xuICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgbW9kZVxuICAgICAgbW9kZSA9IE9iamVjdC5rZXlzKGludGVycG9sYXRvcilbMF07XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVycG9sYXRpb24gbW9kZSBcIiArIG1vZGUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSRoKGNvbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29sMSA9IG5ldyBDb2xvcl8xKGNvbDEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlJGgoY29sMikgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb2wyID0gbmV3IENvbG9yXzEoY29sMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRvclttb2RlXShjb2wxLCBjb2wyLCBmKS5hbHBoYShjb2wxLmFscGhhKCkgKyBmICogKGNvbDIuYWxwaGEoKSAtIGNvbDEuYWxwaGEoKSkpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLm1peCA9IENvbG9yXzEucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGNvbDIsIGYpIHtcbiAgICBpZiAoZiA9PT0gdm9pZCAwKSBmID0gMC41O1xuICAgIHZhciByZXN0ID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgcmVzdFtsZW5dID0gYXJndW1lbnRzW2xlbiArIDJdO1xuICAgIH1cblxuICAgIHJldHVybiBtaXguYXBwbHkodm9pZCAwLCBbdGhpcywgY29sMiwgZl0uY29uY2F0KHJlc3QpKTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uIChtdXRhdGUpIHtcbiAgICBpZiAobXV0YXRlID09PSB2b2lkIDApIG11dGF0ZSA9IGZhbHNlO1xuICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgdmFyIGEgPSByZ2JbM107XG5cbiAgICBpZiAobXV0YXRlKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBbcmdiWzBdICogYSwgcmdiWzFdICogYSwgcmdiWzJdICogYSwgYV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFtyZ2JbMF0gKiBhLCByZ2JbMV0gKiBhLCByZ2JbMl0gKiBhLCBhXSwgJ3JnYicpO1xuICAgIH1cbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIGFtb3VudCA9IDE7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbGNoID0gbWUubGNoKCk7XG4gICAgbGNoWzFdICs9IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcblxuICAgIGlmIChsY2hbMV0gPCAwKSB7XG4gICAgICBsY2hbMV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sb3JfMShsY2gsICdsY2gnKS5hbHBoYShtZS5hbHBoYSgpLCB0cnVlKTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkgYW1vdW50ID0gMTtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0ZSgtYW1vdW50KTtcbiAgfTtcblxuICB2YXIgdHlwZSRpID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobWMsIHZhbHVlLCBtdXRhdGUpIHtcbiAgICBpZiAobXV0YXRlID09PSB2b2lkIDApIG11dGF0ZSA9IGZhbHNlO1xuICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgIHZhciBtb2RlID0gcmVmWzBdO1xuICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG5cbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCk7XG5cbiAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgaWYgKHR5cGUkaSh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICBzcmNbaV0gKj0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBzcmNbaV0gLz0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNyY1tpXSA9ICt2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSRpKHZhbHVlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzcmNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB2YWx1ZSBmb3IgQ29sb3Iuc2V0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBDb2xvcl8xKHNyYywgbW9kZSk7XG5cbiAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3JnYiA9IG91dC5fcmdiO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGluIG1vZGUgXCIgKyBtb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJnYiQxID0gZnVuY3Rpb24gcmdiJDEoY29sMSwgY29sMiwgZikge1xuICAgIHZhciB4eXowID0gY29sMS5fcmdiO1xuICAgIHZhciB4eXoxID0gY29sMi5fcmdiO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMSh4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSwgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLCAncmdiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLnJnYiA9IHJnYiQxO1xuICB2YXIgc3FydCQyID0gTWF0aC5zcXJ0O1xuICB2YXIgcG93JDMgPSBNYXRoLnBvdztcblxuICB2YXIgbHJnYiA9IGZ1bmN0aW9uIGxyZ2IoY29sMSwgY29sMiwgZikge1xuICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgdmFyIHgxID0gcmVmWzBdO1xuICAgIHZhciB5MSA9IHJlZlsxXTtcbiAgICB2YXIgejEgPSByZWZbMl07XG4gICAgdmFyIHJlZiQxID0gY29sMi5fcmdiO1xuICAgIHZhciB4MiA9IHJlZiQxWzBdO1xuICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgIHZhciB6MiA9IHJlZiQxWzJdO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMShzcXJ0JDIocG93JDMoeDEsIDIpICogKDEgLSBmKSArIHBvdyQzKHgyLCAyKSAqIGYpLCBzcXJ0JDIocG93JDMoeTEsIDIpICogKDEgLSBmKSArIHBvdyQzKHkyLCAyKSAqIGYpLCBzcXJ0JDIocG93JDMoejEsIDIpICogKDEgLSBmKSArIHBvdyQzKHoyLCAyKSAqIGYpLCAncmdiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLmxyZ2IgPSBscmdiO1xuXG4gIHZhciBsYWIkMSA9IGZ1bmN0aW9uIGxhYiQxKGNvbDEsIGNvbDIsIGYpIHtcbiAgICB2YXIgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgdmFyIHh5ejEgPSBjb2wyLmxhYigpO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMSh4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSwgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLCAnbGFiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLmxhYiA9IGxhYiQxO1xuXG4gIHZhciBfaHN4ID0gZnVuY3Rpb24gX2hzeChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG4gICAgdmFyIHh5ejAsIHh5ejE7XG5cbiAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnaHN2Jykge1xuICAgICAgeHl6MCA9IGNvbDEuaHN2KCk7XG4gICAgICB4eXoxID0gY29sMi5oc3YoKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdoY2cnKSB7XG4gICAgICB4eXowID0gY29sMS5oY2coKTtcbiAgICAgIHh5ejEgPSBjb2wyLmhjZygpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnbGNoJyB8fCBtID09PSAnaGNsJykge1xuICAgICAgbSA9ICdoY2wnO1xuICAgICAgeHl6MCA9IGNvbDEuaGNsKCk7XG4gICAgICB4eXoxID0gY29sMi5oY2woKTtcbiAgICB9XG5cbiAgICB2YXIgaHVlMCwgaHVlMSwgc2F0MCwgc2F0MSwgbGJ2MCwgbGJ2MTtcblxuICAgIGlmIChtLnN1YnN0cigwLCAxKSA9PT0gJ2gnKSB7XG4gICAgICBhc3NpZ24gPSB4eXowLCBodWUwID0gYXNzaWduWzBdLCBzYXQwID0gYXNzaWduWzFdLCBsYnYwID0gYXNzaWduWzJdO1xuICAgICAgYXNzaWduJDEgPSB4eXoxLCBodWUxID0gYXNzaWduJDFbMF0sIHNhdDEgPSBhc3NpZ24kMVsxXSwgbGJ2MSA9IGFzc2lnbiQxWzJdO1xuICAgIH1cblxuICAgIHZhciBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgIGlmICghaXNOYU4oaHVlMCkgJiYgIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAvLyBib3RoIGNvbG9ycyBoYXZlIGh1ZVxuICAgICAgaWYgKGh1ZTEgPiBodWUwICYmIGh1ZTEgLSBodWUwID4gMTgwKSB7XG4gICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgIH0gZWxzZSBpZiAoaHVlMSA8IGh1ZTAgJiYgaHVlMCAtIGh1ZTEgPiAxODApIHtcbiAgICAgICAgZGggPSBodWUxICsgMzYwIC0gaHVlMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRoID0gaHVlMSAtIGh1ZTA7XG4gICAgICB9XG5cbiAgICAgIGh1ZSA9IGh1ZTAgKyBmICogZGg7XG4gICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMCkpIHtcbiAgICAgIGh1ZSA9IGh1ZTA7XG5cbiAgICAgIGlmICgobGJ2MSA9PSAxIHx8IGxidjEgPT0gMCkgJiYgbSAhPSAnaHN2Jykge1xuICAgICAgICBzYXQgPSBzYXQwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTEpKSB7XG4gICAgICBodWUgPSBodWUxO1xuXG4gICAgICBpZiAoKGxidjAgPT0gMSB8fCBsYnYwID09IDApICYmIG0gIT0gJ2hzdicpIHtcbiAgICAgICAgc2F0ID0gc2F0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaHVlID0gTnVtYmVyLk5hTjtcbiAgICB9XG5cbiAgICBpZiAoc2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTtcbiAgICB9XG5cbiAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgcmV0dXJuIG5ldyBDb2xvcl8xKFtodWUsIHNhdCwgbGJ2XSwgbSk7XG4gIH07XG5cbiAgdmFyIGxjaCQxID0gZnVuY3Rpb24gbGNoJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdsY2gnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IubGNoID0gbGNoJDE7XG4gIGludGVycG9sYXRvci5oY2wgPSBsY2gkMTtcblxuICB2YXIgbnVtJDEgPSBmdW5jdGlvbiBudW0kMShjb2wxLCBjb2wyLCBmKSB7XG4gICAgdmFyIGMxID0gY29sMS5udW0oKTtcbiAgICB2YXIgYzIgPSBjb2wyLm51bSgpO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMShjMSArIGYgKiAoYzIgLSBjMSksICdudW0nKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IubnVtID0gbnVtJDE7XG5cbiAgdmFyIGhjZyQxID0gZnVuY3Rpb24gaGNnJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoY2cnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaGNnID0gaGNnJDE7XG5cbiAgdmFyIGhzaSQxID0gZnVuY3Rpb24gaHNpJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2knKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHNpID0gaHNpJDE7XG5cbiAgdmFyIGhzbCQxID0gZnVuY3Rpb24gaHNsJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2wnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHNsID0gaHNsJDE7XG5cbiAgdmFyIGhzdiQxID0gZnVuY3Rpb24gaHN2JDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc3YnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHN2ID0gaHN2JDE7XG4gIHZhciBjbGlwX3JnYiQyID0gdXRpbHMuY2xpcF9yZ2I7XG4gIHZhciBwb3ckNCA9IE1hdGgucG93O1xuICB2YXIgc3FydCQzID0gTWF0aC5zcXJ0O1xuICB2YXIgUEkkMSA9IE1hdGguUEk7XG4gIHZhciBjb3MkMiA9IE1hdGguY29zO1xuICB2YXIgc2luJDEgPSBNYXRoLnNpbjtcbiAgdmFyIGF0YW4yJDEgPSBNYXRoLmF0YW4yO1xuXG4gIHZhciBhdmVyYWdlID0gZnVuY3Rpb24gYXZlcmFnZShjb2xvcnMsIG1vZGUsIHdlaWdodHMpIHtcbiAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSBtb2RlID0gJ2xyZ2InO1xuICAgIGlmICh3ZWlnaHRzID09PSB2b2lkIDApIHdlaWdodHMgPSBudWxsO1xuICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGlmICghd2VpZ2h0cykge1xuICAgICAgd2VpZ2h0cyA9IEFycmF5LmZyb20obmV3IEFycmF5KGwpKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuICAgIH0gLy8gbm9ybWFsaXplIHdlaWdodHNcblxuXG4gICAgdmFyIGsgPSBsIC8gd2VpZ2h0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9KTtcbiAgICB3ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHcsIGkpIHtcbiAgICAgIHdlaWdodHNbaV0gKj0gaztcbiAgICB9KTsgLy8gY29udmVydCBjb2xvcnMgdG8gQ29sb3Igb2JqZWN0c1xuXG4gICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKGMpO1xuICAgIH0pO1xuXG4gICAgaWYgKG1vZGUgPT09ICdscmdiJykge1xuICAgICAgcmV0dXJuIF9hdmVyYWdlX2xyZ2IoY29sb3JzLCB3ZWlnaHRzKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3QgPSBjb2xvcnMuc2hpZnQoKTtcbiAgICB2YXIgeHl6ID0gZmlyc3QuZ2V0KG1vZGUpO1xuICAgIHZhciBjbnQgPSBbXTtcbiAgICB2YXIgZHggPSAwO1xuICAgIHZhciBkeSA9IDA7IC8vIGluaXRpYWwgY29sb3JcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG5cbiAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnICYmICFpc05hTih4eXpbaV0pKSB7XG4gICAgICAgIHZhciBBID0geHl6W2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICBkeSArPSBzaW4kMShBKSAqIHdlaWdodHNbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGMsIGNpKSB7XG4gICAgICB2YXIgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSArIDFdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgY250W2ldICs9IHdlaWdodHNbY2kgKyAxXTtcblxuICAgICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnKSB7XG4gICAgICAgICAgICB2YXIgQSA9IHh5ejJbaV0gLyAxODAgKiBQSSQxO1xuICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgICBkeSArPSBzaW4kMShBKSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHl6W2ldICs9IHh5ejJbaV0gKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICB2YXIgQSQxID0gYXRhbjIkMShkeSAvIGNudFtpJDFdLCBkeCAvIGNudFtpJDFdKSAvIFBJJDEgKiAxODA7XG5cbiAgICAgICAgd2hpbGUgKEEkMSA8IDApIHtcbiAgICAgICAgICBBJDEgKz0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKEEkMSA+PSAzNjApIHtcbiAgICAgICAgICBBJDEgLT0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgeHl6W2kkMV0gPSBBJDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4eXpbaSQxXSA9IHh5eltpJDFdIC8gY250W2kkMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWxwaGEgLz0gbDtcbiAgICByZXR1cm4gbmV3IENvbG9yXzEoeHl6LCBtb2RlKS5hbHBoYShhbHBoYSA+IDAuOTk5OTkgPyAxIDogYWxwaGEsIHRydWUpO1xuICB9O1xuXG4gIHZhciBfYXZlcmFnZV9scmdiID0gZnVuY3Rpb24gX2F2ZXJhZ2VfbHJnYihjb2xvcnMsIHdlaWdodHMpIHtcbiAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgdmFyIHh5eiA9IFswLCAwLCAwLCAwXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29sID0gY29sb3JzW2ldO1xuICAgICAgdmFyIGYgPSB3ZWlnaHRzW2ldIC8gbDtcbiAgICAgIHZhciByZ2IgPSBjb2wuX3JnYjtcbiAgICAgIHh5elswXSArPSBwb3ckNChyZ2JbMF0sIDIpICogZjtcbiAgICAgIHh5elsxXSArPSBwb3ckNChyZ2JbMV0sIDIpICogZjtcbiAgICAgIHh5elsyXSArPSBwb3ckNChyZ2JbMl0sIDIpICogZjtcbiAgICAgIHh5elszXSArPSByZ2JbM10gKiBmO1xuICAgIH1cblxuICAgIHh5elswXSA9IHNxcnQkMyh4eXpbMF0pO1xuICAgIHh5elsxXSA9IHNxcnQkMyh4eXpbMV0pO1xuICAgIHh5elsyXSA9IHNxcnQkMyh4eXpbMl0pO1xuXG4gICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkge1xuICAgICAgeHl6WzNdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbG9yXzEoY2xpcF9yZ2IkMih4eXopKTtcbiAgfTsgLy8gbWluaW1hbCBtdWx0aS1wdXJwb3NlIGludGVyZmFjZVxuICAvLyBAcmVxdWlyZXMgdXRpbHMgY29sb3IgYW5hbHl6ZVxuXG5cbiAgdmFyIHR5cGUkaiA9IHV0aWxzLnR5cGU7XG4gIHZhciBwb3ckNSA9IE1hdGgucG93O1xuXG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKGNvbG9ycykge1xuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgdmFyIF9tb2RlID0gJ3JnYic7XG5cbiAgICB2YXIgX25hY29sID0gY2hyb21hXzEoJyNjY2MnKTtcblxuICAgIHZhciBfc3ByZWFkID0gMDsgLy8gY29uc3QgX2ZpeGVkID0gZmFsc2U7XG5cbiAgICB2YXIgX2RvbWFpbiA9IFswLCAxXTtcbiAgICB2YXIgX3BvcyA9IFtdO1xuICAgIHZhciBfcGFkZGluZyA9IFswLCAwXTtcbiAgICB2YXIgX2NsYXNzZXMgPSBmYWxzZTtcbiAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgIHZhciBfb3V0ID0gZmFsc2U7XG4gICAgdmFyIF9taW4gPSAwO1xuICAgIHZhciBfbWF4ID0gMTtcbiAgICB2YXIgX2NvcnJlY3RMaWdodG5lc3MgPSBmYWxzZTtcbiAgICB2YXIgX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICB2YXIgX2dhbW1hID0gMTsgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICB2YXIgc2V0Q29sb3JzID0gZnVuY3Rpb24gc2V0Q29sb3JzKGNvbG9ycykge1xuICAgICAgY29sb3JzID0gY29sb3JzIHx8IFsnI2ZmZicsICcjMDAwJ107XG5cbiAgICAgIGlmIChjb2xvcnMgJiYgdHlwZSRqKGNvbG9ycykgPT09ICdzdHJpbmcnICYmIGNocm9tYV8xLmJyZXdlciAmJiBjaHJvbWFfMS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIGNvbG9ycyA9IGNocm9tYV8xLmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlJGooY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAvLyBoYW5kbGUgc2luZ2xlIGNvbG9yXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29sb3JzID0gW2NvbG9yc1swXSwgY29sb3JzWzBdXTtcbiAgICAgICAgfSAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG5cblxuICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCk7IC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbG9ycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGNvbG9yc1tjXSA9IGNocm9tYV8xKGNvbG9yc1tjXSk7XG4gICAgICAgIH0gLy8gYXV0by1maWxsIGNvbG9yIHBvc2l0aW9uXG5cblxuICAgICAgICBfcG9zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgYyQxID0gMDsgYyQxIDwgY29sb3JzLmxlbmd0aDsgYyQxKyspIHtcbiAgICAgICAgICBfcG9zLnB1c2goYyQxIC8gKGNvbG9ycy5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgcmV0dXJuIF9jb2xvcnMgPSBjb2xvcnM7XG4gICAgfTtcblxuICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzKHZhbHVlKSB7XG4gICAgICBpZiAoX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IF9jbGFzc2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAoaSA8IG4gJiYgdmFsdWUgPj0gX2NsYXNzZXNbaV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICB2YXIgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHZhciB0TWFwRG9tYWluID0gZnVuY3Rpb24gdE1hcERvbWFpbih0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9OyAvLyBjb25zdCBjbGFzc2lmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgIC8vICAgICBpZiAoX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgIC8vICAgICAgICAgY29uc3QgbiA9IF9jbGFzc2VzLmxlbmd0aC0xO1xuICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAvLyAgICAgICAgIGNvbnN0IG1pbmMgPSBfY2xhc3Nlc1swXSArICgoX2NsYXNzZXNbMV0tX2NsYXNzZXNbMF0pICogKDAgKyAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiAxc3QgY2xhc3NcbiAgICAvLyAgICAgICAgIGNvbnN0IG1heGMgPSBfY2xhc3Nlc1tuLTFdICsgKChfY2xhc3Nlc1tuXS1fY2xhc3Nlc1tuLTFdKSAqICgxIC0gKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgbGFzdCBjbGFzc1xuICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gdmFsO1xuICAgIC8vIH07XG5cblxuICAgIHZhciBnZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yKHZhbCwgYnlwYXNzTWFwKSB7XG4gICAgICB2YXIgY29sLCB0O1xuXG4gICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHtcbiAgICAgICAgYnlwYXNzTWFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICBpZiAoX2NsYXNzZXMgJiYgX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgIC8vIGZpbmQgdGhlIGNsYXNzXG4gICAgICAgICAgdmFyIGMgPSBnZXRDbGFzcyh2YWwpO1xuICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKF9tYXggIT09IF9taW4pIHtcbiAgICAgICAgICAvLyBqdXN0IGludGVycG9sYXRlIGJldHdlZW4gbWluL21heFxuICAgICAgICAgIHQgPSAodmFsIC0gX21pbikgLyAoX21heCAtIF9taW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdmFsO1xuICAgICAgfSAvLyBkb21haW4gbWFwXG5cblxuICAgICAgdCA9IHRNYXBEb21haW4odCk7XG5cbiAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgIHQgPSB0TWFwTGlnaHRuZXNzKHQpOyAvLyBsaWdodG5lc3MgY29ycmVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAoX2dhbW1hICE9PSAxKSB7XG4gICAgICAgIHQgPSBwb3ckNSh0LCBfZ2FtbWEpO1xuICAgICAgfVxuXG4gICAgICB0ID0gX3BhZGRpbmdbMF0gKyB0ICogKDEgLSBfcGFkZGluZ1swXSAtIF9wYWRkaW5nWzFdKTtcbiAgICAgIHQgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB0KSk7XG4gICAgICB2YXIgayA9IE1hdGguZmxvb3IodCAqIDEwMDAwKTtcblxuICAgICAgaWYgKF91c2VDYWNoZSAmJiBfY29sb3JDYWNoZVtrXSkge1xuICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlJGooX2NvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBfcG9zW2ldO1xuXG4gICAgICAgICAgICBpZiAodCA8PSBwKSB7XG4gICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodCA+PSBwICYmIGkgPT09IF9wb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2kgKyAxXSkge1xuICAgICAgICAgICAgICB0ID0gKHQgLSBwKSAvIChfcG9zW2kgKyAxXSAtIHApO1xuICAgICAgICAgICAgICBjb2wgPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZShfY29sb3JzW2ldLCBfY29sb3JzW2kgKyAxXSwgdCwgX21vZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSRqKF9jb2xvcnMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29sID0gX2NvbG9ycyh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdXNlQ2FjaGUpIHtcbiAgICAgICAgICBfY29sb3JDYWNoZVtrXSA9IGNvbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH07XG5cbiAgICB2YXIgcmVzZXRDYWNoZSA9IGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgICByZXR1cm4gX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICB9O1xuXG4gICAgc2V0Q29sb3JzKGNvbG9ycyk7IC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgIHZhciBmID0gZnVuY3Rpb24gZih2KSB7XG4gICAgICB2YXIgYyA9IGNocm9tYV8xKGdldENvbG9yKHYpKTtcblxuICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkge1xuICAgICAgICByZXR1cm4gY1tfb3V0XSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICBpZiAoY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlJGooY2xhc3NlcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICBfY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkID0gY2hyb21hXzEuYW5hbHl6ZShfZG9tYWluKTtcblxuICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY2xhc3NlcyA9IGNocm9tYV8xLmxpbWl0cyhkLCAnZScsIGNsYXNzZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2NsYXNzZXM7XG4gICAgfTtcblxuICAgIGYuZG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfZG9tYWluO1xuICAgICAgfVxuXG4gICAgICBfbWluID0gZG9tYWluWzBdO1xuICAgICAgX21heCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgICBfcG9zID0gW107XG4gICAgICB2YXIgayA9IF9jb2xvcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gayAmJiBfbWluICE9PSBfbWF4KSB7XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBBcnJheS5mcm9tKGRvbWFpbik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIGQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgX3Bvcy5wdXNoKChkIC0gX21pbikgLyAoX21heCAtIF9taW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBrOyBjKyspIHtcbiAgICAgICAgICBfcG9zLnB1c2goYyAvIChrIC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbi5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgLy8gc2V0IGRvbWFpbiBtYXBcbiAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC8gKGRvbWFpbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdEJyZWFrcyA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoZCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdEJyZWFrcy5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gdE91dFtpXSA9PT0gdmFsO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0TWFwRG9tYWluID0gZnVuY3Rpb24gdE1hcERvbWFpbih0KSB7XG4gICAgICAgICAgICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZiA9ICh0IC0gdEJyZWFrc1tpXSkgLyAodEJyZWFrc1tpICsgMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgdmFyIG91dCA9IHRPdXRbaV0gKyBmICogKHRPdXRbaSArIDFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZG9tYWluID0gW19taW4sIF9tYXhdO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYubW9kZSA9IGZ1bmN0aW9uIChfbSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgIH1cblxuICAgICAgX21vZGUgPSBfbTtcbiAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnJhbmdlID0gZnVuY3Rpb24gKGNvbG9ycywgX3Bvcykge1xuICAgICAgc2V0Q29sb3JzKGNvbG9ycywgX3Bvcyk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5vdXQgPSBmdW5jdGlvbiAoX28pIHtcbiAgICAgIF9vdXQgPSBfbztcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnNwcmVhZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX3NwcmVhZDtcbiAgICAgIH1cblxuICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmNvcnJlY3RMaWdodG5lc3MgPSBmdW5jdGlvbiAodikge1xuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX2NvcnJlY3RMaWdodG5lc3MgPSB2O1xuICAgICAgcmVzZXRDYWNoZSgpO1xuXG4gICAgICBpZiAoX2NvcnJlY3RMaWdodG5lc3MpIHtcbiAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBMMSA9IGdldENvbG9yKDEsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBwb2wgPSBMMCA+IEwxO1xuICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBMX2lkZWFsID0gTDAgKyAoTDEgLSBMMCkgKiB0O1xuICAgICAgICAgIHZhciBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgdmFyIHQwID0gMDtcbiAgICAgICAgICB2YXIgdDEgPSAxO1xuICAgICAgICAgIHZhciBtYXhfaXRlciA9IDIwO1xuXG4gICAgICAgICAgd2hpbGUgKE1hdGguYWJzKExfZGlmZikgPiAxZS0yICYmIG1heF9pdGVyLS0gPiAwKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAocG9sKSB7XG4gICAgICAgICAgICAgICAgTF9kaWZmICo9IC0xO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICB0MCA9IHQ7XG4gICAgICAgICAgICAgICAgdCArPSAodDEgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MSA9IHQ7XG4gICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIExfYWN0dWFsID0gZ2V0Q29sb3IodCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgIHJldHVybiBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5wYWRkaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUkaihwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwID0gW3AsIHBdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhZGRpbmcgPSBwO1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5jb2xvcnMgPSBmdW5jdGlvbiAobnVtQ29sb3JzLCBvdXQpIHtcbiAgICAgIC8vIElmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW4sIHJldHVybiB0aGUgb3JpZ2luYWwgY29sb3JzIHRoYXQgd2VyZSBwcm92aWRlZFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIG91dCA9ICdoZXgnO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG4gICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA9PT0gMSkge1xuICAgICAgICByZXN1bHQgPSBbZigwLjUpXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICB2YXIgZG0gPSBfZG9tYWluWzBdO1xuICAgICAgICB2YXIgZGQgPSBfZG9tYWluWzFdIC0gZG07XG4gICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMsIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gZihkbSArIGkgLyAobnVtQ29sb3JzIC0gMSkgKiBkZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV0dXJucyBhbGwgY29sb3JzIGJhc2VkIG9uIHRoZSBkZWZpbmVkIGNsYXNzZXNcbiAgICAgICAgY29sb3JzID0gW107XG4gICAgICAgIHZhciBzYW1wbGVzID0gW107XG5cbiAgICAgICAgaWYgKF9jbGFzc2VzICYmIF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDsgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xuICAgICAgICAgICAgc2FtcGxlcy5wdXNoKChfY2xhc3Nlc1tpIC0gMV0gKyBfY2xhc3Nlc1tpXSkgKiAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1wbGVzID0gX2RvbWFpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGYodik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hyb21hXzFbb3V0XSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGNbb3V0XSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZi5jYWNoZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIF91c2VDYWNoZSA9IGM7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5nYW1tYSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nYW1tYTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5ub2RhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICBfbmFjb2wgPSBjaHJvbWFfMShkKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICBmdW5jdGlvbiBfX3JhbmdlX18obGVmdCwgcmlnaHQsIGluY2x1c2l2ZSkge1xuICAgIHZhciByYW5nZSA9IFtdO1xuICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgdmFyIGVuZCA9ICFpbmNsdXNpdmUgPyByaWdodCA6IGFzY2VuZGluZyA/IHJpZ2h0ICsgMSA6IHJpZ2h0IC0gMTtcblxuICAgIGZvciAodmFyIGkgPSBsZWZ0OyBhc2NlbmRpbmcgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjZW5kaW5nID8gaSsrIDogaS0tKSB7XG4gICAgICByYW5nZS5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfSAvL1xuICAvLyBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4gIC8vXG4gIC8vIEByZXF1aXJlcyB1dGlscyBsYWJcblxuXG4gIHZhciBiZXppZXIgPSBmdW5jdGlvbiBiZXppZXIoY29sb3JzKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyO1xuICAgIHZhciBJLCBsYWIwLCBsYWIxLCBsYWIyO1xuICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sb3JfMShjKTtcbiAgICB9KTtcblxuICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgYXNzaWduID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5sYWIoKTtcbiAgICAgIH0pLCBsYWIwID0gYXNzaWduWzBdLCBsYWIxID0gYXNzaWduWzFdO1xuXG4gICAgICBJID0gZnVuY3Rpb24gSSh0KSB7XG4gICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYjBbaV0gKyB0ICogKGxhYjFbaV0gLSBsYWIwW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShsYWIsICdsYWInKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBxdWFkcmF0aWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgIGFzc2lnbiQxID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5sYWIoKTtcbiAgICAgIH0pLCBsYWIwID0gYXNzaWduJDFbMF0sIGxhYjEgPSBhc3NpZ24kMVsxXSwgbGFiMiA9IGFzc2lnbiQxWzJdO1xuXG4gICAgICBJID0gZnVuY3Rpb24gSSh0KSB7XG4gICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogbGFiMFtpXSArIDIgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gKyB0ICogdCAqIGxhYjJbaV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgIHZhciBsYWIzO1xuICAgICAgYXNzaWduJDIgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLmxhYigpO1xuICAgICAgfSksIGxhYjAgPSBhc3NpZ24kMlswXSwgbGFiMSA9IGFzc2lnbiQyWzFdLCBsYWIyID0gYXNzaWduJDJbMl0sIGxhYjMgPSBhc3NpZ24kMlszXTtcblxuICAgICAgSSA9IGZ1bmN0aW9uIEkodCkge1xuICAgICAgICB2YXIgbGFiID0gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgKiBsYWIwW2ldICsgMyAqICgxIC0gdCkgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gKyAzICogKDEgLSB0KSAqIHQgKiB0ICogbGFiMltpXSArIHQgKiB0ICogdCAqIGxhYjNbaV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdmFyIEkwID0gYmV6aWVyKGNvbG9ycy5zbGljZSgwLCAzKSk7XG4gICAgICB2YXIgSTEgPSBiZXppZXIoY29sb3JzLnNsaWNlKDIsIDUpKTtcblxuICAgICAgSSA9IGZ1bmN0aW9uIEkodCkge1xuICAgICAgICBpZiAodCA8IDAuNSkge1xuICAgICAgICAgIHJldHVybiBJMCh0ICogMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEkxKCh0IC0gMC41KSAqIDIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBJO1xuICB9O1xuXG4gIHZhciBiZXppZXJfMSA9IGZ1bmN0aW9uIGJlemllcl8xKGNvbG9ycykge1xuICAgIHZhciBmID0gYmV6aWVyKGNvbG9ycyk7XG5cbiAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNjYWxlKGYpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfTtcbiAgLypcbiAgICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgKiBibGVuZCBtb2RlIGZvcm11bGFzIHRha2VuIGZyb20gaHR0cDovL3d3dy52ZW50dXJlLXdhcmUuY29tL2tldmluL2NvZGluZy9sZXRzLWxlYXJuLW1hdGgtcGhvdG9zaG9wLWJsZW5kLW1vZGVzL1xuICAgKi9cblxuXG4gIHZhciBibGVuZCA9IGZ1bmN0aW9uIGJsZW5kKGJvdHRvbSwgdG9wLCBtb2RlKSB7XG4gICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gIH07XG5cbiAgdmFyIGJsZW5kX2YgPSBmdW5jdGlvbiBibGVuZF9mKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJvdHRvbSwgdG9wKSB7XG4gICAgICB2YXIgYzAgPSBjaHJvbWFfMSh0b3ApLnJnYigpO1xuICAgICAgdmFyIGMxID0gY2hyb21hXzEoYm90dG9tKS5yZ2IoKTtcbiAgICAgIHJldHVybiBjaHJvbWFfMS5yZ2IoZihjMCwgYzEpKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBlYWNoID0gZnVuY3Rpb24gZWFjaChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgIG91dFsyXSA9IGYoYzBbMl0sIGMxWzJdKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gbm9ybWFsKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICB2YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiIC8gMjU1O1xuICB9O1xuXG4gIHZhciBkYXJrZW4kMSA9IGZ1bmN0aW9uIGRhcmtlbiQxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyBiIDogYTtcbiAgfTtcblxuICB2YXIgbGlnaHRlbiA9IGZ1bmN0aW9uIGxpZ2h0ZW4oYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IGEgOiBiO1xuICB9O1xuXG4gIHZhciBzY3JlZW4gPSBmdW5jdGlvbiBzY3JlZW4oYSwgYikge1xuICAgIHJldHVybiAyNTUgKiAoMSAtICgxIC0gYSAvIDI1NSkgKiAoMSAtIGIgLyAyNTUpKTtcbiAgfTtcblxuICB2YXIgb3ZlcmxheSA9IGZ1bmN0aW9uIG92ZXJsYXkoYSwgYikge1xuICAgIHJldHVybiBiIDwgMTI4ID8gMiAqIGEgKiBiIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1KSAqICgxIC0gYiAvIDI1NSkpO1xuICB9O1xuXG4gIHZhciBidXJuID0gZnVuY3Rpb24gYnVybihhLCBiKSB7XG4gICAgcmV0dXJuIDI1NSAqICgxIC0gKDEgLSBiIC8gMjU1KSAvIChhIC8gMjU1KSk7XG4gIH07XG5cbiAgdmFyIGRvZGdlID0gZnVuY3Rpb24gZG9kZ2UoYSwgYikge1xuICAgIGlmIChhID09PSAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuXG4gICAgYSA9IDI1NSAqIChiIC8gMjU1KSAvICgxIC0gYSAvIDI1NSk7XG4gICAgcmV0dXJuIGEgPiAyNTUgPyAyNTUgOiBhO1xuICB9OyAvLyAjIGFkZCA9IChhLGIpIC0+XG4gIC8vICMgICAgIGlmIChhICsgYiA+IDI1NSkgdGhlbiAyNTUgZWxzZSBhICsgYlxuXG5cbiAgYmxlbmQubm9ybWFsID0gYmxlbmRfZihlYWNoKG5vcm1hbCkpO1xuICBibGVuZC5tdWx0aXBseSA9IGJsZW5kX2YoZWFjaChtdWx0aXBseSkpO1xuICBibGVuZC5zY3JlZW4gPSBibGVuZF9mKGVhY2goc2NyZWVuKSk7XG4gIGJsZW5kLm92ZXJsYXkgPSBibGVuZF9mKGVhY2gob3ZlcmxheSkpO1xuICBibGVuZC5kYXJrZW4gPSBibGVuZF9mKGVhY2goZGFya2VuJDEpKTtcbiAgYmxlbmQubGlnaHRlbiA9IGJsZW5kX2YoZWFjaChsaWdodGVuKSk7XG4gIGJsZW5kLmRvZGdlID0gYmxlbmRfZihlYWNoKGRvZGdlKSk7XG4gIGJsZW5kLmJ1cm4gPSBibGVuZF9mKGVhY2goYnVybikpOyAvLyBibGVuZC5hZGQgPSBibGVuZF9mKGVhY2goYWRkKSk7XG5cbiAgdmFyIGJsZW5kXzEgPSBibGVuZDsgLy8gY3ViZWhlbGl4IGludGVycG9sYXRpb25cbiAgLy8gYmFzZWQgb24gRC5BLiBHcmVlbiBcIkEgY29sb3VyIHNjaGVtZSBmb3IgdGhlIGRpc3BsYXkgb2YgYXN0cm9ub21pY2FsIGludGVuc2l0eSBpbWFnZXNcIlxuICAvLyBodHRwOi8vYXN0cm9uLXNvYy5pbi9idWxsZXRpbi8xMUp1bmUvMjg5MzkyMDExLnBkZlxuXG4gIHZhciB0eXBlJGsgPSB1dGlscy50eXBlO1xuICB2YXIgY2xpcF9yZ2IkMyA9IHV0aWxzLmNsaXBfcmdiO1xuICB2YXIgVFdPUEkkMiA9IHV0aWxzLlRXT1BJO1xuICB2YXIgcG93JDYgPSBNYXRoLnBvdztcbiAgdmFyIHNpbiQyID0gTWF0aC5zaW47XG4gIHZhciBjb3MkMyA9IE1hdGguY29zO1xuXG4gIHZhciBjdWJlaGVsaXggPSBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIHJvdGF0aW9ucywgaHVlLCBnYW1tYSwgbGlnaHRuZXNzKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHN0YXJ0ID0gMzAwO1xuICAgIGlmIChyb3RhdGlvbnMgPT09IHZvaWQgMCkgcm90YXRpb25zID0gLTEuNTtcbiAgICBpZiAoaHVlID09PSB2b2lkIDApIGh1ZSA9IDE7XG4gICAgaWYgKGdhbW1hID09PSB2b2lkIDApIGdhbW1hID0gMTtcbiAgICBpZiAobGlnaHRuZXNzID09PSB2b2lkIDApIGxpZ2h0bmVzcyA9IFswLCAxXTtcbiAgICB2YXIgZGggPSAwLFxuICAgICAgICBkbDtcblxuICAgIGlmICh0eXBlJGsobGlnaHRuZXNzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgZGwgPSBsaWdodG5lc3NbMV0gLSBsaWdodG5lc3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRsID0gMDtcbiAgICAgIGxpZ2h0bmVzcyA9IFtsaWdodG5lc3MsIGxpZ2h0bmVzc107XG4gICAgfVxuXG4gICAgdmFyIGYgPSBmdW5jdGlvbiBmKGZyYWN0KSB7XG4gICAgICB2YXIgYSA9IFRXT1BJJDIgKiAoKHN0YXJ0ICsgMTIwKSAvIDM2MCArIHJvdGF0aW9ucyAqIGZyYWN0KTtcbiAgICAgIHZhciBsID0gcG93JDYobGlnaHRuZXNzWzBdICsgZGwgKiBmcmFjdCwgZ2FtbWEpO1xuICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIGZyYWN0ICogZGggOiBodWU7XG4gICAgICB2YXIgYW1wID0gaCAqIGwgKiAoMSAtIGwpIC8gMjtcbiAgICAgIHZhciBjb3NfYSA9IGNvcyQzKGEpO1xuICAgICAgdmFyIHNpbl9hID0gc2luJDIoYSk7XG4gICAgICB2YXIgciA9IGwgKyBhbXAgKiAoLTAuMTQ4NjEgKiBjb3NfYSArIDEuNzgyNzcgKiBzaW5fYSk7XG4gICAgICB2YXIgZyA9IGwgKyBhbXAgKiAoLTAuMjkyMjcgKiBjb3NfYSAtIDAuOTA2NDkgKiBzaW5fYSk7XG4gICAgICB2YXIgYiA9IGwgKyBhbXAgKiAoKzEuOTcyOTQgKiBjb3NfYSk7XG4gICAgICByZXR1cm4gY2hyb21hXzEoY2xpcF9yZ2IkMyhbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgMV0pKTtcbiAgICB9O1xuXG4gICAgZi5zdGFydCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBzO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYucm90YXRpb25zID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9ucztcbiAgICAgIH1cblxuICAgICAgcm90YXRpb25zID0gcjtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmdhbW1hID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgIGlmIChnID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdhbW1hO1xuICAgICAgfVxuXG4gICAgICBnYW1tYSA9IGc7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5odWUgPSBmdW5jdGlvbiAoaCkge1xuICAgICAgaWYgKGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaHVlO1xuICAgICAgfVxuXG4gICAgICBodWUgPSBoO1xuXG4gICAgICBpZiAodHlwZSRrKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgZGggPSBodWVbMV0gLSBodWVbMF07XG5cbiAgICAgICAgaWYgKGRoID09PSAwKSB7XG4gICAgICAgICAgaHVlID0gaHVlWzFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmxpZ2h0bmVzcyA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICBpZiAoaCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaWdodG5lc3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlJGsoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgbGlnaHRuZXNzID0gaDtcbiAgICAgICAgZGwgPSBoWzFdIC0gaFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpZ2h0bmVzcyA9IFtoLCBoXTtcbiAgICAgICAgZGwgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjaHJvbWFfMS5zY2FsZShmKTtcbiAgICB9O1xuXG4gICAgZi5odWUoaHVlKTtcbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICB2YXIgZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICB2YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG4gIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICB2YXIgcmFuZG9tXzEgPSBmdW5jdGlvbiByYW5kb21fMSgpIHtcbiAgICB2YXIgY29kZSA9ICcjJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb2RlICs9IGRpZ2l0cy5jaGFyQXQoZmxvb3IkMihyYW5kb20oKSAqIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xvcl8xKGNvZGUsICdoZXgnKTtcbiAgfTtcblxuICB2YXIgbG9nJDEgPSBNYXRoLmxvZztcbiAgdmFyIHBvdyQ3ID0gTWF0aC5wb3c7XG4gIHZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gIHZhciBhbmFseXplID0gZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSB2b2lkIDApIGtleSA9IG51bGw7XG4gICAgdmFyIHIgPSB7XG4gICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICBtYXg6IE51bWJlci5NQVhfVkFMVUUgKiAtMSxcbiAgICAgIHN1bTogMCxcbiAgICAgIHZhbHVlczogW10sXG4gICAgICBjb3VudDogMFxuICAgIH07XG5cbiAgICBpZiAodHlwZShkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKGRhdGEpO1xuICAgIH1cblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAoa2V5ICYmIHR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsID0gdmFsW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgci52YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICByLnN1bSArPSB2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA8IHIubWluKSB7XG4gICAgICAgICAgci5taW4gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID4gci5tYXgpIHtcbiAgICAgICAgICByLm1heCA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuY291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgci5saW1pdHMgPSBmdW5jdGlvbiAobW9kZSwgbnVtKSB7XG4gICAgICByZXR1cm4gbGltaXRzKHIsIG1vZGUsIG51bSk7XG4gICAgfTtcblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIHZhciBsaW1pdHMgPSBmdW5jdGlvbiBsaW1pdHMoZGF0YSwgbW9kZSwgbnVtKSB7XG4gICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgbW9kZSA9ICdlcXVhbCc7XG4gICAgaWYgKG51bSA9PT0gdm9pZCAwKSBudW0gPSA3O1xuXG4gICAgaWYgKHR5cGUoZGF0YSkgPT0gJ2FycmF5Jykge1xuICAgICAgZGF0YSA9IGFuYWx5emUoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IGRhdGEubWluO1xuICAgIHZhciBtYXggPSBkYXRhLm1heDtcbiAgICB2YXIgdmFsdWVzID0gZGF0YS52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bSA9PT0gMSkge1xuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgdmFyIGxpbWl0cyA9IFtdO1xuXG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnYycpIHtcbiAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH1cblxuICAgIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2UnKSB7XG4gICAgICAvLyBlcXVhbCBpbnRlcnZhbFxuICAgICAgbGltaXRzLnB1c2gobWluKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICBsaW1pdHMucHVzaChtaW4gKyBpIC8gbnVtICogKG1heCAtIG1pbikpO1xuICAgICAgfVxuXG4gICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdsJykge1xuICAgICAgLy8gbG9nIHNjYWxlXG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbl9sb2cgPSBNYXRoLkxPRzEwRSAqIGxvZyQxKG1pbik7XG4gICAgICB2YXIgbWF4X2xvZyA9IE1hdGguTE9HMTBFICogbG9nJDEobWF4KTtcbiAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IG51bTsgaSQxKyspIHtcbiAgICAgICAgbGltaXRzLnB1c2gocG93JDcoMTAsIG1pbl9sb2cgKyBpJDEgLyBudW0gKiAobWF4X2xvZyAtIG1pbl9sb2cpKSk7XG4gICAgICB9XG5cbiAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ3EnKSB7XG4gICAgICAvLyBxdWFudGlsZSBzY2FsZVxuICAgICAgbGltaXRzLnB1c2gobWluKTtcblxuICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgbnVtOyBpJDIrKykge1xuICAgICAgICB2YXIgcCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBpJDIgLyBudW07XG4gICAgICAgIHZhciBwYiA9IGZsb29yJDMocCk7XG5cbiAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgbGltaXRzLnB1c2godmFsdWVzW3BiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcCA+IHBiXG4gICAgICAgICAgdmFyIHByID0gcCAtIHBiO1xuICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0gKiAoMSAtIHByKSArIHZhbHVlc1twYiArIDFdICogcHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2snKSB7XG4gICAgICAvLyBrLW1lYW5zIGNsdXN0ZXJpbmdcblxuICAgICAgLypcbiAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgIHNpbXBsaWZpZWQgZm9yIDEtZCBpbnB1dCB2YWx1ZXNcbiAgICAgICovXG4gICAgICB2YXIgY2x1c3RlcjtcbiAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBhc3NpZ25tZW50cyA9IG5ldyBBcnJheShuKTtcbiAgICAgIHZhciBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgIHZhciByZXBlYXQgPSB0cnVlO1xuICAgICAgdmFyIG5iX2l0ZXJzID0gMDtcbiAgICAgIHZhciBjZW50cm9pZHMgPSBudWxsOyAvLyBnZXQgc2VlZCB2YWx1ZXNcblxuICAgICAgY2VudHJvaWRzID0gW107XG4gICAgICBjZW50cm9pZHMucHVzaChtaW4pO1xuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxOyBpJDMgPCBudW07IGkkMysrKSB7XG4gICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArIGkkMyAvIG51bSAqIChtYXggLSBtaW4pKTtcbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzLnB1c2gobWF4KTtcblxuICAgICAgd2hpbGUgKHJlcGVhdCkge1xuICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgIGNsdXN0ZXJTaXplc1tqXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBuOyBpJDQrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpJDRdO1xuICAgICAgICAgIHZhciBtaW5kaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICB2YXIgYmVzdCA9IHZvaWQgMDtcblxuICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IG51bTsgaiQxKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gYWJzKGNlbnRyb2lkc1tqJDFdIC0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgIGJlc3QgPSBqJDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tiZXN0XSsrO1xuICAgICAgICAgICAgYXNzaWdubWVudHNbaSQ0XSA9IGJlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBjZW50cm9pZHMgc3RlcFxuXG5cbiAgICAgICAgdmFyIG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuXG4gICAgICAgIGZvciAodmFyIGokMiA9IDA7IGokMiA8IG51bTsgaiQyKyspIHtcbiAgICAgICAgICBuZXdDZW50cm9pZHNbaiQyXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBuOyBpJDUrKykge1xuICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpJDVdO1xuXG4gICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSArPSB2YWx1ZXNbaSQ1XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqJDMgPSAwOyBqJDMgPCBudW07IGokMysrKSB7XG4gICAgICAgICAgbmV3Q2VudHJvaWRzW2okM10gKj0gMSAvIGNsdXN0ZXJTaXplc1tqJDNdO1xuICAgICAgICB9IC8vIGNoZWNrIGNvbnZlcmdlbmNlXG5cblxuICAgICAgICByZXBlYXQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqJDQgPSAwOyBqJDQgPCBudW07IGokNCsrKSB7XG4gICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tqJDRdICE9PSBjZW50cm9pZHNbaiQ0XSkge1xuICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgbmJfaXRlcnMrKztcblxuICAgICAgICBpZiAobmJfaXRlcnMgPiAyMDApIHtcbiAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmaW5pc2hlZCBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgIC8vIHRoZSBuZXh0IHBhcnQgaXMgYm9ycm93ZWQgZnJvbSBnYWJyaWVsZmxvci5pdFxuXG5cbiAgICAgIHZhciBrQ2x1c3RlcnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiQ1ID0gMDsgaiQ1IDwgbnVtOyBqJDUrKykge1xuICAgICAgICBrQ2x1c3RlcnNbaiQ1XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpJDYgPSAwOyBpJDYgPCBuOyBpJDYrKykge1xuICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ2XTtcbiAgICAgICAga0NsdXN0ZXJzW2NsdXN0ZXJdLnB1c2godmFsdWVzW2kkNl0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG1wS01lYW5zQnJlYWtzID0gW107XG5cbiAgICAgIGZvciAodmFyIGokNiA9IDA7IGokNiA8IG51bTsgaiQ2KyspIHtcbiAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1bMF0pO1xuICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbaiQ2XVtrQ2x1c3RlcnNbaiQ2XS5sZW5ndGggLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHRtcEtNZWFuc0JyZWFrcyA9IHRtcEtNZWFuc0JyZWFrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pO1xuICAgICAgbGltaXRzLnB1c2godG1wS01lYW5zQnJlYWtzWzBdKTtcblxuICAgICAgZm9yICh2YXIgaSQ3ID0gMTsgaSQ3IDwgdG1wS01lYW5zQnJlYWtzLmxlbmd0aDsgaSQ3ICs9IDIpIHtcbiAgICAgICAgdmFyIHYgPSB0bXBLTWVhbnNCcmVha3NbaSQ3XTtcblxuICAgICAgICBpZiAoIWlzTmFOKHYpICYmIGxpbWl0cy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgIGxpbWl0cy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbWl0cztcbiAgfTtcblxuICB2YXIgYW5hbHl6ZV8xID0ge1xuICAgIGFuYWx5emU6IGFuYWx5emUsXG4gICAgbGltaXRzOiBsaW1pdHNcbiAgfTtcblxuICB2YXIgY29udHJhc3QgPSBmdW5jdGlvbiBjb250cmFzdChhLCBiKSB7XG4gICAgLy8gV0NBRyBjb250cmFzdCByYXRpb1xuICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICB2YXIgbDEgPSBhLmx1bWluYW5jZSgpO1xuICAgIHZhciBsMiA9IGIubHVtaW5hbmNlKCk7XG4gICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbiAgfTtcblxuICB2YXIgc3FydCQ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgYXRhbjIkMiA9IE1hdGguYXRhbjI7XG4gIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuICB2YXIgY29zJDQgPSBNYXRoLmNvcztcbiAgdmFyIFBJJDIgPSBNYXRoLlBJO1xuXG4gIHZhciBkZWx0YUUgPSBmdW5jdGlvbiBkZWx0YUUoYSwgYiwgTCwgQykge1xuICAgIGlmIChMID09PSB2b2lkIDApIEwgPSAxO1xuICAgIGlmIChDID09PSB2b2lkIDApIEMgPSAxOyAvLyBEZWx0YSBFIChDTUMpXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DTUMuaHRtbFxuXG4gICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICB2YXIgcmVmID0gQXJyYXkuZnJvbShhLmxhYigpKTtcbiAgICB2YXIgTDEgPSByZWZbMF07XG4gICAgdmFyIGExID0gcmVmWzFdO1xuICAgIHZhciBiMSA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgIHZhciBMMiA9IHJlZiQxWzBdO1xuICAgIHZhciBhMiA9IHJlZiQxWzFdO1xuICAgIHZhciBiMiA9IHJlZiQxWzJdO1xuICAgIHZhciBjMSA9IHNxcnQkNChhMSAqIGExICsgYjEgKiBiMSk7XG4gICAgdmFyIGMyID0gc3FydCQ0KGEyICogYTIgKyBiMiAqIGIyKTtcbiAgICB2YXIgc2wgPSBMMSA8IDE2LjAgPyAwLjUxMSA6IDAuMDQwOTc1ICogTDEgLyAoMS4wICsgMC4wMTc2NSAqIEwxKTtcbiAgICB2YXIgc2MgPSAwLjA2MzggKiBjMSAvICgxLjAgKyAwLjAxMzEgKiBjMSkgKyAwLjYzODtcbiAgICB2YXIgaDEgPSBjMSA8IDAuMDAwMDAxID8gMC4wIDogYXRhbjIkMihiMSwgYTEpICogMTgwLjAgLyBQSSQyO1xuXG4gICAgd2hpbGUgKGgxIDwgMCkge1xuICAgICAgaDEgKz0gMzYwO1xuICAgIH1cblxuICAgIHdoaWxlIChoMSA+PSAzNjApIHtcbiAgICAgIGgxIC09IDM2MDtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGgxID49IDE2NC4wICYmIGgxIDw9IDM0NS4wID8gMC41NiArIGFicyQxKDAuMiAqIGNvcyQ0KFBJJDIgKiAoaDEgKyAxNjguMCkgLyAxODAuMCkpIDogMC4zNiArIGFicyQxKDAuNCAqIGNvcyQ0KFBJJDIgKiAoaDEgKyAzNS4wKSAvIDE4MC4wKSk7XG4gICAgdmFyIGM0ID0gYzEgKiBjMSAqIGMxICogYzE7XG4gICAgdmFyIGYgPSBzcXJ0JDQoYzQgLyAoYzQgKyAxOTAwLjApKTtcbiAgICB2YXIgc2ggPSBzYyAqIChmICogdCArIDEuMCAtIGYpO1xuICAgIHZhciBkZWxMID0gTDEgLSBMMjtcbiAgICB2YXIgZGVsQyA9IGMxIC0gYzI7XG4gICAgdmFyIGRlbEEgPSBhMSAtIGEyO1xuICAgIHZhciBkZWxCID0gYjEgLSBiMjtcbiAgICB2YXIgZEgyID0gZGVsQSAqIGRlbEEgKyBkZWxCICogZGVsQiAtIGRlbEMgKiBkZWxDO1xuICAgIHZhciB2MSA9IGRlbEwgLyAoTCAqIHNsKTtcbiAgICB2YXIgdjIgPSBkZWxDIC8gKEMgKiBzYyk7XG4gICAgdmFyIHYzID0gc2g7XG4gICAgcmV0dXJuIHNxcnQkNCh2MSAqIHYxICsgdjIgKiB2MiArIGRIMiAvICh2MyAqIHYzKSk7XG4gIH07IC8vIHNpbXBsZSBFdWNsaWRlYW4gZGlzdGFuY2VcblxuXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIsIG1vZGUpIHtcbiAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSBtb2RlID0gJ2xhYic7IC8vIERlbHRhIEUgKENJRSAxOTc2KVxuICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG5cbiAgICBhID0gbmV3IENvbG9yXzEoYSk7XG4gICAgYiA9IG5ldyBDb2xvcl8xKGIpO1xuICAgIHZhciBsMSA9IGEuZ2V0KG1vZGUpO1xuICAgIHZhciBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgIHZhciBzdW1fc3EgPSAwO1xuXG4gICAgZm9yICh2YXIgaSBpbiBsMSkge1xuICAgICAgdmFyIGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICBzdW1fc3EgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChzdW1fc3EpO1xuICB9O1xuXG4gIHZhciB2YWxpZCA9IGZ1bmN0aW9uIHZhbGlkKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTsgLy8gc29tZSBwcmUtZGVmaW5lZCBjb2xvciBzY2FsZXM6XG5cblxuICB2YXIgc2NhbGVzID0ge1xuICAgIGNvb2w6IGZ1bmN0aW9uIGNvb2woKSB7XG4gICAgICByZXR1cm4gc2NhbGUoW2Nocm9tYV8xLmhzbCgxODAsIDEsIC45KSwgY2hyb21hXzEuaHNsKDI1MCwgLjcsIC40KV0pO1xuICAgIH0sXG4gICAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgICByZXR1cm4gc2NhbGUoWycjMDAwJywgJyNmMDAnLCAnI2ZmMCcsICcjZmZmJ10sIFswLCAuMjUsIC43NSwgMV0pLm1vZGUoJ3JnYicpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuICAgICAgIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlciwgYW5kIFRoZVxuICAgICAgUGVubnN5bHZhbmlhIFN0YXRlIFVuaXZlcnNpdHkuXG4gICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZFxuICAgICAgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1JcbiAgICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgICBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAqL1xuXG4gIHZhciBjb2xvcmJyZXdlciA9IHtcbiAgICAvLyBzZXF1ZW50aWFsXG4gICAgT3JSZDogWycjZmZmN2VjJywgJyNmZWU4YzgnLCAnI2ZkZDQ5ZScsICcjZmRiYjg0JywgJyNmYzhkNTknLCAnI2VmNjU0OCcsICcjZDczMDFmJywgJyNiMzAwMDAnLCAnIzdmMDAwMCddLFxuICAgIFB1QnU6IFsnI2ZmZjdmYicsICcjZWNlN2YyJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNzRhOWNmJywgJyMzNjkwYzAnLCAnIzA1NzBiMCcsICcjMDQ1YThkJywgJyMwMjM4NTgnXSxcbiAgICBCdVB1OiBbJyNmN2ZjZmQnLCAnI2UwZWNmNCcsICcjYmZkM2U2JywgJyM5ZWJjZGEnLCAnIzhjOTZjNicsICcjOGM2YmIxJywgJyM4ODQxOWQnLCAnIzgxMGY3YycsICcjNGQwMDRiJ10sXG4gICAgT3JhbmdlczogWycjZmZmNWViJywgJyNmZWU2Y2UnLCAnI2ZkZDBhMicsICcjZmRhZTZiJywgJyNmZDhkM2MnLCAnI2YxNjkxMycsICcjZDk0ODAxJywgJyNhNjM2MDMnLCAnIzdmMjcwNCddLFxuICAgIEJ1R246IFsnI2Y3ZmNmZCcsICcjZTVmNWY5JywgJyNjY2VjZTYnLCAnIzk5ZDhjOScsICcjNjZjMmE0JywgJyM0MWFlNzYnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICBZbE9yQnI6IFsnI2ZmZmZlNScsICcjZmZmN2JjJywgJyNmZWUzOTEnLCAnI2ZlYzQ0ZicsICcjZmU5OTI5JywgJyNlYzcwMTQnLCAnI2NjNGMwMicsICcjOTkzNDA0JywgJyM2NjI1MDYnXSxcbiAgICBZbEduOiBbJyNmZmZmZTUnLCAnI2Y3ZmNiOScsICcjZDlmMGEzJywgJyNhZGRkOGUnLCAnIzc4YzY3OScsICcjNDFhYjVkJywgJyMyMzg0NDMnLCAnIzAwNjgzNycsICcjMDA0NTI5J10sXG4gICAgUmVkczogWycjZmZmNWYwJywgJyNmZWUwZDInLCAnI2ZjYmJhMScsICcjZmM5MjcyJywgJyNmYjZhNGEnLCAnI2VmM2IyYycsICcjY2IxODFkJywgJyNhNTBmMTUnLCAnIzY3MDAwZCddLFxuICAgIFJkUHU6IFsnI2ZmZjdmMycsICcjZmRlMGRkJywgJyNmY2M1YzAnLCAnI2ZhOWZiNScsICcjZjc2OGExJywgJyNkZDM0OTcnLCAnI2FlMDE3ZScsICcjN2EwMTc3JywgJyM0OTAwNmEnXSxcbiAgICBHcmVlbnM6IFsnI2Y3ZmNmNScsICcjZTVmNWUwJywgJyNjN2U5YzAnLCAnI2ExZDk5YicsICcjNzRjNDc2JywgJyM0MWFiNWQnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICBZbEduQnU6IFsnI2ZmZmZkOScsICcjZWRmOGIxJywgJyNjN2U5YjQnLCAnIzdmY2RiYicsICcjNDFiNmM0JywgJyMxZDkxYzAnLCAnIzIyNWVhOCcsICcjMjUzNDk0JywgJyMwODFkNTgnXSxcbiAgICBQdXJwbGVzOiBbJyNmY2ZiZmQnLCAnI2VmZWRmNScsICcjZGFkYWViJywgJyNiY2JkZGMnLCAnIzllOWFjOCcsICcjODA3ZGJhJywgJyM2YTUxYTMnLCAnIzU0Mjc4ZicsICcjM2YwMDdkJ10sXG4gICAgR25CdTogWycjZjdmY2YwJywgJyNlMGYzZGInLCAnI2NjZWJjNScsICcjYThkZGI1JywgJyM3YmNjYzQnLCAnIzRlYjNkMycsICcjMmI4Y2JlJywgJyMwODY4YWMnLCAnIzA4NDA4MSddLFxuICAgIEdyZXlzOiBbJyNmZmZmZmYnLCAnI2YwZjBmMCcsICcjZDlkOWQ5JywgJyNiZGJkYmQnLCAnIzk2OTY5NicsICcjNzM3MzczJywgJyM1MjUyNTInLCAnIzI1MjUyNScsICcjMDAwMDAwJ10sXG4gICAgWWxPclJkOiBbJyNmZmZmY2MnLCAnI2ZmZWRhMCcsICcjZmVkOTc2JywgJyNmZWIyNGMnLCAnI2ZkOGQzYycsICcjZmM0ZTJhJywgJyNlMzFhMWMnLCAnI2JkMDAyNicsICcjODAwMDI2J10sXG4gICAgUHVSZDogWycjZjdmNGY5JywgJyNlN2UxZWYnLCAnI2Q0YjlkYScsICcjYzk5NGM3JywgJyNkZjY1YjAnLCAnI2U3Mjk4YScsICcjY2UxMjU2JywgJyM5ODAwNDMnLCAnIzY3MDAxZiddLFxuICAgIEJsdWVzOiBbJyNmN2ZiZmYnLCAnI2RlZWJmNycsICcjYzZkYmVmJywgJyM5ZWNhZTEnLCAnIzZiYWVkNicsICcjNDI5MmM2JywgJyMyMTcxYjUnLCAnIzA4NTE5YycsICcjMDgzMDZiJ10sXG4gICAgUHVCdUduOiBbJyNmZmY3ZmInLCAnI2VjZTJmMCcsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzY3YTljZicsICcjMzY5MGMwJywgJyMwMjgxOGEnLCAnIzAxNmM1OScsICcjMDE0NjM2J10sXG4gICAgVmlyaWRpczogWycjNDQwMTU0JywgJyM0ODI3NzcnLCAnIzNmNGE4YScsICcjMzE2NzhlJywgJyMyNjgzOGYnLCAnIzFmOWQ4YScsICcjNmNjZTVhJywgJyNiNmRlMmInLCAnI2ZlZTgyNSddLFxuICAgIC8vIGRpdmVyZ2luZ1xuICAgIFNwZWN0cmFsOiBbJyM5ZTAxNDInLCAnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNlNmY1OTgnLCAnI2FiZGRhNCcsICcjNjZjMmE1JywgJyMzMjg4YmQnLCAnIzVlNGZhMiddLFxuICAgIFJkWWxHbjogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZDllZjhiJywgJyNhNmQ5NmEnLCAnIzY2YmQ2MycsICcjMWE5ODUwJywgJyMwMDY4MzcnXSxcbiAgICBSZEJ1OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZjdmN2Y3JywgJyNkMWU1ZjAnLCAnIzkyYzVkZScsICcjNDM5M2MzJywgJyMyMTY2YWMnLCAnIzA1MzA2MSddLFxuICAgIFBpWUc6IFsnIzhlMDE1MicsICcjYzUxYjdkJywgJyNkZTc3YWUnLCAnI2YxYjZkYScsICcjZmRlMGVmJywgJyNmN2Y3ZjcnLCAnI2U2ZjVkMCcsICcjYjhlMTg2JywgJyM3ZmJjNDEnLCAnIzRkOTIyMScsICcjMjc2NDE5J10sXG4gICAgUFJHbjogWycjNDAwMDRiJywgJyM3NjJhODMnLCAnIzk5NzBhYicsICcjYzJhNWNmJywgJyNlN2Q0ZTgnLCAnI2Y3ZjdmNycsICcjZDlmMGQzJywgJyNhNmRiYTAnLCAnIzVhYWU2MScsICcjMWI3ODM3JywgJyMwMDQ0MWInXSxcbiAgICBSZFlsQnU6IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDkwJywgJyNmZmZmYmYnLCAnI2UwZjNmOCcsICcjYWJkOWU5JywgJyM3NGFkZDEnLCAnIzQ1NzViNCcsICcjMzEzNjk1J10sXG4gICAgQnJCRzogWycjNTQzMDA1JywgJyM4YzUxMGEnLCAnI2JmODEyZCcsICcjZGZjMjdkJywgJyNmNmU4YzMnLCAnI2Y1ZjVmNScsICcjYzdlYWU1JywgJyM4MGNkYzEnLCAnIzM1OTc4ZicsICcjMDE2NjVlJywgJyMwMDNjMzAnXSxcbiAgICBSZEd5OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZmZmZmZmJywgJyNlMGUwZTAnLCAnI2JhYmFiYScsICcjODc4Nzg3JywgJyM0ZDRkNGQnLCAnIzFhMWExYSddLFxuICAgIFB1T3I6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG4gICAgLy8gcXVhbGl0YXRpdmVcbiAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgIEFjY2VudDogWycjN2ZjOTdmJywgJyNiZWFlZDQnLCAnI2ZkYzA4NicsICcjZmZmZjk5JywgJyMzODZjYjAnLCAnI2YwMDI3ZicsICcjYmY1YjE3JywgJyM2NjY2NjYnXSxcbiAgICBTZXQxOiBbJyNlNDFhMWMnLCAnIzM3N2ViOCcsICcjNGRhZjRhJywgJyM5ODRlYTMnLCAnI2ZmN2YwMCcsICcjZmZmZjMzJywgJyNhNjU2MjgnLCAnI2Y3ODFiZicsICcjOTk5OTk5J10sXG4gICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgIERhcmsyOiBbJyMxYjllNzcnLCAnI2Q5NWYwMicsICcjNzU3MGIzJywgJyNlNzI5OGEnLCAnIzY2YTYxZScsICcjZTZhYjAyJywgJyNhNjc2MWQnLCAnIzY2NjY2NiddLFxuICAgIFBhaXJlZDogWycjYTZjZWUzJywgJyMxZjc4YjQnLCAnI2IyZGY4YScsICcjMzNhMDJjJywgJyNmYjlhOTknLCAnI2UzMWExYycsICcjZmRiZjZmJywgJyNmZjdmMDAnLCAnI2NhYjJkNicsICcjNmEzZDlhJywgJyNmZmZmOTknLCAnI2IxNTkyOCddLFxuICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgUGFzdGVsMTogWycjZmJiNGFlJywgJyNiM2NkZTMnLCAnI2NjZWJjNScsICcjZGVjYmU0JywgJyNmZWQ5YTYnLCAnI2ZmZmZjYycsICcjZTVkOGJkJywgJyNmZGRhZWMnLCAnI2YyZjJmMiddXG4gIH07IC8vIGFkZCBsb3dlcmNhc2UgYWxpYXNlcyBmb3IgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGVzXG5cbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gT2JqZWN0LmtleXMoY29sb3JicmV3ZXIpOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgIHZhciBrZXkgPSBsaXN0JDFbaSQxXTtcbiAgICBjb2xvcmJyZXdlcltrZXkudG9Mb3dlckNhc2UoKV0gPSBjb2xvcmJyZXdlcltrZXldO1xuICB9XG5cbiAgdmFyIGNvbG9yYnJld2VyXzEgPSBjb2xvcmJyZXdlcjsgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAvLyBhIHNtYWxsZXIgY2hyb21hLmpzIGJ1aWx0XG4gIC8vIGlvIC0tPiBjb252ZXJ0IGNvbG9yc1xuICAvLyBvcGVyYXRvcnMgLS0+IG1vZGlmeSBleGlzdGluZyBDb2xvcnNcbiAgLy8gaW50ZXJwb2xhdG9yc1xuICAvLyBnZW5lcmF0b3JzIC0tID4gY3JlYXRlIG5ldyBjb2xvcnNcblxuICBjaHJvbWFfMS5hdmVyYWdlID0gYXZlcmFnZTtcbiAgY2hyb21hXzEuYmV6aWVyID0gYmV6aWVyXzE7XG4gIGNocm9tYV8xLmJsZW5kID0gYmxlbmRfMTtcbiAgY2hyb21hXzEuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuICBjaHJvbWFfMS5taXggPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZSA9IG1peDtcbiAgY2hyb21hXzEucmFuZG9tID0gcmFuZG9tXzE7XG4gIGNocm9tYV8xLnNjYWxlID0gc2NhbGU7IC8vIG90aGVyIHV0aWxpdHkgbWV0aG9kc1xuXG4gIGNocm9tYV8xLmFuYWx5emUgPSBhbmFseXplXzEuYW5hbHl6ZTtcbiAgY2hyb21hXzEuY29udHJhc3QgPSBjb250cmFzdDtcbiAgY2hyb21hXzEuZGVsdGFFID0gZGVsdGFFO1xuICBjaHJvbWFfMS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICBjaHJvbWFfMS5saW1pdHMgPSBhbmFseXplXzEubGltaXRzO1xuICBjaHJvbWFfMS52YWxpZCA9IHZhbGlkOyAvLyBzY2FsZVxuXG4gIGNocm9tYV8xLnNjYWxlcyA9IHNjYWxlczsgLy8gY29sb3JzXG5cbiAgY2hyb21hXzEuY29sb3JzID0gdzNjeDExXzE7XG4gIGNocm9tYV8xLmJyZXdlciA9IGNvbG9yYnJld2VyXzE7XG4gIHZhciBjaHJvbWFfanMgPSBjaHJvbWFfMTtcbiAgcmV0dXJuIGNocm9tYV9qcztcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3873\n")},5087:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n\n\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n\n\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n\n\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n\n\n  var assign;\n\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n\n\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n\n      i++;\n    }\n\n    return dest;\n  }, 'extend', 'Use `assign`.');\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n\n\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n\n\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n\n    return val;\n  }\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n\n\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n\n\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n\n\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n\n\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n\n\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n\n        i++;\n      }\n\n      return -1;\n    }\n  }\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n\n\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n\n\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n\n      if (prop in obj) {\n        return prop;\n      }\n\n      i++;\n    }\n\n    return undefined;\n  }\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n\n\n  var _uniqueId = 1;\n\n  function uniqueId() {\n    return _uniqueId++;\n  }\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n\n\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function handler() {},\n\n    /**\n     * bind the events\n     */\n    init: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n\n    return new Type(manager, inputHandler);\n  }\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n\n\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    } // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n\n\n    input.eventType = eventType; // compute scale, rotation etc\n\n    computeInputData(manager, input); // emit secret event\n\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n\n\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    } // to compute scale and rotation we need to store the multiple touches\n\n\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input); // find the correct target\n\n    var target = manager.element;\n\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n\n\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity,\n        velocityX,\n        velocityY,\n        direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n\n\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n\n\n  function getCenter(pointers) {\n    var pointersLength = pointers.length; // no need to loop when only one touch\n\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n\n    var x = 0,\n        y = 0,\n        i = 0;\n\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n\n\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n\n\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n\n\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n\n\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n\n\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n\n\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      } // mouse must be down\n\n\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  }; // in IE10 the pointer types is defined as an enum\n\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n\n\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n      if (storeIndex < 0) {\n        return;\n      } // update the event in the store\n\n\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target; // get target touches from touches\n\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    }); // collect touches\n\n    if (type === INPUT_START) {\n      i = 0;\n\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n    i = 0;\n\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      } // cleanup removed touches\n\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n\n      i++;\n    }\n\n    if (!changedTargetTouches.length) {\n      return;\n    }\n\n    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n        y = eventData.srcEvent.clientY;\n\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n          dy = Math.abs(y - t.y);\n\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value\n\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n\n      this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    } // pan-x OR pan-y\n\n\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    } // manipulation\n\n\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n  }\n\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n\n\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function set(options) {\n      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function emit(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      } // 'panstart' and 'panmove'\n\n\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      } // panend and pancancel\n\n\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      } // it's failing anyway\n\n\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function canEmit() {\n      var i = 0;\n\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n\n        i++;\n      }\n\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      } // reset when we've reached the end\n\n\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n      // so trigger an event\n\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function process(inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function getTouchAction() {},\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function reset() {}\n  };\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n\n    return '';\n  }\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n\n\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n\n    return '';\n  }\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n\n\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n\n    return otherRecognizer;\n  }\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n\n\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n\n        return state | STATE_CHANGED;\n      }\n\n      return STATE_FAILED;\n    }\n  });\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function getTouchAction() {\n      var direction = this.options.direction;\n      var actions = [];\n\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n\n      return actions;\n    },\n    directionTest: function directionTest(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY; // lock to axis?\n\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function emit(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input; // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      } // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input; // if tap count matches we have recognized it,\n        // else it has began recognizing...\n\n        var tapCount = this.count % options.taps;\n\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n\n      return STATE_FAILED;\n    },\n    failTimeout: function failTimeout() {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n  /**\n   * @const {string}\n   */\n\n\n  Hammer.VERSION = '2.0.7';\n  /**\n   * default settings\n   * @namespace\n   */\n\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function set(options) {\n      assign(this.options, options); // Options that need a little more setup\n\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      } // run the touch-action polyfill\n\n\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n\n      while (i < recognizers.length) {\n        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer == curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n\n\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      } // remove existing\n\n\n      var existing = this.get(recognizer.options.event);\n\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function on(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function off(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      } // no handlers, so skip it all\n\n\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function destroy() {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n\n    if (!element.style) {\n      return;\n    }\n\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  }); // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n  freeGlobal.Hammer = Hammer;\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, document, 'Hammer');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanM/ZWJmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFNBQVM7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLFVBQVU7QUFDcko7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDs7QUFFQSxvR0FBb0c7O0FBRXBHOztBQUVBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxtQ0FBTztBQUNYO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sR0FBRyxNQUFNLEVBSU47QUFDSCxDQUFDIiwiZmlsZSI6IjUwODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgSGFtbWVyLkpTIC0gdjIuMC43IC0gMjAxNi0wNC0yMlxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9yaWsgVGFuZ2VsZGVyO1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xuICB2YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICB2YXIgbm93ID0gRGF0ZS5ub3c7XG4gIC8qKlxuICAgKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICAgKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAgICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcblxuICAgICAgaWYgKGxvZykge1xuICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgdmFyIGFzc2lnbjtcblxuICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuICB9XG4gIC8qKlxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgKi9cblxuXG4gIHZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKCFtZXJnZSB8fCBtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcbiAgLyoqXG4gICAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gICAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgKi9cblxuICB2YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xuICB9LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuICAvKipcbiAgICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICAgKi9cblxuICBmdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgIGNoaWxkUDtcbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICAgKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKlxuICAgKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0geyp9IHZhbDFcbiAgICogQHBhcmFtIHsqfSB2YWwyXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gdmFsMSA9PT0gdW5kZWZpbmVkID8gdmFsMiA6IHZhbDE7XG4gIH1cbiAgLyoqXG4gICAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG5cblxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQG1ldGhvZCBoYXNQYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9XG4gIC8qKlxuICAgKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAgICovXG5cblxuICBmdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgfVxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCB8fCAhZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9XG4gIC8qKlxuICAgKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gICAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcblxuICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBpZiAoIWtleSkge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgIHByb3AgPSBwcmVmaXggPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogZ2V0IGEgdW5pcXVlIGlkXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gICAqL1xuXG5cbiAgdmFyIF91bmlxdWVJZCA9IDE7XG5cbiAgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIF91bmlxdWVJZCsrO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xuICB9XG5cbiAgdmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcbiAgdmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbiAgdmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xuICB2YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbiAgdmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xuICB2YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcbiAgdmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcbiAgdmFyIElOUFVUX1NUQVJUID0gMTtcbiAgdmFyIElOUFVUX01PVkUgPSAyO1xuICB2YXIgSU5QVVRfRU5EID0gNDtcbiAgdmFyIElOUFVUX0NBTkNFTCA9IDg7XG4gIHZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG4gIHZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG4gIHZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xuICB2YXIgRElSRUNUSU9OX1VQID0gODtcbiAgdmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG4gIHZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xuICB2YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG4gIHZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG4gIHZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG4gIHZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDsgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIElucHV0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgdmFyIFR5cGU7XG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSBldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9IC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG5cblxuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTsgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG5cbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTsgLy8gZW1pdCBzZWNyZXQgZXZlbnRcblxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcblxuXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBpbnB1dC5wb2ludGVycy5sZW5ndGggPiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzO1xuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7IC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG5cbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG5cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgIHk6IGNlbnRlci55XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xuICB9XG4gIC8qKlxuICAgKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LFxuICAgICAgICB2ZWxvY2l0eVgsXG4gICAgICAgIHZlbG9jaXR5WSxcbiAgICAgICAgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgIHZlbG9jaXR5ID0gYWJzKHYueCkgPiBhYnModi55KSA/IHYueCA6IHYueTtcbiAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG5cbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cblxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9XG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDFcbiAgICogQHBhcmFtIHtPYmplY3R9IHAyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cblxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAgICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuXG4gIHZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXG4gIH07XG4gIHZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xuICB2YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG4gIC8qKlxuICAgKiBNb3VzZSBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICB9IC8vIG1vdXNlIG11c3QgYmUgZG93blxuXG5cbiAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbiAgfTsgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cblxuICB2YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG5cbiAgfTtcbiAgdmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJzsgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5cbiAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgfVxuICAvKipcbiAgICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdG9yZSA9IHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgfVxuXG4gIGluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG4gICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuICAgICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIOyAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuXG4gICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpOyAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG5cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgfSAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcblxuXG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuXG5cbiAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG4gIHZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gIC8qKlxuICAgKiBUb3VjaCBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG5cbiAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTsgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAgICovXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbiAgfVxuXG4gIHZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuICB2YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gIC8qKlxuICAgKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7IC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDsgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7IC8vIGNvbGxlY3QgdG91Y2hlc1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcblxuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgIH0gLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcblxuXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG4gIH1cbiAgLyoqXG4gICAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICAgKlxuICAgKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAgICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG5cblxuICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gIHZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG4gIGZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbiAgfVxuXG4gIGluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0U7XG5cbiAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcblxuXG4gICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICB2YXIgbGFzdFRvdWNoID0ge1xuICAgICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgICB5OiB0b3VjaC5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcblxuICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uIHJlbW92ZUxhc3RUb3VjaCgpIHtcbiAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLFxuICAgICAgICB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLFxuICAgICAgICAgIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG5cbiAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbiAgdmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDsgLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxuXG4gIHZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbiAgdmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xuICB2YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcblxuICB2YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbiAgdmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG4gIC8qKlxuICAgKiBUb3VjaCBBY3Rpb25cbiAgICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgfVxuXG4gIFRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbiBjb21wdXRlKCkge1xuICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247IC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuXG4gICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTm9uZSB8fCBoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMIHx8IGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbiBwcmV2ZW50U3JjKHNyY0V2ZW50KSB7XG4gICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAgICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAgICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gICAqXG4gICAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAgICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAgICpcbiAgICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICAgKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICAgKlxuICAgKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gICAqICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICAgKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gICAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gICAqL1xuXG5cbiAgdmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbiAgdmFyIFNUQVRFX0JFR0FOID0gMjtcbiAgdmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xuICB2YXIgU1RBVEVfRU5ERUQgPSA4O1xuICB2YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuICB2YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG4gIHZhciBTVEFURV9GQUlMRUQgPSAzMjtcbiAgLyoqXG4gICAqIFJlY29nbml6ZXJcbiAgICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsOyAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG5cbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICB9XG5cbiAgUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuXG4gICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbiByZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24gZHJvcFJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbiByZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24gZHJvcFJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG5cbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uIGhhc1JlcXVpcmVGYWlsdXJlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24gY2FuUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgfSAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcblxuXG4gICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICB9XG5cbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7XG4gICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICB9IC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG5cblxuICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24gdHJ5RW1pdChpbnB1dCkge1xuICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgfSAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG5cblxuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRW1pdDogZnVuY3Rpb24gY2FuRW1pdCgpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTsgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG5cbiAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG5cblxuICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTsgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXREYXRhKSB7fSxcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7fVxuICB9O1xuICAvKipcbiAgICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gICAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICAgKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcblxuICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcbiAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTsgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuXG4gICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBQYW5cbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbiAgfVxuXG4gIGluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbiBkaXJlY3Rpb25UZXN0KGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZOyAvLyBsb2NrIHRvIGF4aXM/XG5cbiAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHggPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBQaW5jaFxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cblxuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogUHJlc3NcbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgfVxuXG4gIGluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRpbWU6IDI1MSxcbiAgICAgIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcblxuICAgIH0sXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcbiAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cbiAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIFJvdGF0ZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBTd2lwZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiYgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJiBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAgICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gICAqIGEgc2luZ2xlIHRhcC5cbiAgICpcbiAgICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gICAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcblxuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0YXBzOiAxLFxuICAgICAgaW50ZXJ2YWw6IDMwMCxcbiAgICAgIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICB0aW1lOiAyNTAsXG4gICAgICAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgdGhyZXNob2xkOiA5LFxuICAgICAgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuXG4gICAgfSxcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG4gICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH0gLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuXG4gICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsIDogdHJ1ZTtcbiAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuXG4gICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG5cbiAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbiBmYWlsVGltZW91dCgpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cblxuXG4gIEhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcbiAgLyoqXG4gICAqIGRlZmF1bHQgc2V0dGluZ3NcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICBIYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgICAgIGVuYWJsZTogZmFsc2VcbiAgICB9XSwgW1BpbmNoUmVjb2duaXplciwge1xuICAgICAgZW5hYmxlOiBmYWxzZVxuICAgIH0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfSwgWydzd2lwZSddXSwgW1RhcFJlY29nbml6ZXJdLCBbVGFwUmVjb2duaXplciwge1xuICAgICAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICAgICAgdGFwczogMlxuICAgIH0sIFsndGFwJ11dLCBbUHJlc3NSZWNvZ25pemVyXV0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAqL1xuICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICovXG4gICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgKi9cbiAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG4gIH07XG4gIHZhciBTVE9QID0gMTtcbiAgdmFyIEZPUkNFRF9TVE9QID0gMjtcbiAgLyoqXG4gICAqIE1hbmFnZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcChmb3JjZSkge1xuICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG4gICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuXG4gICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuXG4gICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07IC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgICAgLy8gM1xuICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICB9IC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuXG5cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChyZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSAvLyByZW1vdmUgZXhpc3RpbmdcblxuXG4gICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuXG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgfSAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcblxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuXG4gICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCAnJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiB0cmlnZ2VyIGRvbSBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG5cblxuICBmdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbiAgfVxuXG4gIGFzc2lnbihIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxuICB9KTsgLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbiAgLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG5cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG4gIH1cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5087\n")},5438:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("var $ = __webpack_require__(2109);\n\n// eslint-disable-next-line es/no-math-hypot -- required for testing\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.es/ecma262/#sec-math.hypot\n$({ target: 'Math', stat: true, forced: BUGGY }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  hypot: function hypot(value1, value2) {\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qcz80MDU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFFBQVEsbUJBQU8sQ0FBQyxJQUFxQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNTQzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC1oeXBvdCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyICRoeXBvdCA9IE1hdGguaHlwb3Q7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLy8gQ2hyb21lIDc3IGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTU0NlxudmFyIEJVR0dZID0gISEkaHlwb3QgJiYgJGh5cG90KEluZmluaXR5LCBOYU4pICE9PSBJbmZpbml0eTtcblxuLy8gYE1hdGguaHlwb3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLmh5cG90XG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogQlVHR1kgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIHNxcnQoc3VtKTtcbiAgfVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5438\n")},2767:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": function() { return /* binding */ cejst; }\n});\n\n// NAMESPACE OBJECT: ./src/components/mapLegend.module.scss\nvar mapLegend_module_namespaceObject = {};\n__webpack_require__.r(mapLegend_module_namespaceObject);\n__webpack_require__.d(mapLegend_module_namespaceObject, {\n  "Ww": function() { return colorSwatch; },\n  "nm": function() { return legendContainer; },\n  "oI": function() { return legendItem; },\n  "KW": function() { return nonPrioritized; },\n  "ah": function() { return prioritized; },\n  "VV": function() { return swatchContainer; },\n  "Lj": function() { return threshold; }\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./src/components/layout.tsx + 7 modules\nvar layout = __webpack_require__(1857);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__(7329);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction defineProperty_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(5697);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\nvar unsupportedIterableToArray = __webpack_require__(2961);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction slicedToArray_slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || (0,unsupportedIterableToArray/* default */.Z)(arr, i) || _nonIterableRest();\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.math.hypot.js\nvar es_math_hypot = __webpack_require__(5438);\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js\n\n\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== \'undefined\' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\r\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec4.js\n\n\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(4);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4\'s after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4\'s\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4\'s\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction vec4_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4\'s\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {ReadonlyVec4} result the receiving vector\r\n * @param {ReadonlyVec4} U the first vector\r\n * @param {ReadonlyVec4} V the second vector\r\n * @param {ReadonlyVec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec4\'s\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec4_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\nvar sub = (/* unused pure expression or super */ null && (subtract));\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nvar mul = (/* unused pure expression or super */ null && (multiply));\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nvar div = (/* unused pure expression or super */ null && (divide));\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nvar dist = (/* unused pure expression or super */ null && (distance));\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nvar sqrDist = (/* unused pure expression or super */ null && (squaredDistance));\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nvar len = (/* unused pure expression or super */ null && (vec4_length));\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = (/* unused pure expression or super */ null && (squaredLength));\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/math-utils.js\n\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction transformVector(matrix, vector) {\n  var result = transformMat4([], vector, matrix);\n  scale(result, result, 1 / result[3]);\n  return result;\n}\nfunction mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction math_utils_lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\n\nfunction ieLog2(x) {\n  return Math.log(x) * Math.LOG2E;\n}\n\nvar log2 = Math.log2 || ieLog2;\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat4.js\n\n\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\n\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nfunction mat4_create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nfunction mat4_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\n\nfunction mat4_fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\nfunction mat4_scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {ReadonlyQuat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\nfunction perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {ReadonlyMat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nfunction mat4_str(a) {\n  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";\n}\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\r\n * Adds two mat4\'s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction mat4_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix\'s elements by\r\n * @returns {mat4} out\r\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\r\n * Adds two mat4\'s after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @param {Number} scale the amount to scale b\'s elements by before adding\r\n * @returns {mat4} out\r\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction mat4_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nfunction mat4_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\n\nvar mat4_mul = (/* unused pure expression or super */ null && (mat4_multiply));\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\n\nvar mat4_sub = (/* unused pure expression or super */ null && (mat4_subtract));\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec2.js\n\n\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction vec2_create() {\n  var out = new ARRAY_TYPE(2);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction vec2_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction vec2_fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the source vector\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Adds two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\r\n * Multiplies two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\r\n * Divides two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to floor\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to round\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\r\n * Adds two vec2\'s after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec2\'s\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction vec2_distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec2\'s\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction vec2_squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction vec2_length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction vec2_squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to negate\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to invert\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec2\'s\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction vec2_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\r\n * Computes the cross product of two vec2\'s\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec2_cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec2\'s\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly \'1\'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly \'0\'\r\n * 4th vector component is implicitly \'1\'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {ReadonlyVec2} a The vec2 point to rotate\r\n * @param {ReadonlyVec2} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {ReadonlyVec2} a The first operand\r\n * @param {ReadonlyVec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec2 to zero\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @returns {vec2} out\r\n */\n\nfunction vec2_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction vec2_str(a) {\n  return "vec2(" + a[0] + ", " + a[1] + ")";\n}\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec2_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec2_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\n\nvar vec2_len = (/* unused pure expression or super */ null && (vec2_length));\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\n\nvar vec2_sub = vec2_subtract;\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\n\nvar vec2_mul = (/* unused pure expression or super */ null && (vec2_multiply));\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\n\nvar vec2_div = (/* unused pure expression or super */ null && (vec2_divide));\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\n\nvar vec2_dist = (/* unused pure expression or super */ null && (vec2_distance));\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\n\nvar vec2_sqrDist = (/* unused pure expression or super */ null && (vec2_squaredDistance));\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\n\nvar vec2_sqrLen = (/* unused pure expression or super */ null && (vec2_squaredLength));\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar vec2_forEach = function () {\n  var vec = vec2_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js\n\n\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction vec3_create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction vec3_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction vec3_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction vec3_fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3\'s after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3\'s\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction vec3_distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3\'s\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction vec3_squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction vec3_squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3\'s\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction vec3_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3\'s\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly \'1\'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction vec3_angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && vec3_dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nfunction vec3_zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction vec3_str(a) {\n  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec3_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction vec3_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nvar vec3_sub = (/* unused pure expression or super */ null && (vec3_subtract));\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nvar vec3_mul = vec3_multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nvar vec3_div = (/* unused pure expression or super */ null && (vec3_divide));\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nvar vec3_dist = (/* unused pure expression or super */ null && (vec3_distance));\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nvar vec3_sqrDist = (/* unused pure expression or super */ null && (vec3_squaredDistance));\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nvar vec3_len = (/* unused pure expression or super */ null && (vec3_length));\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nvar vec3_sqrLen = (/* unused pure expression or super */ null && (vec3_squaredLength));\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar vec3_forEach = function () {\n  var vec = vec3_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/assert.js\nfunction assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \'@math.gl/web-mercator: assertion failed.\');\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js\n\n\n\n\n\n\nvar PI = Math.PI;\nvar PI_4 = PI / 4;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nvar TILE_SIZE = 512;\nvar EARTH_CIRCUMFERENCE = 40.03e6;\nvar DEFAULT_ALTITUDE = 1.5;\nfunction zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nfunction scaleToZoom(scale) {\n  return log2(scale);\n}\nfunction lngLatToWorld(_ref) {\n  var _ref2 = slicedToArray_slicedToArray(_ref, 2),\n      lng = _ref2[0],\n      lat = _ref2[1];\n\n  assert_assert(Number.isFinite(lng));\n  assert_assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, \'invalid latitude\');\n  var lambda2 = lng * DEGREES_TO_RADIANS;\n  var phi2 = lat * DEGREES_TO_RADIANS;\n  var x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  var y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nfunction worldToLngLat(_ref3) {\n  var _ref4 = slicedToArray_slicedToArray(_ref3, 2),\n      x = _ref4[0],\n      y = _ref4[1];\n\n  var lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  var phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nfunction getMeterZoom(_ref5) {\n  var latitude = _ref5.latitude;\n  assert(Number.isFinite(latitude));\n  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nfunction getDistanceScales(_ref6) {\n  var latitude = _ref6.latitude,\n      longitude = _ref6.longitude,\n      _ref6$highPrecision = _ref6.highPrecision,\n      highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;\n  assert_assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  var result = {};\n  var worldSize = TILE_SIZE;\n  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  var unitsPerDegreeX = worldSize / 360;\n  var unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  var altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  result.unitsPerMeter = [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter];\n  result.metersPerUnit = [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter];\n  result.unitsPerDegree = [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter];\n  result.degreesPerUnit = [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter];\n\n  if (highPrecision) {\n    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    var unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    var altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    var altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n\n  return result;\n}\nfunction addMetersToLngLat(lngLatZ, xyz) {\n  var _lngLatZ = _slicedToArray(lngLatZ, 3),\n      longitude = _lngLatZ[0],\n      latitude = _lngLatZ[1],\n      z0 = _lngLatZ[2];\n\n  var _xyz = _slicedToArray(xyz, 3),\n      x = _xyz[0],\n      y = _xyz[1],\n      z = _xyz[2];\n\n  var _getDistanceScales = getDistanceScales({\n    longitude: longitude,\n    latitude: latitude,\n    highPrecision: true\n  }),\n      unitsPerMeter = _getDistanceScales.unitsPerMeter,\n      unitsPerMeter2 = _getDistanceScales.unitsPerMeter2;\n\n  var worldspace = lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  var newLngLat = worldToLngLat(worldspace);\n  var newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nfunction getViewMatrix(_ref7) {\n  var height = _ref7.height,\n      pitch = _ref7.pitch,\n      bearing = _ref7.bearing,\n      altitude = _ref7.altitude,\n      scale = _ref7.scale,\n      _ref7$center = _ref7.center,\n      center = _ref7$center === void 0 ? null : _ref7$center;\n  var vm = createMat4();\n  translate(vm, vm, [0, 0, -altitude]);\n  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n  scale /= height;\n  mat4_scale(vm, vm, [scale, scale, scale]);\n\n  if (center) {\n    translate(vm, vm, vec3_negate([], center));\n  }\n\n  return vm;\n}\nfunction getProjectionParameters(_ref8) {\n  var width = _ref8.width,\n      height = _ref8.height,\n      _ref8$fovy = _ref8.fovy,\n      fovy = _ref8$fovy === void 0 ? altitudeToFovy(DEFAULT_ALTITUDE) : _ref8$fovy,\n      altitude = _ref8.altitude,\n      _ref8$pitch = _ref8.pitch,\n      pitch = _ref8$pitch === void 0 ? 0 : _ref8$pitch,\n      _ref8$nearZMultiplier = _ref8.nearZMultiplier,\n      nearZMultiplier = _ref8$nearZMultiplier === void 0 ? 1 : _ref8$nearZMultiplier,\n      _ref8$farZMultiplier = _ref8.farZMultiplier,\n      farZMultiplier = _ref8$farZMultiplier === void 0 ? 1 : _ref8$farZMultiplier;\n\n  if (altitude !== undefined) {\n    fovy = altitudeToFovy(altitude);\n  }\n\n  var halfFov = 0.5 * fovy * DEGREES_TO_RADIANS;\n  var focalDistance = fovyToAltitude(fovy);\n  var pitchRadians = pitch * DEGREES_TO_RADIANS;\n  var topHalfSurfaceDistance = Math.sin(halfFov) * focalDistance / Math.sin(Math.min(Math.max(Math.PI / 2 - pitchRadians - halfFov, 0.01), Math.PI - 0.01));\n  var farZ = Math.sin(pitchRadians) * topHalfSurfaceDistance + focalDistance;\n  return {\n    fov: 2 * halfFov,\n    aspect: width / height,\n    focalDistance: focalDistance,\n    near: nearZMultiplier,\n    far: farZ * farZMultiplier\n  };\n}\nfunction getProjectionMatrix(_ref9) {\n  var width = _ref9.width,\n      height = _ref9.height,\n      pitch = _ref9.pitch,\n      altitude = _ref9.altitude,\n      fovy = _ref9.fovy,\n      nearZMultiplier = _ref9.nearZMultiplier,\n      farZMultiplier = _ref9.farZMultiplier;\n\n  var _getProjectionParamet = getProjectionParameters({\n    width: width,\n    height: height,\n    altitude: altitude,\n    fovy: fovy,\n    pitch: pitch,\n    nearZMultiplier: nearZMultiplier,\n    farZMultiplier: farZMultiplier\n  }),\n      fov = _getProjectionParamet.fov,\n      aspect = _getProjectionParamet.aspect,\n      near = _getProjectionParamet.near,\n      far = _getProjectionParamet.far;\n\n  var projectionMatrix = perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nfunction altitudeToFovy(altitude) {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\nfunction fovyToAltitude(fovy) {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\nfunction worldToPixels(xyz, pixelProjectionMatrix) {\n  var _xyz2 = slicedToArray_slicedToArray(xyz, 3),\n      x = _xyz2[0],\n      y = _xyz2[1],\n      _xyz2$ = _xyz2[2],\n      z = _xyz2$ === void 0 ? 0 : _xyz2$;\n\n  assert_assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nfunction pixelsToWorld(xyz, pixelUnprojectionMatrix) {\n  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  var _xyz3 = slicedToArray_slicedToArray(xyz, 3),\n      x = _xyz3[0],\n      y = _xyz3[1],\n      z = _xyz3[2];\n\n  assert_assert(Number.isFinite(x) && Number.isFinite(y), \'invalid pixel coordinate\');\n\n  if (Number.isFinite(z)) {\n    var coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  var coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  var coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  var z0 = coord0[2];\n  var z1 = coord1[2];\n  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2_lerp([], coord0, coord1, t);\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js\n\n\n\n\nfunction fit_bounds_fitBounds(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      bounds = _ref.bounds,\n      _ref$minExtent = _ref.minExtent,\n      minExtent = _ref$minExtent === void 0 ? 0 : _ref$minExtent,\n      _ref$maxZoom = _ref.maxZoom,\n      maxZoom = _ref$maxZoom === void 0 ? 24 : _ref$maxZoom,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;\n\n  var _bounds = slicedToArray_slicedToArray(bounds, 2),\n      _bounds$ = slicedToArray_slicedToArray(_bounds[0], 2),\n      west = _bounds$[0],\n      south = _bounds$[1],\n      _bounds$2 = slicedToArray_slicedToArray(_bounds[1], 2),\n      east = _bounds$2[0],\n      north = _bounds$2[1];\n\n  if (Number.isFinite(padding)) {\n    var p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    assert_assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  }\n\n  var viewport = new WebMercatorViewport({\n    width: width,\n    height: height,\n    longitude: 0,\n    latitude: 0,\n    zoom: 0\n  });\n  var nw = viewport.project([west, north]);\n  var se = viewport.project([east, south]);\n  var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert_assert(targetSize[0] > 0 && targetSize[1] > 0);\n  var scaleX = targetSize[0] / size[0];\n  var scaleY = targetSize[1] / size[1];\n  var offsetX = (padding.right - padding.left) / 2 / scaleX;\n  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  var centerLngLat = viewport.unproject(center);\n  var zoom = Math.min(maxZoom, viewport.zoom + log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert_assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom: zoom\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js\n\n\n\nvar get_bounds_DEGREES_TO_RADIANS = Math.PI / 180;\nfunction getBounds(viewport) {\n  var z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var width = viewport.width,\n      height = viewport.height,\n      unproject = viewport.unproject;\n  var unprojectOps = {\n    targetZ: z\n  };\n  var bottomLeft = unproject([0, height], unprojectOps);\n  var bottomRight = unproject([width, height], unprojectOps);\n  var topLeft;\n  var topRight;\n  var halfFov = viewport.fovy ? 0.5 * viewport.fovy * get_bounds_DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);\n  var angleToGround = (90 - viewport.pitch) * get_bounds_DEGREES_TO_RADIANS;\n\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  var pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  var coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  var coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  var z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  var t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  var coord = vec2_lerp([], coord0, coord1, t);\n  var result = worldToLngLat(coord);\n  result[2] = targetZ;\n  return result;\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js\n\n\n\n\n\n\n\n\n\n\n\n\nvar WebMercatorViewport = /*#__PURE__*/function () {\n  function WebMercatorViewport() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    },\n        width = _ref.width,\n        height = _ref.height,\n        _ref$latitude = _ref.latitude,\n        latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,\n        _ref$longitude = _ref.longitude,\n        longitude = _ref$longitude === void 0 ? 0 : _ref$longitude,\n        _ref$zoom = _ref.zoom,\n        zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? null : _ref$altitude,\n        _ref$fovy = _ref.fovy,\n        fovy = _ref$fovy === void 0 ? null : _ref$fovy,\n        _ref$position = _ref.position,\n        position = _ref$position === void 0 ? null : _ref$position,\n        _ref$nearZMultiplier = _ref.nearZMultiplier,\n        nearZMultiplier = _ref$nearZMultiplier === void 0 ? 0.02 : _ref$nearZMultiplier,\n        _ref$farZMultiplier = _ref.farZMultiplier,\n        farZMultiplier = _ref$farZMultiplier === void 0 ? 1.01 : _ref$farZMultiplier;\n\n    _classCallCheck(this, WebMercatorViewport);\n\n    width = width || 1;\n    height = height || 1;\n\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    var scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    var distanceScales = getDistanceScales({\n      longitude: longitude,\n      latitude: latitude\n    });\n    var center = lngLatToWorld([longitude, latitude]);\n    center[2] = 0;\n\n    if (position) {\n      vec3_add(center, center, vec3_mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width: width,\n      height: height,\n      pitch: pitch,\n      fovy: fovy,\n      nearZMultiplier: nearZMultiplier,\n      farZMultiplier: farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height: height,\n      scale: scale,\n      center: center,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    Object.freeze(this);\n  }\n\n  _createClass(WebMercatorViewport, [{\n    key: "_initMatrices",\n    value: function _initMatrices() {\n      var width = this.width,\n          height = this.height,\n          projectionMatrix = this.projectionMatrix,\n          viewMatrix = this.viewMatrix;\n      var vpm = createMat4();\n      mat4_multiply(vpm, vpm, projectionMatrix);\n      mat4_multiply(vpm, vpm, viewMatrix);\n      this.viewProjectionMatrix = vpm;\n      var m = createMat4();\n      mat4_scale(m, m, [width / 2, -height / 2, 1]);\n      translate(m, m, [1, -1, 0]);\n      mat4_multiply(m, m, vpm);\n      var mInverse = invert(createMat4(), m);\n\n      if (!mInverse) {\n        throw new Error(\'Pixel project matrix not invertible\');\n      }\n\n      this.pixelProjectionMatrix = m;\n      this.pixelUnprojectionMatrix = mInverse;\n    }\n  }, {\n    key: "equals",\n    value: function equals(viewport) {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && mat4_equals(viewport.projectionMatrix, this.projectionMatrix) && mat4_equals(viewport.viewMatrix, this.viewMatrix);\n    }\n  }, {\n    key: "project",\n    value: function project(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$topLeft = _ref2.topLeft,\n          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;\n\n      var worldPosition = this.projectPosition(xyz);\n      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n      var _coord = slicedToArray_slicedToArray(coord, 2),\n          x = _coord[0],\n          y = _coord[1];\n\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    }\n  }, {\n    key: "unproject",\n    value: function unproject(xyz) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$topLeft = _ref3.topLeft,\n          topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,\n          _ref3$targetZ = _ref3.targetZ,\n          targetZ = _ref3$targetZ === void 0 ? undefined : _ref3$targetZ;\n\n      var _xyz = slicedToArray_slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          z = _xyz[2];\n\n      var y2 = topLeft ? y : this.height - y;\n      var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n          _this$unprojectPositi2 = slicedToArray_slicedToArray(_this$unprojectPositi, 3),\n          X = _this$unprojectPositi2[0],\n          Y = _this$unprojectPositi2[1],\n          Z = _this$unprojectPositi2[2];\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: "projectPosition",\n    value: function projectPosition(xyz) {\n      var _lngLatToWorld = lngLatToWorld(xyz),\n          _lngLatToWorld2 = slicedToArray_slicedToArray(_lngLatToWorld, 2),\n          X = _lngLatToWorld2[0],\n          Y = _lngLatToWorld2[1];\n\n      var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: "unprojectPosition",\n    value: function unprojectPosition(xyz) {\n      var _worldToLngLat = worldToLngLat(xyz),\n          _worldToLngLat2 = slicedToArray_slicedToArray(_worldToLngLat, 2),\n          X = _worldToLngLat2[0],\n          Y = _worldToLngLat2[1];\n\n      var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: "projectFlat",\n    value: function projectFlat(lngLat) {\n      return lngLatToWorld(lngLat);\n    }\n  }, {\n    key: "unprojectFlat",\n    value: function unprojectFlat(xy) {\n      return worldToLngLat(xy);\n    }\n  }, {\n    key: "getMapCenterByLngLatPosition",\n    value: function getMapCenterByLngLatPosition(_ref4) {\n      var lngLat = _ref4.lngLat,\n          pos = _ref4.pos;\n      var fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n      var toLocation = lngLatToWorld(lngLat);\n      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));\n      var newCenter = vec2_add([], this.center, translate);\n      return worldToLngLat(newCenter);\n    }\n  }, {\n    key: "getLocationAtPoint",\n    value: function getLocationAtPoint(_ref5) {\n      var lngLat = _ref5.lngLat,\n          pos = _ref5.pos;\n      return this.getMapCenterByLngLatPosition({\n        lngLat: lngLat,\n        pos: pos\n      });\n    }\n  }, {\n    key: "fitBounds",\n    value: function fitBounds(bounds) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var width = this.width,\n          height = this.height;\n\n      var _fitBounds2 = fit_bounds_fitBounds(Object.assign({\n        width: width,\n        height: height,\n        bounds: bounds\n      }, options)),\n          longitude = _fitBounds2.longitude,\n          latitude = _fitBounds2.latitude,\n          zoom = _fitBounds2.zoom;\n\n      return new WebMercatorViewport({\n        width: width,\n        height: height,\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom\n      });\n    }\n  }, {\n    key: "getBounds",\n    value: function getBounds(options) {\n      var corners = this.getBoundingRegion(options);\n      var west = Math.min.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[0];\n      })));\n      var east = Math.max.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[0];\n      })));\n      var south = Math.min.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[1];\n      })));\n      var north = Math.max.apply(Math, (0,toConsumableArray/* default */.Z)(corners.map(function (p) {\n        return p[1];\n      })));\n      return [[west, south], [east, north]];\n    }\n  }, {\n    key: "getBoundingRegion",\n    value: function getBoundingRegion() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return getBounds(this, options.z || 0);\n    }\n  }]);\n\n  return WebMercatorViewport;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js\n\n\nvar MAX_LATITUDE = 85.05113;\nvar MIN_LATITUDE = -85.05113;\nfunction normalizeViewportProps(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      longitude = _ref.longitude,\n      latitude = _ref.latitude,\n      zoom = _ref.zoom,\n      _ref$pitch = _ref.pitch,\n      pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n      _ref$bearing = _ref.bearing,\n      bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;\n\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n\n  var flatViewport = new WebMercatorViewport({\n    width: width,\n    height: height,\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var topY = flatViewport.project([longitude, MAX_LATITUDE])[1];\n  var bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];\n  var shiftY = 0;\n\n  if (bottomY - topY < height) {\n    zoom += log2(height / (bottomY - topY));\n    flatViewport = new WebMercatorViewport({\n      width: width,\n      height: height,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom\n    });\n    topY = flatViewport.project([longitude, MAX_LATITUDE])[1];\n    bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];\n  }\n\n  if (topY > 0) {\n    shiftY = topY;\n  } else if (bottomY < height) {\n    shiftY = bottomY - height;\n  }\n\n  if (shiftY) {\n    latitude = flatViewport.unproject([width / 2, height / 2 + shiftY])[1];\n  }\n\n  return {\n    width: width,\n    height: height,\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom,\n    pitch: pitch,\n    bearing: bearing\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\nvar fly_to_viewport_EPSILON = 0.01;\nvar VIEWPORT_TRANSITION_PROPS = [\'longitude\', \'latitude\', \'zoom\'];\nvar DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nfunction flyToViewport(startProps, endProps, t) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var viewport = {};\n\n  var _getFlyToTransitionPa = getFlyToTransitionParams(startProps, endProps, opts),\n      startZoom = _getFlyToTransitionPa.startZoom,\n      startCenterXY = _getFlyToTransitionPa.startCenterXY,\n      uDelta = _getFlyToTransitionPa.uDelta,\n      w0 = _getFlyToTransitionPa.w0,\n      u1 = _getFlyToTransitionPa.u1,\n      S = _getFlyToTransitionPa.S,\n      rho = _getFlyToTransitionPa.rho,\n      rho2 = _getFlyToTransitionPa.rho2,\n      r0 = _getFlyToTransitionPa.r0;\n\n  if (u1 < fly_to_viewport_EPSILON) {\n    var _iterator = _createForOfIteratorHelper(VIEWPORT_TRANSITION_PROPS),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n        var startValue = startProps[key];\n        var endValue = endProps[key];\n        viewport[key] = math_utils_lerp(startValue, endValue, t);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return viewport;\n  }\n\n  var s = t * S;\n  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  var scaleIncrement = 1 / w;\n  var newZoom = startZoom + scaleToZoom(scaleIncrement);\n  var newCenterWorld = vec2_scale([], uDelta, u);\n  vec2_add(newCenterWorld, newCenterWorld, startCenterXY);\n  var newCenter = worldToLngLat(newCenterWorld);\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\nfunction getFlyToDuration(startProps, endProps) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  var _opts = opts,\n      screenSpeed = _opts.screenSpeed,\n      speed = _opts.speed,\n      maxDuration = _opts.maxDuration;\n\n  var _getFlyToTransitionPa2 = getFlyToTransitionParams(startProps, endProps, opts),\n      S = _getFlyToTransitionPa2.S,\n      rho = _getFlyToTransitionPa2.rho;\n\n  var length = 1000 * S;\n  var duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  var rho = opts.curve;\n  var startZoom = startProps.zoom;\n  var startCenter = [startProps.longitude, startProps.latitude];\n  var startScale = zoomToScale(startZoom);\n  var endZoom = endProps.zoom;\n  var endCenter = [endProps.longitude, endProps.latitude];\n  var scale = zoomToScale(endZoom - startZoom);\n  var startCenterXY = lngLatToWorld(startCenter);\n  var endCenterXY = lngLatToWorld(endCenter);\n  var uDelta = vec2_sub([], endCenterXY, startCenterXY);\n  var w0 = Math.max(startProps.width, startProps.height);\n  var w1 = w0 / scale;\n  var u1 = vec2_length(uDelta) * startScale;\n\n  var _u1 = Math.max(u1, fly_to_viewport_EPSILON);\n\n  var rho2 = rho * rho;\n  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  var S = (r1 - r0) / rho;\n  return {\n    startZoom: startZoom,\n    startCenterXY: startCenterXY,\n    uDelta: uDelta,\n    w0: w0,\n    u1: u1,\n    S: S,\n    rho: rho,\n    rho2: rho2,\n    r0: r0,\n    r1: r1\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/viewport-mercator-project/module.js\n\n\n;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = function () {\n  if (typeof Map !== \'undefined\') {\n    return Map;\n  }\n  /**\r\n   * Returns index in provided array that matches the specified key.\r\n   *\r\n   * @param {Array<Array>} arr\r\n   * @param {*} key\r\n   * @returns {number}\r\n   */\n\n\n  function getIndex(arr, key) {\n    var result = -1;\n    arr.some(function (entry, index) {\n      if (entry[0] === key) {\n        result = index;\n        return true;\n      }\n\n      return false;\n    });\n    return result;\n  }\n\n  return (\n    /** @class */\n    function () {\n      function class_1() {\n        this.__entries__ = [];\n      }\n\n      Object.defineProperty(class_1.prototype, "size", {\n        /**\r\n         * @returns {boolean}\r\n         */\n        get: function get() {\n          return this.__entries__.length;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      /**\r\n       * @param {*} key\r\n       * @returns {*}\r\n       */\n\n      class_1.prototype.get = function (key) {\n        var index = getIndex(this.__entries__, key);\n        var entry = this.__entries__[index];\n        return entry && entry[1];\n      };\n      /**\r\n       * @param {*} key\r\n       * @param {*} value\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.set = function (key, value) {\n        var index = getIndex(this.__entries__, key);\n\n        if (~index) {\n          this.__entries__[index][1] = value;\n        } else {\n          this.__entries__.push([key, value]);\n        }\n      };\n      /**\r\n       * @param {*} key\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.delete = function (key) {\n        var entries = this.__entries__;\n        var index = getIndex(entries, key);\n\n        if (~index) {\n          entries.splice(index, 1);\n        }\n      };\n      /**\r\n       * @param {*} key\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.has = function (key) {\n        return !!~getIndex(this.__entries__, key);\n      };\n      /**\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.clear = function () {\n        this.__entries__.splice(0);\n      };\n      /**\r\n       * @param {Function} callback\r\n       * @param {*} [ctx=null]\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.forEach = function (callback, ctx) {\n        if (ctx === void 0) {\n          ctx = null;\n        }\n\n        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n          var entry = _a[_i];\n          callback.call(ctx, entry[1], entry[0]);\n        }\n      };\n\n      return class_1;\n    }()\n  );\n}();\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\n\n\nvar isBrowser = typeof window !== \'undefined\' && typeof document !== \'undefined\' && window.document === document; // Returns global object of a current environment.\n\nvar global$1 = function () {\n  if (typeof __webpack_require__.g !== \'undefined\' && __webpack_require__.g.Math === Math) {\n    return __webpack_require__.g;\n  }\n\n  if (typeof self !== \'undefined\' && self.Math === Math) {\n    return self;\n  }\n\n  if (typeof window !== \'undefined\' && window.Math === Math) {\n    return window;\n  } // eslint-disable-next-line no-new-func\n\n\n  return Function(\'return this\')();\n}();\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests\' identifier.\r\n */\n\n\nvar requestAnimationFrame$1 = function () {\n  if (typeof requestAnimationFrame === \'function\') {\n    // It\'s required to use a bounded function because IE sometimes throws\n    // an "Invalid calling object" error if rAF is invoked without the global\n    // object on the left hand side.\n    return requestAnimationFrame.bind(global$1);\n  }\n\n  return function (callback) {\n    return setTimeout(function () {\n      return callback(Date.now());\n    }, 1000 / 60);\n  };\n}(); // Defines minimum timeout before adding a trailing call.\n\n\nvar trailingTimeout = 2;\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\n\nfunction throttle(callback, delay) {\n  var leadingCall = false,\n      trailingCall = false,\n      lastCallTime = 0;\n  /**\r\n   * Invokes the original callback function and schedules new invocation if\r\n   * the "proxy" was called during current request.\r\n   *\r\n   * @returns {void}\r\n   */\n\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  /**\r\n   * Callback invoked after the specified delay. It will further postpone\r\n   * invocation of the original function delegating it to the\r\n   * requestAnimationFrame.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  /**\r\n   * Schedules invocation of the original function.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  function proxy() {\n    var timeStamp = Date.now();\n\n    if (leadingCall) {\n      // Reject immediately following calls.\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      } // Schedule new call to be in invoked when the pending one is resolved.\n      // This is important for "transitions" which never actually start\n      // immediately so there is a chance that we might miss one if change\n      // happens amids the pending invocation.\n\n\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n\n    lastCallTime = timeStamp;\n  }\n\n  return proxy;\n} // Minimum delay before invoking the update of observers.\n\n\nvar REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\n\nvar transitionKeys = [\'top\', \'right\', \'bottom\', \'left\', \'width\', \'height\', \'size\', \'weight\']; // Check if MutationObserver is available.\n\nvar mutationObserverSupported = typeof MutationObserver !== \'undefined\';\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\n\nvar ResizeObserverController =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserverController.\r\n   *\r\n   * @private\r\n   */\n  function ResizeObserverController() {\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.connected_ = false;\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\n\n    this.mutationEventsAdded_ = false;\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\n\n    this.mutationsObserver_ = null;\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\n\n    this.observers_ = [];\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n  }\n  /**\r\n   * Adds observer to observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be added.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n      this.observers_.push(observer);\n    } // Add listeners if they haven\'t been added yet.\n\n\n    if (!this.connected_) {\n      this.connect_();\n    }\n  };\n  /**\r\n   * Removes observer from observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer); // Remove observer if it\'s present in registry.\n\n    if (~index) {\n      observers.splice(index, 1);\n    } // Remove listeners if controller has no connected observers.\n\n\n    if (!observers.length && this.connected_) {\n      this.disconnect_();\n    }\n  };\n  /**\r\n   * Invokes the update of observers. It will continue running updates insofar\r\n   * it detects changes.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n\n    if (changesDetected) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Updates every observer from observers list and notifies them of queued\r\n   * entries.\r\n   *\r\n   * @private\r\n   * @returns {boolean} Returns "true" if any observer has detected changes in\r\n   *      dimensions of it\'s elements.\r\n   */\n\n\n  ResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n      return observer.gatherActive(), observer.hasActive();\n    }); // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n\n    activeObservers.forEach(function (observer) {\n      return observer.broadcastActive();\n    });\n    return activeObservers.length > 0;\n  };\n  /**\r\n   * Initializes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n      return;\n    } // Subscription to the "Transitionend" event is used as a workaround for\n    // delayed transitions. This way it\'s possible to capture at least the\n    // final state of an element.\n\n\n    document.addEventListener(\'transitionend\', this.onTransitionEnd_);\n    window.addEventListener(\'resize\', this.refresh);\n\n    if (mutationObserverSupported) {\n      this.mutationsObserver_ = new MutationObserver(this.refresh);\n      this.mutationsObserver_.observe(document, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    } else {\n      document.addEventListener(\'DOMSubtreeModified\', this.refresh);\n      this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n  };\n  /**\r\n   * Removes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n      return;\n    }\n\n    document.removeEventListener(\'transitionend\', this.onTransitionEnd_);\n    window.removeEventListener(\'resize\', this.refresh);\n\n    if (this.mutationsObserver_) {\n      this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n      document.removeEventListener(\'DOMSubtreeModified\', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n  };\n  /**\r\n   * "Transitionend" event handler.\r\n   *\r\n   * @private\r\n   * @param {TransitionEvent} event\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n    var _b = _a.propertyName,\n        propertyName = _b === void 0 ? \'\' : _b; // Detect whether transition may affect dimensions of an element.\n\n    var isReflowProperty = transitionKeys.some(function (key) {\n      return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Returns instance of the ResizeObserverController.\r\n   *\r\n   * @returns {ResizeObserverController}\r\n   */\n\n\n  ResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n      this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n  };\n  /**\r\n   * Holds reference to the controller\'s instance.\r\n   *\r\n   * @private {ResizeObserverController}\r\n   */\n\n\n  ResizeObserverController.instance_ = null;\n  return ResizeObserverController;\n}();\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\n\n\nvar defineConfigurable = function defineConfigurable(target, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key = _a[_i];\n    Object.defineProperty(target, key, {\n      value: props[key],\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n\n  return target;\n};\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\n\n\nvar getWindowOf = function getWindowOf(target) {\n  // Assume that the element is an instance of Node, which means that it\n  // has the "ownerDocument" property from which we can retrieve a\n  // corresponding global object.\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it\'s not possible extract one from\n  // provided element.\n\n  return ownerGlobal || global$1;\n}; // Placeholder of an empty content rectangle.\n\n\nvar emptyRect = createRectInit(0, 0, 0, 0);\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\n\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\n\n\nfunction getBordersSize(styles) {\n  var positions = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n\n  return positions.reduce(function (size, position) {\n    var value = styles[\'border-\' + position + \'-width\'];\n    return size + toFloat(value);\n  }, 0);\n}\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\n\n\nfunction getPaddings(styles) {\n  var positions = [\'top\', \'right\', \'bottom\', \'left\'];\n  var paddings = {};\n\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles[\'padding-\' + position];\n    paddings[position] = toFloat(value);\n  }\n\n  return paddings;\n}\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getHTMLElementContentRect(target) {\n  // Client width & height properties can\'t be\n  // used exclusively as they provide rounded values.\n  var clientWidth = target.clientWidth,\n      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and\n  // detached elements. Though elements with width & height properties less\n  // than 0.5 will be discarded as well.\n  //\n  // Without it we would need to implement separate methods for each of\n  // those cases and it\'s not possible to perform a precise and performance\n  // effective test for hidden elements. E.g. even jQuery\'s \':visible\' filter\n  // gives wrong results for elements with width & height less than 0.5.\n\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the\n  // only dimensions available to JS that contain non-rounded values. It could\n  // be possible to utilize the getBoundingClientRect if only it\'s data wasn\'t\n  // affected by CSS transformations let alone paddings, borders and scroll bars.\n\n  var width = toFloat(styles.width),\n      height = toFloat(styles.height); // Width & height include paddings and borders when the \'border-box\' box\n  // model is applied (except for IE).\n\n  if (styles.boxSizing === \'border-box\') {\n    // Following conditions are required to handle Internet Explorer which\n    // doesn\'t include paddings and borders to computed CSS dimensions.\n    //\n    // We can say that if CSS dimensions + paddings are equal to the "client"\n    // properties then it\'s either IE, and thus we don\'t need to subtract\n    // anything, or an element merely doesn\'t have paddings/borders styles.\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, \'left\', \'right\') + horizPad;\n    }\n\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, \'top\', \'bottom\') + vertPad;\n    }\n  } // Following steps can\'t be applied to the document\'s root element as its\n  // client[Width/Height] properties represent viewport area of the window.\n  // Besides, it\'s as well not necessary as the <html> itself neither has\n  // rendered scroll bars nor it can be clipped.\n\n\n  if (!isDocumentElement(target)) {\n    // In some browsers (only in Firefox, actually) CSS width & height\n    // include scroll bars size which can be removed at this step as scroll\n    // bars are the only difference between rounded dimensions + paddings\n    // and "client" properties, though that is not always true in Chrome.\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.\n    // E.g. for an element with content width of 314.2px it sometimes gives\n    // the client width of 315px and for the width of 314.7px it may give\n    // 314px. And it doesn\'t happen all the time. So just ignore this delta\n    // as a non-relevant.\n\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\n\n\nvar isSVGGraphicsElement = function () {\n  // Some browsers, namely IE and Edge, don\'t have the SVGGraphicsElement\n  // interface.\n  if (typeof SVGGraphicsElement !== \'undefined\') {\n    return function (target) {\n      return target instanceof getWindowOf(target).SVGGraphicsElement;\n    };\n  } // If it\'s so, then check that element is at least an instance of the\n  // SVGElement and that it has the "getBBox" method.\n  // eslint-disable-next-line no-extra-parens\n\n\n  return function (target) {\n    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === \'function\';\n  };\n}();\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\n\n\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n\n  return getHTMLElementContentRect(target);\n}\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle\'s x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\n\n\nfunction createReadOnlyRect(_a) {\n  var x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n\n  var Constr = typeof DOMRectReadOnly !== \'undefined\' ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype); // Rectangle\'s properties are not writable and non-enumerable.\n\n  defineConfigurable(rect, {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle\'s width.\r\n * @param {number} height - Rectangle\'s height.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction createRectInit(x, y, width, height) {\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n}\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it\'s changes.\r\n */\n\n\nvar ResizeObservation =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of ResizeObservation.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   */\n  function ResizeObservation(target) {\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastWidth = 0;\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.broadcastHeight = 0;\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\n\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n    this.target = target;\n  }\n  /**\r\n   * Updates content rectangle and tells whether it\'s width or height properties\r\n   * have changed since the last broadcast.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  ResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n    this.contentRect_ = rect;\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n  };\n  /**\r\n   * Updates \'broadcastWidth\' and \'broadcastHeight\' properties with a data\r\n   * from the corresponding properties of the last observed content rectangle.\r\n   *\r\n   * @returns {DOMRectInit} Last observed content rectangle.\r\n   */\n\n\n  ResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n    return rect;\n  };\n\n  return ResizeObservation;\n}();\n\nvar ResizeObserverEntry =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of ResizeObserverEntry.\r\n   *\r\n   * @param {Element} target - Element that is being observed.\r\n   * @param {DOMRectInit} rectInit - Data of the element\'s content rectangle.\r\n   */\n  function ResizeObserverEntry(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they\'d require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don\'t support this type of collections.\n\n    defineConfigurable(this, {\n      target: target,\n      contentRect: contentRect\n    });\n  }\n\n  return ResizeObserverEntry;\n}();\n\nvar ResizeObserverSPI =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n   *      when one of the observed elements changes it\'s content dimensions.\r\n   * @param {ResizeObserverController} controller - Controller instance which\r\n   *      is responsible for the updates of observer.\r\n   * @param {ResizeObserver} callbackCtx - Reference to the public\r\n   *      ResizeObserver instance which will be passed to callback function.\r\n   */\n  function ResizeObserverSPI(callback, controller, callbackCtx) {\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\n    this.activeObservations_ = [];\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\n\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== \'function\') {\n      throw new TypeError(\'The callback provided as parameter 1 is not a function.\');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n  }\n  /**\r\n   * Starts observing provided element.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n      throw new TypeError(\'1 argument required, but only 0 present.\');\n    } // Do nothing if current environment doesn\'t have the Element interface.\n\n\n    if (typeof Element === \'undefined\' || !(Element instanceof Object)) {\n      return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError(\'parameter 1 is not of type "Element".\');\n    }\n\n    var observations = this.observations_; // Do nothing if element is already being observed.\n\n    if (observations.has(target)) {\n      return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n    this.controller_.addObserver(this); // Force the update of observations.\n\n    this.controller_.refresh();\n  };\n  /**\r\n   * Stops observing provided element.\r\n   *\r\n   * @param {Element} target - Element to stop observing.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n      throw new TypeError(\'1 argument required, but only 0 present.\');\n    } // Do nothing if current environment doesn\'t have the Element interface.\n\n\n    if (typeof Element === \'undefined\' || !(Element instanceof Object)) {\n      return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError(\'parameter 1 is not of type "Element".\');\n    }\n\n    var observations = this.observations_; // Do nothing if element is not being observed.\n\n    if (!observations.has(target)) {\n      return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n      this.controller_.removeObserver(this);\n    }\n  };\n  /**\r\n   * Stops observing all elements.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n  };\n  /**\r\n   * Collects observation instances the associated element of which has changed\r\n   * it\'s content rectangle.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.gatherActive = function () {\n    var _this = this;\n\n    this.clearActive();\n    this.observations_.forEach(function (observation) {\n      if (observation.isActive()) {\n        _this.activeObservations_.push(observation);\n      }\n    });\n  };\n  /**\r\n   * Invokes initial callback function with a list of ResizeObserverEntry\r\n   * instances collected from active resize observations.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn\'t have active observations.\n    if (!this.hasActive()) {\n      return;\n    }\n\n    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.\n\n    var entries = this.activeObservations_.map(function (observation) {\n      return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n  };\n  /**\r\n   * Clears the collection of active observations.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n  };\n  /**\r\n   * Tells whether observer has active observations.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  ResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n  };\n\n  return ResizeObserverSPI;\n}(); // Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can\'t be fully polyfilled anyway.\n\n\nvar observers = typeof WeakMap !== \'undefined\' ? new WeakMap() : new MapShim();\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\n\nvar ResizeObserver =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n   *      dimensions of the observed elements change.\r\n   */\n  function ResizeObserver(callback) {\n    if (!(this instanceof ResizeObserver)) {\n      throw new TypeError(\'Cannot call a class as a function.\');\n    }\n\n    if (!arguments.length) {\n      throw new TypeError(\'1 argument required, but only 0 present.\');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n    observers.set(this, observer);\n  }\n\n  return ResizeObserver;\n}(); // Expose public methods of ResizeObserver.\n\n\n[\'observe\', \'unobserve\', \'disconnect\'].forEach(function (method) {\n  ResizeObserver.prototype[method] = function () {\n    var _a;\n\n    return (_a = observers.get(this))[method].apply(_a, arguments);\n  };\n});\n\nvar index = function () {\n  // Export existing implementation if available.\n  if (typeof global$1.ResizeObserver !== \'undefined\') {\n    return global$1.ResizeObserver;\n  }\n\n  return ResizeObserver;\n}();\n\n/* harmony default export */ var ResizeObserver_es = (index);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/globals.js\nvar window_ = typeof window !== \'undefined\' ? window : __webpack_require__.g;\nvar global_ = typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : window;\nvar document_ = typeof document !== \'undefined\' ? document : {};\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/style-utils.js\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction style_utils_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = style_utils_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction style_utils_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return style_utils_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return style_utils_arrayLikeToArray(o, minLen);\n}\n\nfunction style_utils_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar refProps = [\'type\', \'source\', \'source-layer\', \'minzoom\', \'maxzoom\', \'filter\', \'layout\'];\nfunction normalizeStyle(style) {\n  if (!style) {\n    return null;\n  }\n\n  if (typeof style === \'string\') {\n    return style;\n  }\n\n  if (style.toJS) {\n    style = style.toJS();\n  }\n\n  var layerIndex = {};\n\n  var _iterator = style_utils_createForOfIteratorHelper(style.layers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      layerIndex[layer.id] = layer;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var layers = style.layers.map(function (layer) {\n    var layerRef = layerIndex[layer.ref];\n    var normalizedLayer = null;\n\n    if (\'interactive\' in layer) {\n      normalizedLayer = _objectSpread({}, layer);\n      delete normalizedLayer.interactive;\n    }\n\n    if (layerRef) {\n      normalizedLayer = normalizedLayer || _objectSpread({}, layer);\n      delete normalizedLayer.ref;\n\n      var _iterator2 = style_utils_createForOfIteratorHelper(refProps),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n\n          if (propName in layerRef) {\n            normalizedLayer[propName] = layerRef[propName];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    return normalizedLayer || layer;\n  });\n  return _objectSpread(_objectSpread({}, style), {}, {\n    layers: layers\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/mapbox/mapbox.js\n\n\n\n\n\n\n\nfunction noop() {}\n\nfunction defaultOnError(event) {\n  if (event) {\n    console.error(event.error);\n  }\n}\n\nvar propTypes = {\n  container: prop_types.object,\n  gl: prop_types.object,\n  mapboxApiAccessToken: prop_types.string,\n  mapboxApiUrl: prop_types.string,\n  attributionControl: prop_types.bool,\n  preserveDrawingBuffer: prop_types.bool,\n  reuseMaps: prop_types.bool,\n  transformRequest: prop_types.func,\n  mapOptions: prop_types.object,\n  mapStyle: prop_types.oneOfType([prop_types.string, prop_types.object]),\n  preventStyleDiffing: prop_types.bool,\n  visible: prop_types.bool,\n  asyncRender: prop_types.bool,\n  onLoad: prop_types.func,\n  onError: prop_types.func,\n  width: prop_types.number,\n  height: prop_types.number,\n  viewState: prop_types.object,\n  longitude: prop_types.number,\n  latitude: prop_types.number,\n  zoom: prop_types.number,\n  bearing: prop_types.number,\n  pitch: prop_types.number,\n  altitude: prop_types.number\n};\nvar defaultProps = {\n  container: document_.body,\n  mapboxApiAccessToken: getAccessToken(),\n  mapboxApiUrl: \'https://api.mapbox.com\',\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  reuseMaps: false,\n  mapOptions: {},\n  mapStyle: \'mapbox://styles/mapbox/light-v8\',\n  preventStyleDiffing: false,\n  visible: true,\n  asyncRender: false,\n  onLoad: noop,\n  onError: defaultOnError,\n  width: 0,\n  height: 0,\n  longitude: 0,\n  latitude: 0,\n  zoom: 0,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5\n};\nfunction getAccessToken() {\n  var accessToken = null;\n\n  if (typeof window !== \'undefined\' && window.location) {\n    var match = window.location.search.match(/access_token=([^&\\/]*)/);\n    accessToken = match && match[1];\n  }\n\n  if (!accessToken && typeof process !== \'undefined\') {\n    accessToken = accessToken || ({}).MapboxAccessToken || ({}).REACT_APP_MAPBOX_ACCESS_TOKEN;\n  }\n\n  return accessToken || \'no-token\';\n}\n\nfunction checkPropTypes(props) {\n  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \'component\';\n\n  if (props.debug) {\n    prop_types.checkPropTypes(propTypes, props, \'prop\', component);\n  }\n}\n\nvar Mapbox = function () {\n  function Mapbox(props) {\n    var _this = this;\n\n    _classCallCheck(this, Mapbox);\n\n    defineProperty_defineProperty(this, "props", defaultProps);\n\n    defineProperty_defineProperty(this, "width", 0);\n\n    defineProperty_defineProperty(this, "height", 0);\n\n    defineProperty_defineProperty(this, "_fireLoadEvent", function () {\n      _this.props.onLoad({\n        type: \'load\',\n        target: _this._map\n      });\n    });\n\n    if (!props.mapboxgl) {\n      throw new Error(\'Mapbox not available\');\n    }\n\n    this.mapboxgl = props.mapboxgl;\n\n    if (!Mapbox.initialized) {\n      Mapbox.initialized = true;\n\n      this._checkStyleSheet(this.mapboxgl.version);\n    }\n\n    this._initialize(props);\n  }\n\n  _createClass(Mapbox, [{\n    key: "finalize",\n    value: function finalize() {\n      this._destroy();\n\n      return this;\n    }\n  }, {\n    key: "setProps",\n    value: function setProps(props) {\n      this._update(this.props, props);\n\n      return this;\n    }\n  }, {\n    key: "redraw",\n    value: function redraw() {\n      var map = this._map;\n\n      if (map.style) {\n        if (map._frame) {\n          map._frame.cancel();\n\n          map._frame = null;\n        }\n\n        map._render();\n      }\n    }\n  }, {\n    key: "getMap",\n    value: function getMap() {\n      return this._map;\n    }\n  }, {\n    key: "_reuse",\n    value: function _reuse(props) {\n      this._map = Mapbox.savedMap;\n\n      var oldContainer = this._map.getContainer();\n\n      var newContainer = props.container;\n      newContainer.classList.add(\'mapboxgl-map\');\n\n      while (oldContainer.childNodes.length > 0) {\n        newContainer.appendChild(oldContainer.childNodes[0]);\n      }\n\n      this._map._container = newContainer;\n      Mapbox.savedMap = null;\n\n      if (props.mapStyle) {\n        this._map.setStyle(normalizeStyle(props.mapStyle), {\n          diff: false\n        });\n      }\n\n      if (this._map.isStyleLoaded()) {\n        this._fireLoadEvent();\n      } else {\n        this._map.once(\'styledata\', this._fireLoadEvent);\n      }\n    }\n  }, {\n    key: "_create",\n    value: function _create(props) {\n      if (props.reuseMaps && Mapbox.savedMap) {\n        this._reuse(props);\n      } else {\n        if (props.gl) {\n          var getContext = HTMLCanvasElement.prototype.getContext;\n\n          HTMLCanvasElement.prototype.getContext = function () {\n            HTMLCanvasElement.prototype.getContext = getContext;\n            return props.gl;\n          };\n        }\n\n        var mapOptions = {\n          container: props.container,\n          center: [0, 0],\n          zoom: 8,\n          pitch: 0,\n          bearing: 0,\n          maxZoom: 24,\n          style: normalizeStyle(props.mapStyle),\n          interactive: false,\n          trackResize: false,\n          attributionControl: props.attributionControl,\n          preserveDrawingBuffer: props.preserveDrawingBuffer\n        };\n\n        if (props.transformRequest) {\n          mapOptions.transformRequest = props.transformRequest;\n        }\n\n        this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));\n\n        this._map.once(\'load\', props.onLoad);\n\n        this._map.on(\'error\', props.onError);\n      }\n\n      return this;\n    }\n  }, {\n    key: "_destroy",\n    value: function _destroy() {\n      if (!this._map) {\n        return;\n      }\n\n      if (!Mapbox.savedMap) {\n        Mapbox.savedMap = this._map;\n\n        this._map.off(\'load\', this.props.onLoad);\n\n        this._map.off(\'error\', this.props.onError);\n\n        this._map.off(\'styledata\', this._fireLoadEvent);\n      } else {\n        this._map.remove();\n      }\n\n      this._map = null;\n    }\n  }, {\n    key: "_initialize",\n    value: function _initialize(props) {\n      var _this2 = this;\n\n      props = Object.assign({}, defaultProps, props);\n      checkPropTypes(props, \'Mapbox\');\n      this.mapboxgl.accessToken = props.mapboxApiAccessToken || defaultProps.mapboxApiAccessToken;\n      this.mapboxgl.baseApiUrl = props.mapboxApiUrl;\n\n      this._create(props);\n\n      var _props = props,\n          container = _props.container;\n      Object.defineProperty(container, \'offsetWidth\', {\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, \'clientWidth\', {\n        get: function get() {\n          return _this2.width;\n        }\n      });\n      Object.defineProperty(container, \'offsetHeight\', {\n        get: function get() {\n          return _this2.height;\n        }\n      });\n      Object.defineProperty(container, \'clientHeight\', {\n        get: function get() {\n          return _this2.height;\n        }\n      });\n\n      var canvas = this._map.getCanvas();\n\n      if (canvas) {\n        canvas.style.outline = \'none\';\n      }\n\n      this._updateMapViewport({}, props);\n\n      this._updateMapSize({}, props);\n\n      this.props = props;\n    }\n  }, {\n    key: "_update",\n    value: function _update(oldProps, newProps) {\n      if (!this._map) {\n        return;\n      }\n\n      newProps = Object.assign({}, this.props, newProps);\n      checkPropTypes(newProps, \'Mapbox\');\n\n      var viewportChanged = this._updateMapViewport(oldProps, newProps);\n\n      var sizeChanged = this._updateMapSize(oldProps, newProps);\n\n      this._updateMapStyle(oldProps, newProps);\n\n      if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {\n        this.redraw();\n      }\n\n      this.props = newProps;\n    }\n  }, {\n    key: "_updateMapStyle",\n    value: function _updateMapStyle(oldProps, newProps) {\n      var styleChanged = oldProps.mapStyle !== newProps.mapStyle;\n\n      if (styleChanged) {\n        this._map.setStyle(normalizeStyle(newProps.mapStyle), {\n          diff: !newProps.preventStyleDiffing\n        });\n      }\n    }\n  }, {\n    key: "_updateMapSize",\n    value: function _updateMapSize(oldProps, newProps) {\n      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n\n      if (sizeChanged) {\n        this.width = newProps.width;\n        this.height = newProps.height;\n\n        this._map.resize();\n      }\n\n      return sizeChanged;\n    }\n  }, {\n    key: "_updateMapViewport",\n    value: function _updateMapViewport(oldProps, newProps) {\n      var oldViewState = this._getViewState(oldProps);\n\n      var newViewState = this._getViewState(newProps);\n\n      var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;\n\n      if (viewportChanged) {\n        this._map.jumpTo(this._viewStateToMapboxProps(newViewState));\n\n        if (newViewState.altitude !== oldViewState.altitude) {\n          this._map.transform.altitude = newViewState.altitude;\n        }\n      }\n\n      return viewportChanged;\n    }\n  }, {\n    key: "_getViewState",\n    value: function _getViewState(props) {\n      var _ref = props.viewState || props,\n          longitude = _ref.longitude,\n          latitude = _ref.latitude,\n          zoom = _ref.zoom,\n          _ref$pitch = _ref.pitch,\n          pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,\n          _ref$bearing = _ref.bearing,\n          bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,\n          _ref$altitude = _ref.altitude,\n          altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;\n\n      return {\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom,\n        pitch: pitch,\n        bearing: bearing,\n        altitude: altitude\n      };\n    }\n  }, {\n    key: "_checkStyleSheet",\n    value: function _checkStyleSheet() {\n      var mapboxVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'0.47.0\';\n\n      if (typeof document_ === \'undefined\') {\n        return;\n      }\n\n      try {\n        var testElement = document_.createElement(\'div\');\n        testElement.className = \'mapboxgl-map\';\n        testElement.style.display = \'none\';\n        document_.body.appendChild(testElement);\n        var isCssLoaded = window.getComputedStyle(testElement).position !== \'static\';\n\n        if (!isCssLoaded) {\n          var link = document_.createElement(\'link\');\n          link.setAttribute(\'rel\', \'stylesheet\');\n          link.setAttribute(\'type\', \'text/css\');\n          link.setAttribute(\'href\', "https://api.tiles.mapbox.com/mapbox-gl-js/v".concat(mapboxVersion, "/mapbox-gl.css"));\n          document_.head.appendChild(link);\n        }\n      } catch (error) {}\n    }\n  }, {\n    key: "_viewStateToMapboxProps",\n    value: function _viewStateToMapboxProps(viewState) {\n      return {\n        center: [viewState.longitude, viewState.latitude],\n        zoom: viewState.zoom,\n        bearing: viewState.bearing,\n        pitch: viewState.pitch\n      };\n    }\n  }]);\n\n  return Mapbox;\n}();\n\ndefineProperty_defineProperty(Mapbox, "initialized", false);\n\ndefineProperty_defineProperty(Mapbox, "propTypes", propTypes);\n\ndefineProperty_defineProperty(Mapbox, "defaultProps", defaultProps);\n\ndefineProperty_defineProperty(Mapbox, "savedMap", null);\n\n\n// EXTERNAL MODULE: ./node_modules/maplibre-gl/dist/maplibre-gl.js\nvar maplibre_gl = __webpack_require__(9910);\nvar maplibre_gl_default = /*#__PURE__*/__webpack_require__.n(maplibre_gl);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/mapboxgl.browser.js\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/math-utils.js\nvar math_utils_EPSILON = 1e-7;\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nfunction math_utils_equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; ++i) {\n      if (!math_utils_equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return Math.abs(a - b) <= math_utils_EPSILON;\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction utils_math_utils_lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map(function (ai, i) {\n      return utils_math_utils_lerp(ai, b[i], t);\n    });\n  }\n\n  return t * b + (1 - t) * a;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/assert.js\nfunction utils_assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \'react-map-gl: assertion failed.\');\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/map-state.js\n\n\n\n\n\nfunction map_state_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction map_state_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      map_state_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_state_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\nvar MAPBOX_LIMITS = {\n  minZoom: 0,\n  maxZoom: 24,\n  minPitch: 0,\n  maxPitch: 85\n};\nvar DEFAULT_STATE = {\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\nvar PITCH_MOUSE_THRESHOLD = 5;\nvar PITCH_ACCEL = 1.2;\n\nvar MapState = function () {\n  function MapState(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        latitude = _ref.latitude,\n        longitude = _ref.longitude,\n        zoom = _ref.zoom,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,\n        _ref$maxZoom = _ref.maxZoom,\n        maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,\n        _ref$minZoom = _ref.minZoom,\n        minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,\n        _ref$maxPitch = _ref.maxPitch,\n        maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,\n        _ref$minPitch = _ref.minPitch,\n        minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,\n        transitionDuration = _ref.transitionDuration,\n        transitionEasing = _ref.transitionEasing,\n        transitionInterpolator = _ref.transitionInterpolator,\n        transitionInterruption = _ref.transitionInterruption,\n        startPanLngLat = _ref.startPanLngLat,\n        startZoomLngLat = _ref.startZoomLngLat,\n        startRotatePos = _ref.startRotatePos,\n        startBearing = _ref.startBearing,\n        startPitch = _ref.startPitch,\n        startZoom = _ref.startZoom;\n\n    _classCallCheck(this, MapState);\n\n    utils_assert_assert(Number.isFinite(width), \'`width` must be supplied\');\n    utils_assert_assert(Number.isFinite(height), \'`height` must be supplied\');\n    utils_assert_assert(Number.isFinite(longitude), \'`longitude` must be supplied\');\n    utils_assert_assert(Number.isFinite(latitude), \'`latitude` must be supplied\');\n    utils_assert_assert(Number.isFinite(zoom), \'`zoom` must be supplied\');\n    this._viewportProps = this._applyConstraints({\n      width: width,\n      height: height,\n      latitude: latitude,\n      longitude: longitude,\n      zoom: zoom,\n      bearing: bearing,\n      pitch: pitch,\n      altitude: altitude,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      maxPitch: maxPitch,\n      minPitch: minPitch,\n      transitionDuration: transitionDuration,\n      transitionEasing: transitionEasing,\n      transitionInterpolator: transitionInterpolator,\n      transitionInterruption: transitionInterruption\n    });\n    this._state = {\n      startPanLngLat: startPanLngLat,\n      startZoomLngLat: startZoomLngLat,\n      startRotatePos: startRotatePos,\n      startBearing: startBearing,\n      startPitch: startPitch,\n      startZoom: startZoom\n    };\n  }\n\n  _createClass(MapState, [{\n    key: "getViewportProps",\n    value: function getViewportProps() {\n      return this._viewportProps;\n    }\n  }, {\n    key: "getState",\n    value: function getState() {\n      return this._state;\n    }\n  }, {\n    key: "panStart",\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      return this._getUpdatedMapState({\n        startPanLngLat: this._unproject(pos)\n      });\n    }\n  }, {\n    key: "pan",\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n          startPos = _ref3.startPos;\n\n      var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);\n\n      if (!startPanLngLat) {\n        return this;\n      }\n\n      var _this$_calculateNewLn = this._calculateNewLngLat({\n        startPanLngLat: startPanLngLat,\n        pos: pos\n      }),\n          _this$_calculateNewLn2 = slicedToArray_slicedToArray(_this$_calculateNewLn, 2),\n          longitude = _this$_calculateNewLn2[0],\n          latitude = _this$_calculateNewLn2[1];\n\n      return this._getUpdatedMapState({\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: "panEnd",\n    value: function panEnd() {\n      return this._getUpdatedMapState({\n        startPanLngLat: null\n      });\n    }\n  }, {\n    key: "rotateStart",\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this._getUpdatedMapState({\n        startRotatePos: pos,\n        startBearing: this._viewportProps.bearing,\n        startPitch: this._viewportProps.pitch\n      });\n    }\n  }, {\n    key: "rotate",\n    value: function rotate(_ref5) {\n      var pos = _ref5.pos,\n          _ref5$deltaAngleX = _ref5.deltaAngleX,\n          deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX,\n          _ref5$deltaAngleY = _ref5.deltaAngleY,\n          deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;\n      var _this$_state = this._state,\n          startRotatePos = _this$_state.startRotatePos,\n          startBearing = _this$_state.startBearing,\n          startPitch = _this$_state.startPitch;\n\n      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {\n        return this;\n      }\n\n      var newRotation;\n\n      if (pos) {\n        newRotation = this._calculateNewPitchAndBearing(map_state_objectSpread(map_state_objectSpread({}, this._getRotationParams(pos, startRotatePos)), {}, {\n          startBearing: startBearing,\n          startPitch: startPitch\n        }));\n      } else {\n        newRotation = {\n          bearing: startBearing + deltaAngleX,\n          pitch: startPitch + deltaAngleY\n        };\n      }\n\n      return this._getUpdatedMapState(newRotation);\n    }\n  }, {\n    key: "rotateEnd",\n    value: function rotateEnd() {\n      return this._getUpdatedMapState({\n        startBearing: null,\n        startPitch: null\n      });\n    }\n  }, {\n    key: "zoomStart",\n    value: function zoomStart(_ref6) {\n      var pos = _ref6.pos;\n      return this._getUpdatedMapState({\n        startZoomLngLat: this._unproject(pos),\n        startZoom: this._viewportProps.zoom\n      });\n    }\n  }, {\n    key: "zoom",\n    value: function zoom(_ref7) {\n      var pos = _ref7.pos,\n          startPos = _ref7.startPos,\n          scale = _ref7.scale;\n      utils_assert_assert(scale > 0, \'`scale` must be a positive number\');\n      var _this$_state2 = this._state,\n          startZoom = _this$_state2.startZoom,\n          startZoomLngLat = _this$_state2.startZoomLngLat;\n\n      if (!Number.isFinite(startZoom)) {\n        startZoom = this._viewportProps.zoom;\n        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);\n      }\n\n      utils_assert_assert(startZoomLngLat, \'`startZoomLngLat` prop is required \' + \'for zoom behavior to calculate where to position the map.\');\n\n      var zoom = this._calculateNewZoom({\n        scale: scale,\n        startZoom: startZoom || 0\n      });\n\n      var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, {\n        zoom: zoom\n      }));\n\n      var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({\n        lngLat: startZoomLngLat,\n        pos: pos\n      }),\n          _zoomedViewport$getMa2 = slicedToArray_slicedToArray(_zoomedViewport$getMa, 2),\n          longitude = _zoomedViewport$getMa2[0],\n          latitude = _zoomedViewport$getMa2[1];\n\n      return this._getUpdatedMapState({\n        zoom: zoom,\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n  }, {\n    key: "zoomEnd",\n    value: function zoomEnd() {\n      return this._getUpdatedMapState({\n        startZoomLngLat: null,\n        startZoom: null\n      });\n    }\n  }, {\n    key: "_getUpdatedMapState",\n    value: function _getUpdatedMapState(newProps) {\n      return new MapState(Object.assign({}, this._viewportProps, this._state, newProps));\n    }\n  }, {\n    key: "_applyConstraints",\n    value: function _applyConstraints(props) {\n      var maxZoom = props.maxZoom,\n          minZoom = props.minZoom,\n          zoom = props.zoom;\n      props.zoom = clamp(zoom, minZoom, maxZoom);\n      var maxPitch = props.maxPitch,\n          minPitch = props.minPitch,\n          pitch = props.pitch;\n      props.pitch = clamp(pitch, minPitch, maxPitch);\n      Object.assign(props, normalizeViewportProps(props));\n      return props;\n    }\n  }, {\n    key: "_unproject",\n    value: function _unproject(pos) {\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return pos && viewport.unproject(pos);\n    }\n  }, {\n    key: "_calculateNewLngLat",\n    value: function _calculateNewLngLat(_ref8) {\n      var startPanLngLat = _ref8.startPanLngLat,\n          pos = _ref8.pos;\n      var viewport = new WebMercatorViewport(this._viewportProps);\n      return viewport.getMapCenterByLngLatPosition({\n        lngLat: startPanLngLat,\n        pos: pos\n      });\n    }\n  }, {\n    key: "_calculateNewZoom",\n    value: function _calculateNewZoom(_ref9) {\n      var scale = _ref9.scale,\n          startZoom = _ref9.startZoom;\n      var _this$_viewportProps = this._viewportProps,\n          maxZoom = _this$_viewportProps.maxZoom,\n          minZoom = _this$_viewportProps.minZoom;\n      var zoom = startZoom + Math.log2(scale);\n      return clamp(zoom, minZoom, maxZoom);\n    }\n  }, {\n    key: "_calculateNewPitchAndBearing",\n    value: function _calculateNewPitchAndBearing(_ref10) {\n      var deltaScaleX = _ref10.deltaScaleX,\n          deltaScaleY = _ref10.deltaScaleY,\n          startBearing = _ref10.startBearing,\n          startPitch = _ref10.startPitch;\n      deltaScaleY = clamp(deltaScaleY, -1, 1);\n      var _this$_viewportProps2 = this._viewportProps,\n          minPitch = _this$_viewportProps2.minPitch,\n          maxPitch = _this$_viewportProps2.maxPitch;\n      var bearing = startBearing + 180 * deltaScaleX;\n      var pitch = startPitch;\n\n      if (deltaScaleY > 0) {\n        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n      } else if (deltaScaleY < 0) {\n        pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n      }\n\n      return {\n        pitch: pitch,\n        bearing: bearing\n      };\n    }\n  }, {\n    key: "_getRotationParams",\n    value: function _getRotationParams(pos, startPos) {\n      var deltaX = pos[0] - startPos[0];\n      var deltaY = pos[1] - startPos[1];\n      var centerY = pos[1];\n      var startY = startPos[1];\n      var _this$_viewportProps3 = this._viewportProps,\n          width = _this$_viewportProps3.width,\n          height = _this$_viewportProps3.height;\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = 0;\n\n      if (deltaY > 0) {\n        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n        }\n      } else if (deltaY < 0) {\n        if (startY > PITCH_MOUSE_THRESHOLD) {\n          deltaScaleY = 1 - centerY / startY;\n        }\n      }\n\n      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));\n      return {\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      };\n    }\n  }]);\n\n  return MapState;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/map-constraints.js\n\n\nfunction decapitalize(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\n\nfunction checkVisibilityConstraints(props) {\n  var constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAPBOX_LIMITS;\n\n  for (var constraintName in constraints) {\n    var type = constraintName.slice(0, 3);\n    var propName = decapitalize(constraintName.slice(3));\n\n    if (type === \'min\' && props[propName] < constraints[constraintName]) {\n      return false;\n    }\n\n    if (type === \'max\' && props[propName] > constraints[constraintName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/map-context.js\n\n\n\nfunction map_context_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction map_context_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      map_context_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_context_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\nvar map_context_MapContext = (0,react.createContext)({\n  viewport: null,\n  map: null,\n  container: null,\n  onViewportChange: null,\n  onViewStateChange: null,\n  eventManager: null\n});\nvar MapContextProvider = map_context_MapContext.Provider;\n\nfunction WrappedProvider(_ref) {\n  var value = _ref.value,\n      children = _ref.children;\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      map = _useState2[0],\n      setMap = _useState2[1];\n\n  var context = (0,react.useContext)(map_context_MapContext);\n  value = map_context_objectSpread(map_context_objectSpread({\n    setMap: setMap\n  }, context), {}, {\n    map: context && context.map || map\n  }, value);\n  return react.createElement(MapContextProvider, {\n    value: value\n  }, children);\n}\n\nmap_context_MapContext.Provider = WrappedProvider;\n/* harmony default export */ var map_context = (map_context_MapContext);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js\n\nvar useIsomorphicLayoutEffect = typeof window !== \'undefined\' ? react.useLayoutEffect : react.useEffect;\n/* harmony default export */ var use_isomorphic_layout_effect = (useIsomorphicLayoutEffect);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/terrain.js\nfunction getTerrainElevation(map, _ref) {\n  var longitude = _ref.longitude,\n      latitude = _ref.latitude;\n\n  if (map && map.queryTerrainElevation) {\n    return map.queryTerrainElevation([longitude, latitude]) || 0;\n  }\n\n  return 0;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/static-map.js\n\n\n\nfunction static_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction static_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      static_map_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      static_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvar TOKEN_DOC_URL = \'https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens\';\nvar NO_TOKEN_WARNING = \'A valid API access token is required to use Mapbox data\';\n\nfunction static_map_noop() {}\n\nfunction getViewport(_ref) {\n  var map = _ref.map,\n      props = _ref.props,\n      width = _ref.width,\n      height = _ref.height;\n\n  var viewportProps = static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), props.viewState), {}, {\n    width: width,\n    height: height\n  });\n\n  viewportProps.position = [0, 0, getTerrainElevation(map, viewportProps)];\n  return new WebMercatorViewport(viewportProps);\n}\nvar UNAUTHORIZED_ERROR_CODE = 401;\nvar CONTAINER_STYLE = {\n  position: \'absolute\',\n  width: \'100%\',\n  height: \'100%\',\n  overflow: \'hidden\'\n};\nvar static_map_defaultProps = Object.assign({}, Mapbox.defaultProps, {\n  disableTokenWarning: false,\n  visible: true,\n  onResize: static_map_noop,\n  className: \'\',\n  style: null,\n  visibilityConstraints: MAPBOX_LIMITS\n});\n\nfunction NoTokenWarning() {\n  var style = {\n    position: \'absolute\',\n    left: 0,\n    top: 0\n  };\n  return react.createElement("div", {\n    key: "warning",\n    id: "no-token-warning",\n    style: style\n  }, react.createElement("h3", {\n    key: "header"\n  }, NO_TOKEN_WARNING), react.createElement("div", {\n    key: "text"\n  }, "For information on setting up your basemap, read"), react.createElement("a", {\n    key: "link",\n    href: TOKEN_DOC_URL\n  }, "Note on Map Tokens"));\n}\n\nfunction getRefHandles(mapboxRef) {\n  return {\n    getMap: function getMap() {\n      return mapboxRef.current && mapboxRef.current.getMap();\n    },\n    queryRenderedFeatures: function queryRenderedFeatures(geometry) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var map = mapboxRef.current && mapboxRef.current.getMap();\n      return map && map.queryRenderedFeatures(geometry, options);\n    }\n  };\n}\n\nvar StaticMap = (0,react.forwardRef)(function (props, ref) {\n  var _useState = (0,react.useState)(true),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      accessTokenValid = _useState2[0],\n      setTokenState = _useState2[1];\n\n  var _useState3 = (0,react.useState)({\n    width: 0,\n    height: 0\n  }),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var mapboxRef = (0,react.useRef)(null);\n  var mapDivRef = (0,react.useRef)(null);\n  var containerRef = (0,react.useRef)(null);\n  var overlayRef = (0,react.useRef)(null);\n  var context = (0,react.useContext)(map_context);\n  use_isomorphic_layout_effect(function () {\n    if (!StaticMap.supported()) {\n      return undefined;\n    }\n\n    var mapbox = new Mapbox(static_map_objectSpread(static_map_objectSpread(static_map_objectSpread({}, props), size), {}, {\n      mapboxgl: (maplibre_gl_default()),\n      container: mapDivRef.current,\n      onError: function onError(evt) {\n        var statusCode = evt.error && evt.error.status || evt.status;\n\n        if (statusCode === UNAUTHORIZED_ERROR_CODE && accessTokenValid) {\n          console.error(NO_TOKEN_WARNING);\n          setTokenState(false);\n        }\n\n        props.onError(evt);\n      }\n    }));\n    mapboxRef.current = mapbox;\n\n    if (context && context.setMap) {\n      context.setMap(mapbox.getMap());\n    }\n\n    var resizeObserver = new ResizeObserver_es(function (entries) {\n      if (entries[0].contentRect) {\n        var _entries$0$contentRec = entries[0].contentRect,\n            _width = _entries$0$contentRec.width,\n            _height = _entries$0$contentRec.height;\n        setSize({\n          width: _width,\n          height: _height\n        });\n        props.onResize({\n          width: _width,\n          height: _height\n        });\n      }\n    });\n    resizeObserver.observe(containerRef.current);\n    return function () {\n      mapbox.finalize();\n      mapboxRef.current = null;\n      resizeObserver.disconnect();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (mapboxRef.current) {\n      mapboxRef.current.setProps(static_map_objectSpread(static_map_objectSpread({}, props), size));\n    }\n  });\n  var map = mapboxRef.current && mapboxRef.current.getMap();\n  (0,react.useImperativeHandle)(ref, function () {\n    return getRefHandles(mapboxRef);\n  }, []);\n  var preventScroll = (0,react.useCallback)(function (_ref2) {\n    var target = _ref2.target;\n\n    if (target === overlayRef.current) {\n      target.scrollTo(0, 0);\n    }\n  }, []);\n  var overlays = map && react.createElement(MapContextProvider, {\n    value: static_map_objectSpread(static_map_objectSpread({}, context), {}, {\n      viewport: context.viewport || getViewport(static_map_objectSpread({\n        map: map,\n        props: props\n      }, size)),\n      map: map,\n      container: context.container || containerRef.current\n    })\n  }, react.createElement("div", {\n    key: "map-overlays",\n    className: "overlays",\n    ref: overlayRef,\n    style: CONTAINER_STYLE,\n    onScroll: preventScroll\n  }, props.children));\n  var className = props.className,\n      width = props.width,\n      height = props.height,\n      style = props.style,\n      visibilityConstraints = props.visibilityConstraints;\n  var mapContainerStyle = Object.assign({\n    position: \'relative\'\n  }, style, {\n    width: width,\n    height: height\n  });\n  var visible = props.visible && checkVisibilityConstraints(props.viewState || props, visibilityConstraints);\n  var mapStyle = Object.assign({}, CONTAINER_STYLE, {\n    visibility: visible ? \'inherit\' : \'hidden\'\n  });\n  return react.createElement("div", {\n    key: "map-container",\n    ref: containerRef,\n    style: mapContainerStyle\n  }, react.createElement("div", {\n    key: "map-mapbox",\n    ref: mapDivRef,\n    style: mapStyle,\n    className: className\n  }), overlays, !accessTokenValid && !props.disableTokenWarning && react.createElement(NoTokenWarning, null));\n});\n\nStaticMap.supported = function () {\n  return (maplibre_gl_default()) && maplibre_gl_default().supported();\n};\n\nStaticMap.defaultProps = static_map_defaultProps;\n/* harmony default export */ var static_map = (StaticMap);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/transition-interpolator.js\n\n\n\n\nfunction transition_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = transition_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction transition_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return transition_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transition_interpolator_arrayLikeToArray(o, minLen);\n}\n\nfunction transition_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n\n\n\nvar TransitionInterpolator = function () {\n  function TransitionInterpolator() {\n    _classCallCheck(this, TransitionInterpolator);\n\n    defineProperty_defineProperty(this, "propNames", []);\n  }\n\n  _createClass(TransitionInterpolator, [{\n    key: "arePropsEqual",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iterator = transition_interpolator_createForOfIteratorHelper(this.propNames || []),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          if (!math_utils_equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: "initializeProps",\n    value: function initializeProps(startProps, endProps) {\n      return {\n        start: startProps,\n        end: endProps\n      };\n    }\n  }, {\n    key: "interpolateProps",\n    value: function interpolateProps(startProps, endProps, t) {\n      utils_assert_assert(false, \'interpolateProps is not implemented\');\n    }\n  }, {\n    key: "getDuration",\n    value: function getDuration(startProps, endProps) {\n      return endProps.transitionDuration;\n    }\n  }]);\n\n  return TransitionInterpolator;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nvar setPrototypeOf = __webpack_require__(4665);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) (0,setPrototypeOf/* default */.Z)(subClass, superClass);\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\nvar helpers_typeof = __webpack_require__(8);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (helpers_typeof(call) === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/transition-utils.js\nvar WRAPPED_ANGULAR_PROPS = {\n  longitude: 1,\n  bearing: 1\n};\nfunction transition_utils_mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction isValid(prop) {\n  return Number.isFinite(prop) || Array.isArray(prop);\n}\n\nfunction isWrappedAngularProp(propName) {\n  return propName in WRAPPED_ANGULAR_PROPS;\n}\n\nfunction getEndValueByShortestPath(propName, startValue, endValue) {\n  if (isWrappedAngularProp(propName) && Math.abs(endValue - startValue) > 180) {\n    endValue = endValue < 0 ? endValue + 360 : endValue - 360;\n  }\n\n  return endValue;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator.js\n\n\n\n\n\n\n\n\nfunction viewport_fly_to_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = viewport_fly_to_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction viewport_fly_to_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return viewport_fly_to_interpolator_arrayLikeToArray(o, minLen);\n}\n\nfunction viewport_fly_to_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\n\nvar viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS = [\'longitude\', \'latitude\', \'zoom\', \'bearing\', \'pitch\'];\nvar REQUIRED_PROPS = [\'latitude\', \'longitude\', \'zoom\', \'width\', \'height\'];\nvar LINEARLY_INTERPOLATED_PROPS = [\'bearing\', \'pitch\'];\nvar viewport_fly_to_interpolator_DEFAULT_OPTS = {\n  speed: 1.2,\n  curve: 1.414\n};\n\nvar ViewportFlyToInterpolator = function (_TransitionInterpolat) {\n  _inherits(ViewportFlyToInterpolator, _TransitionInterpolat);\n\n  var _super = _createSuper(ViewportFlyToInterpolator);\n\n  function ViewportFlyToInterpolator() {\n    var _this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ViewportFlyToInterpolator);\n\n    _this = _super.call(this);\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "propNames", viewport_fly_to_interpolator_VIEWPORT_TRANSITION_PROPS);\n\n    _this.props = Object.assign({}, viewport_fly_to_interpolator_DEFAULT_OPTS, props);\n    return _this;\n  }\n\n  _createClass(ViewportFlyToInterpolator, [{\n    key: "initializeProps",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n\n      var _iterator = viewport_fly_to_interpolator_createForOfIteratorHelper(REQUIRED_PROPS),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), "".concat(key, " must be supplied for transition"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _key = _step2.value;\n\n          var _startValue = startProps[_key] || 0;\n\n          var _endValue = endProps[_key] || 0;\n\n          startViewportProps[_key] = _startValue;\n          endViewportProps[_key] = getEndValueByShortestPath(_key, _startValue, _endValue);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: "interpolateProps",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = flyToViewport(startProps, endProps, t, this.props);\n\n      var _iterator3 = viewport_fly_to_interpolator_createForOfIteratorHelper(LINEARLY_INTERPOLATED_PROPS),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return viewport;\n    }\n  }, {\n    key: "getDuration",\n    value: function getDuration(startProps, endProps) {\n      var transitionDuration = endProps.transitionDuration;\n\n      if (transitionDuration === \'auto\') {\n        transitionDuration = getFlyToDuration(startProps, endProps, this.props);\n      }\n\n      return transitionDuration;\n    }\n  }]);\n\n  return ViewportFlyToInterpolator;\n}(TransitionInterpolator);\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/linear-interpolator.js\n\n\n\n\n\n\n\nfunction linear_interpolator_createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = linear_interpolator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it["return"] != null) it["return"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction linear_interpolator_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return linear_interpolator_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return linear_interpolator_arrayLikeToArray(o, minLen);\n}\n\nfunction linear_interpolator_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction linear_interpolator_createSuper(Derived) {\n  var hasNativeReflectConstruct = linear_interpolator_isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction linear_interpolator_isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\n\nvar linear_interpolator_VIEWPORT_TRANSITION_PROPS = [\'longitude\', \'latitude\', \'zoom\', \'bearing\', \'pitch\'];\n\nvar LinearInterpolator = function (_TransitionInterpolat) {\n  _inherits(LinearInterpolator, _TransitionInterpolat);\n\n  var _super = linear_interpolator_createSuper(LinearInterpolator);\n\n  function LinearInterpolator() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LinearInterpolator);\n\n    _this = _super.call(this);\n\n    if (Array.isArray(opts)) {\n      opts = {\n        transitionProps: opts\n      };\n    }\n\n    _this.propNames = opts.transitionProps || linear_interpolator_VIEWPORT_TRANSITION_PROPS;\n\n    if (opts.around) {\n      _this.around = opts.around;\n    }\n\n    return _this;\n  }\n\n  _createClass(LinearInterpolator, [{\n    key: "initializeProps",\n    value: function initializeProps(startProps, endProps) {\n      var startViewportProps = {};\n      var endViewportProps = {};\n\n      if (this.around) {\n        startViewportProps.around = this.around;\n        var aroundLngLat = new WebMercatorViewport(startProps).unproject(this.around);\n        Object.assign(endViewportProps, endProps, {\n          around: new WebMercatorViewport(endProps).project(aroundLngLat),\n          aroundLngLat: aroundLngLat\n        });\n      }\n\n      var _iterator = linear_interpolator_createForOfIteratorHelper(this.propNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var startValue = startProps[key];\n          var endValue = endProps[key];\n          utils_assert_assert(isValid(startValue) && isValid(endValue), "".concat(key, " must be supplied for transition"));\n          startViewportProps[key] = startValue;\n          endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        start: startViewportProps,\n        end: endViewportProps\n      };\n    }\n  }, {\n    key: "interpolateProps",\n    value: function interpolateProps(startProps, endProps, t) {\n      var viewport = {};\n\n      var _iterator2 = linear_interpolator_createForOfIteratorHelper(this.propNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          viewport[key] = utils_math_utils_lerp(startProps[key], endProps[key], t);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (endProps.around) {\n        var _WebMercatorViewport$ = new WebMercatorViewport(Object.assign({}, endProps, viewport)).getMapCenterByLngLatPosition({\n          lngLat: endProps.aroundLngLat,\n          pos: utils_math_utils_lerp(startProps.around, endProps.around, t)\n        }),\n            _WebMercatorViewport$2 = slicedToArray_slicedToArray(_WebMercatorViewport$, 2),\n            longitude = _WebMercatorViewport$2[0],\n            latitude = _WebMercatorViewport$2[1];\n\n        viewport.longitude = longitude;\n        viewport.latitude = latitude;\n      }\n\n      return viewport;\n    }\n  }]);\n\n  return LinearInterpolator;\n}(TransitionInterpolator);\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition/index.js\n\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/transition-manager.js\n\n\n\n\n\n\n\nvar transition_manager_noop = function noop() {};\n\nfunction cropEasingFunction(easing, x0) {\n  var y0 = easing(x0);\n  return function (t) {\n    return 1 / (1 - y0) * (easing(t * (1 - x0) + x0) - y0);\n  };\n}\nvar TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3,\n  UPDATE: 4\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: transition_manager_noop,\n  onTransitionInterrupt: transition_manager_noop,\n  onTransitionEnd: transition_manager_noop\n};\n\nvar TransitionManager = function () {\n  function TransitionManager() {\n    var _this = this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TransitionManager);\n\n    defineProperty_defineProperty(this, "_animationFrame", null);\n\n    defineProperty_defineProperty(this, "_onTransitionFrame", function () {\n      _this._animationFrame = requestAnimationFrame(_this._onTransitionFrame);\n\n      _this._updateViewport();\n    });\n\n    this.props = null;\n    this.onViewportChange = opts.onViewportChange || transition_manager_noop;\n    this.onStateChange = opts.onStateChange || transition_manager_noop;\n    this.time = opts.getTime || Date.now;\n  }\n\n  _createClass(TransitionManager, [{\n    key: "getViewportInTransition",\n    value: function getViewportInTransition() {\n      return this._animationFrame ? this.state.propsInTransition : null;\n    }\n  }, {\n    key: "processViewportChange",\n    value: function processViewportChange(nextProps) {\n      var currentProps = this.props;\n      this.props = nextProps;\n\n      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return false;\n      }\n\n      if (this._isTransitionEnabled(nextProps)) {\n        var startProps = Object.assign({}, currentProps);\n        var endProps = Object.assign({}, nextProps);\n\n        if (this._isTransitionInProgress()) {\n          currentProps.onTransitionInterrupt();\n\n          if (this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END) {\n            Object.assign(startProps, this.state.endProps);\n          } else {\n            Object.assign(startProps, this.state.propsInTransition);\n          }\n\n          if (this.state.interruption === TRANSITION_EVENTS.UPDATE) {\n            var currentTime = this.time();\n            var x0 = (currentTime - this.state.startTime) / this.state.duration;\n            endProps.transitionDuration = this.state.duration - (currentTime - this.state.startTime);\n            endProps.transitionEasing = cropEasingFunction(this.state.easing, x0);\n            endProps.transitionInterpolator = startProps.transitionInterpolator;\n          }\n        }\n\n        endProps.onTransitionStart();\n\n        this._triggerTransition(startProps, endProps);\n\n        return true;\n      }\n\n      if (this._isTransitionInProgress()) {\n        currentProps.onTransitionInterrupt();\n\n        this._endTransition();\n      }\n\n      return false;\n    }\n  }, {\n    key: "_isTransitionInProgress",\n    value: function _isTransitionInProgress() {\n      return Boolean(this._animationFrame);\n    }\n  }, {\n    key: "_isTransitionEnabled",\n    value: function _isTransitionEnabled(props) {\n      var transitionDuration = props.transitionDuration,\n          transitionInterpolator = props.transitionInterpolator;\n      return (transitionDuration > 0 || transitionDuration === \'auto\') && Boolean(transitionInterpolator);\n    }\n  }, {\n    key: "_isUpdateDueToCurrentTransition",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.state.propsInTransition) {\n        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);\n      }\n\n      return false;\n    }\n  }, {\n    key: "_shouldIgnoreViewportChange",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (!currentProps) {\n        return true;\n      }\n\n      if (this._isTransitionInProgress()) {\n        return this.state.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n      }\n\n      if (this._isTransitionEnabled(nextProps)) {\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n\n      return true;\n    }\n  }, {\n    key: "_triggerTransition",\n    value: function _triggerTransition(startProps, endProps) {\n      utils_assert_assert(this._isTransitionEnabled(endProps));\n\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n      }\n\n      var transitionInterpolator = endProps.transitionInterpolator;\n      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n\n      if (duration === 0) {\n        return;\n      }\n\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);\n      var interactionState = {\n        inTransition: true,\n        isZooming: startProps.zoom !== endProps.zoom,\n        isPanning: startProps.longitude !== endProps.longitude || startProps.latitude !== endProps.latitude,\n        isRotating: startProps.bearing !== endProps.bearing || startProps.pitch !== endProps.pitch\n      };\n      this.state = {\n        duration: duration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startTime: this.time(),\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        animation: null,\n        propsInTransition: {}\n      };\n\n      this._onTransitionFrame();\n\n      this.onStateChange(interactionState);\n    }\n  }, {\n    key: "_endTransition",\n    value: function _endTransition() {\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n        this._animationFrame = null;\n      }\n\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n    }\n  }, {\n    key: "_updateViewport",\n    value: function _updateViewport() {\n      var currentTime = this.time();\n      var _this$state = this.state,\n          startTime = _this$state.startTime,\n          duration = _this$state.duration,\n          easing = _this$state.easing,\n          interpolator = _this$state.interpolator,\n          startProps = _this$state.startProps,\n          endProps = _this$state.endProps;\n      var shouldEnd = false;\n      var t = (currentTime - startTime) / duration;\n\n      if (t >= 1) {\n        t = 1;\n        shouldEnd = true;\n      }\n\n      t = easing(t);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t);\n      var mapState = new MapState(Object.assign({}, this.props, viewport));\n      this.state.propsInTransition = mapState.getViewportProps();\n      this.onViewportChange(this.state.propsInTransition, this.props);\n\n      if (shouldEnd) {\n        this._endTransition();\n\n        this.props.onTransitionEnd();\n      }\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\ndefineProperty_defineProperty(TransitionManager, "defaultProps", DEFAULT_PROPS);\n\n\n// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js\nvar hammer = __webpack_require__(5087);\nvar hammer_default = /*#__PURE__*/__webpack_require__.n(hammer);\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nfunction some(array, predict) {\n  for (var i = 0; i < array.length; i++) {\n    if (predict(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction enhancePointerEventInput(PointerEventInput) {\n  var oldHandler = PointerEventInput.prototype.handler;\n\n  PointerEventInput.prototype.handler = function handler(ev) {\n    var store = this.store;\n\n    if (ev.button > 0 && ev.type === \'pointerdown\') {\n      if (!some(store, function (e) {\n        return e.pointerId === ev.pointerId;\n      })) {\n        store.push(ev);\n      }\n    }\n\n    oldHandler.call(this, ev);\n  };\n}\nfunction enhanceMouseInput(MouseInput) {\n  MouseInput.prototype.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type];\n\n    if (eventType & INPUT_START && ev.button >= 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which === 0) {\n      eventType = INPUT_END;\n    }\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: \'mouse\',\n      srcEvent: ev\n    });\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js\n\n\nenhancePointerEventInput((hammer_default()).PointerEventInput);\nenhanceMouseInput((hammer_default()).MouseInput);\nvar Manager = (hammer_default()).Manager;\n/* harmony default export */ var hammer_browser = ((hammer_default()));\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/constants.js\n\nvar RECOGNIZERS = hammer_browser ? [[hammer_browser.Pan, {\n  event: \'tripan\',\n  pointers: 3,\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Rotate, {\n  enable: false\n}], [hammer_browser.Pinch, {\n  enable: false\n}], [hammer_browser.Swipe, {\n  enable: false\n}], [hammer_browser.Pan, {\n  threshold: 0,\n  enable: false\n}], [hammer_browser.Press, {\n  enable: false\n}], [hammer_browser.Tap, {\n  event: \'doubletap\',\n  taps: 2,\n  enable: false\n}], [hammer_browser.Tap, {\n  event: \'anytap\',\n  enable: false\n}], [hammer_browser.Tap, {\n  enable: false\n}]] : null;\nvar RECOGNIZER_COMPATIBLE_MAP = {\n  tripan: [\'rotate\', \'pinch\', \'pan\'],\n  rotate: [\'pinch\'],\n  pinch: [\'pan\'],\n  pan: [\'press\', \'doubletap\', \'anytap\', \'tap\'],\n  doubletap: [\'anytap\'],\n  anytap: [\'tap\']\n};\nvar RECOGNIZER_FALLBACK_MAP = {\n  doubletap: [\'tap\']\n};\nvar BASIC_EVENT_ALIASES = {\n  pointerdown: \'pointerdown\',\n  pointermove: \'pointermove\',\n  pointerup: \'pointerup\',\n  touchstart: \'pointerdown\',\n  touchmove: \'pointermove\',\n  touchend: \'pointerup\',\n  mousedown: \'pointerdown\',\n  mousemove: \'pointermove\',\n  mouseup: \'pointerup\'\n};\nvar INPUT_EVENT_TYPES = {\n  KEY_EVENTS: [\'keydown\', \'keyup\'],\n  MOUSE_EVENTS: [\'mousedown\', \'mousemove\', \'mouseup\', \'mouseover\', \'mouseout\', \'mouseleave\'],\n  WHEEL_EVENTS: [\'wheel\', \'mousewheel\']\n};\nvar EVENT_RECOGNIZER_MAP = {\n  tap: \'tap\',\n  anytap: \'anytap\',\n  doubletap: \'doubletap\',\n  press: \'press\',\n  pinch: \'pinch\',\n  pinchin: \'pinch\',\n  pinchout: \'pinch\',\n  pinchstart: \'pinch\',\n  pinchmove: \'pinch\',\n  pinchend: \'pinch\',\n  pinchcancel: \'pinch\',\n  rotate: \'rotate\',\n  rotatestart: \'rotate\',\n  rotatemove: \'rotate\',\n  rotateend: \'rotate\',\n  rotatecancel: \'rotate\',\n  tripan: \'tripan\',\n  tripanstart: \'tripan\',\n  tripanmove: \'tripan\',\n  tripanup: \'tripan\',\n  tripandown: \'tripan\',\n  tripanleft: \'tripan\',\n  tripanright: \'tripan\',\n  tripanend: \'tripan\',\n  tripancancel: \'tripan\',\n  pan: \'pan\',\n  panstart: \'pan\',\n  panmove: \'pan\',\n  panup: \'pan\',\n  pandown: \'pan\',\n  panleft: \'pan\',\n  panright: \'pan\',\n  panend: \'pan\',\n  pancancel: \'pan\',\n  swipe: \'swipe\',\n  swipeleft: \'swipe\',\n  swiperight: \'swipe\',\n  swipeup: \'swipe\',\n  swipedown: \'swipe\'\n};\nvar GESTURE_EVENT_ALIASES = {\n  click: \'tap\',\n  anyclick: \'anytap\',\n  dblclick: \'doubletap\',\n  mousedown: \'pointerdown\',\n  mousemove: \'pointermove\',\n  mouseup: \'pointerup\',\n  mouseover: \'pointerover\',\n  mouseout: \'pointerout\',\n  mouseleave: \'pointerleave\'\n};\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/globals.js\nvar userAgent = typeof navigator !== \'undefined\' && navigator.userAgent ? navigator.userAgent.toLowerCase() : \'\';\nvar globals_window_ = typeof window !== \'undefined\' ? window : __webpack_require__.g;\nvar globals_global_ = typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : window;\nvar globals_document_ = typeof document !== \'undefined\' ? document : {};\n\nvar passiveSupported = false;\n\ntry {\n  var options = {\n    get passive() {\n      passiveSupported = true;\n      return true;\n    }\n\n  };\n  globals_window_.addEventListener(\'test\', options, options);\n  globals_window_.removeEventListener(\'test\', options, options);\n} catch (err) {}\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js\n\n\n\n\nvar firefox = userAgent.indexOf(\'firefox\') !== -1;\nvar WHEEL_EVENTS = INPUT_EVENT_TYPES.WHEEL_EVENTS;\nvar EVENT_TYPE = \'wheel\';\nvar WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nvar WHEEL_DELTA_PER_LINE = 40;\nvar SHIFT_MULTIPLIER = 0.25;\n\nvar WheelInput = /*#__PURE__*/function () {\n  function WheelInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, WheelInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.events = WHEEL_EVENTS.concat(options.events || []);\n    this.handleEvent = this.handleEvent.bind(this);\n    this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent, passiveSupported ? {\n        passive: false\n      } : false);\n    });\n  }\n\n  _createClass(WheelInput, [{\n    key: "destroy",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === EVENT_TYPE) {\n        this.options.enable = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      var value = event.deltaY;\n\n      if (globals_window_.WheelEvent) {\n        if (firefox && event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_PIXEL) {\n          value /= globals_window_.devicePixelRatio;\n        }\n\n        if (event.deltaMode === globals_window_.WheelEvent.DOM_DELTA_LINE) {\n          value *= WHEEL_DELTA_PER_LINE;\n        }\n      }\n\n      var wheelPosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n\n      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n      }\n\n      if (event.shiftKey && value) {\n        value = value * SHIFT_MULTIPLIER;\n      }\n\n      this._onWheel(event, -value, wheelPosition);\n    }\n  }, {\n    key: "_onWheel",\n    value: function _onWheel(srcEvent, delta, position) {\n      this.callback({\n        type: EVENT_TYPE,\n        center: position,\n        delta: delta,\n        srcEvent: srcEvent,\n        pointerType: \'mouse\',\n        target: srcEvent.target\n      });\n    }\n  }]);\n\n  return WheelInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/move-input.js\n\n\n\nvar MOUSE_EVENTS = INPUT_EVENT_TYPES.MOUSE_EVENTS;\nvar MOVE_EVENT_TYPE = \'pointermove\';\nvar OVER_EVENT_TYPE = \'pointerover\';\nvar OUT_EVENT_TYPE = \'pointerout\';\nvar LEAVE_EVENT_TYPE = \'pointerleave\';\n\nvar MoveInput = /*#__PURE__*/function () {\n  function MoveInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, MoveInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.pressed = false;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.enableMoveEvent = this.options.enable;\n    this.enableLeaveEvent = this.options.enable;\n    this.enableOutEvent = this.options.enable;\n    this.enableOverEvent = this.options.enable;\n    this.events = MOUSE_EVENTS.concat(options.events || []);\n    this.handleEvent = this.handleEvent.bind(this);\n    this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  _createClass(MoveInput, [{\n    key: "destroy",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === MOVE_EVENT_TYPE) {\n        this.enableMoveEvent = enabled;\n      }\n\n      if (eventType === OVER_EVENT_TYPE) {\n        this.enableOverEvent = enabled;\n      }\n\n      if (eventType === OUT_EVENT_TYPE) {\n        this.enableOutEvent = enabled;\n      }\n\n      if (eventType === LEAVE_EVENT_TYPE) {\n        this.enableLeaveEvent = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    }\n  }, {\n    key: "handleOverEvent",\n    value: function handleOverEvent(event) {\n      if (this.enableOverEvent) {\n        if (event.type === \'mouseover\') {\n          this.callback({\n            type: OVER_EVENT_TYPE,\n            srcEvent: event,\n            pointerType: \'mouse\',\n            target: event.target\n          });\n        }\n      }\n    }\n  }, {\n    key: "handleOutEvent",\n    value: function handleOutEvent(event) {\n      if (this.enableOutEvent) {\n        if (event.type === \'mouseout\') {\n          this.callback({\n            type: OUT_EVENT_TYPE,\n            srcEvent: event,\n            pointerType: \'mouse\',\n            target: event.target\n          });\n        }\n      }\n    }\n  }, {\n    key: "handleLeaveEvent",\n    value: function handleLeaveEvent(event) {\n      if (this.enableLeaveEvent) {\n        if (event.type === \'mouseleave\') {\n          this.callback({\n            type: LEAVE_EVENT_TYPE,\n            srcEvent: event,\n            pointerType: \'mouse\',\n            target: event.target\n          });\n        }\n      }\n    }\n  }, {\n    key: "handleMoveEvent",\n    value: function handleMoveEvent(event) {\n      if (this.enableMoveEvent) {\n        switch (event.type) {\n          case \'mousedown\':\n            if (event.button >= 0) {\n              this.pressed = true;\n            }\n\n            break;\n\n          case \'mousemove\':\n            if (event.which === 0) {\n              this.pressed = false;\n            }\n\n            if (!this.pressed) {\n              this.callback({\n                type: MOVE_EVENT_TYPE,\n                srcEvent: event,\n                pointerType: \'mouse\',\n                target: event.target\n              });\n            }\n\n            break;\n\n          case \'mouseup\':\n            this.pressed = false;\n            break;\n\n          default:\n        }\n      }\n    }\n  }]);\n\n  return MoveInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/key-input.js\n\n\n\nvar KEY_EVENTS = INPUT_EVENT_TYPES.KEY_EVENTS;\nvar DOWN_EVENT_TYPE = \'keydown\';\nvar UP_EVENT_TYPE = \'keyup\';\n\nvar KeyInput = /*#__PURE__*/function () {\n  function KeyInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, KeyInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n    this.events = KEY_EVENTS.concat(options.events || []);\n    this.handleEvent = this.handleEvent.bind(this);\n    element.tabIndex = options.tabIndex || 0;\n    element.style.outline = \'none\';\n    this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  _createClass(KeyInput, [{\n    key: "destroy",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === DOWN_EVENT_TYPE) {\n        this.enableDownEvent = enabled;\n      }\n\n      if (eventType === UP_EVENT_TYPE) {\n        this.enableUpEvent = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      var targetElement = event.target || event.srcElement;\n\n      if (targetElement.tagName === \'INPUT\' && targetElement.type === \'text\' || targetElement.tagName === \'TEXTAREA\') {\n        return;\n      }\n\n      if (this.enableDownEvent && event.type === \'keydown\') {\n        this.callback({\n          type: DOWN_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n\n      if (this.enableUpEvent && event.type === \'keyup\') {\n        this.callback({\n          type: UP_EVENT_TYPE,\n          srcEvent: event,\n          key: event.key,\n          target: event.target\n        });\n      }\n    }\n  }]);\n\n  return KeyInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js\n\n\nvar contextmenu_input_EVENT_TYPE = \'contextmenu\';\n\nvar ContextmenuInput = /*#__PURE__*/function () {\n  function ContextmenuInput(element, callback) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ContextmenuInput);\n\n    this.element = element;\n    this.callback = callback;\n    this.options = Object.assign({\n      enable: true\n    }, options);\n    this.handleEvent = this.handleEvent.bind(this);\n    element.addEventListener(\'contextmenu\', this.handleEvent);\n  }\n\n  _createClass(ContextmenuInput, [{\n    key: "destroy",\n    value: function destroy() {\n      this.element.removeEventListener(\'contextmenu\', this.handleEvent);\n    }\n  }, {\n    key: "enableEventType",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === contextmenu_input_EVENT_TYPE) {\n        this.options.enable = enabled;\n      }\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      this.callback({\n        type: contextmenu_input_EVENT_TYPE,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        srcEvent: event,\n        pointerType: \'mouse\',\n        target: event.target\n      });\n    }\n  }]);\n\n  return ContextmenuInput;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/event-utils.js\nvar DOWN_EVENT = 1;\nvar MOVE_EVENT = 2;\nvar UP_EVENT = 4;\nvar event_utils_MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\nvar MOUSE_EVENT_WHICH_LEFT = 1;\nvar MOUSE_EVENT_WHICH_MIDDLE = 2;\nvar MOUSE_EVENT_WHICH_RIGHT = 3;\nvar MOUSE_EVENT_BUTTON_LEFT = 0;\nvar MOUSE_EVENT_BUTTON_MIDDLE = 1;\nvar MOUSE_EVENT_BUTTON_RIGHT = 2;\nvar MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nvar MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nvar MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\nfunction whichButtons(event) {\n  var eventType = event_utils_MOUSE_EVENTS[event.srcEvent.type];\n\n  if (!eventType) {\n    return null;\n  }\n\n  var _event$srcEvent = event.srcEvent,\n      buttons = _event$srcEvent.buttons,\n      button = _event$srcEvent.button,\n      which = _event$srcEvent.which;\n  var leftButton = false;\n  var middleButton = false;\n  var rightButton = false;\n\n  if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {\n    leftButton = which === MOUSE_EVENT_WHICH_LEFT;\n    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;\n    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;\n  } else if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else if (eventType === DOWN_EVENT) {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n\n  return {\n    leftButton: leftButton,\n    middleButton: middleButton,\n    rightButton: rightButton\n  };\n}\nfunction getOffsetPosition(event, rootElement) {\n  var srcEvent = event.srcEvent;\n\n  if (!event.center && !Number.isFinite(srcEvent.clientX)) {\n    return null;\n  }\n\n  var center = event.center || {\n    x: srcEvent.clientX,\n    y: srcEvent.clientY\n  };\n  var rect = rootElement.getBoundingClientRect();\n  var scaleX = rect.width / rootElement.offsetWidth || 1;\n  var scaleY = rect.height / rootElement.offsetHeight || 1;\n  var offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n  return {\n    center: center,\n    offsetCenter: offsetCenter\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js\n\n\n\nvar DEFAULT_OPTIONS = {\n  srcElement: \'root\',\n  priority: 0\n};\n\nvar EventRegistrar = /*#__PURE__*/function () {\n  function EventRegistrar(eventManager) {\n    _classCallCheck(this, EventRegistrar);\n\n    this.eventManager = eventManager;\n    this.handlers = [];\n    this.handlersByElement = new Map();\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n\n  _createClass(EventRegistrar, [{\n    key: "isEmpty",\n    value: function isEmpty() {\n      return !this._active;\n    }\n  }, {\n    key: "add",\n    value: function add(type, handler, opts) {\n      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      if (opts && (typeof opts !== \'object\' || opts.addEventListener)) {\n        opts = {\n          srcElement: opts\n        };\n      }\n\n      opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n      var entries = handlersByElement.get(opts.srcElement);\n\n      if (!entries) {\n        entries = [];\n        handlersByElement.set(opts.srcElement, entries);\n      }\n\n      var entry = {\n        type: type,\n        handler: handler,\n        srcElement: opts.srcElement,\n        priority: opts.priority\n      };\n\n      if (once) {\n        entry.once = true;\n      }\n\n      if (passive) {\n        entry.passive = true;\n      }\n\n      handlers.push(entry);\n      this._active = this._active || !entry.passive;\n      var insertPosition = entries.length - 1;\n\n      while (insertPosition >= 0) {\n        if (entries[insertPosition].priority >= entry.priority) {\n          break;\n        }\n\n        insertPosition--;\n      }\n\n      entries.splice(insertPosition + 1, 0, entry);\n    }\n  }, {\n    key: "remove",\n    value: function remove(type, handler) {\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      for (var i = handlers.length - 1; i >= 0; i--) {\n        var entry = handlers[i];\n\n        if (entry.type === type && entry.handler === handler) {\n          handlers.splice(i, 1);\n          var entries = handlersByElement.get(entry.srcElement);\n          entries.splice(entries.indexOf(entry), 1);\n\n          if (entries.length === 0) {\n            handlersByElement.delete(entry.srcElement);\n          }\n        }\n      }\n\n      this._active = handlers.some(function (entry) {\n        return !entry.passive;\n      });\n    }\n  }, {\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      if (this.isEmpty()) {\n        return;\n      }\n\n      var mjolnirEvent = this._normalizeEvent(event);\n\n      var target = event.srcEvent.target;\n\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n\n        if (mjolnirEvent.handled) {\n          return;\n        }\n\n        target = target.parentNode;\n      }\n\n      this._emit(mjolnirEvent, \'root\');\n    }\n  }, {\n    key: "_emit",\n    value: function _emit(event, srcElement) {\n      var entries = this.handlersByElement.get(srcElement);\n\n      if (entries) {\n        var immediatePropagationStopped = false;\n\n        var stopPropagation = function stopPropagation() {\n          event.handled = true;\n        };\n\n        var stopImmediatePropagation = function stopImmediatePropagation() {\n          event.handled = true;\n          immediatePropagationStopped = true;\n        };\n\n        var entriesToRemove = [];\n\n        for (var i = 0; i < entries.length; i++) {\n          var _entries$i = entries[i],\n              type = _entries$i.type,\n              handler = _entries$i.handler,\n              once = _entries$i.once;\n          handler(Object.assign({}, event, {\n            type: type,\n            stopPropagation: stopPropagation,\n            stopImmediatePropagation: stopImmediatePropagation\n          }));\n\n          if (once) {\n            entriesToRemove.push(entries[i]);\n          }\n\n          if (immediatePropagationStopped) {\n            break;\n          }\n        }\n\n        for (var _i = 0; _i < entriesToRemove.length; _i++) {\n          var _entriesToRemove$_i = entriesToRemove[_i],\n              _type = _entriesToRemove$_i.type,\n              _handler = _entriesToRemove$_i.handler;\n          this.remove(_type, _handler);\n        }\n      }\n    }\n  }, {\n    key: "_normalizeEvent",\n    value: function _normalizeEvent(event) {\n      var rootElement = this.eventManager.element;\n      return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n        handled: false,\n        rootElement: rootElement\n      });\n    }\n  }]);\n\n  return EventRegistrar;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/event-manager.js\n\n\n\n\nfunction event_manager_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = event_manager_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction event_manager_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return event_manager_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return event_manager_arrayLikeToArray(o, minLen); }\n\nfunction event_manager_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\n\n\n\nvar event_manager_DEFAULT_OPTIONS = {\n  events: null,\n  recognizers: null,\n  recognizerOptions: {},\n  Manager: Manager,\n  touchAction: \'none\',\n  tabIndex: 0\n};\n\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager() {\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, EventManager);\n\n    this.options = Object.assign({}, event_manager_DEFAULT_OPTIONS, options);\n    this.events = new Map();\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n    this.setElement(element);\n    var events = options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  _createClass(EventManager, [{\n    key: "setElement",\n    value: function setElement(element) {\n      var _this = this;\n\n      if (this.element) {\n        this.destroy();\n      }\n\n      this.element = element;\n\n      if (!element) {\n        return;\n      }\n\n      var options = this.options;\n      var ManagerClass = options.Manager;\n      this.manager = new ManagerClass(element, {\n        touchAction: options.touchAction,\n        recognizers: options.recognizers || RECOGNIZERS\n      }).on(\'hammer.input\', this._onBasicInput);\n\n      if (!options.recognizers) {\n        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {\n          var recognizer = _this.manager.get(name);\n\n          if (recognizer) {\n            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {\n              recognizer.recognizeWith(otherName);\n            });\n          }\n        });\n      }\n\n      for (var recognizerName in options.recognizerOptions) {\n        var recognizer = this.manager.get(recognizerName);\n\n        if (recognizer) {\n          var recognizerOption = options.recognizerOptions[recognizerName];\n          delete recognizerOption.enable;\n          recognizer.set(recognizerOption);\n        }\n      }\n\n      this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.moveInput = new MoveInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.keyInput = new KeyInput(element, this._onOtherEvent, {\n        enable: false,\n        tabIndex: options.tabIndex\n      });\n      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n        enable: false\n      });\n\n      var _iterator = event_manager_createForOfIteratorHelper(this.events),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = slicedToArray_slicedToArray(_step.value, 2),\n              eventAlias = _step$value[0],\n              eventRegistrar = _step$value[1];\n\n          if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n            this.manager.on(eventAlias, eventRegistrar.handleEvent);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this.element) {\n        this.wheelInput.destroy();\n        this.moveInput.destroy();\n        this.keyInput.destroy();\n        this.contextmenuInput.destroy();\n        this.manager.destroy();\n        this.wheelInput = null;\n        this.moveInput = null;\n        this.keyInput = null;\n        this.contextmenuInput = null;\n        this.manager = null;\n        this.element = null;\n      }\n    }\n  }, {\n    key: "on",\n    value: function on(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false);\n    }\n  }, {\n    key: "once",\n    value: function once(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, true);\n    }\n  }, {\n    key: "watch",\n    value: function watch(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false, true);\n    }\n  }, {\n    key: "off",\n    value: function off(event, handler) {\n      this._removeEventHandler(event, handler);\n    }\n  }, {\n    key: "_toggleRecognizer",\n    value: function _toggleRecognizer(name, enabled) {\n      var manager = this.manager;\n\n      if (!manager) {\n        return;\n      }\n\n      var recognizer = manager.get(name);\n\n      if (recognizer && recognizer.options.enable !== enabled) {\n        recognizer.set({\n          enable: enabled\n        });\n        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n        if (fallbackRecognizers && !this.options.recognizers) {\n          fallbackRecognizers.forEach(function (otherName) {\n            var otherRecognizer = manager.get(otherName);\n\n            if (enabled) {\n              otherRecognizer.requireFailure(name);\n              recognizer.dropRequireFailure(otherName);\n            } else {\n              otherRecognizer.dropRequireFailure(name);\n            }\n          });\n        }\n      }\n\n      this.wheelInput.enableEventType(name, enabled);\n      this.moveInput.enableEventType(name, enabled);\n      this.keyInput.enableEventType(name, enabled);\n      this.contextmenuInput.enableEventType(name, enabled);\n    }\n  }, {\n    key: "_addEventHandler",\n    value: function _addEventHandler(event, handler, opts, once, passive) {\n      if (typeof event !== \'string\') {\n        opts = handler;\n\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName], opts, once, passive);\n        }\n\n        return;\n      }\n\n      var manager = this.manager,\n          events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        eventRegistrar = new EventRegistrar(this);\n        events.set(eventAlias, eventRegistrar);\n        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n\n        if (manager) {\n          manager.on(eventAlias, eventRegistrar.handleEvent);\n        }\n      }\n\n      eventRegistrar.add(event, handler, opts, once, passive);\n\n      if (!eventRegistrar.isEmpty()) {\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n      }\n    }\n  }, {\n    key: "_removeEventHandler",\n    value: function _removeEventHandler(event, handler) {\n      if (typeof event !== \'string\') {\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n\n        return;\n      }\n\n      var events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        return;\n      }\n\n      eventRegistrar.remove(event, handler);\n\n      if (eventRegistrar.isEmpty()) {\n        var recognizerName = eventRegistrar.recognizerName;\n        var isRecognizerUsed = false;\n\n        var _iterator2 = event_manager_createForOfIteratorHelper(events.values()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var eh = _step2.value;\n\n            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n              isRecognizerUsed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n  }, {\n    key: "_onBasicInput",\n    value: function _onBasicInput(event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        this.manager.emit(alias, event);\n      }\n    }\n  }, {\n    key: "_onOtherEvent",\n    value: function _onOtherEvent(event) {\n      this.manager.emit(event.type, event);\n    }\n  }]);\n\n  return EventManager;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/mjolnir.js/dist/esm/index.js\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/map-controller.js\n\n\n\n\nfunction map_controller_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction map_controller_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      map_controller_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      map_controller_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\nvar NO_TRANSITION_PROPS = {\n  transitionDuration: 0\n};\nvar LINEAR_TRANSITION_PROPS = {\n  transitionDuration: 300,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK\n};\nvar DEFAULT_INERTIA = 300;\n\nvar INERTIA_EASING = function INERTIA_EASING(t) {\n  return 1 - (1 - t) * (1 - t);\n};\n\nvar EVENT_TYPES = {\n  WHEEL: [\'wheel\'],\n  PAN: [\'panstart\', \'panmove\', \'panend\'],\n  PINCH: [\'pinchstart\', \'pinchmove\', \'pinchend\'],\n  TRIPLE_PAN: [\'tripanstart\', \'tripanmove\', \'tripanend\'],\n  DOUBLE_TAP: [\'doubletap\'],\n  KEYBOARD: [\'keydown\']\n};\n\nvar MapController = function () {\n  function MapController() {\n    var _this = this;\n\n    _classCallCheck(this, MapController);\n\n    defineProperty_defineProperty(this, "events", []);\n\n    defineProperty_defineProperty(this, "scrollZoom", true);\n\n    defineProperty_defineProperty(this, "dragPan", true);\n\n    defineProperty_defineProperty(this, "dragRotate", true);\n\n    defineProperty_defineProperty(this, "doubleClickZoom", true);\n\n    defineProperty_defineProperty(this, "touchZoom", true);\n\n    defineProperty_defineProperty(this, "touchRotate", false);\n\n    defineProperty_defineProperty(this, "keyboard", true);\n\n    defineProperty_defineProperty(this, "_interactionState", {\n      isDragging: false\n    });\n\n    defineProperty_defineProperty(this, "_events", {});\n\n    defineProperty_defineProperty(this, "_setInteractionState", function (newState) {\n      Object.assign(_this._interactionState, newState);\n\n      if (_this.onStateChange) {\n        _this.onStateChange(_this._interactionState);\n      }\n    });\n\n    defineProperty_defineProperty(this, "_onTransition", function (newViewport, oldViewport) {\n      _this.onViewportChange(newViewport, _this._interactionState, oldViewport);\n    });\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this._transitionManager = new TransitionManager({\n      onViewportChange: this._onTransition,\n      onStateChange: this._setInteractionState\n    });\n  }\n\n  _createClass(MapController, [{\n    key: "handleEvent",\n    value: function handleEvent(event) {\n      this.mapState = this.getMapState();\n      var eventStartBlocked = this._eventStartBlocked;\n\n      switch (event.type) {\n        case \'panstart\':\n          return eventStartBlocked ? false : this._onPanStart(event);\n\n        case \'panmove\':\n          return this._onPan(event);\n\n        case \'panend\':\n          return this._onPanEnd(event);\n\n        case \'pinchstart\':\n          return eventStartBlocked ? false : this._onPinchStart(event);\n\n        case \'pinchmove\':\n          return this._onPinch(event);\n\n        case \'pinchend\':\n          return this._onPinchEnd(event);\n\n        case \'tripanstart\':\n          return eventStartBlocked ? false : this._onTriplePanStart(event);\n\n        case \'tripanmove\':\n          return this._onTriplePan(event);\n\n        case \'tripanend\':\n          return this._onTriplePanEnd(event);\n\n        case \'doubletap\':\n          return this._onDoubleTap(event);\n\n        case \'wheel\':\n          return this._onWheel(event);\n\n        case \'keydown\':\n          return this._onKeyDown(event);\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: "getCenter",\n    value: function getCenter(event) {\n      var _event$offsetCenter = event.offsetCenter,\n          x = _event$offsetCenter.x,\n          y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: "isFunctionKeyPressed",\n    value: function isFunctionKeyPressed(event) {\n      var srcEvent = event.srcEvent;\n      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n  }, {\n    key: "blockEvents",\n    value: function blockEvents(timeout) {\n      var _this2 = this;\n\n      var timer = setTimeout(function () {\n        if (_this2._eventStartBlocked === timer) {\n          _this2._eventStartBlocked = null;\n        }\n      }, timeout);\n      this._eventStartBlocked = timer;\n    }\n  }, {\n    key: "updateViewport",\n    value: function updateViewport(newMapState, extraProps, interactionState) {\n      var oldViewport = this.mapState instanceof MapState ? this.mapState.getViewportProps() : this.mapState;\n\n      var newViewport = map_controller_objectSpread(map_controller_objectSpread({}, newMapState.getViewportProps()), extraProps);\n\n      var viewStateChanged = Object.keys(newViewport).some(function (key) {\n        return oldViewport[key] !== newViewport[key];\n      });\n      this._state = newMapState.getState();\n\n      this._setInteractionState(interactionState);\n\n      if (viewStateChanged) {\n        this.onViewportChange(newViewport, this._interactionState, oldViewport);\n      }\n    }\n  }, {\n    key: "getMapState",\n    value: function getMapState(overrides) {\n      return new MapState(map_controller_objectSpread(map_controller_objectSpread(map_controller_objectSpread({}, this.mapStateProps), this._state), overrides));\n    }\n  }, {\n    key: "isDragging",\n    value: function isDragging() {\n      return this._interactionState.isDragging;\n    }\n  }, {\n    key: "setOptions",\n    value: function setOptions(options) {\n      var onViewportChange = options.onViewportChange,\n          onStateChange = options.onStateChange,\n          _options$eventManager = options.eventManager,\n          eventManager = _options$eventManager === void 0 ? this.eventManager : _options$eventManager,\n          _options$isInteractiv = options.isInteractive,\n          isInteractive = _options$isInteractiv === void 0 ? true : _options$isInteractiv,\n          _options$scrollZoom = options.scrollZoom,\n          scrollZoom = _options$scrollZoom === void 0 ? this.scrollZoom : _options$scrollZoom,\n          _options$dragPan = options.dragPan,\n          dragPan = _options$dragPan === void 0 ? this.dragPan : _options$dragPan,\n          _options$dragRotate = options.dragRotate,\n          dragRotate = _options$dragRotate === void 0 ? this.dragRotate : _options$dragRotate,\n          _options$doubleClickZ = options.doubleClickZoom,\n          doubleClickZoom = _options$doubleClickZ === void 0 ? this.doubleClickZoom : _options$doubleClickZ,\n          _options$touchZoom = options.touchZoom,\n          touchZoom = _options$touchZoom === void 0 ? this.touchZoom : _options$touchZoom,\n          _options$touchRotate = options.touchRotate,\n          touchRotate = _options$touchRotate === void 0 ? this.touchRotate : _options$touchRotate,\n          _options$keyboard = options.keyboard,\n          keyboard = _options$keyboard === void 0 ? this.keyboard : _options$keyboard;\n      this.onViewportChange = onViewportChange;\n      this.onStateChange = onStateChange;\n      var prevOptions = this.mapStateProps || {};\n      var dimensionChanged = prevOptions.height !== options.height || prevOptions.width !== options.width;\n      this.mapStateProps = options;\n\n      if (dimensionChanged) {\n        this.mapState = prevOptions;\n        this.updateViewport(new MapState(options));\n      }\n\n      this._transitionManager.processViewportChange(options);\n\n      if (this.eventManager !== eventManager) {\n        this.eventManager = eventManager;\n        this._events = {};\n        this.toggleEvents(this.events, true);\n      }\n\n      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && Boolean(scrollZoom));\n      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && Boolean(dragPan || dragRotate));\n      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && Boolean(touchZoom || touchRotate));\n      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && Boolean(touchRotate));\n      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && Boolean(doubleClickZoom));\n      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && Boolean(keyboard));\n      this.scrollZoom = scrollZoom;\n      this.dragPan = dragPan;\n      this.dragRotate = dragRotate;\n      this.doubleClickZoom = doubleClickZoom;\n      this.touchZoom = touchZoom;\n      this.touchRotate = touchRotate;\n      this.keyboard = keyboard;\n    }\n  }, {\n    key: "toggleEvents",\n    value: function toggleEvents(eventNames, enabled) {\n      var _this3 = this;\n\n      if (this.eventManager) {\n        eventNames.forEach(function (eventName) {\n          if (_this3._events[eventName] !== enabled) {\n            _this3._events[eventName] = enabled;\n\n            if (enabled) {\n              _this3.eventManager.on(eventName, _this3.handleEvent);\n            } else {\n              _this3.eventManager.off(eventName, _this3.handleEvent);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: "_onPanStart",\n    value: function _onPanStart(event) {\n      var pos = this.getCenter(event);\n      this._panRotate = this.isFunctionKeyPressed(event) || event.rightButton;\n      var newMapState = this._panRotate ? this.mapState.rotateStart({\n        pos: pos\n      }) : this.mapState.panStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPan",\n    value: function _onPan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      return this._panRotate ? this._onPanRotate(event) : this._onPanMove(event);\n    }\n  }, {\n    key: "_onPanEnd",\n    value: function _onPanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      return this._panRotate ? this._onPanRotateEnd(event) : this._onPanMoveEnd(event);\n    }\n  }, {\n    key: "_onPanMove",\n    value: function _onPanMove(event) {\n      if (!this.dragPan) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.pan({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isPanning: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPanMoveEnd",\n    value: function _onPanMoveEnd(event) {\n      if (this.dragPan) {\n        var _this$dragPan$inertia = this.dragPan.inertia,\n            inertia = _this$dragPan$inertia === void 0 ? DEFAULT_INERTIA : _this$dragPan$inertia;\n\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.pan({\n            pos: endPos\n          }).panEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: true\n          });\n          return true;\n        }\n      }\n\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false\n      });\n      return true;\n    }\n  }, {\n    key: "_onPanRotate",\n    value: function _onPanRotate(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPanRotateEnd",\n    value: function _onPanRotateEnd(event) {\n      if (this.dragRotate) {\n        var _this$dragRotate$iner = this.dragRotate.inertia,\n            inertia = _this$dragRotate$iner === void 0 ? DEFAULT_INERTIA : _this$dragRotate$iner;\n\n        if (inertia && event.velocity) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n          var newControllerState = this.mapState.rotate({\n            pos: endPos\n          }).rotateEnd();\n          this.updateViewport(newControllerState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          return true;\n        }\n      }\n\n      var newMapState = this.mapState.panEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: "_onWheel",\n    value: function _onWheel(event) {\n      if (!this.scrollZoom) {\n        return false;\n      }\n\n      var _this$scrollZoom = this.scrollZoom,\n          _this$scrollZoom$spee = _this$scrollZoom.speed,\n          speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee,\n          _this$scrollZoom$smoo = _this$scrollZoom.smooth,\n          smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;\n      event.preventDefault();\n      var pos = this.getCenter(event);\n      var delta = event.delta;\n      var scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));\n\n      if (delta < 0 && scale !== 0) {\n        scale = 1 / scale;\n      }\n\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      this.updateViewport(newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        }),\n        transitionDuration: smooth ? 250 : 1\n      }), {\n        isPanning: true,\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPinchStart",\n    value: function _onPinchStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.zoomStart({\n        pos: pos\n      }).rotateStart({\n        pos: pos\n      });\n      this._startPinchRotation = event.rotation;\n      this._lastPinchEvent = event;\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onPinch",\n    value: function _onPinch(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (!this.touchZoom && !this.touchRotate) {\n        return false;\n      }\n\n      var newMapState = this.mapState;\n\n      if (this.touchZoom) {\n        var scale = event.scale;\n        var pos = this.getCenter(event);\n        newMapState = newMapState.zoom({\n          pos: pos,\n          scale: scale\n        });\n      }\n\n      if (this.touchRotate) {\n        var rotation = event.rotation;\n        newMapState = newMapState.rotate({\n          deltaAngleX: this._startPinchRotation - rotation\n        });\n      }\n\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true,\n        isPanning: Boolean(this.touchZoom),\n        isZooming: Boolean(this.touchZoom),\n        isRotating: Boolean(this.touchRotate)\n      });\n      this._lastPinchEvent = event;\n      return true;\n    }\n  }, {\n    key: "_onPinchEnd",\n    value: function _onPinchEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (this.touchZoom) {\n        var _this$touchZoom$inert = this.touchZoom.inertia,\n            inertia = _this$touchZoom$inert === void 0 ? DEFAULT_INERTIA : _this$touchZoom$inert;\n        var _lastPinchEvent = this._lastPinchEvent;\n\n        if (inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {\n          var pos = this.getCenter(event);\n\n          var _newMapState = this.mapState.rotateEnd();\n\n          var z = Math.log2(event.scale);\n\n          var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);\n\n          var endScale = Math.pow(2, z + velocityZ * inertia / 2);\n          _newMapState = _newMapState.zoom({\n            pos: pos,\n            scale: endScale\n          }).zoomEnd();\n          this.updateViewport(_newMapState, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionInterpolator: new LinearInterpolator({\n              around: pos\n            }),\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isPanning: Boolean(this.touchZoom),\n            isZooming: Boolean(this.touchZoom),\n            isRotating: false\n          });\n          this.blockEvents(inertia);\n          return true;\n        }\n      }\n\n      var newMapState = this.mapState.zoomEnd().rotateEnd();\n      this._state.startPinchRotation = 0;\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isPanning: false,\n        isZooming: false,\n        isRotating: false\n      });\n      this._startPinchRotation = null;\n      this._lastPinchEvent = null;\n      return true;\n    }\n  }, {\n    key: "_onTriplePanStart",\n    value: function _onTriplePanStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.rotateStart({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isDragging: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onTriplePan",\n    value: function _onTriplePan(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (!this.touchRotate) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      pos[0] -= event.deltaX;\n      var newMapState = this.mapState.rotate({\n        pos: pos\n      });\n      this.updateViewport(newMapState, NO_TRANSITION_PROPS, {\n        isRotating: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onTriplePanEnd",\n    value: function _onTriplePanEnd(event) {\n      if (!this.isDragging()) {\n        return false;\n      }\n\n      if (this.touchRotate) {\n        var _this$touchRotate$ine = this.touchRotate.inertia,\n            inertia = _this$touchRotate$ine === void 0 ? DEFAULT_INERTIA : _this$touchRotate$ine;\n\n        if (inertia && event.velocityY) {\n          var pos = this.getCenter(event);\n          var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];\n\n          var _newMapState2 = this.mapState.rotate({\n            pos: endPos\n          });\n\n          this.updateViewport(_newMapState2, map_controller_objectSpread(map_controller_objectSpread({}, LINEAR_TRANSITION_PROPS), {}, {\n            transitionDuration: inertia,\n            transitionEasing: INERTIA_EASING\n          }), {\n            isDragging: false,\n            isRotating: true\n          });\n          this.blockEvents(inertia);\n          return false;\n        }\n      }\n\n      var newMapState = this.mapState.rotateEnd();\n      this.updateViewport(newMapState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n      return true;\n    }\n  }, {\n    key: "_onDoubleTap",\n    value: function _onDoubleTap(event) {\n      if (!this.doubleClickZoom) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var isZoomOut = this.isFunctionKeyPressed(event);\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: isZoomOut ? 0.5 : 2\n      });\n      this.updateViewport(newMapState, Object.assign({}, LINEAR_TRANSITION_PROPS, {\n        transitionInterpolator: new LinearInterpolator({\n          around: pos\n        })\n      }), {\n        isZooming: true\n      });\n      return true;\n    }\n  }, {\n    key: "_onKeyDown",\n    value: function _onKeyDown(event) {\n      if (!this.keyboard) {\n        return false;\n      }\n\n      var funcKey = this.isFunctionKeyPressed(event);\n      var _this$keyboard = this.keyboard,\n          _this$keyboard$zoomSp = _this$keyboard.zoomSpeed,\n          zoomSpeed = _this$keyboard$zoomSp === void 0 ? 2 : _this$keyboard$zoomSp,\n          _this$keyboard$moveSp = _this$keyboard.moveSpeed,\n          moveSpeed = _this$keyboard$moveSp === void 0 ? 100 : _this$keyboard$moveSp,\n          _this$keyboard$rotate = _this$keyboard.rotateSpeedX,\n          rotateSpeedX = _this$keyboard$rotate === void 0 ? 15 : _this$keyboard$rotate,\n          _this$keyboard$rotate2 = _this$keyboard.rotateSpeedY,\n          rotateSpeedY = _this$keyboard$rotate2 === void 0 ? 10 : _this$keyboard$rotate2;\n      var mapStateProps = this.mapStateProps;\n      var newMapState;\n\n      switch (event.srcEvent.keyCode) {\n        case 189:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed) - 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom - Math.log2(zoomSpeed)\n            });\n          }\n\n          break;\n\n        case 187:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed) + 1\n            });\n          } else {\n            newMapState = this.getMapState({\n              zoom: mapStateProps.zoom + Math.log2(zoomSpeed)\n            });\n          }\n\n          break;\n\n        case 37:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing - rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        case 39:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              bearing: mapStateProps.bearing + rotateSpeedX\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [-moveSpeed, 0],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        case 38:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch + rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        case 40:\n          if (funcKey) {\n            newMapState = this.getMapState({\n              pitch: mapStateProps.pitch - rotateSpeedY\n            });\n          } else {\n            newMapState = this.mapState.pan({\n              pos: [0, -moveSpeed],\n              startPos: [0, 0]\n            });\n          }\n\n          break;\n\n        default:\n          return false;\n      }\n\n      return this.updateViewport(newMapState, LINEAR_TRANSITION_PROPS);\n    }\n  }]);\n\n  return MapController;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/interactive-map.js\n\n\n\n\nfunction interactive_map_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction interactive_map_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      interactive_map_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      interactive_map_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvar interactive_map_propTypes = Object.assign({}, static_map.propTypes, {\n  maxZoom: prop_types.number,\n  minZoom: prop_types.number,\n  maxPitch: prop_types.number,\n  minPitch: prop_types.number,\n  onViewStateChange: prop_types.func,\n  onViewportChange: prop_types.func,\n  onInteractionStateChange: prop_types.func,\n  transitionDuration: prop_types.oneOfType([prop_types.number, prop_types.string]),\n  transitionInterpolator: prop_types.object,\n  transitionInterruption: prop_types.number,\n  transitionEasing: prop_types.func,\n  onTransitionStart: prop_types.func,\n  onTransitionInterrupt: prop_types.func,\n  onTransitionEnd: prop_types.func,\n  scrollZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragPan: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  dragRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  doubleClickZoom: prop_types.bool,\n  touchZoom: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  touchRotate: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  keyboard: prop_types.oneOfType([prop_types.bool, prop_types.object]),\n  onHover: prop_types.func,\n  onClick: prop_types.func,\n  onDblClick: prop_types.func,\n  onContextMenu: prop_types.func,\n  onMouseDown: prop_types.func,\n  onMouseMove: prop_types.func,\n  onMouseUp: prop_types.func,\n  onTouchStart: prop_types.func,\n  onTouchMove: prop_types.func,\n  onTouchEnd: prop_types.func,\n  onMouseEnter: prop_types.func,\n  onMouseLeave: prop_types.func,\n  onMouseOut: prop_types.func,\n  onWheel: prop_types.func,\n  touchAction: prop_types.string,\n  eventRecognizerOptions: prop_types.object,\n  clickRadius: prop_types.number,\n  interactiveLayerIds: prop_types.array,\n  getCursor: prop_types.func,\n  controller: prop_types.instanceOf(MapController)\n});\n\nvar getDefaultCursor = function getDefaultCursor(_ref) {\n  var isDragging = _ref.isDragging,\n      isHovering = _ref.isHovering;\n  return isDragging ? \'grabbing\' : isHovering ? \'pointer\' : \'grab\';\n};\n\nvar interactive_map_defaultProps = Object.assign({}, static_map.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {\n  onViewStateChange: null,\n  onViewportChange: null,\n  onClick: null,\n  onNativeClick: null,\n  onHover: null,\n  onContextMenu: function onContextMenu(event) {\n    return event.preventDefault();\n  },\n  scrollZoom: true,\n  dragPan: true,\n  dragRotate: true,\n  doubleClickZoom: true,\n  touchZoom: true,\n  touchRotate: false,\n  keyboard: true,\n  touchAction: \'none\',\n  eventRecognizerOptions: {},\n  clickRadius: 0,\n  getCursor: getDefaultCursor\n});\n\nfunction normalizeEvent(event) {\n  if (event.lngLat || !event.offsetCenter) {\n    return event;\n  }\n\n  var _event$offsetCenter = event.offsetCenter,\n      x = _event$offsetCenter.x,\n      y = _event$offsetCenter.y;\n\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return event;\n  }\n\n  var pos = [x, y];\n  event.point = pos;\n  var viewport = this.viewport;\n  var location = viewport.unproject(pos, {\n    targetZ: viewport.meterOffset[2]\n  });\n  event.lngLat = [location[0], location[1]];\n  return event;\n}\n\nfunction getFeatures(pos) {\n  var map = this.map;\n\n  if (!map || !pos) {\n    return null;\n  }\n\n  var queryParams = {};\n  var size = this.props.clickRadius;\n\n  if (this.props.interactiveLayerIds) {\n    queryParams.layers = this.props.interactiveLayerIds;\n  }\n\n  try {\n    return map.queryRenderedFeatures(size ? [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]] : pos, queryParams);\n  } catch (_unused) {\n    return null;\n  }\n}\n\nfunction onEvent(callbackName, event) {\n  var func = this.props[callbackName];\n\n  if (func) {\n    func(normalizeEvent.call(this, event));\n  }\n}\n\nfunction onPointerDown(event) {\n  onEvent.call(this, event.pointerType === \'touch\' ? \'onTouchStart\' : \'onMouseDown\', event);\n}\n\nfunction onPointerUp(event) {\n  onEvent.call(this, event.pointerType === \'touch\' ? \'onTouchEnd\' : \'onMouseUp\', event);\n}\n\nfunction onPointerMove(event) {\n  onEvent.call(this, event.pointerType === \'touch\' ? \'onTouchMove\' : \'onMouseMove\', event);\n\n  if (!this.state.isDragging) {\n    var _this$props = this.props,\n        onHover = _this$props.onHover,\n        interactiveLayerIds = _this$props.interactiveLayerIds;\n    var features;\n    event = normalizeEvent.call(this, event);\n\n    if (interactiveLayerIds || onHover) {\n      features = getFeatures.call(this, event.point);\n    }\n\n    var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);\n    var isEntering = isHovering && !this.state.isHovering;\n    var isExiting = !isHovering && this.state.isHovering;\n\n    if (onHover || isEntering) {\n      event.features = features;\n\n      if (onHover) {\n        onHover(event);\n      }\n    }\n\n    if (isEntering) {\n      onEvent.call(this, \'onMouseEnter\', event);\n    }\n\n    if (isExiting) {\n      onEvent.call(this, \'onMouseLeave\', event);\n    }\n\n    if (isEntering || isExiting) {\n      this.setState({\n        isHovering: isHovering\n      });\n    }\n  }\n}\n\nfunction onPointerClick(event) {\n  var _this$props2 = this.props,\n      onClick = _this$props2.onClick,\n      onNativeClick = _this$props2.onNativeClick,\n      onDblClick = _this$props2.onDblClick,\n      doubleClickZoom = _this$props2.doubleClickZoom;\n  var callbacks = [];\n  var isDoubleClickEnabled = onDblClick || doubleClickZoom;\n\n  switch (event.type) {\n    case \'anyclick\':\n      callbacks.push(onNativeClick);\n\n      if (!isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n\n      break;\n\n    case \'click\':\n      if (isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n\n      break;\n\n    default:\n  }\n\n  callbacks = callbacks.filter(Boolean);\n\n  if (callbacks.length) {\n    event = normalizeEvent.call(this, event);\n    event.features = getFeatures.call(this, event.point);\n    callbacks.forEach(function (cb) {\n      return cb(event);\n    });\n  }\n}\n\nfunction interactive_map_getRefHandles(staticMapRef) {\n  return {\n    getMap: staticMapRef.current && staticMapRef.current.getMap,\n    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures\n  };\n}\n\nvar InteractiveMap = (0,react.forwardRef)(function (props, ref) {\n  var parentContext = (0,react.useContext)(map_context);\n  var controller = (0,react.useMemo)(function () {\n    return props.controller || new MapController();\n  }, []);\n  var eventManager = (0,react.useMemo)(function () {\n    return new EventManager(null, {\n      touchAction: props.touchAction,\n      recognizerOptions: props.eventRecognizerOptions\n    });\n  }, []);\n  var eventCanvasRef = (0,react.useRef)(null);\n  var staticMapRef = (0,react.useRef)(null);\n\n  var _thisRef = (0,react.useRef)({\n    width: 0,\n    height: 0,\n    state: {\n      isHovering: false,\n      isDragging: false\n    }\n  });\n\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();\n\n  thisRef.setState = function (newState) {\n    thisRef.state = interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.state), newState);\n    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);\n  };\n\n  var inRender = true;\n  var viewportUpdateRequested;\n  var stateUpdateRequested;\n\n  var handleViewportChange = function handleViewportChange(viewState, interactionState, oldViewState) {\n    if (inRender) {\n      viewportUpdateRequested = [viewState, interactionState, oldViewState];\n      return;\n    }\n\n    var _thisRef$props = thisRef.props,\n        onViewStateChange = _thisRef$props.onViewStateChange,\n        onViewportChange = _thisRef$props.onViewportChange;\n    Object.defineProperty(viewState, \'position\', {\n      get: function get() {\n        return [0, 0, getTerrainElevation(thisRef.map, viewState)];\n      }\n    });\n\n    if (onViewStateChange) {\n      onViewStateChange({\n        viewState: viewState,\n        interactionState: interactionState,\n        oldViewState: oldViewState\n      });\n    }\n\n    if (onViewportChange) {\n      onViewportChange(viewState, interactionState, oldViewState);\n    }\n  };\n\n  (0,react.useImperativeHandle)(ref, function () {\n    return interactive_map_getRefHandles(staticMapRef);\n  }, []);\n  var context = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({}, parentContext), {}, {\n      eventManager: eventManager,\n      container: parentContext.container || eventCanvasRef.current\n    });\n  }, [parentContext, eventCanvasRef.current]);\n  context.onViewportChange = handleViewportChange;\n  context.viewport = parentContext.viewport || getViewport(thisRef);\n  thisRef.viewport = context.viewport;\n\n  var handleInteractionStateChange = function handleInteractionStateChange(interactionState) {\n    var _interactionState$isD = interactionState.isDragging,\n        isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;\n\n    if (isDragging !== thisRef.state.isDragging) {\n      thisRef.setState({\n        isDragging: isDragging\n      });\n    }\n\n    if (inRender) {\n      stateUpdateRequested = interactionState;\n      return;\n    }\n\n    var onInteractionStateChange = thisRef.props.onInteractionStateChange;\n\n    if (onInteractionStateChange) {\n      onInteractionStateChange(interactionState);\n    }\n  };\n\n  var updateControllerOpts = function updateControllerOpts() {\n    if (thisRef.width && thisRef.height) {\n      controller.setOptions(interactive_map_objectSpread(interactive_map_objectSpread(interactive_map_objectSpread({}, thisRef.props), thisRef.props.viewState), {}, {\n        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),\n        onViewportChange: handleViewportChange,\n        onStateChange: handleInteractionStateChange,\n        eventManager: eventManager,\n        width: thisRef.width,\n        height: thisRef.height\n      }));\n    }\n  };\n\n  var onResize = function onResize(_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    thisRef.width = width;\n    thisRef.height = height;\n    updateControllerOpts();\n    thisRef.props.onResize({\n      width: width,\n      height: height\n    });\n  };\n\n  (0,react.useEffect)(function () {\n    eventManager.setElement(eventCanvasRef.current);\n    eventManager.on({\n      pointerdown: onPointerDown.bind(thisRef),\n      pointermove: onPointerMove.bind(thisRef),\n      pointerup: onPointerUp.bind(thisRef),\n      pointerleave: onEvent.bind(thisRef, \'onMouseOut\'),\n      click: onPointerClick.bind(thisRef),\n      anyclick: onPointerClick.bind(thisRef),\n      dblclick: onEvent.bind(thisRef, \'onDblClick\'),\n      wheel: onEvent.bind(thisRef, \'onWheel\'),\n      contextmenu: onEvent.bind(thisRef, \'onContextMenu\')\n    });\n    return function () {\n      eventManager.destroy();\n    };\n  }, []);\n  use_isomorphic_layout_effect(function () {\n    if (viewportUpdateRequested) {\n      handleViewportChange.apply(void 0, (0,toConsumableArray/* default */.Z)(viewportUpdateRequested));\n    }\n\n    if (stateUpdateRequested) {\n      handleInteractionStateChange(stateUpdateRequested);\n    }\n  });\n  updateControllerOpts();\n  var width = props.width,\n      height = props.height,\n      style = props.style,\n      getCursor = props.getCursor;\n  var eventCanvasStyle = (0,react.useMemo)(function () {\n    return interactive_map_objectSpread(interactive_map_objectSpread({\n      position: \'relative\'\n    }, style), {}, {\n      width: width,\n      height: height,\n      cursor: getCursor(thisRef.state)\n    });\n  }, [style, width, height, getCursor, thisRef.state]);\n\n  if (!viewportUpdateRequested || !thisRef._child) {\n    thisRef._child = react.createElement(MapContextProvider, {\n      value: context\n    }, react.createElement("div", {\n      key: "event-canvas",\n      ref: eventCanvasRef,\n      style: eventCanvasStyle\n    }, react.createElement(static_map, _extends({}, props, {\n      width: "100%",\n      height: "100%",\n      style: null,\n      onResize: onResize,\n      ref: staticMapRef\n    }))));\n  }\n\n  inRender = false;\n  return thisRef._child;\n});\nInteractiveMap.supported = static_map.supported;\nInteractiveMap.propTypes = interactive_map_propTypes;\nInteractiveMap.defaultProps = interactive_map_defaultProps;\n/* harmony default export */ var interactive_map = (InteractiveMap);\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/source.js\n\n\n\nfunction source_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction source_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      source_ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      source_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\nvar sourceCounter = 0;\n\nfunction createSource(map, id, props) {\n  if (map.style && map.style._loaded) {\n    var options = source_objectSpread({}, props);\n\n    delete options.id;\n    delete options.children;\n    map.addSource(id, options);\n    return map.getSource(id);\n  }\n\n  return null;\n}\n\nfunction updateSource(source, props, prevProps) {\n  assert(props.id === prevProps.id, \'source id changed\');\n  assert(props.type === prevProps.type, \'source type changed\');\n  var changedKey = \'\';\n  var changedKeyCount = 0;\n\n  for (var key in props) {\n    if (key !== \'children\' && key !== \'id\' && !deepEqual(prevProps[key], props[key])) {\n      changedKey = key;\n      changedKeyCount++;\n    }\n  }\n\n  if (!changedKeyCount) {\n    return;\n  }\n\n  var type = props.type;\n\n  if (type === \'geojson\') {\n    source.setData(props.data);\n  } else if (type === \'image\') {\n    source.updateImage({\n      url: props.url,\n      coordinates: props.coordinates\n    });\n  } else if ((type === \'canvas\' || type === \'video\') && changedKeyCount === 1 && changedKey === \'coordinates\') {\n    source.setCoordinates(props.coordinates);\n  } else if (type === \'vector\' && source.setUrl) {\n    switch (changedKey) {\n      case \'url\':\n        source.setUrl(props.url);\n        break;\n\n      case \'tiles\':\n        source.setTiles(props.tiles);\n        break;\n\n      default:\n    }\n  } else {\n    console.warn("Unable to update <Source> prop: ".concat(changedKey));\n  }\n}\n\nfunction Source(props) {\n  var context = useContext(MapContext);\n  var propsRef = useRef({\n    id: props.id,\n    type: props.type\n  });\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      setStyleLoaded = _useState2[1];\n\n  var id = useMemo(function () {\n    return props.id || "jsx-source-".concat(sourceCounter++);\n  }, []);\n  var map = context.map;\n  useEffect(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n\n      map.on(\'styledata\', forceUpdate);\n      return function () {\n        map.off(\'styledata\', forceUpdate);\n        requestAnimationFrame(function () {\n          if (map.style && map.style._loaded && map.getSource(id)) {\n            map.removeSource(id);\n          }\n        });\n      };\n    }\n\n    return undefined;\n  }, [map, id]);\n  var source = map && map.style && map.getSource(id);\n\n  if (source) {\n    updateSource(source, props, propsRef.current);\n  } else {\n    source = createSource(map, id, props);\n  }\n\n  propsRef.current = props;\n  return source && React.Children.map(props.children, function (child) {\n    return child && cloneElement(child, {\n      source: id\n    });\n  }) || null;\n}\n\n/* harmony default export */ var source = ((/* unused pure expression or super */ null && (Source)));\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/deep-equal.js\n\nfunction deep_equal_deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n      if (!deep_equal_deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (Array.isArray(b)) {\n    return false;\n  }\n\n  if (_typeof(a) === \'object\' && _typeof(b) === \'object\') {\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {\n      var key = _aKeys[_i];\n\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n\n      if (!deep_equal_deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/layer.js\n\n\n\n\nfunction layer_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction layer_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      layer_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      layer_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\nvar LAYER_TYPES = [\'fill\', \'line\', \'symbol\', \'circle\', \'fill-extrusion\', \'raster\', \'background\', \'heatmap\', \'hillshade\', \'sky\'];\nvar layer_propTypes = {\n  type: prop_types.oneOf(LAYER_TYPES).isRequired,\n  id: prop_types.string,\n  source: prop_types.string,\n  beforeId: prop_types.string\n};\n\nfunction diffLayerStyles(map, id, props, prevProps) {\n  var _props$layout = props.layout,\n      layout = _props$layout === void 0 ? {} : _props$layout,\n      _props$paint = props.paint,\n      paint = _props$paint === void 0 ? {} : _props$paint,\n      filter = props.filter,\n      minzoom = props.minzoom,\n      maxzoom = props.maxzoom,\n      beforeId = props.beforeId,\n      otherProps = _objectWithoutProperties(props, ["layout", "paint", "filter", "minzoom", "maxzoom", "beforeId"]);\n\n  if (beforeId !== prevProps.beforeId) {\n    map.moveLayer(id, beforeId);\n  }\n\n  if (layout !== prevProps.layout) {\n    var prevLayout = prevProps.layout || {};\n\n    for (var key in layout) {\n      if (!deep_equal_deepEqual(layout[key], prevLayout[key])) {\n        map.setLayoutProperty(id, key, layout[key]);\n      }\n    }\n\n    for (var _key in prevLayout) {\n      if (!layout.hasOwnProperty(_key)) {\n        map.setLayoutProperty(id, _key, undefined);\n      }\n    }\n  }\n\n  if (paint !== prevProps.paint) {\n    var prevPaint = prevProps.paint || {};\n\n    for (var _key2 in paint) {\n      if (!deep_equal_deepEqual(paint[_key2], prevPaint[_key2])) {\n        map.setPaintProperty(id, _key2, paint[_key2]);\n      }\n    }\n\n    for (var _key3 in prevPaint) {\n      if (!paint.hasOwnProperty(_key3)) {\n        map.setPaintProperty(id, _key3, undefined);\n      }\n    }\n  }\n\n  if (!deep_equal_deepEqual(filter, prevProps.filter)) {\n    map.setFilter(id, filter);\n  }\n\n  if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {\n    map.setLayerZoomRange(id, minzoom, maxzoom);\n  }\n\n  for (var _key4 in otherProps) {\n    if (!deep_equal_deepEqual(otherProps[_key4], prevProps[_key4])) {\n      map.setLayerProperty(id, _key4, otherProps[_key4]);\n    }\n  }\n}\n\nfunction createLayer(map, id, props) {\n  if (map.style && map.style._loaded) {\n    var options = layer_objectSpread(layer_objectSpread({}, props), {}, {\n      id: id\n    });\n\n    delete options.beforeId;\n    map.addLayer(options, props.beforeId);\n  }\n}\n\nfunction updateLayer(map, id, props, prevProps) {\n  utils_assert_assert(props.id === prevProps.id, \'layer id changed\');\n  utils_assert_assert(props.type === prevProps.type, \'layer type changed\');\n\n  try {\n    diffLayerStyles(map, id, props, prevProps);\n  } catch (error) {\n    console.warn(error);\n  }\n}\n\nvar layerCounter = 0;\n\nfunction Layer(props) {\n  var context = (0,react.useContext)(map_context);\n  var propsRef = (0,react.useRef)({\n    id: props.id,\n    type: props.type\n  });\n\n  var _useState = (0,react.useState)(0),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      setStyleLoaded = _useState2[1];\n\n  var id = (0,react.useMemo)(function () {\n    return props.id || "jsx-layer-".concat(layerCounter++);\n  }, []);\n  var map = context.map;\n  (0,react.useEffect)(function () {\n    if (map) {\n      var forceUpdate = function forceUpdate() {\n        return setStyleLoaded(function (version) {\n          return version + 1;\n        });\n      };\n\n      map.on(\'styledata\', forceUpdate);\n      return function () {\n        map.off(\'styledata\', forceUpdate);\n\n        if (map.style && map.style._loaded) {\n          map.removeLayer(id);\n        }\n      };\n    }\n\n    return undefined;\n  }, [map]);\n  var layer = map && map.style && map.getLayer(id);\n\n  if (layer) {\n    updateLayer(map, id, props, propsRef.current);\n  } else {\n    createLayer(map, id, props);\n  }\n\n  propsRef.current = props;\n  return null;\n}\n\nLayer.propTypes = layer_propTypes;\n/* harmony default export */ var components_layer = ((/* unused pure expression or super */ null && (Layer)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/use-map-control.js\n\n\n\nvar mapControlDefaultProps = {\n  captureScroll: false,\n  captureDrag: true,\n  captureClick: true,\n  captureDoubleClick: true,\n  capturePointerMove: false\n};\nvar mapControlPropTypes = {\n  captureScroll: prop_types.bool,\n  captureDrag: prop_types.bool,\n  captureClick: prop_types.bool,\n  captureDoubleClick: prop_types.bool,\n  capturePointerMove: prop_types.bool\n};\n\nfunction onMount(thisRef) {\n  var ref = thisRef.containerRef.current;\n  var eventManager = thisRef.context.eventManager;\n\n  if (!ref || !eventManager) {\n    return undefined;\n  }\n\n  var events = {\n    wheel: function wheel(evt) {\n      var props = thisRef.props;\n\n      if (props.captureScroll) {\n        evt.stopPropagation();\n      }\n\n      if (props.onScroll) {\n        props.onScroll(evt, thisRef);\n      }\n    },\n    panstart: function panstart(evt) {\n      var props = thisRef.props;\n\n      if (props.captureDrag) {\n        evt.stopPropagation();\n      }\n\n      if (props.onDragStart) {\n        props.onDragStart(evt, thisRef);\n      }\n    },\n    anyclick: function anyclick(evt) {\n      var props = thisRef.props;\n\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n\n      if (props.onClick) {\n        props.onClick(evt, thisRef);\n      }\n    },\n    click: function click(evt) {\n      var props = thisRef.props;\n\n      if (props.captureClick) {\n        evt.stopPropagation();\n      }\n\n      if (props.onClick) {\n        props.onClick(evt, thisRef);\n      }\n    },\n    dblclick: function dblclick(evt) {\n      var props = thisRef.props;\n\n      if (props.captureDoubleClick) {\n        evt.stopPropagation();\n      }\n\n      if (props.onDoubleClick) {\n        props.onDoubleClick(evt, thisRef);\n      }\n    },\n    pointermove: function pointermove(evt) {\n      var props = thisRef.props;\n\n      if (props.capturePointerMove) {\n        evt.stopPropagation();\n      }\n\n      if (props.onPointerMove) {\n        props.onPointerMove(evt, thisRef);\n      }\n    }\n  };\n  eventManager.watch(events, ref);\n  return function () {\n    eventManager.off(events);\n  };\n}\n\nfunction useMapControl() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var context = (0,react.useContext)(map_context);\n  var containerRef = (0,react.useRef)(null);\n\n  var _thisRef = (0,react.useRef)({\n    props: props,\n    state: {},\n    context: context,\n    containerRef: containerRef\n  });\n\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.context = context;\n  (0,react.useEffect)(function () {\n    return onMount(thisRef);\n  }, [context.eventManager]);\n  return thisRef;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/base-control.js\n\n\n\n\n\n\n\n\n\nfunction base_control_createSuper(Derived) {\n  var hasNativeReflectConstruct = base_control_isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction base_control_isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n\n\n\nfunction Control(props) {\n  var instance = props.instance;\n\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  instance._context = context;\n  instance._containerRef = containerRef;\n  return instance._render();\n}\n\nvar BaseControl = function (_PureComponent) {\n  _inherits(BaseControl, _PureComponent);\n\n  var _super = base_control_createSuper(BaseControl);\n\n  function BaseControl() {\n    var _this;\n\n    _classCallCheck(this, BaseControl);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_context", {});\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_containerRef", (0,react.createRef)());\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_onScroll", function (evt) {});\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_onDragStart", function (evt) {});\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_onDblClick", function (evt) {});\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_onClick", function (evt) {});\n\n    defineProperty_defineProperty(_assertThisInitialized(_this), "_onPointerMove", function (evt) {});\n\n    return _this;\n  }\n\n  _createClass(BaseControl, [{\n    key: "_render",\n    value: function _render() {\n      throw new Error(\'_render() not implemented\');\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return react.createElement(Control, _extends({\n        instance: this\n      }, this.props, {\n        onScroll: this._onScroll,\n        onDragStart: this._onDragStart,\n        onDblClick: this._onDblClick,\n        onClick: this._onClick,\n        onPointerMove: this._onPointerMove\n      }));\n    }\n  }]);\n\n  return BaseControl;\n}(react.PureComponent);\n\ndefineProperty_defineProperty(BaseControl, "propTypes", mapControlPropTypes);\n\ndefineProperty_defineProperty(BaseControl, "defaultProps", mapControlDefaultProps);\n\n\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/draggable-control.js\n\n\n\nfunction draggable_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction draggable_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      draggable_control_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      draggable_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\nvar draggableControlPropTypes = Object.assign({}, mapControlPropTypes, {\n  draggable: prop_types.bool,\n  onDrag: prop_types.func,\n  onDragEnd: prop_types.func,\n  onDragStart: prop_types.func,\n  offsetLeft: prop_types.number,\n  offsetTop: prop_types.number\n});\nvar draggableControlDefaultProps = Object.assign({}, mapControlDefaultProps, {\n  draggable: false,\n  offsetLeft: 0,\n  offsetTop: 0\n});\n\nfunction getDragEventPosition(event) {\n  var _event$offsetCenter = event.offsetCenter,\n      x = _event$offsetCenter.x,\n      y = _event$offsetCenter.y;\n  return [x, y];\n}\n\nfunction getDragEventOffset(event, container) {\n  var _event$center = event.center,\n      x = _event$center.x,\n      y = _event$center.y;\n\n  if (container) {\n    var rect = container.getBoundingClientRect();\n    return [rect.left - x, rect.top - y];\n  }\n\n  return null;\n}\n\nfunction getDragLngLat(dragPos, dragOffset, props, context) {\n  var x = dragPos[0] + dragOffset[0] - props.offsetLeft;\n  var y = dragPos[1] + dragOffset[1] - props.offsetTop;\n  return context.viewport.unproject([x, y]);\n}\n\nfunction onDragStart(event, _ref) {\n  var props = _ref.props,\n      callbacks = _ref.callbacks,\n      state = _ref.state,\n      context = _ref.context,\n      containerRef = _ref.containerRef;\n  var draggable = props.draggable;\n\n  if (!draggable) {\n    return;\n  }\n\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  var dragOffset = getDragEventOffset(event, containerRef.current);\n  state.setDragPos(dragPos);\n  state.setDragOffset(dragOffset);\n\n  if (callbacks.onDragStart && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragStart(callbackEvent);\n  }\n}\n\nfunction onDrag(event, _ref2) {\n  var props = _ref2.props,\n      callbacks = _ref2.callbacks,\n      state = _ref2.state,\n      context = _ref2.context;\n  event.stopPropagation();\n  var dragPos = getDragEventPosition(event);\n  state.setDragPos(dragPos);\n  var dragOffset = state.dragOffset;\n\n  if (callbacks.onDrag && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDrag(callbackEvent);\n  }\n}\n\nfunction onDragEnd(event, _ref3) {\n  var props = _ref3.props,\n      callbacks = _ref3.callbacks,\n      state = _ref3.state,\n      context = _ref3.context;\n  event.stopPropagation();\n  var dragPos = state.dragPos,\n      dragOffset = state.dragOffset;\n  state.setDragPos(null);\n  state.setDragOffset(null);\n\n  if (callbacks.onDragEnd && dragPos && dragOffset) {\n    var callbackEvent = Object.assign({}, event);\n    callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);\n    callbacks.onDragEnd(callbackEvent);\n  }\n}\n\nfunction onDragCancel(event, _ref4) {\n  var state = _ref4.state;\n  event.stopPropagation();\n  state.setDragPos(null);\n  state.setDragOffset(null);\n}\n\nfunction registerEvents(thisRef) {\n  var eventManager = thisRef.context.eventManager;\n\n  if (!eventManager || !thisRef.state.dragPos) {\n    return undefined;\n  }\n\n  var events = {\n    panmove: function panmove(evt) {\n      return onDrag(evt, thisRef);\n    },\n    panend: function panend(evt) {\n      return onDragEnd(evt, thisRef);\n    },\n    pancancel: function pancancel(evt) {\n      return onDragCancel(evt, thisRef);\n    }\n  };\n  eventManager.watch(events);\n  return function () {\n    eventManager.off(events);\n  };\n}\n\nfunction useDraggableControl(props) {\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      dragPos = _useState2[0],\n      setDragPos = _useState2[1];\n\n  var _useState3 = (0,react.useState)(null),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      dragOffset = _useState4[0],\n      setDragOffset = _useState4[1];\n\n  var thisRef = useMapControl(draggable_control_objectSpread(draggable_control_objectSpread({}, props), {}, {\n    onDragStart: onDragStart\n  }));\n  thisRef.callbacks = props;\n  thisRef.state.dragPos = dragPos;\n  thisRef.state.setDragPos = setDragPos;\n  thisRef.state.dragOffset = dragOffset;\n  thisRef.state.setDragOffset = setDragOffset;\n  (0,react.useEffect)(function () {\n    return registerEvents(thisRef);\n  }, [thisRef.context.eventManager, Boolean(dragPos)]);\n  return thisRef;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/crisp-pixel.js\nvar pixelRatio = typeof window !== \'undefined\' && window.devicePixelRatio || 1;\nvar crispPixel = function crispPixel(size) {\n  return Math.round(size * pixelRatio) / pixelRatio;\n};\nvar crispPercentage = function crispPercentage(el, percentage) {\n  var dimension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'x\';\n\n  if (el === null) {\n    return percentage;\n  }\n\n  var origSize = dimension === \'x\' ? el.offsetWidth : el.offsetHeight;\n  return crispPixel(percentage / 100 * origSize) / origSize * 100;\n};\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/marker.js\n\n\n\n\n\n\nvar marker_defaultProps = Object.assign({}, draggableControlDefaultProps, {\n  className: \'\'\n});\n\nfunction getPosition(_ref) {\n  var props = _ref.props,\n      state = _ref.state,\n      context = _ref.context;\n  var longitude = props.longitude,\n      latitude = props.latitude,\n      offsetLeft = props.offsetLeft,\n      offsetTop = props.offsetTop;\n  var dragPos = state.dragPos,\n      dragOffset = state.dragOffset;\n  var viewport = context.viewport,\n      map = context.map;\n\n  if (dragPos && dragOffset) {\n    return [dragPos[0] + dragOffset[0], dragPos[1] + dragOffset[1]];\n  }\n\n  var altitude = getTerrainElevation(map, {\n    longitude: longitude,\n    latitude: latitude\n  });\n\n  var _viewport$project = viewport.project([longitude, latitude, altitude]),\n      _viewport$project2 = slicedToArray_slicedToArray(_viewport$project, 2),\n      x = _viewport$project2[0],\n      y = _viewport$project2[1];\n\n  x += offsetLeft;\n  y += offsetTop;\n  return [x, y];\n}\n\nfunction Marker(props) {\n  var thisRef = useDraggableControl(props);\n  var state = thisRef.state,\n      containerRef = thisRef.containerRef;\n  var children = props.children,\n      className = props.className,\n      draggable = props.draggable;\n  var dragPos = state.dragPos;\n\n  var _getPosition = getPosition(thisRef),\n      _getPosition2 = slicedToArray_slicedToArray(_getPosition, 2),\n      x = _getPosition2[0],\n      y = _getPosition2[1];\n\n  var transform = "translate(".concat(crispPixel(x), "px, ").concat(crispPixel(y), "px)");\n  var cursor = draggable ? dragPos ? \'grabbing\' : \'grab\' : \'auto\';\n  var control = (0,react.useMemo)(function () {\n    var containerStyle = {\n      position: \'absolute\',\n      left: 0,\n      top: 0,\n      transform: transform,\n      cursor: cursor\n    };\n    return react.createElement("div", {\n      className: "mapboxgl-marker ".concat(className),\n      ref: thisRef.containerRef,\n      style: containerStyle\n    }, children);\n  }, [children, className]);\n  var container = containerRef.current;\n\n  if (container) {\n    container.style.transform = transform;\n    container.style.cursor = cursor;\n  }\n\n  return control;\n}\n\nMarker.defaultProps = marker_defaultProps;\n/* harmony default export */ var marker = (react.memo(Marker));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/dynamic-position.js\nvar ANCHOR_POSITION = {\n  top: {\n    x: 0.5,\n    y: 0\n  },\n  \'top-left\': {\n    x: 0,\n    y: 0\n  },\n  \'top-right\': {\n    x: 1,\n    y: 0\n  },\n  bottom: {\n    x: 0.5,\n    y: 1\n  },\n  \'bottom-left\': {\n    x: 0,\n    y: 1\n  },\n  \'bottom-right\': {\n    x: 1,\n    y: 1\n  },\n  left: {\n    x: 0,\n    y: 0.5\n  },\n  right: {\n    x: 1,\n    y: 0.5\n  }\n};\nvar ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\nfunction getDynamicPosition(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      selfWidth = _ref.selfWidth,\n      selfHeight = _ref.selfHeight,\n      anchor = _ref.anchor,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding;\n  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor],\n      anchorX = _ANCHOR_POSITION$anch.x,\n      anchorY = _ANCHOR_POSITION$anch.y;\n  var top = y - anchorY * selfHeight;\n  var bottom = top + selfHeight;\n  var cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n  if (cutoffY > 0) {\n    var bestAnchorY = anchorY;\n    var minCutoff = cutoffY;\n\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n\n    anchorY = bestAnchorY;\n  }\n\n  var xStep = 0.5;\n\n  if (anchorY === 0.5) {\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  var left = x - anchorX * selfWidth;\n  var right = left + selfWidth;\n  var cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n  if (cutoffX > 0) {\n    var bestAnchorX = anchorX;\n    var _minCutoff = cutoffX;\n\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n      if (cutoffX < _minCutoff) {\n        _minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n\n    anchorX = bestAnchorX;\n  }\n\n  return ANCHOR_TYPES.find(function (positionType) {\n    var anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  }) || anchor;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/popup.js\n\n\n\nfunction popup_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction popup_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      popup_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      popup_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\nvar popup_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  offsetLeft: 0,\n  offsetTop: 0,\n  tipSize: 10,\n  anchor: \'bottom\',\n  dynamicPosition: true,\n  sortByDepth: false,\n  closeButton: true,\n  closeOnClick: true,\n  onClose: function onClose() {}\n});\n\nfunction popup_getPosition(props, viewport, el, _ref) {\n  var _ref2 = slicedToArray_slicedToArray(_ref, 2),\n      x = _ref2[0],\n      y = _ref2[1];\n\n  var anchor = props.anchor,\n      dynamicPosition = props.dynamicPosition,\n      tipSize = props.tipSize;\n\n  if (el) {\n    return dynamicPosition ? getDynamicPosition({\n      x: x,\n      y: y,\n      anchor: anchor,\n      padding: tipSize,\n      width: viewport.width,\n      height: viewport.height,\n      selfWidth: el.clientWidth,\n      selfHeight: el.clientHeight\n    }) : anchor;\n  }\n\n  return anchor;\n}\n\nfunction getContainerStyle(props, viewport, el, _ref3, positionType) {\n  var _ref4 = slicedToArray_slicedToArray(_ref3, 3),\n      x = _ref4[0],\n      y = _ref4[1],\n      z = _ref4[2];\n\n  var offsetLeft = props.offsetLeft,\n      offsetTop = props.offsetTop,\n      sortByDepth = props.sortByDepth;\n  var anchorPosition = ANCHOR_POSITION[positionType];\n  var left = x + offsetLeft;\n  var top = y + offsetTop;\n  var xPercentage = crispPercentage(el, -anchorPosition.x * 100);\n  var yPercentage = crispPercentage(el, -anchorPosition.y * 100, \'y\');\n  var style = {\n    position: \'absolute\',\n    transform: "\\n      translate(".concat(xPercentage, "%, ").concat(yPercentage, "%)\\n      translate(").concat(crispPixel(left), "px, ").concat(crispPixel(top), "px)\\n    "),\n    display: undefined,\n    zIndex: undefined\n  };\n\n  if (!sortByDepth) {\n    return style;\n  }\n\n  if (z > 1 || z < -1 || x < 0 || x > viewport.width || y < 0 || y > viewport.height) {\n    style.display = \'none\';\n  } else {\n    style.zIndex = Math.floor((1 - z) / 2 * 100000);\n  }\n\n  return style;\n}\n\nfunction onClick(evt, _ref5) {\n  var props = _ref5.props,\n      context = _ref5.context;\n\n  if (props.closeOnClick || evt.target.className === \'mapboxgl-popup-close-button\') {\n    props.onClose();\n\n    if (context.eventManager) {\n      context.eventManager.once(\'click\', function (e) {\n        return e.stopPropagation();\n      }, evt.target);\n    }\n  }\n}\n\nfunction Popup(props) {\n  var contentRef = (0,react.useRef)(null);\n  var thisRef = useMapControl(popup_objectSpread(popup_objectSpread({}, props), {}, {\n    onClick: onClick\n  }));\n  var context = thisRef.context,\n      containerRef = thisRef.containerRef;\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      setLoaded = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    setLoaded(true);\n  }, [contentRef.current]);\n  var viewport = context.viewport,\n      map = context.map;\n  var className = props.className,\n      longitude = props.longitude,\n      latitude = props.latitude,\n      tipSize = props.tipSize,\n      closeButton = props.closeButton,\n      children = props.children;\n  var altitude = props.altitude;\n\n  if (altitude === undefined) {\n    altitude = getTerrainElevation(map, {\n      longitude: longitude,\n      latitude: latitude\n    });\n  }\n\n  var position = viewport.project([longitude, latitude, altitude]);\n  var positionType = popup_getPosition(props, viewport, contentRef.current, position);\n  var containerStyle = getContainerStyle(props, viewport, containerRef.current, position, positionType);\n  var onReactClick = (0,react.useCallback)(function (e) {\n    return !context.eventManager && onClick(e, thisRef);\n  }, [context.eventManager]);\n  return react.createElement("div", {\n    className: "mapboxgl-popup mapboxgl-popup-anchor-".concat(positionType, " ").concat(className),\n    style: containerStyle,\n    ref: containerRef\n  }, react.createElement("div", {\n    key: "tip",\n    className: "mapboxgl-popup-tip",\n    style: {\n      borderWidth: tipSize\n    }\n  }), react.createElement("div", {\n    key: "content",\n    ref: contentRef,\n    className: "mapboxgl-popup-content",\n    onClick: onReactClick\n  }, closeButton && react.createElement("button", {\n    key: "close-button",\n    className: "mapboxgl-popup-close-button",\n    type: "button"\n  }, "\\xD7"), children));\n}\n\nPopup.defaultProps = popup_defaultProps;\n/* harmony default export */ var popup = (react.memo(Popup));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/attribution-control.js\n\n\n\nfunction attribution_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction attribution_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      attribution_control_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      attribution_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\nvar attribution_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  toggleLabel: \'Toggle Attribution\'\n});\n\nfunction setupAttributioncontrol(opts, map, container, attributionContainer) {\n  var control = new (maplibre_gl_default()).AttributionControl(opts);\n  control._map = map;\n  control._container = container;\n  control._innerContainer = attributionContainer;\n\n  control._updateAttributions();\n\n  control._updateEditLink();\n\n  map.on(\'styledata\', control._updateData);\n  map.on(\'sourcedata\', control._updateData);\n  return control;\n}\n\nfunction removeAttributionControl(control) {\n  control._map.off(\'styledata\', control._updateData);\n\n  control._map.off(\'sourcedata\', control._updateData);\n}\n\nfunction AttributionControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var innerContainerRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      showCompact = _useState2[0],\n      setShowCompact = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    var control;\n\n    if (context.map) {\n      control = setupAttributioncontrol({\n        customAttribution: props.customAttribution\n      }, context.map, containerRef.current, innerContainerRef.current);\n    }\n\n    return function () {\n      return control && removeAttributionControl(control);\n    };\n  }, [context.map]);\n  var compact = props.compact === undefined ? context.viewport.width <= 640 : props.compact;\n  (0,react.useEffect)(function () {\n    if (!compact && showCompact) {\n      setShowCompact(false);\n    }\n  }, [compact]);\n  var toggleAttribution = (0,react.useCallback)(function () {\n    return setShowCompact(function (value) {\n      return !value;\n    });\n  }, []);\n  var style = (0,react.useMemo)(function () {\n    return attribution_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: props.className\n  }, react.createElement("div", {\n    ref: containerRef,\n    "aria-pressed": showCompact,\n    className: "mapboxgl-ctrl mapboxgl-ctrl-attrib ".concat(compact ? \'mapboxgl-compact\' : \'\', " ").concat(showCompact ? \'mapboxgl-compact-show\' : \'\')\n  }, react.createElement("button", {\n    type: "button",\n    className: "mapboxgl-ctrl-attrib-button",\n    title: props.toggleLabel,\n    onClick: toggleAttribution\n  }), react.createElement("div", {\n    ref: innerContainerRef,\n    className: "mapboxgl-ctrl-attrib-inner",\n    role: "list"\n  })));\n}\n\nAttributionControl.defaultProps = attribution_control_defaultProps;\n/* harmony default export */ var attribution_control = (react.memo(AttributionControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/fullscreen-control.js\n\n\n\nfunction fullscreen_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction fullscreen_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      fullscreen_control_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      fullscreen_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\nvar fullscreen_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  container: null,\n  label: \'Toggle fullscreen\'\n});\n\nfunction FullscreenControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var _useState = (0,react.useState)(false),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      isFullscreen = _useState2[0],\n      setIsFullscreen = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      showButton = _useState4[0],\n      setShowButton = _useState4[1];\n\n  var _useState5 = (0,react.useState)(null),\n      _useState6 = slicedToArray_slicedToArray(_useState5, 2),\n      mapboxFullscreenControl = _useState6[0],\n      createMapboxFullscreenControl = _useState6[1];\n\n  (0,react.useEffect)(function () {\n    var control = new (maplibre_gl_default()).FullscreenControl();\n    createMapboxFullscreenControl(control);\n    setShowButton(control._checkFullscreenSupport());\n\n    var onFullscreenChange = function onFullscreenChange() {\n      var nextState = !control._fullscreen;\n      control._fullscreen = nextState;\n      setIsFullscreen(nextState);\n    };\n\n    document_.addEventListener(control._fullscreenchange, onFullscreenChange);\n    return function () {\n      document_.removeEventListener(control._fullscreenchange, onFullscreenChange);\n    };\n  }, []);\n\n  var onClickFullscreen = function onClickFullscreen() {\n    if (mapboxFullscreenControl) {\n      mapboxFullscreenControl._container = props.container || context.container;\n\n      mapboxFullscreenControl._onClickFullscreen();\n    }\n  };\n\n  var style = (0,react.useMemo)(function () {\n    return fullscreen_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n\n  if (!showButton) {\n    return null;\n  }\n\n  var className = props.className,\n      label = props.label;\n  var type = isFullscreen ? \'shrink\' : \'fullscreen\';\n  return react.createElement("div", {\n    style: style,\n    className: className\n  }, react.createElement("div", {\n    className: "mapboxgl-ctrl mapboxgl-ctrl-group",\n    ref: containerRef\n  }, react.createElement("button", {\n    key: type,\n    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),\n    type: "button",\n    title: label,\n    onClick: onClickFullscreen\n  }, react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true"\n  }))));\n}\n\nFullscreenControl.defaultProps = fullscreen_control_defaultProps;\n/* harmony default export */ var fullscreen_control = (react.memo(FullscreenControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/geolocate-utils.js\nvar supported;\nfunction isGeolocationSupported() {\n  if (supported !== undefined) {\n    return Promise.resolve(supported);\n  }\n\n  if (window.navigator.permissions !== undefined) {\n    return window.navigator.permissions.query({\n      name: \'geolocation\'\n    }).then(function (p) {\n      supported = p.state !== \'denied\';\n      return supported;\n    });\n  }\n\n  supported = Boolean(window.navigator.geolocation);\n  return Promise.resolve(supported);\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/geolocate-control.js\n\n\n\nfunction geolocate_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction geolocate_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      geolocate_control_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      geolocate_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\n\n\nvar geolocate_control_noop = function noop() {};\n\nvar geolocate_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  label: \'Find My Location\',\n  disabledLabel: \'Location Not Available\',\n  auto: false,\n  positionOptions: {\n    enableHighAccuracy: false,\n    timeout: 6000\n  },\n  fitBoundsOptions: {\n    maxZoom: 15\n  },\n  trackUserLocation: false,\n  showUserLocation: true,\n  showAccuracyCircle: true,\n  onGeolocate: function onGeolocate() {}\n});\n\nfunction geolocate_control_getBounds(position) {\n  var center = new (maplibre_gl_default()).LngLat(position.coords.longitude, position.coords.latitude);\n  var radius = position.coords.accuracy;\n  var bounds = center.toBounds(radius);\n  return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n}\n\nfunction setupMapboxGeolocateControl(context, props, geolocateButton) {\n  var control = new (maplibre_gl_default()).GeolocateControl(props);\n  control._container = document_.createElement(\'div\');\n  control._map = {\n    on: function on() {},\n    _getUIString: function _getUIString() {\n      return \'\';\n    }\n  };\n\n  control._setupUI(true);\n\n  control._map = context.map;\n  control._geolocateButton = geolocateButton;\n  var eventManager = context.eventManager;\n\n  if (control.options.trackUserLocation && eventManager) {\n    eventManager.on(\'panstart\', function () {\n      if (control._watchState === \'ACTIVE_LOCK\') {\n        control._watchState = \'BACKGROUND\';\n        geolocateButton.classList.add(\'mapboxgl-ctrl-geolocate-background\');\n        geolocateButton.classList.remove(\'mapboxgl-ctrl-geolocate-active\');\n      }\n    });\n  }\n\n  control.on(\'geolocate\', props.onGeolocate);\n  return control;\n}\n\nfunction updateCamera(position, _ref) {\n  var context = _ref.context,\n      props = _ref.props;\n  var bounds = geolocate_control_getBounds(position);\n\n  var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions),\n      longitude = _context$viewport$fit.longitude,\n      latitude = _context$viewport$fit.latitude,\n      zoom = _context$viewport$fit.zoom;\n\n  var newViewState = Object.assign({}, context.viewport, {\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var mapState = new MapState(newViewState);\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || geolocate_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || geolocate_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\n\nfunction GeolocateControl(props) {\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n      containerRef = thisRef.containerRef;\n  var geolocateButtonRef = (0,react.useRef)(null);\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      mapboxGeolocateControl = _useState2[0],\n      createMapboxGeolocateControl = _useState2[1];\n\n  var _useState3 = (0,react.useState)(false),\n      _useState4 = slicedToArray_slicedToArray(_useState3, 2),\n      supportsGeolocation = _useState4[0],\n      setSupportsGeolocation = _useState4[1];\n\n  (0,react.useEffect)(function () {\n    var control;\n\n    if (context.map) {\n      isGeolocationSupported().then(function (result) {\n        setSupportsGeolocation(result);\n\n        if (geolocateButtonRef.current) {\n          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);\n\n          control._updateCamera = function (position) {\n            return updateCamera(position, thisRef);\n          };\n\n          createMapboxGeolocateControl(control);\n        }\n      });\n    }\n\n    return function () {\n      if (control) {\n        control._clearWatch();\n      }\n    };\n  }, [context.map]);\n  var triggerGeolocate = (0,react.useCallback)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl.options = thisRef.props;\n      mapboxGeolocateControl.trigger();\n    }\n  }, [mapboxGeolocateControl]);\n  (0,react.useEffect)(function () {\n    if (props.auto) {\n      triggerGeolocate();\n    }\n  }, [mapboxGeolocateControl, props.auto]);\n  (0,react.useEffect)(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl._onZoom();\n    }\n  }, [context.viewport.zoom]);\n  var className = props.className,\n      label = props.label,\n      disabledLabel = props.disabledLabel,\n      trackUserLocation = props.trackUserLocation;\n  var style = (0,react.useMemo)(function () {\n    return geolocate_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: className\n  }, react.createElement("div", {\n    key: "geolocate-control",\n    className: "mapboxgl-ctrl mapboxgl-ctrl-group",\n    ref: containerRef\n  }, react.createElement("button", {\n    key: "geolocate",\n    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",\n    ref: geolocateButtonRef,\n    disabled: !supportsGeolocation,\n    "aria-pressed": !trackUserLocation,\n    type: "button",\n    title: supportsGeolocation ? label : disabledLabel,\n    "aria-label": supportsGeolocation ? label : disabledLabel,\n    onClick: triggerGeolocate\n  }, react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true"\n  }))));\n}\n\nGeolocateControl.defaultProps = geolocate_control_defaultProps;\n/* harmony default export */ var geolocate_control = (react.memo(GeolocateControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/version.js\nfunction compareVersions(version1, version2) {\n  var v1 = (version1 || \'\').split(\'.\').map(Number);\n  var v2 = (version2 || \'\').split(\'.\').map(Number);\n\n  for (var i = 0; i < 3; i++) {\n    var part1 = v1[i] || 0;\n    var part2 = v2[i] || 0;\n\n    if (part1 < part2) {\n      return -1;\n    }\n\n    if (part1 > part2) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/navigation-control.js\n\n\nfunction navigation_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction navigation_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      navigation_control_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      navigation_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\n\n\n\nvar navigation_control_noop = function noop() {};\n\nvar navigation_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  showCompass: true,\n  showZoom: true,\n  zoomInLabel: \'Zoom In\',\n  zoomOutLabel: \'Zoom Out\',\n  compassLabel: \'Reset North\'\n});\nvar VERSION_LEGACY = 1;\nvar VERSION_1_6 = 2;\n\nfunction getUIVersion(mapboxVersion) {\n  return compareVersions(mapboxVersion, \'1.6.0\') >= 0 ? VERSION_1_6 : VERSION_LEGACY;\n}\n\nfunction updateViewport(context, props, opts) {\n  var viewport = context.viewport;\n  var mapState = new MapState(Object.assign({}, viewport, opts));\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || navigation_control_noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || navigation_control_noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\n\nfunction renderButton(type, label, callback, children) {\n  return react.createElement("button", {\n    key: type,\n    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),\n    type: "button",\n    title: label,\n    onClick: callback\n  }, children || react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true"\n  }));\n}\n\nfunction renderCompass(context) {\n  var uiVersion = (0,react.useMemo)(function () {\n    return context.map ? getUIVersion(context.map.version) : VERSION_1_6;\n  }, [context.map]);\n  var bearing = context.viewport.bearing;\n  var style = {\n    transform: "rotate(".concat(-bearing, "deg)")\n  };\n  return uiVersion === VERSION_1_6 ? react.createElement("span", {\n    className: "mapboxgl-ctrl-icon",\n    "aria-hidden": "true",\n    style: style\n  }) : react.createElement("span", {\n    className: "mapboxgl-ctrl-compass-arrow",\n    style: style\n  });\n}\n\nfunction NavigationControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var onZoomIn = function onZoomIn() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom + 1\n    });\n  };\n\n  var onZoomOut = function onZoomOut() {\n    updateViewport(context, props, {\n      zoom: context.viewport.zoom - 1\n    });\n  };\n\n  var onResetNorth = function onResetNorth() {\n    updateViewport(context, props, {\n      bearing: 0,\n      pitch: 0\n    });\n  };\n\n  var className = props.className,\n      showCompass = props.showCompass,\n      showZoom = props.showZoom,\n      zoomInLabel = props.zoomInLabel,\n      zoomOutLabel = props.zoomOutLabel,\n      compassLabel = props.compassLabel;\n  var style = (0,react.useMemo)(function () {\n    return navigation_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: className\n  }, react.createElement("div", {\n    className: "mapboxgl-ctrl mapboxgl-ctrl-group",\n    ref: containerRef\n  }, showZoom && renderButton(\'zoom-in\', zoomInLabel, onZoomIn), showZoom && renderButton(\'zoom-out\', zoomOutLabel, onZoomOut), showCompass && renderButton(\'compass\', compassLabel, onResetNorth, renderCompass(context))));\n}\n\nNavigationControl.defaultProps = navigation_control_defaultProps;\n/* harmony default export */ var navigation_control = (react.memo(NavigationControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/components/scale-control.js\n\n\n\nfunction scale_control_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction scale_control_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      scale_control_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      scale_control_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\n\n\nvar scale_control_defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: \'\',\n  maxWidth: 100,\n  unit: \'metric\'\n});\n\nfunction ScaleControl(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      mapboxScaleControl = _useState2[0],\n      createMapboxScaleControl = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    if (context.map) {\n      var control = new (maplibre_gl_default()).ScaleControl();\n      control._map = context.map;\n      control._container = containerRef.current;\n      createMapboxScaleControl(control);\n    }\n  }, [context.map]);\n\n  if (mapboxScaleControl) {\n    mapboxScaleControl.options = props;\n\n    mapboxScaleControl._onMove();\n  }\n\n  var style = (0,react.useMemo)(function () {\n    return scale_control_objectSpread({\n      position: \'absolute\'\n    }, props.style);\n  }, [props.style]);\n  return react.createElement("div", {\n    style: style,\n    className: props.className\n  }, react.createElement("div", {\n    ref: containerRef,\n    className: "mapboxgl-ctrl mapboxgl-ctrl-scale"\n  }));\n}\n\nScaleControl.defaultProps = scale_control_defaultProps;\n/* harmony default export */ var scale_control = (react.memo(ScaleControl));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/overlays/canvas-overlay.js\n\n\n\n\nvar canvas_overlay_pixelRatio = typeof window !== \'undefined\' && window.devicePixelRatio || 1;\nvar canvas_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\n\nfunction CanvasOverlay(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var _useState = (0,react.useState)(null),\n      _useState2 = slicedToArray_slicedToArray(_useState, 2),\n      ctx = _useState2[0],\n      setDrawingContext = _useState2[1];\n\n  (0,react.useEffect)(function () {\n    setDrawingContext(containerRef.current.getContext(\'2d\'));\n  }, []);\n  var viewport = context.viewport,\n      isDragging = context.isDragging;\n\n  if (ctx) {\n    ctx.save();\n    ctx.scale(canvas_overlay_pixelRatio, canvas_overlay_pixelRatio);\n    props.redraw({\n      width: viewport.width,\n      height: viewport.height,\n      ctx: ctx,\n      isDragging: isDragging,\n      project: viewport.project,\n      unproject: viewport.unproject\n    });\n    ctx.restore();\n  }\n\n  return react.createElement("canvas", {\n    ref: containerRef,\n    width: viewport.width * canvas_overlay_pixelRatio,\n    height: viewport.height * canvas_overlay_pixelRatio,\n    style: {\n      width: "".concat(viewport.width, "px"),\n      height: "".concat(viewport.height, "px"),\n      position: \'absolute\',\n      left: 0,\n      top: 0\n    }\n  });\n}\n\nCanvasOverlay.defaultProps = canvas_overlay_defaultProps;\n/* harmony default export */ var canvas_overlay = ((/* unused pure expression or super */ null && (CanvasOverlay)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/overlays/html-overlay.js\n\n\nfunction html_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction html_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      html_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      html_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\nvar html_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\n\nfunction HTMLOverlay(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var viewport = context.viewport,\n      isDragging = context.isDragging;\n\n  var style = html_overlay_objectSpread({\n    position: \'absolute\',\n    left: 0,\n    top: 0,\n    width: viewport.width,\n    height: viewport.height\n  }, props.style);\n\n  return react.createElement("div", {\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\n\nHTMLOverlay.defaultProps = html_overlay_defaultProps;\n/* harmony default export */ var html_overlay = ((/* unused pure expression or super */ null && (HTMLOverlay)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/overlays/svg-overlay.js\n\n\nfunction svg_overlay_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction svg_overlay_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      svg_overlay_ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      svg_overlay_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n\nvar svg_overlay_defaultProps = {\n  captureScroll: false,\n  captureDrag: false,\n  captureClick: false,\n  captureDoubleClick: false,\n  capturePointerMove: false\n};\n\nfunction SVGOverlay(props) {\n  var _useMapControl = useMapControl(props),\n      context = _useMapControl.context,\n      containerRef = _useMapControl.containerRef;\n\n  var viewport = context.viewport,\n      isDragging = context.isDragging;\n\n  var style = svg_overlay_objectSpread({\n    position: \'absolute\',\n    left: 0,\n    top: 0\n  }, props.style);\n\n  return react.createElement("svg", {\n    width: viewport.width,\n    height: viewport.height,\n    ref: containerRef,\n    style: style\n  }, props.redraw({\n    width: viewport.width,\n    height: viewport.height,\n    isDragging: isDragging,\n    project: viewport.project,\n    unproject: viewport.unproject\n  }));\n}\n\nSVGOverlay.defaultProps = svg_overlay_defaultProps;\n/* harmony default export */ var svg_overlay = ((/* unused pure expression or super */ null && (SVGOverlay)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/utils/set-rtl-text-plugin.js\n\nvar setRTLTextPlugin = (maplibre_gl_default()) ? (maplibre_gl_default()).setRTLTextPlugin : function () {};\n/* harmony default export */ var set_rtl_text_plugin = ((/* unused pure expression or super */ null && (setRTLTextPlugin)));\n;// CONCATENATED MODULE: ./node_modules/react-map-gl/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/chroma-js/chroma.js\nvar chroma = __webpack_require__(3873);\nvar chroma_default = /*#__PURE__*/__webpack_require__.n(chroma);\n;// CONCATENATED MODULE: ./src/data/constants.tsx\n// URLS\nvar FEATURE_TILE_BASE_URL=\'https://d2zjid6n5ja2pt.cloudfront.net\';var XYZ_SUFFIX=\'{z}/{x}/{y}.pbf\';var featureURLForTilesetName=function featureURLForTilesetName(tilesetName){return FEATURE_TILE_BASE_URL+"/"+tilesetName+"/"+XYZ_SUFFIX;};var FEATURE_TILE_HIGH_ZOOM_URL=featureURLForTilesetName(\'0714_high\');var FEATURE_TILE_LOW_ZOOM_URL=featureURLForTilesetName(\'tiles_low\');// Performance markers\nvar PERFORMANCE_MARKER_MAP_IDLE=\'MAP_IDLE\';// Properties\nvar SCORE_PROPERTY_HIGH=\'Score D (percentile)\';var SCORE_PROPERTY_LOW=\'D_SCORE\';var GEOID_PROPERTY=\'GEOID10\';var HIGH_SCORE_SOURCE_NAME=\'score-high\';var HIGH_SCORE_LAYER_NAME=\'score-high-layer\';var LOW_SCORE_SOURCE_NAME=\'score-low\';var LOW_SCORE_LAYER_NAME=\'score-low-layer\';var SELECTED_PROPERTY=\'selected\';// The name of the layer within the tiles that contains the score\nvar SCORE_SOURCE_LAYER=\'blocks\';// Zoom\nvar GLOBAL_MIN_ZOOM=3;var GLOBAL_MAX_ZOOM=22;var GLOBAL_MIN_ZOOM_LOW=3;var GLOBAL_MAX_ZOOM_LOW=7;var GLOBAL_MIN_ZOOM_HIGHLIGHT=9;var GLOBAL_MAX_ZOOM_HIGHLIGHT=22;var GLOBAL_MIN_ZOOM_HIGH=7;var GLOBAL_MAX_ZOOM_HIGH=11;// Bounds\nvar GLOBAL_MAX_BOUNDS=(/* unused pure expression or super */ null && ([[-180.118306,5.499550],[-65.0,83.162102]]));var LOWER_48_BOUNDS=[[-124.7844079,24.7433195],[-66.9513812,49.3457868]];var ALASKA_BOUNDS=[[-183.856888,50.875311],[-140.932617,71.958797]];var HAWAII_BOUNDS=[[-168.118306,18.748115],[-154.757881,22.378413]];var PUERTO_RICO_BOUNDS=[[-67.945404,17.88328],[-65.220703,18.515683]];var GUAM_BOUNDS=(/* unused pure expression or super */ null && ([[-215.389709,13.225909],[-215.040894,13.663335]]));var MARIANA_ISLAND_BOUNDS=(/* unused pure expression or super */ null && ([[-215.313449,14.007801],[-213.742404,19.750326]]));var AMERICAN_SAMOA_BOUNDS=(/* unused pure expression or super */ null && ([[-171.089874,-14.548699],[-168.1433,-11.046934]]));var DEFAULT_CENTER=[32.4687126,-86.502136];// Opacity\nvar DEFAULT_LAYER_OPACITY=0.6;// Colors\nvar DEFAULT_OUTLINE_COLOR=\'#4EA5CF\';var MIN_COLOR=\'#FFFFFF\';var MED_COLOR=\'#D1DAE6\';var MAX_COLOR=\'#768FB3\';var BORDER_HIGHLIGHT_COLOR=\'#00BDE3\';// Widths\nvar HIGHLIGHT_BORDER_WIDTH=5.0;// Score boundaries\nvar SCORE_BOUNDARY_LOW=0.0;var SCORE_BOUNDARY_THRESHOLD=0.6;var SCORE_BOUNDARY_PRIORITIZED=0.75;var isMobile=typeof window!==\'undefined\'&&window.innerWidth<400;\n;// CONCATENATED MODULE: ./src/data/mapStyle.tsx\n// eslint-disable-next-line require-jsdoc\nfunction hexToHSLA(hex,alpha){return chroma_default()(hex).alpha(alpha).css(\'hsl\');}/**\n * `MakePaint` generates a zoom-faded Maplibre style formatted layer given a set of parameters.\n *\n * @param {string} field : the field within the data to consult\n * @param {number} minRamp : the minimum value this can assume\n * @param {number} medRamp : the medium value this can assume\n * @param {number} maxRamp : the maximum value this can assume\n * @return {FillPaint} a maplibregl fill layer\n **/function makePaint(_ref){var field=_ref.field,minRamp=_ref.minRamp,medRamp=_ref.medRamp,maxRamp=_ref.maxRamp;var paintDescriptor={\'fill-color\':[\'step\',[\'get\',field],hexToHSLA(MIN_COLOR,DEFAULT_LAYER_OPACITY),minRamp,hexToHSLA(MIN_COLOR,DEFAULT_LAYER_OPACITY),medRamp,hexToHSLA(MED_COLOR,DEFAULT_LAYER_OPACITY),maxRamp,hexToHSLA(MAX_COLOR,DEFAULT_LAYER_OPACITY)]};return paintDescriptor;}var imageSuffix=isMobile?\'\':\'@2x\';var makeMapStyle=function makeMapStyle(flagContainer){var _sources;return{\'version\':8,\'sources\':(_sources={\'carto\':{\'type\':\'raster\',\'tiles\':["https://a.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}"+imageSuffix+".png","https://b.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}"+imageSuffix+".png","https://c.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}"+imageSuffix+".png","https://d.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}"+imageSuffix+".png"],\'minzoom\':GLOBAL_MIN_ZOOM,\'maxzoom\':GLOBAL_MAX_ZOOM},\'geo\':{\'type\':\'raster\',\'tiles\':[\'https://mt0.google.com/vt/lyrs=p&hl=en&x={x}&y={y}&z={z}\'],\'minzoom\':GLOBAL_MIN_ZOOM,\'maxzoom\':GLOBAL_MAX_ZOOM}},_sources[HIGH_SCORE_SOURCE_NAME]={// "Score-high" represents the full set of data\n// at the census block group level. It is only shown\n// at high zoom levels to avoid performance issues at lower zooms\n\'type\':\'vector\',// Our current tippecanoe command does not set an id.\n// The below line promotes the GEOID10 property to the ID\n\'promoteId\':GEOID_PROPERTY,\'tiles\':[\'high_tiles\'in flagContainer?featureURLForTilesetName(flagContainer[\'high_tiles\']):FEATURE_TILE_HIGH_ZOOM_URL],// Seeting maxzoom here enables \'overzooming\'\n// e.g. continued zooming beyond the max bounds.\n// More here: https://docs.mapbox.com/help/glossary/overzoom/\n\'minzoom\':GLOBAL_MIN_ZOOM_HIGH,\'maxzoom\':GLOBAL_MAX_ZOOM_HIGH},_sources[LOW_SCORE_SOURCE_NAME]={// "Score-low" represents a tileset at the level of bucketed tracts.\n// census block group information is `dissolve`d into tracts, then\n// each tract is `dissolve`d into one of ten buckets. It is meant\n// to give us a favorable tradeoff between performance and fidelity.\n\'type\':\'vector\',\'promoteId\':GEOID_PROPERTY,\'tiles\':[\'low_tiles\'in flagContainer?featureURLForTilesetName(flagContainer[\'low_tiles\']):FEATURE_TILE_LOW_ZOOM_URL// For local development, use:\n// \'http://localhost:8080/data/tl_2010_bg_with_data/{z}/{x}/{y}.pbf\',\n],\'minzoom\':GLOBAL_MIN_ZOOM_LOW,\'maxzoom\':GLOBAL_MAX_ZOOM_LOW},_sources[\'labels\']={\'type\':\'raster\',\'tiles\':["https://cartodb-basemaps-a.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}"+imageSuffix+".png","https://cartodb-basemaps-b.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}"+imageSuffix+".png","https://cartodb-basemaps-c.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}"+imageSuffix+".png","https://cartodb-basemaps-d.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}"+imageSuffix+".png"]},_sources),\'layers\':[{\'id\':\'carto\',\'source\':\'carto\',\'type\':\'raster\',\'minzoom\':GLOBAL_MIN_ZOOM,\'maxzoom\':GLOBAL_MAX_ZOOM},{\'id\':\'geo\',\'source\':\'geo\',\'type\':\'raster\',\'layout\':{// Make the layer invisible by default.\n\'visibility\':\'none\'},\'minzoom\':GLOBAL_MIN_ZOOM,\'maxzoom\':GLOBAL_MAX_ZOOM},{\'id\':HIGH_SCORE_LAYER_NAME,\'source\':HIGH_SCORE_SOURCE_NAME,\'source-layer\':SCORE_SOURCE_LAYER,\'type\':\'fill\',\'filter\':[\'all\',[\'>\',SCORE_PROPERTY_HIGH,SCORE_BOUNDARY_THRESHOLD]],\'paint\':makePaint({field:SCORE_PROPERTY_HIGH,minRamp:SCORE_BOUNDARY_LOW,medRamp:SCORE_BOUNDARY_THRESHOLD,maxRamp:SCORE_BOUNDARY_PRIORITIZED}),\'minzoom\':GLOBAL_MIN_ZOOM_HIGH},{\'id\':LOW_SCORE_LAYER_NAME,\'source\':LOW_SCORE_SOURCE_NAME,\'source-layer\':SCORE_SOURCE_LAYER,\'type\':\'fill\',\'filter\':[\'all\',[\'>\',SCORE_PROPERTY_LOW,SCORE_BOUNDARY_THRESHOLD]],\'paint\':makePaint({field:SCORE_PROPERTY_LOW,minRamp:SCORE_BOUNDARY_LOW,medRamp:SCORE_BOUNDARY_THRESHOLD,maxRamp:SCORE_BOUNDARY_PRIORITIZED}),\'minzoom\':GLOBAL_MIN_ZOOM_LOW,\'maxzoom\':GLOBAL_MAX_ZOOM_LOW},{// "Score-highlights" represents the border\n// around given tiles that appears at higher zooms\n\'id\':\'score-highlights-layer\',\'source\':HIGH_SCORE_SOURCE_NAME,\'source-layer\':SCORE_SOURCE_LAYER,\'type\':\'line\',\'layout\':{\'visibility\':\'visible\',\'line-join\':\'round\',\'line-cap\':\'round\'},\'paint\':{\'line-color\':DEFAULT_OUTLINE_COLOR,\'line-width\':0.8,\'line-opacity\':0.5},\'minzoom\':GLOBAL_MIN_ZOOM_HIGHLIGHT,\'maxzoom\':GLOBAL_MAX_ZOOM_HIGHLIGHT},{// "score-border-highlight" is used to highlight\n// the currently-selected feature\n\'id\':\'score-border-highlight-layer\',\'type\':\'line\',\'source\':HIGH_SCORE_SOURCE_NAME,\'source-layer\':SCORE_SOURCE_LAYER,\'layout\':{},\'paint\':{\'line-color\':BORDER_HIGHLIGHT_COLOR,\'line-width\':[\'case\',[\'boolean\',[\'feature-state\',SELECTED_PROPERTY],false],HIGHLIGHT_BORDER_WIDTH,0]},\'minzoom\':GLOBAL_MIN_ZOOM_HIGH},{// We put labels last to ensure prominence\n\'id\':\'labels-only-layer\',\'type\':\'raster\',\'source\':\'labels\',\'minzoom\':GLOBAL_MIN_ZOOM,\'maxzoom\':GLOBAL_MAX_ZOOM}]};};\n;// CONCATENATED MODULE: ./src/components/areaDetail.module.scss\n// extracted by mini-css-extract-plugin\nvar areaDetailTable = "areaDetail-module--areaDetailTable--1kW55";\nvar titleContainer = "areaDetail-module--titleContainer--1tUIN";\nvar titleIndicatorName = "areaDetail-module--titleIndicatorName--uAnFV";\nvar areaDetailContainer = "areaDetail-module--areaDetailContainer--15ae9";\nvar areaDetailTableContainer = "areaDetail-module--areaDetailTableContainer--1l8cw";\n;// CONCATENATED MODULE: ./src/components/areaDetail.tsx\nfunction _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=areaDetail_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function areaDetail_unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return areaDetail_arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return areaDetail_arrayLikeToArray(o,minLen);}function areaDetail_arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var AreaDetail=function AreaDetail(_ref){var properties=_ref.properties;var readablePercent=function readablePercent(percent){return""+(percent*100).toFixed(2);};var getCategorization=function getCategorization(percentile){var categorization;if(percentile>=0.75){categorization=\'Prioritized\';}else if(0.60<=percentile&&percentile<0.75){categorization=\'Threshold\';}else{categorization=\'Non-prioritized\';}return categorization;};var getTitleContent=function getTitleContent(){var blockGroup=properties[GEOID_PROPERTY];var score=properties[SCORE_PROPERTY_HIGH];return/*#__PURE__*/react.createElement("div",{className:titleContainer},/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("span",{className:titleIndicatorName},"Census Block Group: "),/*#__PURE__*/react.createElement("span",null,blockGroup)),/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("span",{className:titleIndicatorName},"Just Progress Categorization: "),/*#__PURE__*/react.createElement("span",null,getCategorization(score))),/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("span",{className:titleIndicatorName},"Cumulative Index Score: "),/*#__PURE__*/react.createElement("span",null,readablePercent(score))));};var getBodyContent=function getBodyContent(){var rows=[];var sortedKeys=Object.entries(properties).sort();for(var _iterator=_createForOfIteratorHelperLoose(sortedKeys),_step;!(_step=_iterator()).done;){var _step$value=_step.value,key=_step$value[0],value=_step$value[1];// We should only format floats\nif(typeof value===\'number\'&&value%1!==0){value=readablePercent(value);}// Filter out all caps\nif(!key.match(/^[A-Z0-9]+$/)){rows.push(/*#__PURE__*/react.createElement("tr",{key:key},/*#__PURE__*/react.createElement("td",null,key),/*#__PURE__*/react.createElement("td",null,value)));}}return rows;};return/*#__PURE__*/react.createElement(react.Fragment,null,properties?/*#__PURE__*/react.createElement("div",{className:areaDetailContainer},getTitleContent(),/*#__PURE__*/react.createElement("div",{className:areaDetailTableContainer},/*#__PURE__*/react.createElement("table",{className:\'usa-table usa-table--borderless \'+areaDetailTable},/*#__PURE__*/react.createElement("thead",null,/*#__PURE__*/react.createElement("tr",null,/*#__PURE__*/react.createElement("th",{scope:"col"},"INDICATOR"),/*#__PURE__*/react.createElement("th",{scope:"col"},"VALUE"))),/*#__PURE__*/react.createElement("tbody",null,getBodyContent())))):\'\');};/* harmony default export */ var areaDetail = (AreaDetail);\n;// CONCATENATED MODULE: ./node_modules/@turf/helpers/dist/es/index.js\n/**\n * @module helpers\n */\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nvar earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: earthRadius / 111325,\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nvar unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / earthRadius,\n  yards: 1.0936133\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nvar areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   "type": "Point",\n *   "coordinates": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\n\nfunction es_feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var feat = {\n    type: "Feature"\n  };\n\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = "Point";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\n\nfunction geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n\n  switch (type) {\n    case "Point":\n      return es_point(coordinates).geometry;\n\n    case "LineString":\n      return es_lineString(coordinates).geometry;\n\n    case "Polygon":\n      return polygon(coordinates).geometry;\n\n    case "MultiPoint":\n      return multiPoint(coordinates).geometry;\n\n    case "MultiLineString":\n      return multiLineString(coordinates).geometry;\n\n    case "MultiPolygon":\n      return multiPolygon(coordinates).geometry;\n\n    default:\n      throw new Error(type + " is invalid");\n  }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\n\nfunction es_point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!coordinates) {\n    throw new Error("coordinates is required");\n  }\n\n  if (!Array.isArray(coordinates)) {\n    throw new Error("coordinates must be an Array");\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error("coordinates must be at least 2 numbers long");\n  }\n\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error("coordinates must contain numbers");\n  }\n\n  var geom = {\n    type: "Point",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\n\nfunction points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return es_point(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: \'poly1\' });\n *\n * //=polygon\n */\n\nfunction polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n\n    if (ring.length < 4) {\n      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");\n    }\n\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error("First and last Position are not equivalent.");\n      }\n    }\n  }\n\n  var geom = {\n    type: "Polygon",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\n\nfunction polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: \'line 1\'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: \'line 2\'});\n *\n * //=linestring1\n * //=linestring2\n */\n\nfunction es_lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error("coordinates must be an array of two or more positions");\n  }\n\n  var geom = {\n    type: "LineString",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\n\nfunction lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return es_lineString(coords, properties);\n  }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: \'Location A\'});\n * var locationB = turf.point([-75.833, 39.284], {name: \'Location B\'});\n * var locationC = turf.point([-75.534, 39.123], {name: \'Location C\'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\n\nfunction featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var fc = {\n    type: "FeatureCollection"\n  };\n\n  if (options.id) {\n    fc.id = options.id;\n  }\n\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n\n  fc.features = features;\n  return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\n\nfunction multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "MultiLineString",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\n\nfunction multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "MultiPoint",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\n\nfunction multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "MultiPolygon",\n    coordinates: coordinates\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry("Point", [100, 0]);\n * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\n\nfunction geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: "GeometryCollection",\n    geometries: geometries\n  };\n  return es_feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\n\nfunction es_round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n\n  if (precision && !(precision >= 0)) {\n    throw new Error("precision must be a positive number");\n  }\n\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\n\nfunction radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = "kilometers";\n  }\n\n  var factor = factors[units];\n\n  if (!factor) {\n    throw new Error(units + " units is invalid");\n  }\n\n  return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\n\nfunction lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = "kilometers";\n  }\n\n  var factor = factors[units];\n\n  if (!factor) {\n    throw new Error(units + " units is invalid");\n  }\n\n  return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\n\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\n\nfunction bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\n\nfunction radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\n\nfunction degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit="kilometers"] of the length\n * @param {Units} [finalUnit="kilometers"] returned unit\n * @returns {number} the converted length\n */\n\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = "kilometers";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = "kilometers";\n  }\n\n  if (!(length >= 0)) {\n    throw new Error("length must be a positive number");\n  }\n\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit="meters"] of the distance\n * @param {Units} [finalUnit="kilometers"] returned unit\n * @returns {number} the converted area\n */\n\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = "meters";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = "kilometers";\n  }\n\n  if (!(area >= 0)) {\n    throw new Error("area must be a positive number");\n  }\n\n  var startFactor = areaFactors[originalUnit];\n\n  if (!startFactor) {\n    throw new Error("invalid original units");\n  }\n\n  var finalFactor = areaFactors[finalUnit];\n\n  if (!finalFactor) {\n    throw new Error("invalid final units");\n  }\n\n  return area / startFactor * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber(\'foo\')\n * //=false\n */\n\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject(\'foo\')\n * //=false\n */\n\nfunction es_isObject(input) {\n  return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox(\'Foo\')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\n\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error("bbox is required");\n  }\n\n  if (!Array.isArray(bbox)) {\n    throw new Error("bbox must be an Array");\n  }\n\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error("bbox must be an Array of 4 or 6 numbers");\n  }\n\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error("bbox must only contain numbers");\n    }\n  });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId(\'Foo\')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\n\nfunction validateId(id) {\n  if (!id) {\n    throw new Error("id is required");\n  }\n\n  if (["string", "number"].indexOf(typeof id) === -1) {\n    throw new Error("id must be a number or a string");\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@turf/meta/dist/es/index.js\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {"foo": "bar"}),\n *   turf.point([36, 53], {"hello": "world"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n      k,\n      l,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      coordIndex = 0,\n      isGeometryCollection,\n      type = geojson.type,\n      isFeatureCollection = type === "FeatureCollection",\n      isFeature = type === "Feature",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it\'s trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don\'t apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it\'s called \'geometry\'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry\n\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n\n        case "Point":\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n\n        case "LineString":\n        case "MultiPoint":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === "MultiPoint") multiFeatureIndex++;\n          }\n\n          if (geomType === "LineString") multiFeatureIndex++;\n          break;\n\n        case "Polygon":\n        case "MultiLineString":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n\n            if (geomType === "MultiLineString") multiFeatureIndex++;\n            if (geomType === "Polygon") geometryIndex++;\n          }\n\n          if (geomType === "Polygon") multiFeatureIndex++;\n          break;\n\n        case "MultiPolygon":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n\n              geometryIndex++;\n            }\n\n            multiFeatureIndex++;\n          }\n\n          break;\n\n        case "GeometryCollection":\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          }\n\n          break;\n\n        default:\n          throw new Error("Unknown Geometry Type");\n      }\n    }\n  }\n}\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {"foo": "bar"}),\n *   turf.point([36, 53], {"hello": "world"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\n\n\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\n\n\nfunction propEach(geojson, callback) {\n  var i;\n\n  switch (geojson.type) {\n    case "FeatureCollection":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n\n      break;\n\n    case "Feature":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\n\n\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: \'bar\'}),\n *   turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\n\n\nfunction featureEach(geojson, callback) {\n  if (geojson.type === "Feature") {\n    callback(geojson, 0);\n  } else if (geojson.type === "FeatureCollection") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {"foo": "bar"}),\n *   turf.point([36, 53], {"hello": "world"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: \'bar\'}),\n *   turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\n\n\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\n\n\nfunction geomEach(geojson, callback) {\n  var i,\n      j,\n      g,\n      geometry,\n      stopG,\n      geometryMaybeCollection,\n      isGeometryCollection,\n      featureProperties,\n      featureBBox,\n      featureId,\n      featureIndex = 0,\n      isFeatureCollection = geojson.type === "FeatureCollection",\n      isFeature = geojson.type === "Feature",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it\'s trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don\'t apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it\'s called \'geometry\'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry\n\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n\n      switch (geometry.type) {\n        case "Point":\n        case "LineString":\n        case "MultiPoint":\n        case "Polygon":\n        case "MultiLineString":\n        case "MultiPolygon":\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n\n        case "GeometryCollection":\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error("Unknown Geometry Type");\n      }\n    } // Only increase `featureIndex` per each feature\n\n\n    featureIndex++;\n  }\n}\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.point([36, 53], {hello: \'world\'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\n\n\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: \'world\'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\n\n\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n\n    switch (type) {\n      case null:\n      case "Point":\n      case "LineString":\n      case "Polygon":\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n\n    var geomType; // Callback for multi-geometry\n\n    switch (type) {\n      case "MultiPoint":\n        geomType = "Point";\n        break;\n\n      case "MultiLineString":\n        geomType = "LineString";\n        break;\n\n      case "MultiPolygon":\n        geomType = "Polygon";\n        break;\n    }\n\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: \'bar\'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: \'world\'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\n\n\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0; // Exclude null Geometries\n\n    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n\n    var type = feature.geometry.type;\n    if (type === "Point" || type === "MultiPoint") return; // Generate 2-vertex line segments\n\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n\n      var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\n\n\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\n\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error("geojson is required");\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n\n    switch (type) {\n      case "LineString":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n\n      case "Polygon":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n\n        break;\n    }\n  });\n}\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\n\n\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\n\n\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error("options is invalid");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case "FeatureCollection":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case "Feature":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case "Point":\n    case "MultiPoint":\n      return null;\n\n    case "LineString":\n    case "Polygon":\n    case "MultiLineString":\n    case "MultiPolygon":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error("geojson is invalid");\n  } // Find SegmentIndex\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case "Point":\n    case "MultiPoint":\n      return null;\n\n    case "LineString":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n\n    case "Polygon":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n\n    case "MultiLineString":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n\n    case "MultiPolygon":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n\n  throw new Error("geojson is invalid");\n}\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\n\n\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error("options is invalid");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case "FeatureCollection":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case "Feature":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case "Point":\n    case "MultiPoint":\n      return null;\n\n    case "LineString":\n    case "Polygon":\n    case "MultiLineString":\n    case "MultiPolygon":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error("geojson is invalid");\n  } // Find Coord Index\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case "Point":\n      return point(coords, properties, options);\n\n    case "MultiPoint":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n\n    case "LineString":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n\n    case "Polygon":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n\n    case "MultiLineString":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n\n    case "MultiPolygon":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n\n  throw new Error("geojson is invalid");\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/@turf/bbox/dist/es/index.js\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\n\nfunction bbox(geojson) {\n  var result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, function (coord) {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\n\nbbox["default"] = bbox;\n/* harmony default export */ var es = (bbox);\n;// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n// EXTERNAL MODULE: ./src/contexts/FlagContext.tsx\nvar FlagContext = __webpack_require__(774);\n;// CONCATENATED MODULE: ./src/components/territoryFocusControl.module.scss\n// extracted by mini-css-extract-plugin\nvar territoryFocusButton = "territoryFocusControl-module--territoryFocusButton--3wWoV";\nvar territoryFocusContainer = "territoryFocusControl-module--territoryFocusContainer--3N0XM";\n;// CONCATENATED MODULE: ./src/components/territoryFocusControl.tsx\nvar TerritoryFocusControl=function TerritoryFocusControl(_ref){var onClickTerritoryFocusButton=_ref.onClickTerritoryFocusButton;var _useMapControl=useMapControl({// @ts-ignore // Types have not caught up yet, see https://github.com/visgl/react-map-gl/issues/1492\nonClick:onClickTerritoryFocusButton}),containerRef=_useMapControl.containerRef;return/*#__PURE__*/react.createElement("div",{ref:containerRef,className:territoryFocusContainer},/*#__PURE__*/react.createElement("button",{id:\'48\',onClick:onClickTerritoryFocusButton,className:territoryFocusButton},"48"),/*#__PURE__*/react.createElement("button",{id:\'AK\',onClick:onClickTerritoryFocusButton,className:territoryFocusButton},"AK"),/*#__PURE__*/react.createElement("button",{id:\'HI\',onClick:onClickTerritoryFocusButton,className:territoryFocusButton},"HI"),/*#__PURE__*/react.createElement("button",{id:\'PR\',onClick:onClickTerritoryFocusButton,className:territoryFocusButton},"PR"));};/* harmony default export */ var territoryFocusControl = (TerritoryFocusControl);\n;// CONCATENATED MODULE: ./src/components/J40Map.module.scss\n// extracted by mini-css-extract-plugin\nvar mapContainer = "J40Map-module--mapContainer--3U7xl";\nvar j40Popup = "J40Map-module--j40Popup--3yJGr";\nvar navigationControl = "J40Map-module--navigationControl--2Aybf";\nvar fullscreenControl = "J40Map-module--fullscreenControl--1UBKe";\nvar geolocateControl = "J40Map-module--geolocateControl--3KVAk";\n;// CONCATENATED MODULE: ./src/components/J40Map.tsx\n/* eslint-disable no-unused-vars */;var J40Map=function J40Map(){var _useState=(0,react.useState)({latitude:DEFAULT_CENTER[0],longitude:DEFAULT_CENTER[1],zoom:GLOBAL_MIN_ZOOM}),viewport=_useState[0],setViewport=_useState[1];var _useState2=(0,react.useState)(),selectedFeature=_useState2[0],setSelectedFeature=_useState2[1];var _useState3=(0,react.useState)(),detailViewData=_useState3[0],setDetailViewData=_useState3[1];var _useState4=(0,react.useState)(false),transitionInProgress=_useState4[0],setTransitionInProgress=_useState4[1];var _useState5=(0,react.useState)(false),geolocationInProgress=_useState5[0],setGeolocationInProgress=_useState5[1];var mapRef=(0,react.useRef)(null);var flags=(0,FlagContext/* useFlags */.Vb)();var onClick=function onClick(event){var feature=event.features&&event.features[0];if(feature){var _bbox=es(feature),minLng=_bbox[0],minLat=_bbox[1],maxLng=_bbox[2],maxLat=_bbox[3];var newViewPort=new WebMercatorViewport({height:viewport.height,width:viewport.width});var _newViewPort$fitBound=newViewPort.fitBounds([[minLng,minLat],[maxLng,maxLat]],{padding:40}),longitude=_newViewPort$fitBound.longitude,latitude=_newViewPort$fitBound.latitude,zoom=_newViewPort$fitBound.zoom;// If we\'ve selected a new feature, set \'selected\' to false\nif(selectedFeature&&feature.id!==selectedFeature.id){setMapSelected(selectedFeature,false);}setMapSelected(feature,true);var popupInfo={longitude:longitude,latitude:latitude,zoom:zoom,properties:feature.properties};goToPlace([[minLng,minLat],[maxLng,maxLat]]);setDetailViewData(popupInfo);}};var onLoad=function onLoad(){if(typeof window!==\'undefined\'&&window.Cypress&&mapRef.current){window.underlyingMap=mapRef.current.getMap();}};var goToPlace=function goToPlace(bounds){var _WebMercatorViewport$=new WebMercatorViewport({height:viewport.height,width:viewport.width}).fitBounds(bounds,{padding:20,offset:[0,-100]}),longitude=_WebMercatorViewport$.longitude,latitude=_WebMercatorViewport$.latitude,zoom=_WebMercatorViewport$.zoom;setViewport(Object.assign({},viewport,{longitude:longitude,latitude:latitude,zoom:zoom,transitionDuration:1000,transitionInterpolator:new ViewportFlyToInterpolator(),transitionEasing:cubicInOut}));};var setMapSelected=function setMapSelected(feature,isSelected){var _mapRef$current$getMa;// The below can be confirmed during debug with:\n// mapRef.current.getFeatureState({"id":feature.id, "source":feature.source, "sourceLayer":feature.sourceLayer})\nmapRef.current&&mapRef.current.getMap().setFeatureState({source:feature.source,sourceLayer:feature.sourceLayer,id:feature.id},(_mapRef$current$getMa={},_mapRef$current$getMa[SELECTED_PROPERTY]=isSelected,_mapRef$current$getMa));if(isSelected){setSelectedFeature(feature);}else{setSelectedFeature(undefined);}};var onClickTerritoryFocusButton=function onClickTerritoryFocusButton(event){var buttonID=event.target&&event.target.id;switch(buttonID){case\'48\':goToPlace(LOWER_48_BOUNDS);break;case\'AK\':goToPlace(ALASKA_BOUNDS);break;case\'HI\':goToPlace(HAWAII_BOUNDS);break;case\'PR\':goToPlace(PUERTO_RICO_BOUNDS);break;default:break;}};var onTransitionStart=function onTransitionStart(){setTransitionInProgress(true);};var onTransitionEnd=function onTransitionEnd(){setTransitionInProgress(false);};var onGeolocate=function onGeolocate(){setGeolocationInProgress(false);};var onClickGeolocate=function onClickGeolocate(){setGeolocationInProgress(true);};return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(interactive_map,Object.assign({},viewport,{className:mapContainer,mapStyle:makeMapStyle(flags),minZoom:GLOBAL_MIN_ZOOM,maxZoom:GLOBAL_MAX_ZOOM,mapOptions:{hash:true},width:"100%",height:"52vw",dragRotate:false,touchRotate:false,interactiveLayerIds:[HIGH_SCORE_LAYER_NAME],onViewportChange:setViewport,onClick:onClick,onLoad:onLoad,onTransitionStart:onTransitionStart,onTransitionEnd:onTransitionEnd,ref:mapRef}),detailViewData&&!transitionInProgress&&/*#__PURE__*/react.createElement(popup,{className:j40Popup,tipSize:5,anchor:"top",longitude:detailViewData.longitude,latitude:detailViewData.latitude,closeOnClick:true,onClose:setDetailViewData,captureScroll:true},/*#__PURE__*/react.createElement(areaDetail,{properties:detailViewData.properties})),/*#__PURE__*/react.createElement(navigation_control,{showCompass:false,className:navigationControl}),\'gl\'in flags?/*#__PURE__*/react.createElement(geolocate_control,{className:geolocateControl,positionOptions:{enableHighAccuracy:true},onGeolocate:onGeolocate// @ts-ignore // Types have not caught up yet, see https://github.com/visgl/react-map-gl/issues/1492\n,onClick:onClickGeolocate}):\'\',geolocationInProgress?/*#__PURE__*/react.createElement("div",null,"Geolocation in progress..."):\'\',/*#__PURE__*/react.createElement(territoryFocusControl,{onClickTerritoryFocusButton:onClickTerritoryFocusButton}),\'fs\'in flags?/*#__PURE__*/react.createElement(fullscreen_control,{className:fullscreenControl}):\'\'));};/* harmony default export */ var components_J40Map = (J40Map);\n;// CONCATENATED MODULE: ./src/components/mapWrapper.tsx\nvar MapWrapper=function MapWrapper(){return/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement(components_J40Map,null));};/* harmony default export */ var mapWrapper = (MapWrapper);\n;// CONCATENATED MODULE: ./src/components/HowYouCanHelp.module.scss\n// extracted by mini-css-extract-plugin\nvar howYouCanHelpContainer = "HowYouCanHelp-module--howYouCanHelpContainer--2kqBa";\n;// CONCATENATED MODULE: ./src/components/HowYouCanHelp.tsx\nvar HowYouCanHelp=function HowYouCanHelp(){return/*#__PURE__*/react.createElement("div",{className:howYouCanHelpContainer},/*#__PURE__*/react.createElement("h2",null,"How You Can Help Improve the Tool"),/*#__PURE__*/react.createElement("ul",{className:\'usa-list\'},/*#__PURE__*/react.createElement("li",null,"If you have information that could help, we\\u2019d love to hear from you."),/*#__PURE__*/react.createElement("li",null,"View our full set of data sources and methodology where you can add or download sources and check statuses on our data roadmap."),/*#__PURE__*/react.createElement("li",null,"Check out our timeline and send feedback or attend relevant events."),/*#__PURE__*/react.createElement("li",null,"Contact us and share the stories of your community.")));};/* harmony default export */ var components_HowYouCanHelp = (HowYouCanHelp);\n;// CONCATENATED MODULE: ./src/components/mapLegend.module.scss\n// extracted by mini-css-extract-plugin\nvar legendContainer = "mapLegend-module--legendContainer--2N1FC";\nvar swatchContainer = "mapLegend-module--swatchContainer--1yZX1";\nvar legendItem = "mapLegend-module--legendItem--WezUf";\nvar colorSwatch = "mapLegend-module--colorSwatch--oBUN2";\nvar prioritized = "mapLegend-module--prioritized--1I534";\nvar threshold = "mapLegend-module--threshold--1zali";\nvar nonPrioritized = "mapLegend-module--nonPrioritized--2y0Vm";\n;// CONCATENATED MODULE: ./src/components/mapLegend.tsx\nvar MapLegend=function MapLegend(){return/*#__PURE__*/react.createElement("div",{className:legendContainer},/*#__PURE__*/react.createElement("h3",{className:mapLegend_module_namespaceObject.legendHeader},"COLOR KEY"),/*#__PURE__*/react.createElement("div",{className:swatchContainer},/*#__PURE__*/react.createElement("div",{className:legendItem},/*#__PURE__*/react.createElement("div",{className:colorSwatch,id:prioritized}),/*#__PURE__*/react.createElement("span",null,"Prioritized Community")),/*#__PURE__*/react.createElement("div",{className:legendItem},/*#__PURE__*/react.createElement("div",{className:colorSwatch,id:threshold}),/*#__PURE__*/react.createElement("span",null,"Threshold Community")),/*#__PURE__*/react.createElement("div",{className:legendItem},/*#__PURE__*/react.createElement("div",{className:colorSwatch,id:nonPrioritized}),/*#__PURE__*/react.createElement("span",null,"Non-Prioritized Community"))));};/* harmony default export */ var mapLegend = (MapLegend);\n// EXTERNAL MODULE: ./node_modules/@trussworks/react-uswds/lib/index.js\nvar lib = __webpack_require__(2593);\n;// CONCATENATED MODULE: ./src/components/downloadPacket.module.scss\n// extracted by mini-css-extract-plugin\nvar downloadBoxContainer = "downloadPacket-module--downloadBoxContainer--IfYSI";\nvar downloadBox = "downloadPacket-module--downloadBox--23qAG";\nvar downloadBoxTextBox = "downloadPacket-module--downloadBoxTextBox--2C08I";\nvar downloadBoxTitle = "downloadPacket-module--downloadBoxTitle--2oQsR";\nvar downloadBoxText = "downloadPacket-module--downloadBoxText--s09H8";\nvar downloadBoxButtonContainer = "downloadPacket-module--downloadBoxButtonContainer--EBWUf";\nvar downloadBoxButton = "downloadPacket-module--downloadBoxButton--3w-ok";\nvar downloadPacketText = "downloadPacket-module--downloadPacketText--2MyEV";\n;// CONCATENATED MODULE: ./node_modules/uswds/dist/img/usa-icons/file_download.svg\n/* harmony default export */ var file_download = ("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXoiLz48L3N2Zz4=");\n;// CONCATENATED MODULE: ./src/components/downloadPacket.tsx\n// @ts-ignore\nvar cbgFileURL=\'https://justice40-data.s3.amazonaws.com/Score/usa.zip\';var DownloadPacket=function DownloadPacket(){return/*#__PURE__*/react.createElement("div",{className:downloadBoxContainer},/*#__PURE__*/react.createElement("div",{className:downloadBox},/*#__PURE__*/react.createElement("div",{className:downloadBoxTextBox},/*#__PURE__*/react.createElement("div",{className:downloadBoxTitle},"Just Progress Packet"),/*#__PURE__*/react.createElement("div",{className:downloadBoxText},"This downloadable packet includes the list of Just Progress prioritized communities (30,021 census block groups) and 18 datasets."),/*#__PURE__*/react.createElement("div",{className:downloadBoxButtonContainer},/*#__PURE__*/react.createElement("a",{id:\'download-link\',href:cbgFileURL},/*#__PURE__*/react.createElement(lib.Button,{className:downloadBoxButton,type:"button"},/*#__PURE__*/react.createElement("div",null,/*#__PURE__*/react.createElement("img",{src:file_download})," "),/*#__PURE__*/react.createElement("div",{className:downloadPacketText},"Download packet")))))));};/* harmony default export */ var downloadPacket = (DownloadPacket);\n;// CONCATENATED MODULE: ./src/pages/cejst.module.scss\n// extracted by mini-css-extract-plugin\nvar disclaimer = "cejst-module--disclaimer--3LC1y";\nvar textBox = "cejst-module--textBox--9wuDw";\n;// CONCATENATED MODULE: ./src/pages/cejst.tsx\nvar CEJSTPage=function CEJSTPage(_ref){var location=_ref.location;// We temporarily removed MapControls, which would enable you to `setFeatures` also, for now\n//   We will bring back later when we have interactive controls.\nreturn/*#__PURE__*/react.createElement(layout/* default */.Z,{location:location},/*#__PURE__*/react.createElement("main",{id:"main-content",role:"main"},/*#__PURE__*/react.createElement("section",null,/*#__PURE__*/react.createElement("h2",null,"Just Progress communities"),/*#__PURE__*/react.createElement("div",{className:disclaimer},/*#__PURE__*/react.createElement("div",{className:textBox},/*#__PURE__*/react.createElement("p",null,"Just Progress helps identify and prioritize communities across the United States and U.S. territories that have been historically overburdened and underserved. These communities will receive 40% of the benefits from investments in key areas outlined by the \\xA0",/*#__PURE__*/react.createElement("a",{href:\'https://www.whitehouse.gov/briefing-room/\'+\'presidential-actions/2021/01/27/\'+\'executive-order-on-tackling-the-climate-\'+\'crisis-at-home-and-abroad/\',target:\'_blank\',rel:\'noreferrer\'},"Executive Order on Tackling the Climate Crisis at Home and Abroad"),"."),/*#__PURE__*/react.createElement("p",null,"Download the Just Progress packet or explore the map below to see the list of prioritized communites. To learn more about how these communities were prioritized check out the \\xA0",/*#__PURE__*/react.createElement("a",{href:\'./methodology\'},"Methodology"),"\\xA0 page.")),/*#__PURE__*/react.createElement(downloadPacket,null))),/*#__PURE__*/react.createElement("h2",null,"Explore the Tool"),/*#__PURE__*/react.createElement(mapWrapper,null),/*#__PURE__*/react.createElement(mapLegend,null),/*#__PURE__*/react.createElement(components_HowYouCanHelp,null)));};/* harmony default export */ var cejst = (CEJSTPage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzP2MzMWQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/YWRlMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcz8wZDIxIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzPzA5ZjAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzPzNkOGMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcz8zODM1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzP2Q0ZWMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanM/YmVlMiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2NvbW1vbi5qcz9iOTNlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjNC5qcz84OWJiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9tYXRoLXV0aWxzLmpzP2Q5MDYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQ0LmpzPzQ1ODkiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMyLmpzPzFhNzEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzPzg5MDIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2Fzc2VydC5qcz9hYTdhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS93ZWItbWVyY2F0b3ItdXRpbHMuanM/NzM1MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vZml0LWJvdW5kcy5qcz84MTdlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9nZXQtYm91bmRzLmpzPzQwZjMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcz8xYWQ2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMuanM/YzNkOCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vZmx5LXRvLXZpZXdwb3J0LmpzPzNjMjgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2luZGV4LmpzP2U1YjMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdC9tb2R1bGUuanM/ZTI0NSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcz82ZmVhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9nbG9iYWxzLmpzP2U3YWUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3N0eWxlLXV0aWxzLmpzP2UyZGEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL21hcGJveC9tYXBib3guanM/OWM3ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWF0aC11dGlscy5qcz9mOTFhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9hc3NlcnQuanM/ODA0NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLXN0YXRlLmpzPzRmYjEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL21hcC1jb25zdHJhaW50cy5qcz8yMWNiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL21hcC1jb250ZXh0LmpzP2M2N2EiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QuanM/NGY3MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdGVycmFpbi5qcz8xMDFiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3N0YXRpYy1tYXAuanM/NjhkMCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLWludGVycG9sYXRvci5qcz80YWQ0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcz8yNTdlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzPzI2MmUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz85OWRlIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzPzdlODQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vdHJhbnNpdGlvbi11dGlscy5qcz84ZDM2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy90cmFuc2l0aW9uL3ZpZXdwb3J0LWZseS10by1pbnRlcnBvbGF0b3IuanM/NDg3MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi9saW5lYXItaW50ZXJwb2xhdG9yLmpzPzRiMGUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL3V0aWxzL3RyYW5zaXRpb24vaW5kZXguanM/MmJiOSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvdHJhbnNpdGlvbi1tYW5hZ2VyLmpzP2MzMzQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9oYW1tZXItb3ZlcnJpZGVzLmpzPzNjNzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9oYW1tZXIuYnJvd3Nlci5qcz9iNjk4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL21qb2xuaXIuanMvZGlzdC9lc20vY29uc3RhbnRzLmpzP2Y0MjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9nbG9iYWxzLmpzP2UxNDEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMvd2hlZWwtaW5wdXQuanM/MDUzZSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2lucHV0cy9tb3ZlLWlucHV0LmpzP2JiNDAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMva2V5LWlucHV0LmpzPzQzMmEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS9pbnB1dHMvY29udGV4dG1lbnUtaW5wdXQuanM/NWVkMSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL3V0aWxzL2V2ZW50LXV0aWxzLmpzPzI1NjIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvbWpvbG5pci5qcy9kaXN0L2VzbS91dGlscy9ldmVudC1yZWdpc3RyYXIuanM/NDc1MyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tam9sbmlyLmpzL2Rpc3QvZXNtL2V2ZW50LW1hbmFnZXIuanM/ZDE3MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvbWFwLWNvbnRyb2xsZXIuanM/MmM1MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAuanM/ODZkYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9zb3VyY2UuanM/NmVlNCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzP2NjYjUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanM/MTVmZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanM/NTNjYSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZGVlcC1lcXVhbC5qcz82NTAyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2xheWVyLmpzPzlmZjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sLmpzPzgzYjciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYmFzZS1jb250cm9sLmpzP2MzNTciLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvZHJhZ2dhYmxlLWNvbnRyb2wuanM/MmY3NCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvY3Jpc3AtcGl4ZWwuanM/ODhhZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9tYXJrZXIuanM/MDA4ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvZHluYW1pYy1wb3NpdGlvbi5qcz9hZDM5Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL3BvcHVwLmpzPzk5MzYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvYXR0cmlidXRpb24tY29udHJvbC5qcz8yMzEyIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9jb21wb25lbnRzL2Z1bGxzY3JlZW4tY29udHJvbC5qcz8xMDM2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy9nZW9sb2NhdGUtdXRpbHMuanM/ZDM2YiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vY29tcG9uZW50cy9nZW9sb2NhdGUtY29udHJvbC5qcz9hYzMwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS91dGlscy92ZXJzaW9uLmpzP2IyNzgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvbmF2aWdhdGlvbi1jb250cm9sLmpzP2ExYzUiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWFwLWdsL2Rpc3QvZXNtL2NvbXBvbmVudHMvc2NhbGUtY29udHJvbC5qcz9lNzIwIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9jYW52YXMtb3ZlcmxheS5qcz84NTMzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9vdmVybGF5cy9odG1sLW92ZXJsYXkuanM/Y2Q3ZCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vb3ZlcmxheXMvc3ZnLW92ZXJsYXkuanM/OGU1MCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9yZWFjdC1tYXAtZ2wvZGlzdC9lc20vdXRpbHMvc2V0LXJ0bC10ZXh0LXBsdWdpbi5qcz8wMGNmIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hcC1nbC9kaXN0L2VzbS9pbmRleC5qcz9jMWIzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2RhdGEvY29uc3RhbnRzLnRzeD9iZTVhIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2RhdGEvbWFwU3R5bGUudHN4PzlkOTYiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9hcmVhRGV0YWlsLm1vZHVsZS5zY3NzPzRjNzAiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9hcmVhRGV0YWlsLnRzeD8yOTU3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2hlbHBlcnMvZGlzdC9lcy9pbmRleC5qcz8yOTI1Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0B0dXJmL21ldGEvZGlzdC9lcy9pbmRleC5qcz80ZTU4Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jib3gvZGlzdC9lcy9pbmRleC5qcz9jZTFjIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2N1YmljLmpzP2U0MmQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy90ZXJyaXRvcnlGb2N1c0NvbnRyb2wubW9kdWxlLnNjc3M/MDAwYyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL3RlcnJpdG9yeUZvY3VzQ29udHJvbC50c3g/MTRlNSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0o0ME1hcC5tb2R1bGUuc2Nzcz9iN2RiIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvSjQwTWFwLnRzeD9hZjc3Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvbWFwV3JhcHBlci50c3g/MTViOCIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0hvd1lvdUNhbkhlbHAubW9kdWxlLnNjc3M/Y2NjYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0hvd1lvdUNhbkhlbHAudHN4PzkwYjQiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9tYXBMZWdlbmQubW9kdWxlLnNjc3M/YmNiYyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL21hcExlZ2VuZC50c3g/ODE2MSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL2Rvd25sb2FkUGFja2V0Lm1vZHVsZS5zY3NzP2JiODMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2ZpbGVfZG93bmxvYWQuc3ZnPzIyNzkiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9kb3dubG9hZFBhY2tldC50c3g/Nzk4MiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9wYWdlcy9jZWpzdC5tb2R1bGUuc2Nzcz82MWUzIiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL3BhZ2VzL2NlanN0LnRzeD9lMWRmIl0sIm5hbWVzIjpbIkZFQVRVUkVfVElMRV9CQVNFX1VSTCIsIlhZWl9TVUZGSVgiLCJmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUiLCJ0aWxlc2V0TmFtZSIsIkZFQVRVUkVfVElMRV9ISUdIX1pPT01fVVJMIiwiRkVBVFVSRV9USUxFX0xPV19aT09NX1VSTCIsIlBFUkZPUk1BTkNFX01BUktFUl9NQVBfSURMRSIsIlNDT1JFX1BST1BFUlRZX0hJR0giLCJTQ09SRV9QUk9QRVJUWV9MT1ciLCJHRU9JRF9QUk9QRVJUWSIsIkhJR0hfU0NPUkVfU09VUkNFX05BTUUiLCJISUdIX1NDT1JFX0xBWUVSX05BTUUiLCJMT1dfU0NPUkVfU09VUkNFX05BTUUiLCJMT1dfU0NPUkVfTEFZRVJfTkFNRSIsIlNFTEVDVEVEX1BST1BFUlRZIiwiU0NPUkVfU09VUkNFX0xBWUVSIiwiR0xPQkFMX01JTl9aT09NIiwiR0xPQkFMX01BWF9aT09NIiwiR0xPQkFMX01JTl9aT09NX0xPVyIsIkdMT0JBTF9NQVhfWk9PTV9MT1ciLCJHTE9CQUxfTUlOX1pPT01fSElHSExJR0hUIiwiR0xPQkFMX01BWF9aT09NX0hJR0hMSUdIVCIsIkdMT0JBTF9NSU5fWk9PTV9ISUdIIiwiR0xPQkFMX01BWF9aT09NX0hJR0giLCJHTE9CQUxfTUFYX0JPVU5EUyIsIkxPV0VSXzQ4X0JPVU5EUyIsIkFMQVNLQV9CT1VORFMiLCJIQVdBSUlfQk9VTkRTIiwiUFVFUlRPX1JJQ09fQk9VTkRTIiwiR1VBTV9CT1VORFMiLCJNQVJJQU5BX0lTTEFORF9CT1VORFMiLCJBTUVSSUNBTl9TQU1PQV9CT1VORFMiLCJERUZBVUxUX0NFTlRFUiIsIkRFRkFVTFRfTEFZRVJfT1BBQ0lUWSIsIkRFRkFVTFRfT1VUTElORV9DT0xPUiIsIk1JTl9DT0xPUiIsIk1FRF9DT0xPUiIsIk1BWF9DT0xPUiIsIkJPUkRFUl9ISUdITElHSFRfQ09MT1IiLCJISUdITElHSFRfQk9SREVSX1dJRFRIIiwiU0NPUkVfQk9VTkRBUllfTE9XIiwiU0NPUkVfQk9VTkRBUllfVEhSRVNIT0xEIiwiU0NPUkVfQk9VTkRBUllfUFJJT1JJVElaRUQiLCJpc01vYmlsZSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJoZXhUb0hTTEEiLCJoZXgiLCJhbHBoYSIsImNocm9tYSIsImNzcyIsIm1ha2VQYWludCIsImZpZWxkIiwibWluUmFtcCIsIm1lZFJhbXAiLCJtYXhSYW1wIiwicGFpbnREZXNjcmlwdG9yIiwiY29uc3RhbnRzIiwiaW1hZ2VTdWZmaXgiLCJtYWtlTWFwU3R5bGUiLCJmbGFnQ29udGFpbmVyIiwiQXJlYURldGFpbCIsInByb3BlcnRpZXMiLCJyZWFkYWJsZVBlcmNlbnQiLCJwZXJjZW50IiwidG9GaXhlZCIsImdldENhdGVnb3JpemF0aW9uIiwicGVyY2VudGlsZSIsImNhdGVnb3JpemF0aW9uIiwiZ2V0VGl0bGVDb250ZW50IiwiYmxvY2tHcm91cCIsInNjb3JlIiwic3R5bGVzIiwiZ2V0Qm9keUNvbnRlbnQiLCJyb3dzIiwic29ydGVkS2V5cyIsIk9iamVjdCIsImVudHJpZXMiLCJzb3J0Iiwia2V5IiwidmFsdWUiLCJtYXRjaCIsInB1c2giLCJUZXJyaXRvcnlGb2N1c0NvbnRyb2wiLCJvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b24iLCJ1c2VNYXBDb250cm9sIiwib25DbGljayIsImNvbnRhaW5lclJlZiIsIko0ME1hcCIsInVzZVN0YXRlIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwidmlld3BvcnQiLCJzZXRWaWV3cG9ydCIsInNlbGVjdGVkRmVhdHVyZSIsInNldFNlbGVjdGVkRmVhdHVyZSIsImRldGFpbFZpZXdEYXRhIiwic2V0RGV0YWlsVmlld0RhdGEiLCJ0cmFuc2l0aW9uSW5Qcm9ncmVzcyIsInNldFRyYW5zaXRpb25JblByb2dyZXNzIiwiZ2VvbG9jYXRpb25JblByb2dyZXNzIiwic2V0R2VvbG9jYXRpb25JblByb2dyZXNzIiwibWFwUmVmIiwidXNlUmVmIiwiZmxhZ3MiLCJ1c2VGbGFncyIsImV2ZW50IiwiZmVhdHVyZSIsImZlYXR1cmVzIiwiYmJveCIsIm1pbkxuZyIsIm1pbkxhdCIsIm1heExuZyIsIm1heExhdCIsIm5ld1ZpZXdQb3J0IiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsImhlaWdodCIsIndpZHRoIiwiZml0Qm91bmRzIiwicGFkZGluZyIsImlkIiwic2V0TWFwU2VsZWN0ZWQiLCJwb3B1cEluZm8iLCJnb1RvUGxhY2UiLCJvbkxvYWQiLCJDeXByZXNzIiwiY3VycmVudCIsInVuZGVybHlpbmdNYXAiLCJnZXRNYXAiLCJib3VuZHMiLCJvZmZzZXQiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uSW50ZXJwb2xhdG9yIiwiRmx5VG9JbnRlcnBvbGF0b3IiLCJ0cmFuc2l0aW9uRWFzaW5nIiwiZDMiLCJpc1NlbGVjdGVkIiwic2V0RmVhdHVyZVN0YXRlIiwic291cmNlIiwic291cmNlTGF5ZXIiLCJ1bmRlZmluZWQiLCJidXR0b25JRCIsInRhcmdldCIsIm9uVHJhbnNpdGlvblN0YXJ0Iiwib25UcmFuc2l0aW9uRW5kIiwib25HZW9sb2NhdGUiLCJvbkNsaWNrR2VvbG9jYXRlIiwiaGFzaCIsImVuYWJsZUhpZ2hBY2N1cmFjeSIsIk1hcFdyYXBwZXIiLCJIb3dZb3VDYW5IZWxwIiwiTWFwTGVnZW5kIiwiY2JnRmlsZVVSTCIsIkRvd25sb2FkUGFja2V0IiwiZG93bmxvYWRJY29uIiwiQ0VKU1RQYWdlIiwibG9jYXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWU7QUFDZjtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU8sU0FBUyxhQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU8sU0FBUyxVQUFLO0FBQ3JCO0FB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Q0FGRixDQUZGLGNBcUNFLGlEQXJDRixjQXNDRSxvQkFBQyxVQUFELE1BdENGLGNBdUNFLG9CQUFDLFNBQUQsTUF2Q0YsY0F3Q0Usb0JBQUMsd0JBQUQsTUF4Q0YsQ0FERixDQURGLENBOENELENBakRELENBbURBLDBDQUFlb0YsU0FBZiIsImZpbGUiOiIyNzY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5TGltaXQgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3QuanNcIjtcblxuLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcclxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCBcImNvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmh5cG90LmpzXCI7XG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHosIHcpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6LCB3KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5mbG9vcihhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHosIHcpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IC1hWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0geCAqIGxlbjtcbiAgb3V0WzFdID0geSAqIGxlbjtcbiAgb3V0WzJdID0geiAqIGxlbjtcbiAgb3V0WzNdID0gdyAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdGhyZWUgdmVjdG9ycyBpbiBhIDQtZGltZW5zaW9uYWwgc3BhY2VcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IHJlc3VsdCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gVSB0aGUgZmlyc3QgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBWIHRoZSBzZWNvbmQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBXIHRoZSB0aGlyZCB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IHJlc3VsdFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgdSwgdiwgdykge1xuICB2YXIgQSA9IHZbMF0gKiB3WzFdIC0gdlsxXSAqIHdbMF0sXG4gICAgICBCID0gdlswXSAqIHdbMl0gLSB2WzJdICogd1swXSxcbiAgICAgIEMgPSB2WzBdICogd1szXSAtIHZbM10gKiB3WzBdLFxuICAgICAgRCA9IHZbMV0gKiB3WzJdIC0gdlsyXSAqIHdbMV0sXG4gICAgICBFID0gdlsxXSAqIHdbM10gLSB2WzNdICogd1sxXSxcbiAgICAgIEYgPSB2WzJdICogd1szXSAtIHZbM10gKiB3WzJdO1xuICB2YXIgRyA9IHVbMF07XG4gIHZhciBIID0gdVsxXTtcbiAgdmFyIEkgPSB1WzJdO1xuICB2YXIgSiA9IHVbM107XG4gIG91dFswXSA9IEggKiBGIC0gSSAqIEUgKyBKICogRDtcbiAgb3V0WzFdID0gLShHICogRikgKyBJICogQyAtIEogKiBCO1xuICBvdXRbMl0gPSBHICogRSAtIEggKiBDICsgSiAqIEE7XG4gIG91dFszXSA9IC0oRyAqIEQpICsgSCAqIEIgLSBJICogQTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgdmFyIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wOyAvLyBNYXJzYWdsaWEsIEdlb3JnZS4gQ2hvb3NpbmcgYSBQb2ludCBmcm9tIHRoZSBTdXJmYWNlIG9mIGFcbiAgLy8gU3BoZXJlLiBBbm4uIE1hdGguIFN0YXRpc3QuIDQzICgxOTcyKSwgbm8uIDIsIDY0NS0tNjQ2LlxuICAvLyBodHRwOi8vcHJvamVjdGV1Y2xpZC5vcmcvZXVjbGlkLmFvbXMvMTE3NzY5MjY0NDtcblxuICB2YXIgdjEsIHYyLCB2MywgdjQ7XG4gIHZhciBzMSwgczI7XG5cbiAgZG8ge1xuICAgIHYxID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2MiA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczEgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgfSB3aGlsZSAoczEgPj0gMSk7XG5cbiAgZG8ge1xuICAgIHYzID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2NCA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczIgPSB2MyAqIHYzICsgdjQgKiB2NDtcbiAgfSB3aGlsZSAoczIgPj0gMSk7XG5cbiAgdmFyIGQgPSBNYXRoLnNxcnQoKDEgLSBzMSkgLyBzMik7XG4gIG91dFswXSA9IHNjYWxlICogdjE7XG4gIG91dFsxXSA9IHNjYWxlICogdjI7XG4gIG91dFsyXSA9IHNjYWxlICogdjMgKiBkO1xuICBvdXRbM10gPSBzY2FsZSAqIHY0ICogZDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdOyAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuXG4gIHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgdmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICB2YXIgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIHZhciBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7IC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gNDtcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgdmVjWzNdID0gYVtpICsgM107XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgICAgYVtpICsgM10gPSB2ZWNbM107XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0ICogYXMgdmVjNCBmcm9tICdnbC1tYXRyaXgvdmVjNCc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1WZWN0b3IobWF0cml4LCB2ZWN0b3IpIHtcbiAgdmFyIHJlc3VsdCA9IHZlYzQudHJhbnNmb3JtTWF0NChbXSwgdmVjdG9yLCBtYXRyaXgpO1xuICB2ZWM0LnNjYWxlKHJlc3VsdCwgcmVzdWx0LCAxIC8gcmVzdWx0WzNdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb2QodmFsdWUsIGRpdmlzb3IpIHtcbiAgdmFyIG1vZHVsdXMgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gIHJldHVybiBtb2R1bHVzIDwgMCA/IGRpdmlzb3IgKyBtb2R1bHVzIDogbW9kdWx1cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAgKiBlbmQgKyAoMSAtIHN0ZXApICogc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGllTG9nMih4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMkU7XG59XG5cbmV4cG9ydCB2YXIgbG9nMiA9IE1hdGgubG9nMiB8fCBpZUxvZzI7IiwiaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3QuanNcIjtcbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IE1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcclxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XHJcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxyXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXHJcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cclxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxyXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qc1wiO1xuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWMyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeTtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAyRCB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSB2ZWMyIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCByYWQpIHtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICB2YXIgcDAgPSBhWzBdIC0gYlswXSxcbiAgICAgIHAxID0gYVsxXSAtIGJbMV0sXG4gICAgICBzaW5DID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGNvc0MgPSBNYXRoLmNvcyhyYWQpOyAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgICAgeTEgPSBhWzFdLFxuICAgICAgeDIgPSBiWzBdLFxuICAgICAgeTIgPSBiWzFdLFxuICAgICAgLy8gbWFnIGlzIHRoZSBwcm9kdWN0IG9mIHRoZSBtYWduaXR1ZGVzIG9mIGEgYW5kIGJcbiAgbWFnID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKSAqIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5MiksXG4gICAgICAvLyBtYWcgJiYuLiBzaG9ydCBjaXJjdWl0cyBpZiBtYWcgPT0gMFxuICBjb3NpbmUgPSBtYWcgJiYgKHgxICogeDIgKyB5MSAqIHkyKSAvIG1hZzsgLy8gTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpIGNsYW1wcyB0aGUgY29zaW5lIGJldHdlZW4gLTEgYW5kIDFcblxuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAyO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3QuanNcIjtcbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjM1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcclxuICpcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaGVybWl0ZShvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMTtcbiAgdmFyIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdDtcbiAgdmFyIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcclxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gYmVuY2htYXJrczogaHR0cHM6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zLWZpeGVkXG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07IC8vIHZhciBxdmVjID0gW3F4LCBxeSwgcXpdO1xuICAvLyB2YXIgdXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCBhKTtcblxuICB2YXIgdXZ4ID0gcXkgKiB6IC0gcXogKiB5LFxuICAgICAgdXZ5ID0gcXogKiB4IC0gcXggKiB6LFxuICAgICAgdXZ6ID0gcXggKiB5IC0gcXkgKiB4OyAvLyB2YXIgdXV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgdXYpO1xuXG4gIHZhciB1dXZ4ID0gcXkgKiB1dnogLSBxeiAqIHV2eSxcbiAgICAgIHV1dnkgPSBxeiAqIHV2eCAtIHF4ICogdXZ6LFxuICAgICAgdXV2eiA9IHF4ICogdXZ5IC0gcXkgKiB1dng7IC8vIHZlYzMuc2NhbGUodXYsIHV2LCAyICogdyk7XG5cbiAgdmFyIHcyID0gcXcgKiAyO1xuICB1dnggKj0gdzI7XG4gIHV2eSAqPSB3MjtcbiAgdXZ6ICo9IHcyOyAvLyB2ZWMzLnNjYWxlKHV1diwgdXV2LCAyKTtcblxuICB1dXZ4ICo9IDI7XG4gIHV1dnkgKj0gMjtcbiAgdXV2eiAqPSAyOyAvLyByZXR1cm4gdmVjMy5hZGQob3V0LCBhLCB2ZWMzLmFkZChvdXQsIHV2LCB1dXYpKTtcblxuICBvdXRbMF0gPSB4ICsgdXZ4ICsgdXV2eDtcbiAgb3V0WzFdID0geSArIHV2eSArIHV1dnk7XG4gIG91dFsyXSA9IHogKyB1dnogKyB1dXZ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4ocmFkKSArIHBbMF0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhyYWQpIC0gcFswXSAqIE1hdGguc2luKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdICogTWF0aC5jb3MocmFkKSAtIHBbMV0gKiBNYXRoLnNpbihyYWQpO1xuICByWzFdID0gcFswXSAqIE1hdGguc2luKHJhZCkgKyBwWzFdICogTWF0aC5jb3MocmFkKTtcbiAgclsyXSA9IHBbMl07IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBtYWcxID0gTWF0aC5zcXJ0KGF4ICogYXggKyBheSAqIGF5ICsgYXogKiBheiksXG4gICAgICBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiksXG4gICAgICBtYWcgPSBtYWcxICogbWFnMixcbiAgICAgIGNvc2luZSA9IG1hZyAmJiBkb3QoYSwgYikgLyBtYWc7XG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjMyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdAbWF0aC5nbC93ZWItbWVyY2F0b3I6IGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IHsgY3JlYXRlTWF0NCwgdHJhbnNmb3JtVmVjdG9yLCBsb2cyIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnZ2wtbWF0cml4L21hdDQnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBQSV80ID0gUEkgLyA0O1xudmFyIERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xudmFyIFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MCAvIFBJO1xudmFyIFRJTEVfU0laRSA9IDUxMjtcbnZhciBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcbmV4cG9ydCB2YXIgREVGQVVMVF9BTFRJVFVERSA9IDEuNTtcbmV4cG9ydCBmdW5jdGlvbiB6b29tVG9TY2FsZSh6b29tKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZVRvWm9vbShzY2FsZSkge1xuICByZXR1cm4gbG9nMihzY2FsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG5nTGF0VG9Xb3JsZChfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgbG5nID0gX3JlZjJbMF0sXG4gICAgICBsYXQgPSBfcmVmMlsxXTtcblxuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxuZykpO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdCkgJiYgbGF0ID49IC05MCAmJiBsYXQgPD0gOTAsICdpbnZhbGlkIGxhdGl0dWRlJyk7XG4gIHZhciBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICB2YXIgcGhpMiA9IGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgdmFyIHggPSBUSUxFX1NJWkUgKiAobGFtYmRhMiArIFBJKSAvICgyICogUEkpO1xuICB2YXIgeSA9IFRJTEVfU0laRSAqIChQSSArIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb0xuZ0xhdChfcmVmMykge1xuICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICB4ID0gX3JlZjRbMF0sXG4gICAgICB5ID0gX3JlZjRbMV07XG5cbiAgdmFyIGxhbWJkYTIgPSB4IC8gVElMRV9TSVpFICogKDIgKiBQSSkgLSBQSTtcbiAgdmFyIHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cCh5IC8gVElMRV9TSVpFICogKDIgKiBQSSkgLSBQSSkpIC0gUElfNCk7XG4gIHJldHVybiBbbGFtYmRhMiAqIFJBRElBTlNfVE9fREVHUkVFUywgcGhpMiAqIFJBRElBTlNfVE9fREVHUkVFU107XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0ZXJab29tKF9yZWY1KSB7XG4gIHZhciBsYXRpdHVkZSA9IF9yZWY1LmxhdGl0dWRlO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSk7XG4gIHZhciBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIHJldHVybiBzY2FsZVRvWm9vbShFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lKSAtIDk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2VTY2FsZXMoX3JlZjYpIHtcbiAgdmFyIGxhdGl0dWRlID0gX3JlZjYubGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGUgPSBfcmVmNi5sb25naXR1ZGUsXG4gICAgICBfcmVmNiRoaWdoUHJlY2lzaW9uID0gX3JlZjYuaGlnaFByZWNpc2lvbixcbiAgICAgIGhpZ2hQcmVjaXNpb24gPSBfcmVmNiRoaWdoUHJlY2lzaW9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY2JGhpZ2hQcmVjaXNpb247XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpICYmIE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpKTtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgd29ybGRTaXplID0gVElMRV9TSVpFO1xuICB2YXIgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICB2YXIgdW5pdHNQZXJEZWdyZWVYID0gd29ybGRTaXplIC8gMzYwO1xuICB2YXIgdW5pdHNQZXJEZWdyZWVZID0gdW5pdHNQZXJEZWdyZWVYIC8gbGF0Q29zaW5lO1xuICB2YXIgYWx0VW5pdHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG4gIHJlc3VsdC51bml0c1Blck1ldGVyID0gW2FsdFVuaXRzUGVyTWV0ZXIsIGFsdFVuaXRzUGVyTWV0ZXIsIGFsdFVuaXRzUGVyTWV0ZXJdO1xuICByZXN1bHQubWV0ZXJzUGVyVW5pdCA9IFsxIC8gYWx0VW5pdHNQZXJNZXRlciwgMSAvIGFsdFVuaXRzUGVyTWV0ZXIsIDEgLyBhbHRVbml0c1Blck1ldGVyXTtcbiAgcmVzdWx0LnVuaXRzUGVyRGVncmVlID0gW3VuaXRzUGVyRGVncmVlWCwgdW5pdHNQZXJEZWdyZWVZLCBhbHRVbml0c1Blck1ldGVyXTtcbiAgcmVzdWx0LmRlZ3JlZXNQZXJVbml0ID0gWzEgLyB1bml0c1BlckRlZ3JlZVgsIDEgLyB1bml0c1BlckRlZ3JlZVksIDEgLyBhbHRVbml0c1Blck1ldGVyXTtcblxuICBpZiAoaGlnaFByZWNpc2lvbikge1xuICAgIHZhciBsYXRDb3NpbmUyID0gREVHUkVFU19UT19SQURJQU5TICogTWF0aC50YW4obGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gbGF0Q29zaW5lO1xuICAgIHZhciB1bml0c1BlckRlZ3JlZVkyID0gdW5pdHNQZXJEZWdyZWVYICogbGF0Q29zaW5lMiAvIDI7XG4gICAgdmFyIGFsdFVuaXRzUGVyRGVncmVlMiA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUyO1xuICAgIHZhciBhbHRVbml0c1Blck1ldGVyMiA9IGFsdFVuaXRzUGVyRGVncmVlMiAvIHVuaXRzUGVyRGVncmVlWSAqIGFsdFVuaXRzUGVyTWV0ZXI7XG4gICAgcmVzdWx0LnVuaXRzUGVyRGVncmVlMiA9IFswLCB1bml0c1BlckRlZ3JlZVkyLCBhbHRVbml0c1BlckRlZ3JlZTJdO1xuICAgIHJlc3VsdC51bml0c1Blck1ldGVyMiA9IFthbHRVbml0c1Blck1ldGVyMiwgMCwgYWx0VW5pdHNQZXJNZXRlcjJdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgdmFyIF9sbmdMYXRaID0gX3NsaWNlZFRvQXJyYXkobG5nTGF0WiwgMyksXG4gICAgICBsb25naXR1ZGUgPSBfbG5nTGF0WlswXSxcbiAgICAgIGxhdGl0dWRlID0gX2xuZ0xhdFpbMV0sXG4gICAgICB6MCA9IF9sbmdMYXRaWzJdO1xuXG4gIHZhciBfeHl6ID0gX3NsaWNlZFRvQXJyYXkoeHl6LCAzKSxcbiAgICAgIHggPSBfeHl6WzBdLFxuICAgICAgeSA9IF94eXpbMV0sXG4gICAgICB6ID0gX3h5elsyXTtcblxuICB2YXIgX2dldERpc3RhbmNlU2NhbGVzID0gZ2V0RGlzdGFuY2VTY2FsZXMoe1xuICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICBoaWdoUHJlY2lzaW9uOiB0cnVlXG4gIH0pLFxuICAgICAgdW5pdHNQZXJNZXRlciA9IF9nZXREaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyLFxuICAgICAgdW5pdHNQZXJNZXRlcjIgPSBfZ2V0RGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlcjI7XG5cbiAgdmFyIHdvcmxkc3BhY2UgPSBsbmdMYXRUb1dvcmxkKGxuZ0xhdFopO1xuICB3b3JsZHNwYWNlWzBdICs9IHggKiAodW5pdHNQZXJNZXRlclswXSArIHVuaXRzUGVyTWV0ZXIyWzBdICogeSk7XG4gIHdvcmxkc3BhY2VbMV0gKz0geSAqICh1bml0c1Blck1ldGVyWzFdICsgdW5pdHNQZXJNZXRlcjJbMV0gKiB5KTtcbiAgdmFyIG5ld0xuZ0xhdCA9IHdvcmxkVG9MbmdMYXQod29ybGRzcGFjZSk7XG4gIHZhciBuZXdaID0gKHowIHx8IDApICsgKHogfHwgMCk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoejApIHx8IE51bWJlci5pc0Zpbml0ZSh6KSA/IFtuZXdMbmdMYXRbMF0sIG5ld0xuZ0xhdFsxXSwgbmV3Wl0gOiBuZXdMbmdMYXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeChfcmVmNykge1xuICB2YXIgaGVpZ2h0ID0gX3JlZjcuaGVpZ2h0LFxuICAgICAgcGl0Y2ggPSBfcmVmNy5waXRjaCxcbiAgICAgIGJlYXJpbmcgPSBfcmVmNy5iZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUgPSBfcmVmNy5hbHRpdHVkZSxcbiAgICAgIHNjYWxlID0gX3JlZjcuc2NhbGUsXG4gICAgICBfcmVmNyRjZW50ZXIgPSBfcmVmNy5jZW50ZXIsXG4gICAgICBjZW50ZXIgPSBfcmVmNyRjZW50ZXIgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNyRjZW50ZXI7XG4gIHZhciB2bSA9IGNyZWF0ZU1hdDQoKTtcbiAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCBbMCwgMCwgLWFsdGl0dWRlXSk7XG4gIG1hdDQucm90YXRlWCh2bSwgdm0sIC1waXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIG1hdDQucm90YXRlWih2bSwgdm0sIGJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBzY2FsZSAvPSBoZWlnaHQ7XG4gIG1hdDQuc2NhbGUodm0sIHZtLCBbc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIHZlYzMubmVnYXRlKFtdLCBjZW50ZXIpKTtcbiAgfVxuXG4gIHJldHVybiB2bTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uUGFyYW1ldGVycyhfcmVmOCkge1xuICB2YXIgd2lkdGggPSBfcmVmOC53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWY4LmhlaWdodCxcbiAgICAgIF9yZWY4JGZvdnkgPSBfcmVmOC5mb3Z5LFxuICAgICAgZm92eSA9IF9yZWY4JGZvdnkgPT09IHZvaWQgMCA/IGFsdGl0dWRlVG9Gb3Z5KERFRkFVTFRfQUxUSVRVREUpIDogX3JlZjgkZm92eSxcbiAgICAgIGFsdGl0dWRlID0gX3JlZjguYWx0aXR1ZGUsXG4gICAgICBfcmVmOCRwaXRjaCA9IF9yZWY4LnBpdGNoLFxuICAgICAgcGl0Y2ggPSBfcmVmOCRwaXRjaCA9PT0gdm9pZCAwID8gMCA6IF9yZWY4JHBpdGNoLFxuICAgICAgX3JlZjgkbmVhclpNdWx0aXBsaWVyID0gX3JlZjgubmVhclpNdWx0aXBsaWVyLFxuICAgICAgbmVhclpNdWx0aXBsaWVyID0gX3JlZjgkbmVhclpNdWx0aXBsaWVyID09PSB2b2lkIDAgPyAxIDogX3JlZjgkbmVhclpNdWx0aXBsaWVyLFxuICAgICAgX3JlZjgkZmFyWk11bHRpcGxpZXIgPSBfcmVmOC5mYXJaTXVsdGlwbGllcixcbiAgICAgIGZhclpNdWx0aXBsaWVyID0gX3JlZjgkZmFyWk11bHRpcGxpZXIgPT09IHZvaWQgMCA/IDEgOiBfcmVmOCRmYXJaTXVsdGlwbGllcjtcblxuICBpZiAoYWx0aXR1ZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gIH1cblxuICB2YXIgaGFsZkZvdiA9IDAuNSAqIGZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIHZhciBmb2NhbERpc3RhbmNlID0gZm92eVRvQWx0aXR1ZGUoZm92eSk7XG4gIHZhciBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgdmFyIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPSBNYXRoLnNpbihoYWxmRm92KSAqIGZvY2FsRGlzdGFuY2UgLyBNYXRoLnNpbihNYXRoLm1pbihNYXRoLm1heChNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YsIDAuMDEpLCBNYXRoLlBJIC0gMC4wMSkpO1xuICB2YXIgZmFyWiA9IE1hdGguc2luKHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgZm9jYWxEaXN0YW5jZTtcbiAgcmV0dXJuIHtcbiAgICBmb3Y6IDIgKiBoYWxmRm92LFxuICAgIGFzcGVjdDogd2lkdGggLyBoZWlnaHQsXG4gICAgZm9jYWxEaXN0YW5jZTogZm9jYWxEaXN0YW5jZSxcbiAgICBuZWFyOiBuZWFyWk11bHRpcGxpZXIsXG4gICAgZmFyOiBmYXJaICogZmFyWk11bHRpcGxpZXJcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uTWF0cml4KF9yZWY5KSB7XG4gIHZhciB3aWR0aCA9IF9yZWY5LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjkuaGVpZ2h0LFxuICAgICAgcGl0Y2ggPSBfcmVmOS5waXRjaCxcbiAgICAgIGFsdGl0dWRlID0gX3JlZjkuYWx0aXR1ZGUsXG4gICAgICBmb3Z5ID0gX3JlZjkuZm92eSxcbiAgICAgIG5lYXJaTXVsdGlwbGllciA9IF9yZWY5Lm5lYXJaTXVsdGlwbGllcixcbiAgICAgIGZhclpNdWx0aXBsaWVyID0gX3JlZjkuZmFyWk11bHRpcGxpZXI7XG5cbiAgdmFyIF9nZXRQcm9qZWN0aW9uUGFyYW1ldCA9IGdldFByb2plY3Rpb25QYXJhbWV0ZXJzKHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgYWx0aXR1ZGU6IGFsdGl0dWRlLFxuICAgIGZvdnk6IGZvdnksXG4gICAgcGl0Y2g6IHBpdGNoLFxuICAgIG5lYXJaTXVsdGlwbGllcjogbmVhclpNdWx0aXBsaWVyLFxuICAgIGZhclpNdWx0aXBsaWVyOiBmYXJaTXVsdGlwbGllclxuICB9KSxcbiAgICAgIGZvdiA9IF9nZXRQcm9qZWN0aW9uUGFyYW1ldC5mb3YsXG4gICAgICBhc3BlY3QgPSBfZ2V0UHJvamVjdGlvblBhcmFtZXQuYXNwZWN0LFxuICAgICAgbmVhciA9IF9nZXRQcm9qZWN0aW9uUGFyYW1ldC5uZWFyLFxuICAgICAgZmFyID0gX2dldFByb2plY3Rpb25QYXJhbWV0LmZhcjtcblxuICB2YXIgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoW10sIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSkge1xuICByZXR1cm4gMiAqIE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSkgKiBSQURJQU5TX1RPX0RFR1JFRVM7XG59XG5leHBvcnQgZnVuY3Rpb24gZm92eVRvQWx0aXR1ZGUoZm92eSkge1xuICByZXR1cm4gMC41IC8gTWF0aC50YW4oMC41ICogZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb1BpeGVscyh4eXosIHBpeGVsUHJvamVjdGlvbk1hdHJpeCkge1xuICB2YXIgX3h5ejIgPSBfc2xpY2VkVG9BcnJheSh4eXosIDMpLFxuICAgICAgeCA9IF94eXoyWzBdLFxuICAgICAgeSA9IF94eXoyWzFdLFxuICAgICAgX3h5ejIkID0gX3h5ejJbMl0sXG4gICAgICB6ID0gX3h5ejIkID09PSB2b2lkIDAgPyAwIDogX3h5ejIkO1xuXG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpICYmIE51bWJlci5pc0Zpbml0ZSh6KSk7XG4gIHJldHVybiB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgeiwgMV0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpeGVsc1RvV29ybGQoeHl6LCBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCkge1xuICB2YXIgdGFyZ2V0WiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICB2YXIgX3h5ejMgPSBfc2xpY2VkVG9BcnJheSh4eXosIDMpLFxuICAgICAgeCA9IF94eXozWzBdLFxuICAgICAgeSA9IF94eXozWzFdLFxuICAgICAgeiA9IF94eXozWzJdO1xuXG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpLCAnaW52YWxpZCBwaXhlbCBjb29yZGluYXRlJyk7XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgIHZhciBjb29yZCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbiAgICByZXR1cm4gY29vcmQ7XG4gIH1cblxuICB2YXIgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMCwgMV0pO1xuICB2YXIgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMSwgMV0pO1xuICB2YXIgejAgPSBjb29yZDBbMl07XG4gIHZhciB6MSA9IGNvb3JkMVsyXTtcbiAgdmFyIHQgPSB6MCA9PT0gejEgPyAwIDogKCh0YXJnZXRaIHx8IDApIC0gejApIC8gKHoxIC0gejApO1xuICByZXR1cm4gdmVjMi5sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJy4vd2ViLW1lcmNhdG9yLXZpZXdwb3J0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuaW1wb3J0IHsgbG9nMiB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaXRCb3VuZHMoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBib3VuZHMgPSBfcmVmLmJvdW5kcyxcbiAgICAgIF9yZWYkbWluRXh0ZW50ID0gX3JlZi5taW5FeHRlbnQsXG4gICAgICBtaW5FeHRlbnQgPSBfcmVmJG1pbkV4dGVudCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkbWluRXh0ZW50LFxuICAgICAgX3JlZiRtYXhab29tID0gX3JlZi5tYXhab29tLFxuICAgICAgbWF4Wm9vbSA9IF9yZWYkbWF4Wm9vbSA9PT0gdm9pZCAwID8gMjQgOiBfcmVmJG1heFpvb20sXG4gICAgICBfcmVmJHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX3JlZiRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX3JlZiRwYWRkaW5nLFxuICAgICAgX3JlZiRvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9yZWYkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfcmVmJG9mZnNldDtcblxuICB2YXIgX2JvdW5kcyA9IF9zbGljZWRUb0FycmF5KGJvdW5kcywgMiksXG4gICAgICBfYm91bmRzJCA9IF9zbGljZWRUb0FycmF5KF9ib3VuZHNbMF0sIDIpLFxuICAgICAgd2VzdCA9IF9ib3VuZHMkWzBdLFxuICAgICAgc291dGggPSBfYm91bmRzJFsxXSxcbiAgICAgIF9ib3VuZHMkMiA9IF9zbGljZWRUb0FycmF5KF9ib3VuZHNbMV0sIDIpLFxuICAgICAgZWFzdCA9IF9ib3VuZHMkMlswXSxcbiAgICAgIG5vcnRoID0gX2JvdW5kcyQyWzFdO1xuXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUocGFkZGluZykpIHtcbiAgICB2YXIgcCA9IHBhZGRpbmc7XG4gICAgcGFkZGluZyA9IHtcbiAgICAgIHRvcDogcCxcbiAgICAgIGJvdHRvbTogcCxcbiAgICAgIGxlZnQ6IHAsXG4gICAgICByaWdodDogcFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLnRvcCkgJiYgTnVtYmVyLmlzRmluaXRlKHBhZGRpbmcuYm90dG9tKSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5sZWZ0KSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5yaWdodCkpO1xuICB9XG5cbiAgdmFyIHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBsb25naXR1ZGU6IDAsXG4gICAgbGF0aXR1ZGU6IDAsXG4gICAgem9vbTogMFxuICB9KTtcbiAgdmFyIG53ID0gdmlld3BvcnQucHJvamVjdChbd2VzdCwgbm9ydGhdKTtcbiAgdmFyIHNlID0gdmlld3BvcnQucHJvamVjdChbZWFzdCwgc291dGhdKTtcbiAgdmFyIHNpemUgPSBbTWF0aC5tYXgoTWF0aC5hYnMoc2VbMF0gLSBud1swXSksIG1pbkV4dGVudCksIE1hdGgubWF4KE1hdGguYWJzKHNlWzFdIC0gbndbMV0pLCBtaW5FeHRlbnQpXTtcbiAgdmFyIHRhcmdldFNpemUgPSBbd2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0IC0gTWF0aC5hYnMob2Zmc2V0WzBdKSAqIDIsIGhlaWdodCAtIHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20gLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMl07XG4gIGFzc2VydCh0YXJnZXRTaXplWzBdID4gMCAmJiB0YXJnZXRTaXplWzFdID4gMCk7XG4gIHZhciBzY2FsZVggPSB0YXJnZXRTaXplWzBdIC8gc2l6ZVswXTtcbiAgdmFyIHNjYWxlWSA9IHRhcmdldFNpemVbMV0gLyBzaXplWzFdO1xuICB2YXIgb2Zmc2V0WCA9IChwYWRkaW5nLnJpZ2h0IC0gcGFkZGluZy5sZWZ0KSAvIDIgLyBzY2FsZVg7XG4gIHZhciBvZmZzZXRZID0gKHBhZGRpbmcuYm90dG9tIC0gcGFkZGluZy50b3ApIC8gMiAvIHNjYWxlWTtcbiAgdmFyIGNlbnRlciA9IFsoc2VbMF0gKyBud1swXSkgLyAyICsgb2Zmc2V0WCwgKHNlWzFdICsgbndbMV0pIC8gMiArIG9mZnNldFldO1xuICB2YXIgY2VudGVyTG5nTGF0ID0gdmlld3BvcnQudW5wcm9qZWN0KGNlbnRlcik7XG4gIHZhciB6b29tID0gTWF0aC5taW4obWF4Wm9vbSwgdmlld3BvcnQuem9vbSArIGxvZzIoTWF0aC5hYnMoTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSkpO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pKTtcbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IGNlbnRlckxuZ0xhdFswXSxcbiAgICBsYXRpdHVkZTogY2VudGVyTG5nTGF0WzFdLFxuICAgIHpvb206IHpvb21cbiAgfTtcbn0iLCJpbXBvcnQgeyB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgeyB0cmFuc2Zvcm1WZWN0b3IgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xudmFyIERFR1JFRVNfVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZHModmlld3BvcnQpIHtcbiAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciB3aWR0aCA9IHZpZXdwb3J0LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgdW5wcm9qZWN0ID0gdmlld3BvcnQudW5wcm9qZWN0O1xuICB2YXIgdW5wcm9qZWN0T3BzID0ge1xuICAgIHRhcmdldFo6IHpcbiAgfTtcbiAgdmFyIGJvdHRvbUxlZnQgPSB1bnByb2plY3QoWzAsIGhlaWdodF0sIHVucHJvamVjdE9wcyk7XG4gIHZhciBib3R0b21SaWdodCA9IHVucHJvamVjdChbd2lkdGgsIGhlaWdodF0sIHVucHJvamVjdE9wcyk7XG4gIHZhciB0b3BMZWZ0O1xuICB2YXIgdG9wUmlnaHQ7XG4gIHZhciBoYWxmRm92ID0gdmlld3BvcnQuZm92eSA/IDAuNSAqIHZpZXdwb3J0LmZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlMgOiBNYXRoLmF0YW4oMC41IC8gdmlld3BvcnQuYWx0aXR1ZGUpO1xuICB2YXIgYW5nbGVUb0dyb3VuZCA9ICg5MCAtIHZpZXdwb3J0LnBpdGNoKSAqIERFR1JFRVNfVE9fUkFESUFOUztcblxuICBpZiAoaGFsZkZvdiA+IGFuZ2xlVG9Hcm91bmQgLSAwLjAxKSB7XG4gICAgdG9wTGVmdCA9IHVucHJvamVjdE9uRmFyUGxhbmUodmlld3BvcnQsIDAsIHopO1xuICAgIHRvcFJpZ2h0ID0gdW5wcm9qZWN0T25GYXJQbGFuZSh2aWV3cG9ydCwgd2lkdGgsIHopO1xuICB9IGVsc2Uge1xuICAgIHRvcExlZnQgPSB1bnByb2plY3QoWzAsIDBdLCB1bnByb2plY3RPcHMpO1xuICAgIHRvcFJpZ2h0ID0gdW5wcm9qZWN0KFt3aWR0aCwgMF0sIHVucHJvamVjdE9wcyk7XG4gIH1cblxuICByZXR1cm4gW2JvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgdG9wTGVmdF07XG59XG5cbmZ1bmN0aW9uIHVucHJvamVjdE9uRmFyUGxhbmUodmlld3BvcnQsIHgsIHRhcmdldFopIHtcbiAgdmFyIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gdmlld3BvcnQucGl4ZWxVbnByb2plY3Rpb25NYXRyaXg7XG4gIHZhciBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCAwLCAxLCAxXSk7XG4gIHZhciBjb29yZDEgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB2aWV3cG9ydC5oZWlnaHQsIDEsIDFdKTtcbiAgdmFyIHogPSB0YXJnZXRaICogdmlld3BvcnQuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgdmFyIHQgPSAoeiAtIGNvb3JkMFsyXSkgLyAoY29vcmQxWzJdIC0gY29vcmQwWzJdKTtcbiAgdmFyIGNvb3JkID0gdmVjMi5sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG4gIHZhciByZXN1bHQgPSB3b3JsZFRvTG5nTGF0KGNvb3JkKTtcbiAgcmVzdWx0WzJdID0gdGFyZ2V0WjtcbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IHsgY3JlYXRlTWF0NCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyB6b29tVG9TY2FsZSwgcGl4ZWxzVG9Xb3JsZCwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCwgd29ybGRUb1BpeGVscywgYWx0aXR1ZGVUb0ZvdnksIGZvdnlUb0FsdGl0dWRlLCBERUZBVUxUX0FMVElUVURFLCBnZXRQcm9qZWN0aW9uTWF0cml4LCBnZXREaXN0YW5jZVNjYWxlcywgZ2V0Vmlld01hdHJpeCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmltcG9ydCBfZml0Qm91bmRzIGZyb20gJy4vZml0LWJvdW5kcyc7XG5pbXBvcnQgZ2V0Qm91bmRzIGZyb20gJy4vZ2V0LWJvdW5kcyc7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJ2dsLW1hdHJpeC9tYXQ0JztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tICdnbC1tYXRyaXgvdmVjMyc7XG5cbnZhciBXZWJNZXJjYXRvclZpZXdwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViTWVyY2F0b3JWaWV3cG9ydCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9LFxuICAgICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgICBfcmVmJGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGUgPSBfcmVmJGxhdGl0dWRlID09PSB2b2lkIDAgPyAwIDogX3JlZiRsYXRpdHVkZSxcbiAgICAgICAgX3JlZiRsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3JlZiRsb25naXR1ZGUgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGxvbmdpdHVkZSxcbiAgICAgICAgX3JlZiR6b29tID0gX3JlZi56b29tLFxuICAgICAgICB6b29tID0gX3JlZiR6b29tID09PSB2b2lkIDAgPyAwIDogX3JlZiR6b29tLFxuICAgICAgICBfcmVmJHBpdGNoID0gX3JlZi5waXRjaCxcbiAgICAgICAgcGl0Y2ggPSBfcmVmJHBpdGNoID09PSB2b2lkIDAgPyAwIDogX3JlZiRwaXRjaCxcbiAgICAgICAgX3JlZiRiZWFyaW5nID0gX3JlZi5iZWFyaW5nLFxuICAgICAgICBiZWFyaW5nID0gX3JlZiRiZWFyaW5nID09PSB2b2lkIDAgPyAwIDogX3JlZiRiZWFyaW5nLFxuICAgICAgICBfcmVmJGFsdGl0dWRlID0gX3JlZi5hbHRpdHVkZSxcbiAgICAgICAgYWx0aXR1ZGUgPSBfcmVmJGFsdGl0dWRlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRhbHRpdHVkZSxcbiAgICAgICAgX3JlZiRmb3Z5ID0gX3JlZi5mb3Z5LFxuICAgICAgICBmb3Z5ID0gX3JlZiRmb3Z5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRmb3Z5LFxuICAgICAgICBfcmVmJHBvc2l0aW9uID0gX3JlZi5wb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb24gPSBfcmVmJHBvc2l0aW9uID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRwb3NpdGlvbixcbiAgICAgICAgX3JlZiRuZWFyWk11bHRpcGxpZXIgPSBfcmVmLm5lYXJaTXVsdGlwbGllcixcbiAgICAgICAgbmVhclpNdWx0aXBsaWVyID0gX3JlZiRuZWFyWk11bHRpcGxpZXIgPT09IHZvaWQgMCA/IDAuMDIgOiBfcmVmJG5lYXJaTXVsdGlwbGllcixcbiAgICAgICAgX3JlZiRmYXJaTXVsdGlwbGllciA9IF9yZWYuZmFyWk11bHRpcGxpZXIsXG4gICAgICAgIGZhclpNdWx0aXBsaWVyID0gX3JlZiRmYXJaTXVsdGlwbGllciA9PT0gdm9pZCAwID8gMS4wMSA6IF9yZWYkZmFyWk11bHRpcGxpZXI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViTWVyY2F0b3JWaWV3cG9ydCk7XG5cbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBpZiAoZm92eSA9PT0gbnVsbCAmJiBhbHRpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgYWx0aXR1ZGUgPSBERUZBVUxUX0FMVElUVURFO1xuICAgICAgZm92eSA9IGFsdGl0dWRlVG9Gb3Z5KGFsdGl0dWRlKTtcbiAgICB9IGVsc2UgaWYgKGZvdnkgPT09IG51bGwpIHtcbiAgICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gICAgfSBlbHNlIGlmIChhbHRpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgYWx0aXR1ZGUgPSBmb3Z5VG9BbHRpdHVkZShmb3Z5KTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGUgPSB6b29tVG9TY2FsZSh6b29tKTtcbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcbiAgICB2YXIgZGlzdGFuY2VTY2FsZXMgPSBnZXREaXN0YW5jZVNjYWxlcyh7XG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZVxuICAgIH0pO1xuICAgIHZhciBjZW50ZXIgPSBsbmdMYXRUb1dvcmxkKFtsb25naXR1ZGUsIGxhdGl0dWRlXSk7XG4gICAgY2VudGVyWzJdID0gMDtcblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgdmVjMy5hZGQoY2VudGVyLCBjZW50ZXIsIHZlYzMubXVsKFtdLCBwb3NpdGlvbiwgZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlcikpO1xuICAgIH1cblxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IGdldFByb2plY3Rpb25NYXRyaXgoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICBmb3Z5OiBmb3Z5LFxuICAgICAgbmVhclpNdWx0aXBsaWVyOiBuZWFyWk11bHRpcGxpZXIsXG4gICAgICBmYXJaTXVsdGlwbGllcjogZmFyWk11bHRpcGxpZXJcbiAgICB9KTtcbiAgICB0aGlzLnZpZXdNYXRyaXggPSBnZXRWaWV3TWF0cml4KHtcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlXG4gICAgfSk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG4gICAgdGhpcy5mb3Z5ID0gZm92eTtcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB0aGlzLm1ldGVyT2Zmc2V0ID0gcG9zaXRpb24gfHwgWzAsIDAsIDBdO1xuICAgIHRoaXMuZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcztcblxuICAgIHRoaXMuX2luaXRNYXRyaWNlcygpO1xuXG4gICAgdGhpcy5lcXVhbHMgPSB0aGlzLmVxdWFscy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdCA9IHRoaXMucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0ID0gdGhpcy51bnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3RQb3NpdGlvbiA9IHRoaXMucHJvamVjdFBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3RQb3NpdGlvbiA9IHRoaXMudW5wcm9qZWN0UG9zaXRpb24uYmluZCh0aGlzKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdlYk1lcmNhdG9yVmlld3BvcnQsIFt7XG4gICAga2V5OiBcIl9pbml0TWF0cmljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRNYXRyaWNlcygpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgcHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgICAgICB2aWV3TWF0cml4ID0gdGhpcy52aWV3TWF0cml4O1xuICAgICAgdmFyIHZwbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdmlld01hdHJpeCk7XG4gICAgICB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdnBtO1xuICAgICAgdmFyIG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgICBtYXQ0LnNjYWxlKG0sIG0sIFt3aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCAxXSk7XG4gICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdnBtKTtcbiAgICAgIHZhciBtSW52ZXJzZSA9IG1hdDQuaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG5cbiAgICAgIGlmICghbUludmVyc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG4gICAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHModmlld3BvcnQpIHtcbiAgICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgV2ViTWVyY2F0b3JWaWV3cG9ydCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiYgdmlld3BvcnQuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJiBtYXQ0LmVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2plY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdCh4eXopIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgX3JlZjIkdG9wTGVmdCA9IF9yZWYyLnRvcExlZnQsXG4gICAgICAgICAgdG9wTGVmdCA9IF9yZWYyJHRvcExlZnQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiR0b3BMZWZ0O1xuXG4gICAgICB2YXIgd29ybGRQb3NpdGlvbiA9IHRoaXMucHJvamVjdFBvc2l0aW9uKHh5eik7XG4gICAgICB2YXIgY29vcmQgPSB3b3JsZFRvUGl4ZWxzKHdvcmxkUG9zaXRpb24sIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgdmFyIF9jb29yZCA9IF9zbGljZWRUb0FycmF5KGNvb3JkLCAyKSxcbiAgICAgICAgICB4ID0gX2Nvb3JkWzBdLFxuICAgICAgICAgIHkgPSBfY29vcmRbMV07XG5cbiAgICAgIHZhciB5MiA9IHRvcExlZnQgPyB5IDogdGhpcy5oZWlnaHQgLSB5O1xuICAgICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCBjb29yZFsyXV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVucHJvamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnByb2plY3QoeHl6KSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICAgIF9yZWYzJHRvcExlZnQgPSBfcmVmMy50b3BMZWZ0LFxuICAgICAgICAgIHRvcExlZnQgPSBfcmVmMyR0b3BMZWZ0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkdG9wTGVmdCxcbiAgICAgICAgICBfcmVmMyR0YXJnZXRaID0gX3JlZjMudGFyZ2V0WixcbiAgICAgICAgICB0YXJnZXRaID0gX3JlZjMkdGFyZ2V0WiA9PT0gdm9pZCAwID8gdW5kZWZpbmVkIDogX3JlZjMkdGFyZ2V0WjtcblxuICAgICAgdmFyIF94eXogPSBfc2xpY2VkVG9BcnJheSh4eXosIDMpLFxuICAgICAgICAgIHggPSBfeHl6WzBdLFxuICAgICAgICAgIHkgPSBfeHl6WzFdLFxuICAgICAgICAgIHogPSBfeHl6WzJdO1xuXG4gICAgICB2YXIgeTIgPSB0b3BMZWZ0ID8geSA6IHRoaXMuaGVpZ2h0IC0geTtcbiAgICAgIHZhciB0YXJnZXRaV29ybGQgPSB0YXJnZXRaICYmIHRhcmdldFogKiB0aGlzLmRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXJbMl07XG4gICAgICB2YXIgY29vcmQgPSBwaXhlbHNUb1dvcmxkKFt4LCB5Miwgel0sIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIHRhcmdldFpXb3JsZCk7XG5cbiAgICAgIHZhciBfdGhpcyR1bnByb2plY3RQb3NpdGkgPSB0aGlzLnVucHJvamVjdFBvc2l0aW9uKGNvb3JkKSxcbiAgICAgICAgICBfdGhpcyR1bnByb2plY3RQb3NpdGkyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkdW5wcm9qZWN0UG9zaXRpLCAzKSxcbiAgICAgICAgICBYID0gX3RoaXMkdW5wcm9qZWN0UG9zaXRpMlswXSxcbiAgICAgICAgICBZID0gX3RoaXMkdW5wcm9qZWN0UG9zaXRpMlsxXSxcbiAgICAgICAgICBaID0gX3RoaXMkdW5wcm9qZWN0UG9zaXRpMlsyXTtcblxuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRhcmdldFopID8gW1gsIFksIHRhcmdldFpdIDogW1gsIFldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9qZWN0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdFBvc2l0aW9uKHh5eikge1xuICAgICAgdmFyIF9sbmdMYXRUb1dvcmxkID0gbG5nTGF0VG9Xb3JsZCh4eXopLFxuICAgICAgICAgIF9sbmdMYXRUb1dvcmxkMiA9IF9zbGljZWRUb0FycmF5KF9sbmdMYXRUb1dvcmxkLCAyKSxcbiAgICAgICAgICBYID0gX2xuZ0xhdFRvV29ybGQyWzBdLFxuICAgICAgICAgIFkgPSBfbG5nTGF0VG9Xb3JsZDJbMV07XG5cbiAgICAgIHZhciBaID0gKHh5elsyXSB8fCAwKSAqIHRoaXMuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgICAgIHJldHVybiBbWCwgWSwgWl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVucHJvamVjdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucHJvamVjdFBvc2l0aW9uKHh5eikge1xuICAgICAgdmFyIF93b3JsZFRvTG5nTGF0ID0gd29ybGRUb0xuZ0xhdCh4eXopLFxuICAgICAgICAgIF93b3JsZFRvTG5nTGF0MiA9IF9zbGljZWRUb0FycmF5KF93b3JsZFRvTG5nTGF0LCAyKSxcbiAgICAgICAgICBYID0gX3dvcmxkVG9MbmdMYXQyWzBdLFxuICAgICAgICAgIFkgPSBfd29ybGRUb0xuZ0xhdDJbMV07XG5cbiAgICAgIHZhciBaID0gKHh5elsyXSB8fCAwKSAqIHRoaXMuZGlzdGFuY2VTY2FsZXMubWV0ZXJzUGVyVW5pdFsyXTtcbiAgICAgIHJldHVybiBbWCwgWSwgWl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2plY3RGbGF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3RGbGF0KGxuZ0xhdCkge1xuICAgICAgcmV0dXJuIGxuZ0xhdFRvV29ybGQobG5nTGF0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5wcm9qZWN0RmxhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnByb2plY3RGbGF0KHh5KSB7XG4gICAgICByZXR1cm4gd29ybGRUb0xuZ0xhdCh4eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbihfcmVmNCkge1xuICAgICAgdmFyIGxuZ0xhdCA9IF9yZWY0LmxuZ0xhdCxcbiAgICAgICAgICBwb3MgPSBfcmVmNC5wb3M7XG4gICAgICB2YXIgZnJvbUxvY2F0aW9uID0gcGl4ZWxzVG9Xb3JsZChwb3MsIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgdmFyIHRvTG9jYXRpb24gPSBsbmdMYXRUb1dvcmxkKGxuZ0xhdCk7XG4gICAgICB2YXIgdHJhbnNsYXRlID0gdmVjMi5hZGQoW10sIHRvTG9jYXRpb24sIHZlYzIubmVnYXRlKFtdLCBmcm9tTG9jYXRpb24pKTtcbiAgICAgIHZhciBuZXdDZW50ZXIgPSB2ZWMyLmFkZChbXSwgdGhpcy5jZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgICByZXR1cm4gd29ybGRUb0xuZ0xhdChuZXdDZW50ZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb2NhdGlvbkF0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9jYXRpb25BdFBvaW50KF9yZWY1KSB7XG4gICAgICB2YXIgbG5nTGF0ID0gX3JlZjUubG5nTGF0LFxuICAgICAgICAgIHBvcyA9IF9yZWY1LnBvcztcbiAgICAgIHJldHVybiB0aGlzLmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgICBsbmdMYXQ6IGxuZ0xhdCxcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXRCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0Qm91bmRzKGJvdW5kcykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgdmFyIF9maXRCb3VuZHMyID0gX2ZpdEJvdW5kcyhPYmplY3QuYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgYm91bmRzOiBib3VuZHNcbiAgICAgIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICBsb25naXR1ZGUgPSBfZml0Qm91bmRzMi5sb25naXR1ZGUsXG4gICAgICAgICAgbGF0aXR1ZGUgPSBfZml0Qm91bmRzMi5sYXRpdHVkZSxcbiAgICAgICAgICB6b29tID0gX2ZpdEJvdW5kczIuem9vbTtcblxuICAgICAgcmV0dXJuIG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgICAgem9vbTogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZHMob3B0aW9ucykge1xuICAgICAgdmFyIGNvcm5lcnMgPSB0aGlzLmdldEJvdW5kaW5nUmVnaW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIHdlc3QgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoY29ybmVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHBbMF07XG4gICAgICB9KSkpO1xuICAgICAgdmFyIGVhc3QgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoY29ybmVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHBbMF07XG4gICAgICB9KSkpO1xuICAgICAgdmFyIHNvdXRoID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvcm5lcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwWzFdO1xuICAgICAgfSkpKTtcbiAgICAgIHZhciBub3J0aCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShjb3JuZXJzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcFsxXTtcbiAgICAgIH0pKSk7XG4gICAgICByZXR1cm4gW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ1JlZ2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ1JlZ2lvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHJldHVybiBnZXRCb3VuZHModGhpcywgb3B0aW9ucy56IHx8IDApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJNZXJjYXRvclZpZXdwb3J0O1xufSgpO1xuXG5leHBvcnQgeyBXZWJNZXJjYXRvclZpZXdwb3J0IGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5pbXBvcnQgeyBtb2QsIGxvZzIgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xudmFyIE1BWF9MQVRJVFVERSA9IDg1LjA1MTEzO1xudmFyIE1JTl9MQVRJVFVERSA9IC04NS4wNTExMztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBsb25naXR1ZGUgPSBfcmVmLmxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICBfcmVmJHBpdGNoID0gX3JlZi5waXRjaCxcbiAgICAgIHBpdGNoID0gX3JlZiRwaXRjaCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkcGl0Y2gsXG4gICAgICBfcmVmJGJlYXJpbmcgPSBfcmVmLmJlYXJpbmcsXG4gICAgICBiZWFyaW5nID0gX3JlZiRiZWFyaW5nID09PSB2b2lkIDAgPyAwIDogX3JlZiRiZWFyaW5nO1xuXG4gIGlmIChsb25naXR1ZGUgPCAtMTgwIHx8IGxvbmdpdHVkZSA+IDE4MCkge1xuICAgIGxvbmdpdHVkZSA9IG1vZChsb25naXR1ZGUgKyAxODAsIDM2MCkgLSAxODA7XG4gIH1cblxuICBpZiAoYmVhcmluZyA8IC0xODAgfHwgYmVhcmluZyA+IDE4MCkge1xuICAgIGJlYXJpbmcgPSBtb2QoYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuXG4gIHZhciBmbGF0Vmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICB6b29tOiB6b29tXG4gIH0pO1xuICB2YXIgdG9wWSA9IGZsYXRWaWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIE1BWF9MQVRJVFVERV0pWzFdO1xuICB2YXIgYm90dG9tWSA9IGZsYXRWaWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIE1JTl9MQVRJVFVERV0pWzFdO1xuICB2YXIgc2hpZnRZID0gMDtcblxuICBpZiAoYm90dG9tWSAtIHRvcFkgPCBoZWlnaHQpIHtcbiAgICB6b29tICs9IGxvZzIoaGVpZ2h0IC8gKGJvdHRvbVkgLSB0b3BZKSk7XG4gICAgZmxhdFZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgIHpvb206IHpvb21cbiAgICB9KTtcbiAgICB0b3BZID0gZmxhdFZpZXdwb3J0LnByb2plY3QoW2xvbmdpdHVkZSwgTUFYX0xBVElUVURFXSlbMV07XG4gICAgYm90dG9tWSA9IGZsYXRWaWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIE1JTl9MQVRJVFVERV0pWzFdO1xuICB9XG5cbiAgaWYgKHRvcFkgPiAwKSB7XG4gICAgc2hpZnRZID0gdG9wWTtcbiAgfSBlbHNlIGlmIChib3R0b21ZIDwgaGVpZ2h0KSB7XG4gICAgc2hpZnRZID0gYm90dG9tWSAtIGhlaWdodDtcbiAgfVxuXG4gIGlmIChzaGlmdFkpIHtcbiAgICBsYXRpdHVkZSA9IGZsYXRWaWV3cG9ydC51bnByb2plY3QoW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMiArIHNoaWZ0WV0pWzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgIHpvb206IHpvb20sXG4gICAgcGl0Y2g6IHBpdGNoLFxuICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgfTtcbn0iLCJmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0IHsgc2NhbGVUb1pvb20sIHpvb21Ub1NjYWxlLCBsbmdMYXRUb1dvcmxkLCB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG52YXIgRVBTSUxPTiA9IDAuMDE7XG52YXIgVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyA9IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nXTtcbnZhciBERUZBVUxUX09QVFMgPSB7XG4gIGN1cnZlOiAxLjQxNCxcbiAgc3BlZWQ6IDEuMlxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZseVRvVmlld3BvcnQoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICB2YXIgdmlld3BvcnQgPSB7fTtcblxuICB2YXIgX2dldEZseVRvVHJhbnNpdGlvblBhID0gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKSxcbiAgICAgIHN0YXJ0Wm9vbSA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS5zdGFydFpvb20sXG4gICAgICBzdGFydENlbnRlclhZID0gX2dldEZseVRvVHJhbnNpdGlvblBhLnN0YXJ0Q2VudGVyWFksXG4gICAgICB1RGVsdGEgPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEudURlbHRhLFxuICAgICAgdzAgPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEudzAsXG4gICAgICB1MSA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS51MSxcbiAgICAgIFMgPSBfZ2V0Rmx5VG9UcmFuc2l0aW9uUGEuUyxcbiAgICAgIHJobyA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS5yaG8sXG4gICAgICByaG8yID0gX2dldEZseVRvVHJhbnNpdGlvblBhLnJobzIsXG4gICAgICByMCA9IF9nZXRGbHlUb1RyYW5zaXRpb25QYS5yMDtcblxuICBpZiAodTEgPCBFUFNJTE9OKSB7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBzdGFydFZhbHVlID0gc3RhcnRQcm9wc1trZXldO1xuICAgICAgICB2YXIgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgICB2aWV3cG9ydFtrZXldID0gbGVycChzdGFydFZhbHVlLCBlbmRWYWx1ZSwgdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3cG9ydDtcbiAgfVxuXG4gIHZhciBzID0gdCAqIFM7XG4gIHZhciB3ID0gTWF0aC5jb3NoKHIwKSAvIE1hdGguY29zaChyMCArIHJobyAqIHMpO1xuICB2YXIgdSA9IHcwICogKChNYXRoLmNvc2gocjApICogTWF0aC50YW5oKHIwICsgcmhvICogcykgLSBNYXRoLnNpbmgocjApKSAvIHJobzIpIC8gdTE7XG4gIHZhciBzY2FsZUluY3JlbWVudCA9IDEgLyB3O1xuICB2YXIgbmV3Wm9vbSA9IHN0YXJ0Wm9vbSArIHNjYWxlVG9ab29tKHNjYWxlSW5jcmVtZW50KTtcbiAgdmFyIG5ld0NlbnRlcldvcmxkID0gdmVjMi5zY2FsZShbXSwgdURlbHRhLCB1KTtcbiAgdmVjMi5hZGQobmV3Q2VudGVyV29ybGQsIG5ld0NlbnRlcldvcmxkLCBzdGFydENlbnRlclhZKTtcbiAgdmFyIG5ld0NlbnRlciA9IHdvcmxkVG9MbmdMYXQobmV3Q2VudGVyV29ybGQpO1xuICB2aWV3cG9ydC5sb25naXR1ZGUgPSBuZXdDZW50ZXJbMF07XG4gIHZpZXdwb3J0LmxhdGl0dWRlID0gbmV3Q2VudGVyWzFdO1xuICB2aWV3cG9ydC56b29tID0gbmV3Wm9vbTtcbiAgcmV0dXJuIHZpZXdwb3J0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZseVRvRHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRTLCBvcHRzKTtcbiAgdmFyIF9vcHRzID0gb3B0cyxcbiAgICAgIHNjcmVlblNwZWVkID0gX29wdHMuc2NyZWVuU3BlZWQsXG4gICAgICBzcGVlZCA9IF9vcHRzLnNwZWVkLFxuICAgICAgbWF4RHVyYXRpb24gPSBfb3B0cy5tYXhEdXJhdGlvbjtcblxuICB2YXIgX2dldEZseVRvVHJhbnNpdGlvblBhMiA9IGdldEZseVRvVHJhbnNpdGlvblBhcmFtcyhzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0cyksXG4gICAgICBTID0gX2dldEZseVRvVHJhbnNpdGlvblBhMi5TLFxuICAgICAgcmhvID0gX2dldEZseVRvVHJhbnNpdGlvblBhMi5yaG87XG5cbiAgdmFyIGxlbmd0aCA9IDEwMDAgKiBTO1xuICB2YXIgZHVyYXRpb247XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZShzY3JlZW5TcGVlZCkpIHtcbiAgICBkdXJhdGlvbiA9IGxlbmd0aCAvIChzY3JlZW5TcGVlZCAvIHJobyk7XG4gIH0gZWxzZSB7XG4gICAgZHVyYXRpb24gPSBsZW5ndGggLyBzcGVlZDtcbiAgfVxuXG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWF4RHVyYXRpb24pICYmIGR1cmF0aW9uID4gbWF4RHVyYXRpb24gPyAwIDogZHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldEZseVRvVHJhbnNpdGlvblBhcmFtcyhzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0cykge1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRTLCBvcHRzKTtcbiAgdmFyIHJobyA9IG9wdHMuY3VydmU7XG4gIHZhciBzdGFydFpvb20gPSBzdGFydFByb3BzLnpvb207XG4gIHZhciBzdGFydENlbnRlciA9IFtzdGFydFByb3BzLmxvbmdpdHVkZSwgc3RhcnRQcm9wcy5sYXRpdHVkZV07XG4gIHZhciBzdGFydFNjYWxlID0gem9vbVRvU2NhbGUoc3RhcnRab29tKTtcbiAgdmFyIGVuZFpvb20gPSBlbmRQcm9wcy56b29tO1xuICB2YXIgZW5kQ2VudGVyID0gW2VuZFByb3BzLmxvbmdpdHVkZSwgZW5kUHJvcHMubGF0aXR1ZGVdO1xuICB2YXIgc2NhbGUgPSB6b29tVG9TY2FsZShlbmRab29tIC0gc3RhcnRab29tKTtcbiAgdmFyIHN0YXJ0Q2VudGVyWFkgPSBsbmdMYXRUb1dvcmxkKHN0YXJ0Q2VudGVyKTtcbiAgdmFyIGVuZENlbnRlclhZID0gbG5nTGF0VG9Xb3JsZChlbmRDZW50ZXIpO1xuICB2YXIgdURlbHRhID0gdmVjMi5zdWIoW10sIGVuZENlbnRlclhZLCBzdGFydENlbnRlclhZKTtcbiAgdmFyIHcwID0gTWF0aC5tYXgoc3RhcnRQcm9wcy53aWR0aCwgc3RhcnRQcm9wcy5oZWlnaHQpO1xuICB2YXIgdzEgPSB3MCAvIHNjYWxlO1xuICB2YXIgdTEgPSB2ZWMyLmxlbmd0aCh1RGVsdGEpICogc3RhcnRTY2FsZTtcblxuICB2YXIgX3UxID0gTWF0aC5tYXgodTEsIEVQU0lMT04pO1xuXG4gIHZhciByaG8yID0gcmhvICogcmhvO1xuICB2YXIgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG8yICogcmhvMiAqIF91MSAqIF91MSkgLyAoMiAqIHcwICogcmhvMiAqIF91MSk7XG4gIHZhciBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzIgKiByaG8yICogX3UxICogX3UxKSAvICgyICogdzEgKiByaG8yICogX3UxKTtcbiAgdmFyIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKTtcbiAgdmFyIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgdmFyIFMgPSAocjEgLSByMCkgLyByaG87XG4gIHJldHVybiB7XG4gICAgc3RhcnRab29tOiBzdGFydFpvb20sXG4gICAgc3RhcnRDZW50ZXJYWTogc3RhcnRDZW50ZXJYWSxcbiAgICB1RGVsdGE6IHVEZWx0YSxcbiAgICB3MDogdzAsXG4gICAgdTE6IHUxLFxuICAgIFM6IFMsXG4gICAgcmhvOiByaG8sXG4gICAgcmhvMjogcmhvMixcbiAgICByMDogcjAsXG4gICAgcjE6IHIxXG4gIH07XG59IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXZpZXdwb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgV2ViTWVyY2F0b3JWaWV3cG9ydCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXZpZXdwb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0Qm91bmRzIH0gZnJvbSAnLi9nZXQtYm91bmRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZml0Qm91bmRzIH0gZnJvbSAnLi9maXQtYm91bmRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9ybWFsaXplVmlld3BvcnRQcm9wcyB9IGZyb20gJy4vbm9ybWFsaXplLXZpZXdwb3J0LXByb3BzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmx5VG9WaWV3cG9ydCwgZ2V0Rmx5VG9EdXJhdGlvbiB9IGZyb20gJy4vZmx5LXRvLXZpZXdwb3J0JztcbmV4cG9ydCB7IGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQsIHdvcmxkVG9QaXhlbHMsIHBpeGVsc1RvV29ybGQsIHpvb21Ub1NjYWxlLCBzY2FsZVRvWm9vbSwgZ2V0TWV0ZXJab29tLCBnZXREaXN0YW5jZVNjYWxlcywgYWRkTWV0ZXJzVG9MbmdMYXQsIGdldFZpZXdNYXRyaXgsIGdldFByb2plY3Rpb25NYXRyaXgsIGdldFByb2plY3Rpb25QYXJhbWV0ZXJzIH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnOyIsImV4cG9ydCB7IFdlYk1lcmNhdG9yVmlld3BvcnQgYXMgZGVmYXVsdCB9IGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7XG5leHBvcnQgKiBmcm9tICdAbWF0aC5nbC93ZWItbWVyY2F0b3InOyIsIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xudmFyIE1hcFNoaW0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBNYXA7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gLTE7XG4gICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgLyoqXHJcbiAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgKi9cblxuICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xuICAgICAgfTtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xuXG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXHJcbiAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcbiAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcblxuICAgICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXHJcbiAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xuICAgICAgfTtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICovXG5cblxuICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xuICAgICAgfTtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjdHggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KClcbiAgKTtcbn0oKTtcbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXG5cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDsgLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cblxudmFyIGdsb2JhbCQxID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cblxuICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn0oKTtcbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xuXG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXG4gICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXG4gICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cbiAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTtcbiAgICB9LCAxMDAwIC8gNjApO1xuICB9O1xufSgpOyAvLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cblxuXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBkZWxheSkge1xuICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLFxuICAgICAgbGFzdENhbGxUaW1lID0gMDtcbiAgLyoqXHJcbiAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XG4gICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBpZiAodHJhaWxpbmdDYWxsKSB7XG4gICAgICBwcm94eSgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xuICB9XG4gIC8qKlxyXG4gICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHJveHkoKSB7XG4gICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXG4gICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcbiAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXG4gICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXG5cblxuICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xuICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xuICAgIH1cblxuICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcbiAgfVxuXG4gIHJldHVybiBwcm94eTtcbn0gLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXG5cblxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDsgLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxuXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTsgLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXG5cbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuLyoqXHJcbiAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAqL1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgKi9cblxuICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5vYnNlcnZlcnNfID0gW107XG4gICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xuICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xuICAgIH0gLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXG5cblxuICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICB0aGlzLmNvbm5lY3RfKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcbiAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7IC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXG5cbiAgICBpZiAofmluZGV4KSB7XG4gICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9IC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cblxuXG4gICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG4gICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTsgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XG4gICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cblxuICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAqIGVudHJpZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxuICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcbiAgICB9KTsgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XG4gICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxuICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFyZSB0cmFja2luZyB0aGUgc2FtZSBlbGVtZW50IGFuZCB0aGUgY2FsbGJhY2sgb2Ygb25lXG4gICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcbiAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXG5cbiAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gIH07XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcbiAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cbiAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXG4gICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxuICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG5cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xuXG4gICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcbiAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcbiAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xuICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXG4gICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xuXG4gICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XG4gICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XG4gICAgfVxuXG4gICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xuICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2ZW50XHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iOyAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxuXG4gICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XG4gICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XG4gIH07XG4gIC8qKlxyXG4gICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xufSgpO1xuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXG5cblxudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uIGRlZmluZUNvbmZpZ3VyYWJsZSh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGtleSA9IF9hW19pXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXG5cblxudmFyIGdldFdpbmRvd09mID0gZnVuY3Rpb24gZ2V0V2luZG93T2YodGFyZ2V0KSB7XG4gIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcbiAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXG4gIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cbiAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3OyAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxuICAvLyBwcm92aWRlZCBlbGVtZW50LlxuXG4gIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcbn07IC8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxuXG5cbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXG5cbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG59XG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XG4gIHZhciBwb3NpdGlvbnMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcbiAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xuICB9LCAwKTtcbn1cbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG4gIHZhciBwYWRkaW5ncyA9IHt9O1xuXG4gIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlc1sncGFkZGluZy0nICsgcG9zaXRpb25dO1xuICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhZGRpbmdzO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcbiAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xuICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcbiAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcbiAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXG4gIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7IC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxuICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXG4gIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXG4gIC8vXG4gIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxuICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXG4gIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxuICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXG5cbiAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XG4gICAgcmV0dXJuIGVtcHR5UmVjdDtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcbiAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xuICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTsgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXG4gIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcbiAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxuICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXG5cbiAgdmFyIHdpZHRoID0gdG9GbG9hdChzdHlsZXMud2lkdGgpLFxuICAgICAgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTsgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XG4gIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxuXG4gIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcbiAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXG4gICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxuICAgIC8vXG4gICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXG4gICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XG4gICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cbiAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcbiAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xuICAgIH1cblxuICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcbiAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xuICAgIH1cbiAgfSAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXG4gIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cbiAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcbiAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxuXG5cbiAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XG4gICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XG4gICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcbiAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcbiAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxuICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xuICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7IC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxuICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXG4gICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXG4gICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcbiAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cblxuICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xuICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XG4gICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XG59XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xuXG5cbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcbiAgLy8gaW50ZXJmYWNlLlxuICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50O1xuICAgIH07XG4gIH0gLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXG4gIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblxuXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJiB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbic7XG4gIH07XG59KCk7XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5cblxuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KHRhcmdldCkge1xuICBpZiAoIWlzQnJvd3Nlcikge1xuICAgIHJldHVybiBlbXB0eVJlY3Q7XG4gIH1cblxuICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcbiAgdmFyIHggPSBfYS54LFxuICAgICAgeSA9IF9hLnksXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0OyAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cblxuICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XG4gIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTsgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cblxuICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiBoZWlnaHQgKyB5LFxuICAgIGxlZnQ6IHhcbiAgfSk7XG4gIHJldHVybiByZWN0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gKi9cblxuXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcbiAgICAvKipcclxuICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcbiAgICAvKipcclxuICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICovXG5cbiAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcbiAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XG4gICAgcmV0dXJuIHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHwgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0O1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xuICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG5cbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xufSgpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpOyAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxuICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxuICAgIC8vXG4gICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxuICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxuXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcbn0oKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyU1BJID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcbiAgICAvKipcclxuICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICovXG5cbiAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XG4gICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcbiAgfVxuICAvKipcclxuICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcbiAgICB9IC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxuXG5cbiAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfOyAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cblxuICAgIGlmIChvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xuICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7IC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxuXG4gICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcbiAgICB9IC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxuXG5cbiAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfOyAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxuXG4gICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XG5cbiAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xuICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xuICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xuXG5cbiAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xuICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xuICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cbiAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87IC8vIENyZWF0ZSBSZXNpemVPYnNlcnZlckVudHJ5IGluc3RhbmNlIGZvciBldmVyeSBhY3RpdmUgb2JzZXJ2YXRpb24uXG5cbiAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xuICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cblxuXG4gIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xuICB9O1xuICAvKipcclxuICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXG5cblxuICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcbiAgfTtcblxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XG59KCk7IC8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcbi8vIGNhbid0IGJlIGZ1bGx5IHBvbHlmaWxsZWQgYW55d2F5LlxuXG5cbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcbi8qKlxyXG4gKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gKi9cblxudmFyIFJlc2l6ZU9ic2VydmVyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcbiAgICB9XG5cbiAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XG4gICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XG4gIH1cblxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XG59KCk7IC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cblxuXG5bJ29ic2VydmUnLCAndW5vYnNlcnZlJywgJ2Rpc2Nvbm5lY3QnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcblxudmFyIGluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxuICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcbiAgfVxuXG4gIHJldHVybiBSZXNpemVPYnNlcnZlcjtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7IiwidmFyIHdpbmRvd18gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcbnZhciBnbG9iYWxfID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG52YXIgZG9jdW1lbnRfID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge307XG5leHBvcnQgeyB3aW5kb3dfIGFzIHdpbmRvdywgZ2xvYmFsXyBhcyBnbG9iYWwsIGRvY3VtZW50XyBhcyBkb2N1bWVudCB9OyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBGID0gZnVuY3Rpb24gRigpIHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUoX2UyKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gX2UyO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gZigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbnZhciByZWZQcm9wcyA9IFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLCAnbGF5b3V0J107XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBpZiAoc3R5bGUudG9KUykge1xuICAgIHN0eWxlID0gc3R5bGUudG9KUygpO1xuICB9XG5cbiAgdmFyIGxheWVySW5kZXggPSB7fTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3R5bGUubGF5ZXJzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsYXllciA9IF9zdGVwLnZhbHVlO1xuICAgICAgbGF5ZXJJbmRleFtsYXllci5pZF0gPSBsYXllcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHZhciBsYXllcnMgPSBzdHlsZS5sYXllcnMubWFwKGZ1bmN0aW9uIChsYXllcikge1xuICAgIHZhciBsYXllclJlZiA9IGxheWVySW5kZXhbbGF5ZXIucmVmXTtcbiAgICB2YXIgbm9ybWFsaXplZExheWVyID0gbnVsbDtcblxuICAgIGlmICgnaW50ZXJhY3RpdmUnIGluIGxheWVyKSB7XG4gICAgICBub3JtYWxpemVkTGF5ZXIgPSBfb2JqZWN0U3ByZWFkKHt9LCBsYXllcik7XG4gICAgICBkZWxldGUgbm9ybWFsaXplZExheWVyLmludGVyYWN0aXZlO1xuICAgIH1cblxuICAgIGlmIChsYXllclJlZikge1xuICAgICAgbm9ybWFsaXplZExheWVyID0gbm9ybWFsaXplZExheWVyIHx8IF9vYmplY3RTcHJlYWQoe30sIGxheWVyKTtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkTGF5ZXIucmVmO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlZlByb3BzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHByb3BOYW1lIGluIGxheWVyUmVmKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGF5ZXJbcHJvcE5hbWVdID0gbGF5ZXJSZWZbcHJvcE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRMYXllciB8fCBsYXllcjtcbiAgfSk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlKSwge30sIHtcbiAgICBsYXllcnM6IGxheWVyc1xuICB9KTtcbn0iLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbHMnO1xuaW1wb3J0IHsgbm9ybWFsaXplU3R5bGUgfSBmcm9tICcuLi91dGlscy9zdHlsZS11dGlscyc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihldmVudCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmVycm9yKGV2ZW50LmVycm9yKTtcbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICBjb250YWluZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gIGdsOiBQcm9wVHlwZXMub2JqZWN0LFxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgbWFwYm94QXBpVXJsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhdHRyaWJ1dGlvbkNvbnRyb2w6IFByb3BUeXBlcy5ib29sLFxuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IFByb3BUeXBlcy5ib29sLFxuICByZXVzZU1hcHM6IFByb3BUeXBlcy5ib29sLFxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgbWFwT3B0aW9uczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbWFwU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgcHJldmVudFN0eWxlRGlmZmluZzogUHJvcFR5cGVzLmJvb2wsXG4gIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICBhc3luY1JlbmRlcjogUHJvcFR5cGVzLmJvb2wsXG4gIG9uTG9hZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB2aWV3U3RhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxvbmdpdHVkZTogUHJvcFR5cGVzLm51bWJlcixcbiAgbGF0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIGJlYXJpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBhbHRpdHVkZTogUHJvcFR5cGVzLm51bWJlclxufTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgbWFwYm94QXBpQWNjZXNzVG9rZW46IGdldEFjY2Vzc1Rva2VuKCksXG4gIG1hcGJveEFwaVVybDogJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20nLFxuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWUsXG4gIHJldXNlTWFwczogZmFsc2UsXG4gIG1hcE9wdGlvbnM6IHt9LFxuICBtYXBTdHlsZTogJ21hcGJveDovL3N0eWxlcy9tYXBib3gvbGlnaHQtdjgnLFxuICBwcmV2ZW50U3R5bGVEaWZmaW5nOiBmYWxzZSxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgYXN5bmNSZW5kZXI6IGZhbHNlLFxuICBvbkxvYWQ6IG5vb3AsXG4gIG9uRXJyb3I6IGRlZmF1bHRPbkVycm9yLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBsb25naXR1ZGU6IDAsXG4gIGxhdGl0dWRlOiAwLFxuICB6b29tOiAwLFxuICBiZWFyaW5nOiAwLFxuICBwaXRjaDogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgdmFyIGFjY2Vzc1Rva2VuID0gbnVsbDtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvYWNjZXNzX3Rva2VuPShbXiZcXC9dKikvKTtcbiAgICBhY2Nlc3NUb2tlbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICB9XG5cbiAgaWYgKCFhY2Nlc3NUb2tlbiAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IHByb2Nlc3MuZW52Lk1hcGJveEFjY2Vzc1Rva2VuIHx8IHByb2Nlc3MuZW52LlJFQUNUX0FQUF9NQVBCT1hfQUNDRVNTX1RPS0VOO1xuICB9XG5cbiAgcmV0dXJuIGFjY2Vzc1Rva2VuIHx8ICduby10b2tlbic7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHByb3BzKSB7XG4gIHZhciBjb21wb25lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjb21wb25lbnQnO1xuXG4gIGlmIChwcm9wcy5kZWJ1Zykge1xuICAgIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIGNvbXBvbmVudCk7XG4gIH1cbn1cblxudmFyIE1hcGJveCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFwYm94KHByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBib3gpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcHNcIiwgZGVmYXVsdFByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZpcmVMb2FkRXZlbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucHJvcHMub25Mb2FkKHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICB0YXJnZXQ6IF90aGlzLl9tYXBcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwcm9wcy5tYXBib3hnbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXBib3ggbm90IGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMubWFwYm94Z2wgPSBwcm9wcy5tYXBib3hnbDtcblxuICAgIGlmICghTWFwYm94LmluaXRpYWxpemVkKSB7XG4gICAgICBNYXBib3guaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9jaGVja1N0eWxlU2hlZXQodGhpcy5tYXBib3hnbC52ZXJzaW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBib3gsIFt7XG4gICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgdGhpcy5fZGVzdHJveSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSh0aGlzLnByb3BzLCBwcm9wcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgaWYgKG1hcC5zdHlsZSkge1xuICAgICAgICBpZiAobWFwLl9mcmFtZSkge1xuICAgICAgICAgIG1hcC5fZnJhbWUuY2FuY2VsKCk7XG5cbiAgICAgICAgICBtYXAuX2ZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5fcmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmV1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldXNlKHByb3BzKSB7XG4gICAgICB0aGlzLl9tYXAgPSBNYXBib3guc2F2ZWRNYXA7XG5cbiAgICAgIHZhciBvbGRDb250YWluZXIgPSB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCk7XG5cbiAgICAgIHZhciBuZXdDb250YWluZXIgPSBwcm9wcy5jb250YWluZXI7XG4gICAgICBuZXdDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtbWFwJyk7XG5cbiAgICAgIHdoaWxlIChvbGRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld0NvbnRhaW5lci5hcHBlbmRDaGlsZChvbGRDb250YWluZXIuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcC5fY29udGFpbmVyID0gbmV3Q29udGFpbmVyO1xuICAgICAgTWFwYm94LnNhdmVkTWFwID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BzLm1hcFN0eWxlKSB7XG4gICAgICAgIHRoaXMuX21hcC5zZXRTdHlsZShub3JtYWxpemVTdHlsZShwcm9wcy5tYXBTdHlsZSksIHtcbiAgICAgICAgICBkaWZmOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX21hcC5pc1N0eWxlTG9hZGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZmlyZUxvYWRFdmVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uY2UoJ3N0eWxlZGF0YScsIHRoaXMuX2ZpcmVMb2FkRXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUocHJvcHMpIHtcbiAgICAgIGlmIChwcm9wcy5yZXVzZU1hcHMgJiYgTWFwYm94LnNhdmVkTWFwKSB7XG4gICAgICAgIHRoaXMuX3JldXNlKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wcy5nbCkge1xuICAgICAgICAgIHZhciBnZXRDb250ZXh0ID0gSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHQ7XG5cbiAgICAgICAgICBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5nbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcE9wdGlvbnMgPSB7XG4gICAgICAgICAgY29udGFpbmVyOiBwcm9wcy5jb250YWluZXIsXG4gICAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICAgICAgem9vbTogOCxcbiAgICAgICAgICBwaXRjaDogMCxcbiAgICAgICAgICBiZWFyaW5nOiAwLFxuICAgICAgICAgIG1heFpvb206IDI0LFxuICAgICAgICAgIHN0eWxlOiBub3JtYWxpemVTdHlsZShwcm9wcy5tYXBTdHlsZSksXG4gICAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHRyYWNrUmVzaXplOiBmYWxzZSxcbiAgICAgICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHByb3BzLmF0dHJpYnV0aW9uQ29udHJvbCxcbiAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHByb3BzLnByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwcm9wcy50cmFuc2Zvcm1SZXF1ZXN0KSB7XG4gICAgICAgICAgbWFwT3B0aW9ucy50cmFuc2Zvcm1SZXF1ZXN0ID0gcHJvcHMudHJhbnNmb3JtUmVxdWVzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyB0aGlzLm1hcGJveGdsLk1hcChPYmplY3QuYXNzaWduKHt9LCBtYXBPcHRpb25zLCBwcm9wcy5tYXBPcHRpb25zKSk7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9uY2UoJ2xvYWQnLCBwcm9wcy5vbkxvYWQpO1xuXG4gICAgICAgIHRoaXMuX21hcC5vbignZXJyb3InLCBwcm9wcy5vbkVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIU1hcGJveC5zYXZlZE1hcCkge1xuICAgICAgICBNYXBib3guc2F2ZWRNYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9mZignbG9hZCcsIHRoaXMucHJvcHMub25Mb2FkKTtcblxuICAgICAgICB0aGlzLl9tYXAub2ZmKCdlcnJvcicsIHRoaXMucHJvcHMub25FcnJvcik7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9mZignc3R5bGVkYXRhJywgdGhpcy5fZmlyZUxvYWRFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplKHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BzLCAnTWFwYm94Jyk7XG4gICAgICB0aGlzLm1hcGJveGdsLmFjY2Vzc1Rva2VuID0gcHJvcHMubWFwYm94QXBpQWNjZXNzVG9rZW4gfHwgZGVmYXVsdFByb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuO1xuICAgICAgdGhpcy5tYXBib3hnbC5iYXNlQXBpVXJsID0gcHJvcHMubWFwYm94QXBpVXJsO1xuXG4gICAgICB0aGlzLl9jcmVhdGUocHJvcHMpO1xuXG4gICAgICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICAgICAgY29udGFpbmVyID0gX3Byb3BzLmNvbnRhaW5lcjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXIsICdvZmZzZXRXaWR0aCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCAnY2xpZW50V2lkdGgnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRhaW5lciwgJ29mZnNldEhlaWdodCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fbWFwLmdldENhbnZhcygpO1xuXG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVNYXBWaWV3cG9ydCh7fSwgcHJvcHMpO1xuXG4gICAgICB0aGlzLl91cGRhdGVNYXBTaXplKHt9LCBwcm9wcyk7XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKG5ld1Byb3BzLCAnTWFwYm94Jyk7XG5cbiAgICAgIHZhciB2aWV3cG9ydENoYW5nZWQgPSB0aGlzLl91cGRhdGVNYXBWaWV3cG9ydChvbGRQcm9wcywgbmV3UHJvcHMpO1xuXG4gICAgICB2YXIgc2l6ZUNoYW5nZWQgPSB0aGlzLl91cGRhdGVNYXBTaXplKG9sZFByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZU1hcFN0eWxlKG9sZFByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICAgIGlmICghbmV3UHJvcHMuYXN5bmNSZW5kZXIgJiYgKHZpZXdwb3J0Q2hhbmdlZCB8fCBzaXplQ2hhbmdlZCkpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlTWFwU3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hcFN0eWxlKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIHN0eWxlQ2hhbmdlZCA9IG9sZFByb3BzLm1hcFN0eWxlICE9PSBuZXdQcm9wcy5tYXBTdHlsZTtcblxuICAgICAgaWYgKHN0eWxlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9tYXAuc2V0U3R5bGUobm9ybWFsaXplU3R5bGUobmV3UHJvcHMubWFwU3R5bGUpLCB7XG4gICAgICAgICAgZGlmZjogIW5ld1Byb3BzLnByZXZlbnRTdHlsZURpZmZpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVNYXBTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNYXBTaXplKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIHNpemVDaGFuZ2VkID0gb2xkUHJvcHMud2lkdGggIT09IG5ld1Byb3BzLndpZHRoIHx8IG9sZFByb3BzLmhlaWdodCAhPT0gbmV3UHJvcHMuaGVpZ2h0O1xuXG4gICAgICBpZiAoc2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IG5ld1Byb3BzLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG5ld1Byb3BzLmhlaWdodDtcblxuICAgICAgICB0aGlzLl9tYXAucmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaXplQ2hhbmdlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1hcFZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNYXBWaWV3cG9ydChvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIHZhciBvbGRWaWV3U3RhdGUgPSB0aGlzLl9nZXRWaWV3U3RhdGUob2xkUHJvcHMpO1xuXG4gICAgICB2YXIgbmV3Vmlld1N0YXRlID0gdGhpcy5fZ2V0Vmlld1N0YXRlKG5ld1Byb3BzKTtcblxuICAgICAgdmFyIHZpZXdwb3J0Q2hhbmdlZCA9IG5ld1ZpZXdTdGF0ZS5sYXRpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmxhdGl0dWRlIHx8IG5ld1ZpZXdTdGF0ZS5sb25naXR1ZGUgIT09IG9sZFZpZXdTdGF0ZS5sb25naXR1ZGUgfHwgbmV3Vmlld1N0YXRlLnpvb20gIT09IG9sZFZpZXdTdGF0ZS56b29tIHx8IG5ld1ZpZXdTdGF0ZS5waXRjaCAhPT0gb2xkVmlld1N0YXRlLnBpdGNoIHx8IG5ld1ZpZXdTdGF0ZS5iZWFyaW5nICE9PSBvbGRWaWV3U3RhdGUuYmVhcmluZyB8fCBuZXdWaWV3U3RhdGUuYWx0aXR1ZGUgIT09IG9sZFZpZXdTdGF0ZS5hbHRpdHVkZTtcblxuICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9tYXAuanVtcFRvKHRoaXMuX3ZpZXdTdGF0ZVRvTWFwYm94UHJvcHMobmV3Vmlld1N0YXRlKSk7XG5cbiAgICAgICAgaWYgKG5ld1ZpZXdTdGF0ZS5hbHRpdHVkZSAhPT0gb2xkVmlld1N0YXRlLmFsdGl0dWRlKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLnRyYW5zZm9ybS5hbHRpdHVkZSA9IG5ld1ZpZXdTdGF0ZS5hbHRpdHVkZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlld3BvcnRDaGFuZ2VkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Vmlld1N0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWV3U3RhdGUocHJvcHMpIHtcbiAgICAgIHZhciBfcmVmID0gcHJvcHMudmlld1N0YXRlIHx8IHByb3BzLFxuICAgICAgICAgIGxvbmdpdHVkZSA9IF9yZWYubG9uZ2l0dWRlLFxuICAgICAgICAgIGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgICAgICB6b29tID0gX3JlZi56b29tLFxuICAgICAgICAgIF9yZWYkcGl0Y2ggPSBfcmVmLnBpdGNoLFxuICAgICAgICAgIHBpdGNoID0gX3JlZiRwaXRjaCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkcGl0Y2gsXG4gICAgICAgICAgX3JlZiRiZWFyaW5nID0gX3JlZi5iZWFyaW5nLFxuICAgICAgICAgIGJlYXJpbmcgPSBfcmVmJGJlYXJpbmcgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGJlYXJpbmcsXG4gICAgICAgICAgX3JlZiRhbHRpdHVkZSA9IF9yZWYuYWx0aXR1ZGUsXG4gICAgICAgICAgYWx0aXR1ZGUgPSBfcmVmJGFsdGl0dWRlID09PSB2b2lkIDAgPyAxLjUgOiBfcmVmJGFsdGl0dWRlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgIGJlYXJpbmc6IGJlYXJpbmcsXG4gICAgICAgIGFsdGl0dWRlOiBhbHRpdHVkZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrU3R5bGVTaGVldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTdHlsZVNoZWV0KCkge1xuICAgICAgdmFyIG1hcGJveFZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcwLjQ3LjAnO1xuXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZXN0RWxlbWVudC5jbGFzc05hbWUgPSAnbWFwYm94Z2wtbWFwJztcbiAgICAgICAgdGVzdEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgIHZhciBpc0Nzc0xvYWRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlc3RFbGVtZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYyc7XG5cbiAgICAgICAgaWYgKCFpc0Nzc0xvYWRlZCkge1xuICAgICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBcImh0dHBzOi8vYXBpLnRpbGVzLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3ZcIi5jb25jYXQobWFwYm94VmVyc2lvbiwgXCIvbWFwYm94LWdsLmNzc1wiKSk7XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92aWV3U3RhdGVUb01hcGJveFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92aWV3U3RhdGVUb01hcGJveFByb3BzKHZpZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2VudGVyOiBbdmlld1N0YXRlLmxvbmdpdHVkZSwgdmlld1N0YXRlLmxhdGl0dWRlXSxcbiAgICAgICAgem9vbTogdmlld1N0YXRlLnpvb20sXG4gICAgICAgIGJlYXJpbmc6IHZpZXdTdGF0ZS5iZWFyaW5nLFxuICAgICAgICBwaXRjaDogdmlld1N0YXRlLnBpdGNoXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBib3g7XG59KCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShNYXBib3gsIFwiaW5pdGlhbGl6ZWRcIiwgZmFsc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoTWFwYm94LCBcInByb3BUeXBlc1wiLCBwcm9wVHlwZXMpO1xuXG5fZGVmaW5lUHJvcGVydHkoTWFwYm94LCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5fZGVmaW5lUHJvcGVydHkoTWFwYm94LCBcInNhdmVkTWFwXCIsIG51bGwpO1xuXG5leHBvcnQgeyBNYXBib3ggYXMgZGVmYXVsdCB9OyIsInZhciBFUFNJTE9OID0gMWUtNztcblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uIChhaSwgaSkge1xuICAgICAgcmV0dXJuIGxlcnAoYWksIGJbaV0sIHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHQgKiBiICsgKDEgLSB0KSAqIGE7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdyZWFjdC1tYXAtZ2w6IGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCwgeyBub3JtYWxpemVWaWV3cG9ydFByb3BzIH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmV4cG9ydCB2YXIgTUFQQk9YX0xJTUlUUyA9IHtcbiAgbWluWm9vbTogMCxcbiAgbWF4Wm9vbTogMjQsXG4gIG1pblBpdGNoOiAwLFxuICBtYXhQaXRjaDogODVcbn07XG52YXIgREVGQVVMVF9TVEFURSA9IHtcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG52YXIgUElUQ0hfTU9VU0VfVEhSRVNIT0xEID0gNTtcbnZhciBQSVRDSF9BQ0NFTCA9IDEuMjtcblxudmFyIE1hcFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBTdGF0ZShfcmVmKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICAgIGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICAgIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICAgIF9yZWYkYmVhcmluZyA9IF9yZWYuYmVhcmluZyxcbiAgICAgICAgYmVhcmluZyA9IF9yZWYkYmVhcmluZyA9PT0gdm9pZCAwID8gREVGQVVMVF9TVEFURS5iZWFyaW5nIDogX3JlZiRiZWFyaW5nLFxuICAgICAgICBfcmVmJHBpdGNoID0gX3JlZi5waXRjaCxcbiAgICAgICAgcGl0Y2ggPSBfcmVmJHBpdGNoID09PSB2b2lkIDAgPyBERUZBVUxUX1NUQVRFLnBpdGNoIDogX3JlZiRwaXRjaCxcbiAgICAgICAgX3JlZiRhbHRpdHVkZSA9IF9yZWYuYWx0aXR1ZGUsXG4gICAgICAgIGFsdGl0dWRlID0gX3JlZiRhbHRpdHVkZSA9PT0gdm9pZCAwID8gREVGQVVMVF9TVEFURS5hbHRpdHVkZSA6IF9yZWYkYWx0aXR1ZGUsXG4gICAgICAgIF9yZWYkbWF4Wm9vbSA9IF9yZWYubWF4Wm9vbSxcbiAgICAgICAgbWF4Wm9vbSA9IF9yZWYkbWF4Wm9vbSA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5tYXhab29tIDogX3JlZiRtYXhab29tLFxuICAgICAgICBfcmVmJG1pblpvb20gPSBfcmVmLm1pblpvb20sXG4gICAgICAgIG1pblpvb20gPSBfcmVmJG1pblpvb20gPT09IHZvaWQgMCA/IE1BUEJPWF9MSU1JVFMubWluWm9vbSA6IF9yZWYkbWluWm9vbSxcbiAgICAgICAgX3JlZiRtYXhQaXRjaCA9IF9yZWYubWF4UGl0Y2gsXG4gICAgICAgIG1heFBpdGNoID0gX3JlZiRtYXhQaXRjaCA9PT0gdm9pZCAwID8gTUFQQk9YX0xJTUlUUy5tYXhQaXRjaCA6IF9yZWYkbWF4UGl0Y2gsXG4gICAgICAgIF9yZWYkbWluUGl0Y2ggPSBfcmVmLm1pblBpdGNoLFxuICAgICAgICBtaW5QaXRjaCA9IF9yZWYkbWluUGl0Y2ggPT09IHZvaWQgMCA/IE1BUEJPWF9MSU1JVFMubWluUGl0Y2ggOiBfcmVmJG1pblBpdGNoLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfcmVmLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgdHJhbnNpdGlvbkVhc2luZyA9IF9yZWYudHJhbnNpdGlvbkVhc2luZyxcbiAgICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvciA9IF9yZWYudHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgICAgdHJhbnNpdGlvbkludGVycnVwdGlvbiA9IF9yZWYudHJhbnNpdGlvbkludGVycnVwdGlvbixcbiAgICAgICAgc3RhcnRQYW5MbmdMYXQgPSBfcmVmLnN0YXJ0UGFuTG5nTGF0LFxuICAgICAgICBzdGFydFpvb21MbmdMYXQgPSBfcmVmLnN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgICAgc3RhcnRSb3RhdGVQb3MgPSBfcmVmLnN0YXJ0Um90YXRlUG9zLFxuICAgICAgICBzdGFydEJlYXJpbmcgPSBfcmVmLnN0YXJ0QmVhcmluZyxcbiAgICAgICAgc3RhcnRQaXRjaCA9IF9yZWYuc3RhcnRQaXRjaCxcbiAgICAgICAgc3RhcnRab29tID0gX3JlZi5zdGFydFpvb207XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwU3RhdGUpO1xuXG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh3aWR0aCksICdgd2lkdGhgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGhlaWdodCksICdgaGVpZ2h0YCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpLCAnYGxvbmdpdHVkZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpLCAnYGxhdGl0dWRlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh6b29tKSwgJ2B6b29tYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuX2FwcGx5Q29uc3RyYWludHMoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgIHpvb206IHpvb20sXG4gICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgcGl0Y2g6IHBpdGNoLFxuICAgICAgYWx0aXR1ZGU6IGFsdGl0dWRlLFxuICAgICAgbWF4Wm9vbTogbWF4Wm9vbSxcbiAgICAgIG1pblpvb206IG1pblpvb20sXG4gICAgICBtYXhQaXRjaDogbWF4UGl0Y2gsXG4gICAgICBtaW5QaXRjaDogbWluUGl0Y2gsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25FYXNpbmc6IHRyYW5zaXRpb25FYXNpbmcsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yLFxuICAgICAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogdHJhbnNpdGlvbkludGVycnVwdGlvblxuICAgIH0pO1xuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgc3RhcnRQYW5MbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgc3RhcnRab29tTG5nTGF0OiBzdGFydFpvb21MbmdMYXQsXG4gICAgICBzdGFydFJvdGF0ZVBvczogc3RhcnRSb3RhdGVQb3MsXG4gICAgICBzdGFydEJlYXJpbmc6IHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHN0YXJ0UGl0Y2gsXG4gICAgICBzdGFydFpvb206IHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwU3RhdGUsIFt7XG4gICAga2V5OiBcImdldFZpZXdwb3J0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld3BvcnRQcm9wcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuU3RhcnQoX3JlZjIpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmMi5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRQYW5MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbihfcmVmMykge1xuICAgICAgdmFyIHBvcyA9IF9yZWYzLnBvcyxcbiAgICAgICAgICBzdGFydFBvcyA9IF9yZWYzLnN0YXJ0UG9zO1xuXG4gICAgICB2YXIgc3RhcnRQYW5MbmdMYXQgPSB0aGlzLl9zdGF0ZS5zdGFydFBhbkxuZ0xhdCB8fCB0aGlzLl91bnByb2plY3Qoc3RhcnRQb3MpO1xuXG4gICAgICBpZiAoIXN0YXJ0UGFuTG5nTGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkX2NhbGN1bGF0ZU5ld0xuID0gdGhpcy5fY2FsY3VsYXRlTmV3TG5nTGF0KHtcbiAgICAgICAgc3RhcnRQYW5MbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSksXG4gICAgICAgICAgX3RoaXMkX2NhbGN1bGF0ZU5ld0xuMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9jYWxjdWxhdGVOZXdMbiwgMiksXG4gICAgICAgICAgbG9uZ2l0dWRlID0gX3RoaXMkX2NhbGN1bGF0ZU5ld0xuMlswXSxcbiAgICAgICAgICBsYXRpdHVkZSA9IF90aGlzJF9jYWxjdWxhdGVOZXdMbjJbMV07XG5cbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbkVuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICBzdGFydFBhbkxuZ0xhdDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZVN0YXJ0KF9yZWY0KSB7XG4gICAgICB2YXIgcG9zID0gX3JlZjQucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0Um90YXRlUG9zOiBwb3MsXG4gICAgICAgIHN0YXJ0QmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nLFxuICAgICAgICBzdGFydFBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZShfcmVmNSkge1xuICAgICAgdmFyIHBvcyA9IF9yZWY1LnBvcyxcbiAgICAgICAgICBfcmVmNSRkZWx0YUFuZ2xlWCA9IF9yZWY1LmRlbHRhQW5nbGVYLFxuICAgICAgICAgIGRlbHRhQW5nbGVYID0gX3JlZjUkZGVsdGFBbmdsZVggPT09IHZvaWQgMCA/IDAgOiBfcmVmNSRkZWx0YUFuZ2xlWCxcbiAgICAgICAgICBfcmVmNSRkZWx0YUFuZ2xlWSA9IF9yZWY1LmRlbHRhQW5nbGVZLFxuICAgICAgICAgIGRlbHRhQW5nbGVZID0gX3JlZjUkZGVsdGFBbmdsZVkgPT09IHZvaWQgMCA/IDAgOiBfcmVmNSRkZWx0YUFuZ2xlWTtcbiAgICAgIHZhciBfdGhpcyRfc3RhdGUgPSB0aGlzLl9zdGF0ZSxcbiAgICAgICAgICBzdGFydFJvdGF0ZVBvcyA9IF90aGlzJF9zdGF0ZS5zdGFydFJvdGF0ZVBvcyxcbiAgICAgICAgICBzdGFydEJlYXJpbmcgPSBfdGhpcyRfc3RhdGUuc3RhcnRCZWFyaW5nLFxuICAgICAgICAgIHN0YXJ0UGl0Y2ggPSBfdGhpcyRfc3RhdGUuc3RhcnRQaXRjaDtcblxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRCZWFyaW5nKSB8fCAhTnVtYmVyLmlzRmluaXRlKHN0YXJ0UGl0Y2gpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Um90YXRpb247XG5cbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgbmV3Um90YXRpb24gPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLl9nZXRSb3RhdGlvblBhcmFtcyhwb3MsIHN0YXJ0Um90YXRlUG9zKSksIHt9LCB7XG4gICAgICAgICAgc3RhcnRCZWFyaW5nOiBzdGFydEJlYXJpbmcsXG4gICAgICAgICAgc3RhcnRQaXRjaDogc3RhcnRQaXRjaFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdSb3RhdGlvbiA9IHtcbiAgICAgICAgICBiZWFyaW5nOiBzdGFydEJlYXJpbmcgKyBkZWx0YUFuZ2xlWCxcbiAgICAgICAgICBwaXRjaDogc3RhcnRQaXRjaCArIGRlbHRhQW5nbGVZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUobmV3Um90YXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlRW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0QmVhcmluZzogbnVsbCxcbiAgICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpvb21TdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tU3RhcnQoX3JlZjYpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmNi5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgICAgc3RhcnRab29tTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKSxcbiAgICAgICAgc3RhcnRab29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20oX3JlZjcpIHtcbiAgICAgIHZhciBwb3MgPSBfcmVmNy5wb3MsXG4gICAgICAgICAgc3RhcnRQb3MgPSBfcmVmNy5zdGFydFBvcyxcbiAgICAgICAgICBzY2FsZSA9IF9yZWY3LnNjYWxlO1xuICAgICAgYXNzZXJ0KHNjYWxlID4gMCwgJ2BzY2FsZWAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgdmFyIF90aGlzJF9zdGF0ZTIgPSB0aGlzLl9zdGF0ZSxcbiAgICAgICAgICBzdGFydFpvb20gPSBfdGhpcyRfc3RhdGUyLnN0YXJ0Wm9vbSxcbiAgICAgICAgICBzdGFydFpvb21MbmdMYXQgPSBfdGhpcyRfc3RhdGUyLnN0YXJ0Wm9vbUxuZ0xhdDtcblxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRab29tKSkge1xuICAgICAgICBzdGFydFpvb20gPSB0aGlzLl92aWV3cG9ydFByb3BzLnpvb207XG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IHRoaXMuX3VucHJvamVjdChzdGFydFBvcykgfHwgdGhpcy5fdW5wcm9qZWN0KHBvcyk7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChzdGFydFpvb21MbmdMYXQsICdgc3RhcnRab29tTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgKyAnZm9yIHpvb20gYmVoYXZpb3IgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBtYXAuJyk7XG5cbiAgICAgIHZhciB6b29tID0gdGhpcy5fY2FsY3VsYXRlTmV3Wm9vbSh7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgc3RhcnRab29tOiBzdGFydFpvb20gfHwgMFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB6b29tZWRWaWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHtcbiAgICAgICAgem9vbTogem9vbVxuICAgICAgfSkpO1xuXG4gICAgICB2YXIgX3pvb21lZFZpZXdwb3J0JGdldE1hID0gem9vbWVkVmlld3BvcnQuZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbih7XG4gICAgICAgIGxuZ0xhdDogc3RhcnRab29tTG5nTGF0LFxuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSksXG4gICAgICAgICAgX3pvb21lZFZpZXdwb3J0JGdldE1hMiA9IF9zbGljZWRUb0FycmF5KF96b29tZWRWaWV3cG9ydCRnZXRNYSwgMiksXG4gICAgICAgICAgbG9uZ2l0dWRlID0gX3pvb21lZFZpZXdwb3J0JGdldE1hMlswXSxcbiAgICAgICAgICBsYXRpdHVkZSA9IF96b29tZWRWaWV3cG9ydCRnZXRNYTJbMV07XG5cbiAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tRW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICAgIHN0YXJ0Wm9vbUxuZ0xhdDogbnVsbCxcbiAgICAgICAgc3RhcnRab29tOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFVwZGF0ZWRNYXBTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VXBkYXRlZE1hcFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHRoaXMuX3N0YXRlLCBuZXdQcm9wcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwbHlDb25zdHJhaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgICAgdmFyIG1heFpvb20gPSBwcm9wcy5tYXhab29tLFxuICAgICAgICAgIG1pblpvb20gPSBwcm9wcy5taW5ab29tLFxuICAgICAgICAgIHpvb20gPSBwcm9wcy56b29tO1xuICAgICAgcHJvcHMuem9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgICAgdmFyIG1heFBpdGNoID0gcHJvcHMubWF4UGl0Y2gsXG4gICAgICAgICAgbWluUGl0Y2ggPSBwcm9wcy5taW5QaXRjaCxcbiAgICAgICAgICBwaXRjaCA9IHByb3BzLnBpdGNoO1xuICAgICAgcHJvcHMucGl0Y2ggPSBjbGFtcChwaXRjaCwgbWluUGl0Y2gsIG1heFBpdGNoKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMocHJvcHMpKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucHJvamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wcm9qZWN0KHBvcykge1xuICAgICAgdmFyIHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG4gICAgICByZXR1cm4gcG9zICYmIHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlTmV3TG5nTGF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdMbmdMYXQoX3JlZjgpIHtcbiAgICAgIHZhciBzdGFydFBhbkxuZ0xhdCA9IF9yZWY4LnN0YXJ0UGFuTG5nTGF0LFxuICAgICAgICAgIHBvcyA9IF9yZWY4LnBvcztcbiAgICAgIHZhciB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHRoaXMuX3ZpZXdwb3J0UHJvcHMpO1xuICAgICAgcmV0dXJuIHZpZXdwb3J0LmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgICBsbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVOZXdab29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdab29tKF9yZWY5KSB7XG4gICAgICB2YXIgc2NhbGUgPSBfcmVmOS5zY2FsZSxcbiAgICAgICAgICBzdGFydFpvb20gPSBfcmVmOS5zdGFydFpvb207XG4gICAgICB2YXIgX3RoaXMkX3ZpZXdwb3J0UHJvcHMgPSB0aGlzLl92aWV3cG9ydFByb3BzLFxuICAgICAgICAgIG1heFpvb20gPSBfdGhpcyRfdmlld3BvcnRQcm9wcy5tYXhab29tLFxuICAgICAgICAgIG1pblpvb20gPSBfdGhpcyRfdmlld3BvcnRQcm9wcy5taW5ab29tO1xuICAgICAgdmFyIHpvb20gPSBzdGFydFpvb20gKyBNYXRoLmxvZzIoc2NhbGUpO1xuICAgICAgcmV0dXJuIGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoX3JlZjEwKSB7XG4gICAgICB2YXIgZGVsdGFTY2FsZVggPSBfcmVmMTAuZGVsdGFTY2FsZVgsXG4gICAgICAgICAgZGVsdGFTY2FsZVkgPSBfcmVmMTAuZGVsdGFTY2FsZVksXG4gICAgICAgICAgc3RhcnRCZWFyaW5nID0gX3JlZjEwLnN0YXJ0QmVhcmluZyxcbiAgICAgICAgICBzdGFydFBpdGNoID0gX3JlZjEwLnN0YXJ0UGl0Y2g7XG4gICAgICBkZWx0YVNjYWxlWSA9IGNsYW1wKGRlbHRhU2NhbGVZLCAtMSwgMSk7XG4gICAgICB2YXIgX3RoaXMkX3ZpZXdwb3J0UHJvcHMyID0gdGhpcy5fdmlld3BvcnRQcm9wcyxcbiAgICAgICAgICBtaW5QaXRjaCA9IF90aGlzJF92aWV3cG9ydFByb3BzMi5taW5QaXRjaCxcbiAgICAgICAgICBtYXhQaXRjaCA9IF90aGlzJF92aWV3cG9ydFByb3BzMi5tYXhQaXRjaDtcbiAgICAgIHZhciBiZWFyaW5nID0gc3RhcnRCZWFyaW5nICsgMTgwICogZGVsdGFTY2FsZVg7XG4gICAgICB2YXIgcGl0Y2ggPSBzdGFydFBpdGNoO1xuXG4gICAgICBpZiAoZGVsdGFTY2FsZVkgPiAwKSB7XG4gICAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCArIGRlbHRhU2NhbGVZICogKG1heFBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhU2NhbGVZIDwgMCkge1xuICAgICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggLSBkZWx0YVNjYWxlWSAqIChtaW5QaXRjaCAtIHN0YXJ0UGl0Y2gpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSb3RhdGlvblBhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb25QYXJhbXMocG9zLCBzdGFydFBvcykge1xuICAgICAgdmFyIGRlbHRhWCA9IHBvc1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgICAgdmFyIGRlbHRhWSA9IHBvc1sxXSAtIHN0YXJ0UG9zWzFdO1xuICAgICAgdmFyIGNlbnRlclkgPSBwb3NbMV07XG4gICAgICB2YXIgc3RhcnRZID0gc3RhcnRQb3NbMV07XG4gICAgICB2YXIgX3RoaXMkX3ZpZXdwb3J0UHJvcHMzID0gdGhpcy5fdmlld3BvcnRQcm9wcyxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJF92aWV3cG9ydFByb3BzMy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRfdmlld3BvcnRQcm9wczMuaGVpZ2h0O1xuICAgICAgdmFyIGRlbHRhU2NhbGVYID0gZGVsdGFYIC8gd2lkdGg7XG4gICAgICB2YXIgZGVsdGFTY2FsZVkgPSAwO1xuXG4gICAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc3RhcnRZKSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gKHN0YXJ0WSAtIGhlaWdodCkgKiBQSVRDSF9BQ0NFTDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZWx0YVkgPCAwKSB7XG4gICAgICAgIGlmIChzdGFydFkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgICBkZWx0YVNjYWxlWSA9IDEgLSBjZW50ZXJZIC8gc3RhcnRZO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlbHRhU2NhbGVZID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoLTEsIGRlbHRhU2NhbGVZKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWx0YVNjYWxlWDogZGVsdGFTY2FsZVgsXG4gICAgICAgIGRlbHRhU2NhbGVZOiBkZWx0YVNjYWxlWVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFwU3RhdGU7XG59KCk7XG5cbmV4cG9ydCB7IE1hcFN0YXRlIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgeyBNQVBCT1hfTElNSVRTIH0gZnJvbSAnLi9tYXAtc3RhdGUnO1xuXG5mdW5jdGlvbiBkZWNhcGl0YWxpemUocykge1xuICByZXR1cm4gc1swXS50b0xvd2VyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gIHZhciBjb25zdHJhaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTUFQQk9YX0xJTUlUUztcblxuICBmb3IgKHZhciBjb25zdHJhaW50TmFtZSBpbiBjb25zdHJhaW50cykge1xuICAgIHZhciB0eXBlID0gY29uc3RyYWludE5hbWUuc2xpY2UoMCwgMyk7XG4gICAgdmFyIHByb3BOYW1lID0gZGVjYXBpdGFsaXplKGNvbnN0cmFpbnROYW1lLnNsaWNlKDMpKTtcblxuICAgIGlmICh0eXBlID09PSAnbWluJyAmJiBwcm9wc1twcm9wTmFtZV0gPCBjb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ21heCcgJiYgcHJvcHNbcHJvcE5hbWVdID4gY29uc3RyYWludHNbY29uc3RyYWludE5hbWVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xudmFyIE1hcENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgdmlld3BvcnQ6IG51bGwsXG4gIG1hcDogbnVsbCxcbiAgY29udGFpbmVyOiBudWxsLFxuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuICBvblZpZXdTdGF0ZUNoYW5nZTogbnVsbCxcbiAgZXZlbnRNYW5hZ2VyOiBudWxsXG59KTtcbmV4cG9ydCB2YXIgTWFwQ29udGV4dFByb3ZpZGVyID0gTWFwQ29udGV4dC5Qcm92aWRlcjtcblxuZnVuY3Rpb24gV3JhcHBlZFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIG1hcCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRNYXAgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFsdWUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgIHNldE1hcDogc2V0TWFwXG4gIH0sIGNvbnRleHQpLCB7fSwge1xuICAgIG1hcDogY29udGV4dCAmJiBjb250ZXh0Lm1hcCB8fCBtYXBcbiAgfSwgdmFsdWUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNYXBDb250ZXh0UHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5NYXBDb250ZXh0LlByb3ZpZGVyID0gV3JhcHBlZFByb3ZpZGVyO1xuZXhwb3J0IGRlZmF1bHQgTWFwQ29udGV4dDsiLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5leHBvcnQgZGVmYXVsdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0OyIsImV4cG9ydCBmdW5jdGlvbiBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwgX3JlZikge1xuICB2YXIgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSA9IF9yZWYubGF0aXR1ZGU7XG5cbiAgaWYgKG1hcCAmJiBtYXAucXVlcnlUZXJyYWluRWxldmF0aW9uKSB7XG4gICAgcmV0dXJuIG1hcC5xdWVyeVRlcnJhaW5FbGV2YXRpb24oW2xvbmdpdHVkZSwgbGF0aXR1ZGVdKSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcbmltcG9ydCBNYXBib3ggZnJvbSAnLi4vbWFwYm94L21hcGJveCc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IHsgY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMgfSBmcm9tICcuLi91dGlscy9tYXAtY29uc3RyYWludHMnO1xuaW1wb3J0IHsgTUFQQk9YX0xJTUlUUyB9IGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5pbXBvcnQgTWFwQ29udGV4dCwgeyBNYXBDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL21hcC1jb250ZXh0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgZ2V0VGVycmFpbkVsZXZhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3RlcnJhaW4nO1xudmFyIFRPS0VOX0RPQ19VUkwgPSAnaHR0cHM6Ly92aXNnbC5naXRodWIuaW8vcmVhY3QtbWFwLWdsL2RvY3MvZ2V0LXN0YXJ0ZWQvbWFwYm94LXRva2Vucyc7XG52YXIgTk9fVE9LRU5fV0FSTklORyA9ICdBIHZhbGlkIEFQSSBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQgdG8gdXNlIE1hcGJveCBkYXRhJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3cG9ydChfcmVmKSB7XG4gIHZhciBtYXAgPSBfcmVmLm1hcCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHZhciB2aWV3cG9ydFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgcHJvcHMudmlld1N0YXRlKSwge30sIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSk7XG5cbiAgdmlld3BvcnRQcm9wcy5wb3NpdGlvbiA9IFswLCAwLCBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwgdmlld3BvcnRQcm9wcyldO1xuICByZXR1cm4gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodmlld3BvcnRQcm9wcyk7XG59XG52YXIgVU5BVVRIT1JJWkVEX0VSUk9SX0NPREUgPSA0MDE7XG52YXIgQ09OVEFJTkVSX1NUWUxFID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJScsXG4gIG92ZXJmbG93OiAnaGlkZGVuJ1xufTtcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBNYXBib3guZGVmYXVsdFByb3BzLCB7XG4gIGRpc2FibGVUb2tlbldhcm5pbmc6IGZhbHNlLFxuICB2aXNpYmxlOiB0cnVlLFxuICBvblJlc2l6ZTogbm9vcCxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgc3R5bGU6IG51bGwsXG4gIHZpc2liaWxpdHlDb25zdHJhaW50czogTUFQQk9YX0xJTUlUU1xufSk7XG5cbmZ1bmN0aW9uIE5vVG9rZW5XYXJuaW5nKCkge1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJ3YXJuaW5nXCIsXG4gICAgaWQ6IFwibm8tdG9rZW4td2FybmluZ1wiLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge1xuICAgIGtleTogXCJoZWFkZXJcIlxuICB9LCBOT19UT0tFTl9XQVJOSU5HKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcInRleHRcIlxuICB9LCBcIkZvciBpbmZvcm1hdGlvbiBvbiBzZXR0aW5nIHVwIHlvdXIgYmFzZW1hcCwgcmVhZFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgIGtleTogXCJsaW5rXCIsXG4gICAgaHJlZjogVE9LRU5fRE9DX1VSTFxuICB9LCBcIk5vdGUgb24gTWFwIFRva2Vuc1wiKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlZkhhbmRsZXMobWFwYm94UmVmKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0TWFwOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gbWFwYm94UmVmLmN1cnJlbnQgJiYgbWFwYm94UmVmLmN1cnJlbnQuZ2V0TWFwKCk7XG4gICAgfSxcbiAgICBxdWVyeVJlbmRlcmVkRmVhdHVyZXM6IGZ1bmN0aW9uIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhnZW9tZXRyeSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIG1hcCA9IG1hcGJveFJlZi5jdXJyZW50ICYmIG1hcGJveFJlZi5jdXJyZW50LmdldE1hcCgpO1xuICAgICAgcmV0dXJuIG1hcCAmJiBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdGF0aWNNYXAgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh0cnVlKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgYWNjZXNzVG9rZW5WYWxpZCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRUb2tlblN0YXRlID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICBzaXplID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldFNpemUgPSBfdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBtYXBib3hSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBtYXBEaXZSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBvdmVybGF5UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghU3RhdGljTWFwLnN1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBtYXBib3ggPSBuZXcgTWFwYm94KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHNpemUpLCB7fSwge1xuICAgICAgbWFwYm94Z2w6IG1hcGJveGdsLFxuICAgICAgY29udGFpbmVyOiBtYXBEaXZSZWYuY3VycmVudCxcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXZ0KSB7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gZXZ0LmVycm9yICYmIGV2dC5lcnJvci5zdGF0dXMgfHwgZXZ0LnN0YXR1cztcblxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gVU5BVVRIT1JJWkVEX0VSUk9SX0NPREUgJiYgYWNjZXNzVG9rZW5WYWxpZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoTk9fVE9LRU5fV0FSTklORyk7XG4gICAgICAgICAgc2V0VG9rZW5TdGF0ZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5vbkVycm9yKGV2dCk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIG1hcGJveFJlZi5jdXJyZW50ID0gbWFwYm94O1xuXG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5zZXRNYXApIHtcbiAgICAgIGNvbnRleHQuc2V0TWFwKG1hcGJveC5nZXRNYXAoKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cmllc1swXS5jb250ZW50UmVjdCkge1xuICAgICAgICB2YXIgX2VudHJpZXMkMCRjb250ZW50UmVjID0gZW50cmllc1swXS5jb250ZW50UmVjdCxcbiAgICAgICAgICAgIF93aWR0aCA9IF9lbnRyaWVzJDAkY29udGVudFJlYy53aWR0aCxcbiAgICAgICAgICAgIF9oZWlnaHQgPSBfZW50cmllcyQwJGNvbnRlbnRSZWMuaGVpZ2h0O1xuICAgICAgICBzZXRTaXplKHtcbiAgICAgICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub25SZXNpemUoe1xuICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBtYXBib3guZmluYWxpemUoKTtcbiAgICAgIG1hcGJveFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXBib3hSZWYuY3VycmVudCkge1xuICAgICAgbWFwYm94UmVmLmN1cnJlbnQuc2V0UHJvcHMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHNpemUpKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgbWFwID0gbWFwYm94UmVmLmN1cnJlbnQgJiYgbWFwYm94UmVmLmN1cnJlbnQuZ2V0TWFwKCk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlZkhhbmRsZXMobWFwYm94UmVmKTtcbiAgfSwgW10pO1xuICB2YXIgcHJldmVudFNjcm9sbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB0YXJnZXQgPSBfcmVmMi50YXJnZXQ7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBvdmVybGF5UmVmLmN1cnJlbnQpIHtcbiAgICAgIHRhcmdldC5zY3JvbGxUbygwLCAwKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIG92ZXJsYXlzID0gbWFwICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFwQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29udGV4dCksIHt9LCB7XG4gICAgICB2aWV3cG9ydDogY29udGV4dC52aWV3cG9ydCB8fCBnZXRWaWV3cG9ydChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgfSwgc2l6ZSkpLFxuICAgICAgbWFwOiBtYXAsXG4gICAgICBjb250YWluZXI6IGNvbnRleHQuY29udGFpbmVyIHx8IGNvbnRhaW5lclJlZi5jdXJyZW50XG4gICAgfSlcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcIm1hcC1vdmVybGF5c1wiLFxuICAgIGNsYXNzTmFtZTogXCJvdmVybGF5c1wiLFxuICAgIHJlZjogb3ZlcmxheVJlZixcbiAgICBzdHlsZTogQ09OVEFJTkVSX1NUWUxFLFxuICAgIG9uU2Nyb2xsOiBwcmV2ZW50U2Nyb2xsXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIHZpc2liaWxpdHlDb25zdHJhaW50cyA9IHByb3BzLnZpc2liaWxpdHlDb25zdHJhaW50cztcbiAgdmFyIG1hcENvbnRhaW5lclN0eWxlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgfSwgc3R5bGUsIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSk7XG4gIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZSAmJiBjaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyhwcm9wcy52aWV3U3RhdGUgfHwgcHJvcHMsIHZpc2liaWxpdHlDb25zdHJhaW50cyk7XG4gIHZhciBtYXBTdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIENPTlRBSU5FUl9TVFlMRSwge1xuICAgIHZpc2liaWxpdHk6IHZpc2libGUgPyAnaW5oZXJpdCcgOiAnaGlkZGVuJ1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJtYXAtY29udGFpbmVyXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgc3R5bGU6IG1hcENvbnRhaW5lclN0eWxlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJtYXAtbWFwYm94XCIsXG4gICAgcmVmOiBtYXBEaXZSZWYsXG4gICAgc3R5bGU6IG1hcFN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pLCBvdmVybGF5cywgIWFjY2Vzc1Rva2VuVmFsaWQgJiYgIXByb3BzLmRpc2FibGVUb2tlbldhcm5pbmcgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChOb1Rva2VuV2FybmluZywgbnVsbCkpO1xufSk7XG5cblN0YXRpY01hcC5zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtYXBib3hnbCAmJiBtYXBib3hnbC5zdXBwb3J0ZWQoKTtcbn07XG5cblN0YXRpY01hcC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBTdGF0aWNNYXA7IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gZShfZSkge1xuICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uIHMoKSB7XG4gICAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gZShfZTIpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBfZTI7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiBmKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuaW1wb3J0IHsgZXF1YWxzIH0gZnJvbSAnLi4vbWF0aC11dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydCc7XG5cbnZhciBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3BOYW1lc1wiLCBbXSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNpdGlvbkludGVycG9sYXRvciwgW3tcbiAgICBrZXk6IFwiYXJlUHJvcHNFcXVhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcmVQcm9wc0VxdWFsKGN1cnJlbnRQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5wcm9wTmFtZXMgfHwgW10pLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmICghZXF1YWxzKGN1cnJlbnRQcm9wc1trZXldLCBuZXh0UHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFByb3BzLFxuICAgICAgICBlbmQ6IGVuZFByb3BzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnBvbGF0ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRlUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ2ludGVycG9sYXRlUHJvcHMgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICByZXR1cm4gZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xufSgpO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yIGFzIGRlZmF1bHQgfTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufSIsInZhciBXUkFQUEVEX0FOR1VMQVJfUFJPUFMgPSB7XG4gIGxvbmdpdHVkZTogMSxcbiAgYmVhcmluZzogMVxufTtcbmV4cG9ydCBmdW5jdGlvbiBtb2QodmFsdWUsIGRpdmlzb3IpIHtcbiAgdmFyIG1vZHVsdXMgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gIHJldHVybiBtb2R1bHVzIDwgMCA/IGRpdmlzb3IgKyBtb2R1bHVzIDogbW9kdWx1cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkKHByb3ApIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwcm9wKSB8fCBBcnJheS5pc0FycmF5KHByb3ApO1xufVxuXG5mdW5jdGlvbiBpc1dyYXBwZWRBbmd1bGFyUHJvcChwcm9wTmFtZSkge1xuICByZXR1cm4gcHJvcE5hbWUgaW4gV1JBUFBFRF9BTkdVTEFSX1BST1BTO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChwcm9wTmFtZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgaWYgKGlzV3JhcHBlZEFuZ3VsYXJQcm9wKHByb3BOYW1lKSAmJiBNYXRoLmFicyhlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpID4gMTgwKSB7XG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSA8IDAgPyBlbmRWYWx1ZSArIDM2MCA6IGVuZFZhbHVlIC0gMzYwO1xuICB9XG5cbiAgcmV0dXJuIGVuZFZhbHVlO1xufSIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiBlKF9lKSB7XG4gICAgICAgICAgdGhyb3cgX2U7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gcygpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiBlKF9lMikge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IF9lMjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydCc7XG5pbXBvcnQgVHJhbnNpdGlvbkludGVycG9sYXRvciBmcm9tICcuL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yJztcbmltcG9ydCB7IGZseVRvVmlld3BvcnQsIGdldEZseVRvRHVyYXRpb24gfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IGlzVmFsaWQsIGdldEVuZFZhbHVlQnlTaG9ydGVzdFBhdGggfSBmcm9tICcuL3RyYW5zaXRpb24tdXRpbHMnO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJy4uL21hdGgtdXRpbHMnO1xudmFyIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMgPSBbJ2xvbmdpdHVkZScsICdsYXRpdHVkZScsICd6b29tJywgJ2JlYXJpbmcnLCAncGl0Y2gnXTtcbnZhciBSRVFVSVJFRF9QUk9QUyA9IFsnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ3pvb20nLCAnd2lkdGgnLCAnaGVpZ2h0J107XG52YXIgTElORUFSTFlfSU5URVJQT0xBVEVEX1BST1BTID0gWydiZWFyaW5nJywgJ3BpdGNoJ107XG52YXIgREVGQVVMVF9PUFRTID0ge1xuICBzcGVlZDogMS4yLFxuICBjdXJ2ZTogMS40MTRcbn07XG5cbnZhciBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKF9UcmFuc2l0aW9uSW50ZXJwb2xhdCkge1xuICBfaW5oZXJpdHMoVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciwgX1RyYW5zaXRpb25JbnRlcnBvbGF0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IpO1xuXG4gIGZ1bmN0aW9uIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicHJvcE5hbWVzXCIsIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMpO1xuXG4gICAgX3RoaXMucHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIHByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVQcm9wcyhzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgdmFyIHN0YXJ0Vmlld3BvcnRQcm9wcyA9IHt9O1xuICAgICAgdmFyIGVuZFZpZXdwb3J0UHJvcHMgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFJFUVVJUkVEX1BST1BTKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFByb3BzW2tleV07XG4gICAgICAgICAgdmFyIGVuZFZhbHVlID0gZW5kUHJvcHNba2V5XTtcbiAgICAgICAgICBhc3NlcnQoaXNWYWxpZChzdGFydFZhbHVlKSAmJiBpc1ZhbGlkKGVuZFZhbHVlKSwgXCJcIi5jb25jYXQoa2V5LCBcIiBtdXN0IGJlIHN1cHBsaWVkIGZvciB0cmFuc2l0aW9uXCIpKTtcbiAgICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHNba2V5XSA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgZW5kVmlld3BvcnRQcm9wc1trZXldID0gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChrZXksIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKExJTkVBUkxZX0lOVEVSUE9MQVRFRF9QUk9QUyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfa2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9zdGFydFZhbHVlID0gc3RhcnRQcm9wc1tfa2V5XSB8fCAwO1xuXG4gICAgICAgICAgdmFyIF9lbmRWYWx1ZSA9IGVuZFByb3BzW19rZXldIHx8IDA7XG5cbiAgICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHNbX2tleV0gPSBfc3RhcnRWYWx1ZTtcbiAgICAgICAgICBlbmRWaWV3cG9ydFByb3BzW19rZXldID0gZ2V0RW5kVmFsdWVCeVNob3J0ZXN0UGF0aChfa2V5LCBfc3RhcnRWYWx1ZSwgX2VuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFZpZXdwb3J0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kVmlld3BvcnRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSBmbHlUb1ZpZXdwb3J0KHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0LCB0aGlzLnByb3BzKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihMSU5FQVJMWV9JTlRFUlBPTEFURURfUFJPUFMpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIHZpZXdwb3J0W2tleV0gPSBsZXJwKHN0YXJ0UHJvcHNba2V5XSwgZW5kUHJvcHNba2V5XSwgdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbkR1cmF0aW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0Rmx5VG9EdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3I7XG59KFRyYW5zaXRpb25JbnRlcnBvbGF0b3IpO1xuXG5leHBvcnQgeyBWaWV3cG9ydEZseVRvSW50ZXJwb2xhdG9yIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBGID0gZnVuY3Rpb24gRigpIHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUoX2UpIHtcbiAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUoX2UyKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gX2UyO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gZigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi9hc3NlcnQnO1xuaW1wb3J0IFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgZnJvbSAnLi90cmFuc2l0aW9uLWludGVycG9sYXRvcic7XG5pbXBvcnQgeyBpc1ZhbGlkLCBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoIH0gZnJvbSAnLi90cmFuc2l0aW9uLXV0aWxzJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi9tYXRoLXV0aWxzJztcbnZhciBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbScsICdiZWFyaW5nJywgJ3BpdGNoJ107XG5cbnZhciBMaW5lYXJJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoX1RyYW5zaXRpb25JbnRlcnBvbGF0KSB7XG4gIF9pbmhlcml0cyhMaW5lYXJJbnRlcnBvbGF0b3IsIF9UcmFuc2l0aW9uSW50ZXJwb2xhdCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMaW5lYXJJbnRlcnBvbGF0b3IpO1xuXG4gIGZ1bmN0aW9uIExpbmVhckludGVycG9sYXRvcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZWFySW50ZXJwb2xhdG9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BzOiBvcHRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIF90aGlzLnByb3BOYW1lcyA9IG9wdHMudHJhbnNpdGlvblByb3BzIHx8IFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFM7XG5cbiAgICBpZiAob3B0cy5hcm91bmQpIHtcbiAgICAgIF90aGlzLmFyb3VuZCA9IG9wdHMuYXJvdW5kO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lYXJJbnRlcnBvbGF0b3IsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICAgIHZhciBzdGFydFZpZXdwb3J0UHJvcHMgPSB7fTtcbiAgICAgIHZhciBlbmRWaWV3cG9ydFByb3BzID0ge307XG5cbiAgICAgIGlmICh0aGlzLmFyb3VuZCkge1xuICAgICAgICBzdGFydFZpZXdwb3J0UHJvcHMuYXJvdW5kID0gdGhpcy5hcm91bmQ7XG4gICAgICAgIHZhciBhcm91bmRMbmdMYXQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChzdGFydFByb3BzKS51bnByb2plY3QodGhpcy5hcm91bmQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGVuZFZpZXdwb3J0UHJvcHMsIGVuZFByb3BzLCB7XG4gICAgICAgICAgYXJvdW5kOiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChlbmRQcm9wcykucHJvamVjdChhcm91bmRMbmdMYXQpLFxuICAgICAgICAgIGFyb3VuZExuZ0xhdDogYXJvdW5kTG5nTGF0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5wcm9wTmFtZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IHN0YXJ0UHJvcHNba2V5XTtcbiAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgICAgIGFzc2VydChpc1ZhbGlkKHN0YXJ0VmFsdWUpICYmIGlzVmFsaWQoZW5kVmFsdWUpLCBcIlwiLmNvbmNhdChrZXksIFwiIG11c3QgYmUgc3VwcGxpZWQgZm9yIHRyYW5zaXRpb25cIikpO1xuICAgICAgICAgIHN0YXJ0Vmlld3BvcnRQcm9wc1trZXldID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICBlbmRWaWV3cG9ydFByb3BzW2tleV0gPSBnZXRFbmRWYWx1ZUJ5U2hvcnRlc3RQYXRoKGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFZpZXdwb3J0UHJvcHMsXG4gICAgICAgIGVuZDogZW5kVmlld3BvcnRQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnByb3BOYW1lcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRQcm9wc1trZXldLCBlbmRQcm9wc1trZXldLCB0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQcm9wcy5hcm91bmQpIHtcbiAgICAgICAgdmFyIF9XZWJNZXJjYXRvclZpZXdwb3J0JCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIGVuZFByb3BzLCB2aWV3cG9ydCkpLmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgICAgIGxuZ0xhdDogZW5kUHJvcHMuYXJvdW5kTG5nTGF0LFxuICAgICAgICAgIHBvczogbGVycChzdGFydFByb3BzLmFyb3VuZCwgZW5kUHJvcHMuYXJvdW5kLCB0KVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIF9XZWJNZXJjYXRvclZpZXdwb3J0JDIgPSBfc2xpY2VkVG9BcnJheShfV2ViTWVyY2F0b3JWaWV3cG9ydCQsIDIpLFxuICAgICAgICAgICAgbG9uZ2l0dWRlID0gX1dlYk1lcmNhdG9yVmlld3BvcnQkMlswXSxcbiAgICAgICAgICAgIGxhdGl0dWRlID0gX1dlYk1lcmNhdG9yVmlld3BvcnQkMlsxXTtcblxuICAgICAgICB2aWV3cG9ydC5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgICAgIHZpZXdwb3J0LmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZWFySW50ZXJwb2xhdG9yO1xufShUcmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcblxuZXhwb3J0IHsgTGluZWFySW50ZXJwb2xhdG9yIGFzIGRlZmF1bHQgfTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIFRyYW5zaXRpb25JbnRlcnBvbGF0b3IgfSBmcm9tICcuL3RyYW5zaXRpb24taW50ZXJwb2xhdG9yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmlld3BvcnRGbHlUb0ludGVycG9sYXRvciB9IGZyb20gJy4vdmlld3BvcnQtZmx5LXRvLWludGVycG9sYXRvcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmVhckludGVycG9sYXRvciB9IGZyb20gJy4vbGluZWFyLWludGVycG9sYXRvcic7IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBMaW5lYXJJbnRlcnBvbGF0b3IgfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4vbWFwLXN0YXRlJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9wRWFzaW5nRnVuY3Rpb24oZWFzaW5nLCB4MCkge1xuICB2YXIgeTAgPSBlYXNpbmcoeDApO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSAvICgxIC0geTApICogKGVhc2luZyh0ICogKDEgLSB4MCkgKyB4MCkgLSB5MCk7XG4gIH07XG59XG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRVZFTlRTID0ge1xuICBCUkVBSzogMSxcbiAgU05BUF9UT19FTkQ6IDIsXG4gIElHTk9SRTogMyxcbiAgVVBEQVRFOiA0XG59O1xudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMCxcbiAgdHJhbnNpdGlvbkVhc2luZzogZnVuY3Rpb24gdHJhbnNpdGlvbkVhc2luZyh0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3IoKSxcbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogVFJBTlNJVElPTl9FVkVOVFMuQlJFQUssXG4gIG9uVHJhbnNpdGlvblN0YXJ0OiBub29wLFxuICBvblRyYW5zaXRpb25JbnRlcnJ1cHQ6IG5vb3AsXG4gIG9uVHJhbnNpdGlvbkVuZDogbm9vcFxufTtcblxudmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hbmltYXRpb25GcmFtZVwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblRyYW5zaXRpb25GcmFtZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuX29uVHJhbnNpdGlvbkZyYW1lKTtcblxuICAgICAgX3RoaXMuX3VwZGF0ZVZpZXdwb3J0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UgPSBvcHRzLm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvcHRzLm9uU3RhdGVDaGFuZ2UgfHwgbm9vcDtcbiAgICB0aGlzLnRpbWUgPSBvcHRzLmdldFRpbWUgfHwgRGF0ZS5ub3c7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNpdGlvbk1hbmFnZXIsIFt7XG4gICAga2V5OiBcImdldFZpZXdwb3J0SW5UcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdwb3J0SW5UcmFuc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbkZyYW1lID8gdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbiA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaWV3cG9ydENoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKSB7XG4gICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMucHJvcHMgPSBuZXh0UHJvcHM7XG5cbiAgICAgIGlmICghY3VycmVudFByb3BzIHx8IHRoaXMuX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlKGN1cnJlbnRQcm9wcywgbmV4dFByb3BzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgICAgdmFyIHN0YXJ0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UHJvcHMpO1xuICAgICAgICB2YXIgZW5kUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0UHJvcHMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgICBjdXJyZW50UHJvcHMub25UcmFuc2l0aW9uSW50ZXJydXB0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLlNOQVBfVE9fRU5EKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXJ0UHJvcHMsIHRoaXMuc3RhdGUuZW5kUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXJ0UHJvcHMsIHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmludGVycnVwdGlvbiA9PT0gVFJBTlNJVElPTl9FVkVOVFMuVVBEQVRFKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRpbWUoKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjdXJyZW50VGltZSAtIHRoaXMuc3RhdGUuc3RhcnRUaW1lKSAvIHRoaXMuc3RhdGUuZHVyYXRpb247XG4gICAgICAgICAgICBlbmRQcm9wcy50cmFuc2l0aW9uRHVyYXRpb24gPSB0aGlzLnN0YXRlLmR1cmF0aW9uIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5zdGF0ZS5zdGFydFRpbWUpO1xuICAgICAgICAgICAgZW5kUHJvcHMudHJhbnNpdGlvbkVhc2luZyA9IGNyb3BFYXNpbmdGdW5jdGlvbih0aGlzLnN0YXRlLmVhc2luZywgeDApO1xuICAgICAgICAgICAgZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvciA9IHN0YXJ0UHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbmRQcm9wcy5vblRyYW5zaXRpb25TdGFydCgpO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXJUcmFuc2l0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICBjdXJyZW50UHJvcHMub25UcmFuc2l0aW9uSW50ZXJydXB0KCk7XG5cbiAgICAgICAgdGhpcy5fZW5kVHJhbnNpdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1RyYW5zaXRpb25JblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNUcmFuc2l0aW9uRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNUcmFuc2l0aW9uRW5hYmxlZChwcm9wcykge1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gcHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcjtcbiAgICAgIHJldHVybiAodHJhbnNpdGlvbkR1cmF0aW9uID4gMCB8fCB0cmFuc2l0aW9uRHVyYXRpb24gPT09ICdhdXRvJykgJiYgQm9vbGVhbih0cmFuc2l0aW9uSW50ZXJwb2xhdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVXBkYXRlRHVlVG9DdXJyZW50VHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKHByb3BzKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbnRlcnBvbGF0b3IuYXJlUHJvcHNFcXVhbChwcm9wcywgdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZShjdXJyZW50UHJvcHMsIG5leHRQcm9wcykge1xuICAgICAgaWYgKCFjdXJyZW50UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaW50ZXJydXB0aW9uID09PSBUUkFOU0lUSU9OX0VWRU5UUy5JR05PUkUgfHwgdGhpcy5faXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKG5leHRQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLmFyZVByb3BzRXF1YWwoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyaWdnZXJUcmFuc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyVHJhbnNpdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgICAgYXNzZXJ0KHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQoZW5kUHJvcHMpKTtcblxuICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgICAgdmFyIGR1cmF0aW9uID0gdHJhbnNpdGlvbkludGVycG9sYXRvci5nZXREdXJhdGlvbiA/IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IuZ2V0RHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIDogZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuXG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5pdGlhbFByb3BzID0gZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvci5pbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMpO1xuICAgICAgdmFyIGludGVyYWN0aW9uU3RhdGUgPSB7XG4gICAgICAgIGluVHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNab29taW5nOiBzdGFydFByb3BzLnpvb20gIT09IGVuZFByb3BzLnpvb20sXG4gICAgICAgIGlzUGFubmluZzogc3RhcnRQcm9wcy5sb25naXR1ZGUgIT09IGVuZFByb3BzLmxvbmdpdHVkZSB8fCBzdGFydFByb3BzLmxhdGl0dWRlICE9PSBlbmRQcm9wcy5sYXRpdHVkZSxcbiAgICAgICAgaXNSb3RhdGluZzogc3RhcnRQcm9wcy5iZWFyaW5nICE9PSBlbmRQcm9wcy5iZWFyaW5nIHx8IHN0YXJ0UHJvcHMucGl0Y2ggIT09IGVuZFByb3BzLnBpdGNoXG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVuZFByb3BzLnRyYW5zaXRpb25FYXNpbmcsXG4gICAgICAgIGludGVycG9sYXRvcjogZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgICAgaW50ZXJydXB0aW9uOiBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJydXB0aW9uLFxuICAgICAgICBzdGFydFRpbWU6IHRoaXMudGltZSgpLFxuICAgICAgICBzdGFydFByb3BzOiBpbml0aWFsUHJvcHMuc3RhcnQsXG4gICAgICAgIGVuZFByb3BzOiBpbml0aWFsUHJvcHMuZW5kLFxuICAgICAgICBhbmltYXRpb246IG51bGwsXG4gICAgICAgIHByb3BzSW5UcmFuc2l0aW9uOiB7fVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fb25UcmFuc2l0aW9uRnJhbWUoKTtcblxuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKGludGVyYWN0aW9uU3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW5kVHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5kVHJhbnNpdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKHtcbiAgICAgICAgaW5UcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgaXNab29taW5nOiBmYWxzZSxcbiAgICAgICAgaXNQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZpZXdwb3J0KCkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50aW1lKCk7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIHN0YXJ0VGltZSA9IF90aGlzJHN0YXRlLnN0YXJ0VGltZSxcbiAgICAgICAgICBkdXJhdGlvbiA9IF90aGlzJHN0YXRlLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZyA9IF90aGlzJHN0YXRlLmVhc2luZyxcbiAgICAgICAgICBpbnRlcnBvbGF0b3IgPSBfdGhpcyRzdGF0ZS5pbnRlcnBvbGF0b3IsXG4gICAgICAgICAgc3RhcnRQcm9wcyA9IF90aGlzJHN0YXRlLnN0YXJ0UHJvcHMsXG4gICAgICAgICAgZW5kUHJvcHMgPSBfdGhpcyRzdGF0ZS5lbmRQcm9wcztcbiAgICAgIHZhciBzaG91bGRFbmQgPSBmYWxzZTtcbiAgICAgIHZhciB0ID0gKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lKSAvIGR1cmF0aW9uO1xuXG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIHQgPSAxO1xuICAgICAgICBzaG91bGRFbmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0ID0gZWFzaW5nKHQpO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gaW50ZXJwb2xhdG9yLmludGVycG9sYXRlUHJvcHMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIHQpO1xuICAgICAgdmFyIG1hcFN0YXRlID0gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHZpZXdwb3J0KSk7XG4gICAgICB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uID0gbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24sIHRoaXMucHJvcHMpO1xuXG4gICAgICBpZiAoc2hvdWxkRW5kKSB7XG4gICAgICAgIHRoaXMuX2VuZFRyYW5zaXRpb24oKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2l0aW9uTWFuYWdlcjtcbn0oKTtcblxuX2RlZmluZVByb3BlcnR5KFRyYW5zaXRpb25NYW5hZ2VyLCBcImRlZmF1bHRQcm9wc1wiLCBERUZBVUxUX1BST1BTKTtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbk1hbmFnZXIgYXMgZGVmYXVsdCB9OyIsInZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG5mdW5jdGlvbiBzb21lKGFycmF5LCBwcmVkaWN0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljdChhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dChQb2ludGVyRXZlbnRJbnB1dCkge1xuICB2YXIgb2xkSGFuZGxlciA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyO1xuXG4gIFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG5cbiAgICBpZiAoZXYuYnV0dG9uID4gMCAmJiBldi50eXBlID09PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICBpZiAoIXNvbWUoc3RvcmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnBvaW50ZXJJZCA9PT0gZXYucG9pbnRlcklkO1xuICAgICAgfSkpIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2xkSGFuZGxlci5jYWxsKHRoaXMsIGV2KTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlTW91c2VJbnB1dChNb3VzZUlucHV0KSB7XG4gIE1vdXNlSW5wdXQucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPj0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCA9PT0gMCkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xufSIsImltcG9ydCBoYW1tZXJqcyBmcm9tICdoYW1tZXJqcyc7XG5pbXBvcnQgeyBlbmhhbmNlUG9pbnRlckV2ZW50SW5wdXQsIGVuaGFuY2VNb3VzZUlucHV0IH0gZnJvbSAnLi9oYW1tZXItb3ZlcnJpZGVzJztcbmVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dChoYW1tZXJqcy5Qb2ludGVyRXZlbnRJbnB1dCk7XG5lbmhhbmNlTW91c2VJbnB1dChoYW1tZXJqcy5Nb3VzZUlucHV0KTtcbmV4cG9ydCB2YXIgTWFuYWdlciA9IGhhbW1lcmpzLk1hbmFnZXI7XG5leHBvcnQgZGVmYXVsdCBoYW1tZXJqczsiLCJpbXBvcnQgSGFtbWVyIGZyb20gJy4vdXRpbHMvaGFtbWVyJztcbmV4cG9ydCB2YXIgUkVDT0dOSVpFUlMgPSBIYW1tZXIgPyBbW0hhbW1lci5QYW4sIHtcbiAgZXZlbnQ6ICd0cmlwYW4nLFxuICBwb2ludGVyczogMyxcbiAgdGhyZXNob2xkOiAwLFxuICBlbmFibGU6IGZhbHNlXG59XSwgW0hhbW1lci5Sb3RhdGUsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUGluY2gsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuU3dpcGUsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUGFuLCB7XG4gIHRocmVzaG9sZDogMCxcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuUHJlc3MsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGV2ZW50OiAnZG91YmxldGFwJyxcbiAgdGFwczogMixcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGV2ZW50OiAnYW55dGFwJyxcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtIYW1tZXIuVGFwLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dXSA6IG51bGw7XG5leHBvcnQgdmFyIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAgPSB7XG4gIHRyaXBhbjogWydyb3RhdGUnLCAncGluY2gnLCAncGFuJ10sXG4gIHJvdGF0ZTogWydwaW5jaCddLFxuICBwaW5jaDogWydwYW4nXSxcbiAgcGFuOiBbJ3ByZXNzJywgJ2RvdWJsZXRhcCcsICdhbnl0YXAnLCAndGFwJ10sXG4gIGRvdWJsZXRhcDogWydhbnl0YXAnXSxcbiAgYW55dGFwOiBbJ3RhcCddXG59O1xuZXhwb3J0IHZhciBSRUNPR05JWkVSX0ZBTExCQUNLX01BUCA9IHtcbiAgZG91YmxldGFwOiBbJ3RhcCddXG59O1xuZXhwb3J0IHZhciBCQVNJQ19FVkVOVF9BTElBU0VTID0ge1xuICBwb2ludGVyZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdwb2ludGVybW92ZScsXG4gIHBvaW50ZXJ1cDogJ3BvaW50ZXJ1cCcsXG4gIHRvdWNoc3RhcnQ6ICdwb2ludGVyZG93bicsXG4gIHRvdWNobW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdwb2ludGVydXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCdcbn07XG5leHBvcnQgdmFyIElOUFVUX0VWRU5UX1RZUEVTID0ge1xuICBLRVlfRVZFTlRTOiBbJ2tleWRvd24nLCAna2V5dXAnXSxcbiAgTU9VU0VfRVZFTlRTOiBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2VsZWF2ZSddLFxuICBXSEVFTF9FVkVOVFM6IFsnd2hlZWwnLCAnbW91c2V3aGVlbCddXG59O1xuZXhwb3J0IHZhciBFVkVOVF9SRUNPR05JWkVSX01BUCA9IHtcbiAgdGFwOiAndGFwJyxcbiAgYW55dGFwOiAnYW55dGFwJyxcbiAgZG91YmxldGFwOiAnZG91YmxldGFwJyxcbiAgcHJlc3M6ICdwcmVzcycsXG4gIHBpbmNoOiAncGluY2gnLFxuICBwaW5jaGluOiAncGluY2gnLFxuICBwaW5jaG91dDogJ3BpbmNoJyxcbiAgcGluY2hzdGFydDogJ3BpbmNoJyxcbiAgcGluY2htb3ZlOiAncGluY2gnLFxuICBwaW5jaGVuZDogJ3BpbmNoJyxcbiAgcGluY2hjYW5jZWw6ICdwaW5jaCcsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJvdGF0ZXN0YXJ0OiAncm90YXRlJyxcbiAgcm90YXRlbW92ZTogJ3JvdGF0ZScsXG4gIHJvdGF0ZWVuZDogJ3JvdGF0ZScsXG4gIHJvdGF0ZWNhbmNlbDogJ3JvdGF0ZScsXG4gIHRyaXBhbjogJ3RyaXBhbicsXG4gIHRyaXBhbnN0YXJ0OiAndHJpcGFuJyxcbiAgdHJpcGFubW92ZTogJ3RyaXBhbicsXG4gIHRyaXBhbnVwOiAndHJpcGFuJyxcbiAgdHJpcGFuZG93bjogJ3RyaXBhbicsXG4gIHRyaXBhbmxlZnQ6ICd0cmlwYW4nLFxuICB0cmlwYW5yaWdodDogJ3RyaXBhbicsXG4gIHRyaXBhbmVuZDogJ3RyaXBhbicsXG4gIHRyaXBhbmNhbmNlbDogJ3RyaXBhbicsXG4gIHBhbjogJ3BhbicsXG4gIHBhbnN0YXJ0OiAncGFuJyxcbiAgcGFubW92ZTogJ3BhbicsXG4gIHBhbnVwOiAncGFuJyxcbiAgcGFuZG93bjogJ3BhbicsXG4gIHBhbmxlZnQ6ICdwYW4nLFxuICBwYW5yaWdodDogJ3BhbicsXG4gIHBhbmVuZDogJ3BhbicsXG4gIHBhbmNhbmNlbDogJ3BhbicsXG4gIHN3aXBlOiAnc3dpcGUnLFxuICBzd2lwZWxlZnQ6ICdzd2lwZScsXG4gIHN3aXBlcmlnaHQ6ICdzd2lwZScsXG4gIHN3aXBldXA6ICdzd2lwZScsXG4gIHN3aXBlZG93bjogJ3N3aXBlJ1xufTtcbmV4cG9ydCB2YXIgR0VTVFVSRV9FVkVOVF9BTElBU0VTID0ge1xuICBjbGljazogJ3RhcCcsXG4gIGFueWNsaWNrOiAnYW55dGFwJyxcbiAgZGJsY2xpY2s6ICdkb3VibGV0YXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCcsXG4gIG1vdXNlb3ZlcjogJ3BvaW50ZXJvdmVyJyxcbiAgbW91c2VvdXQ6ICdwb2ludGVyb3V0JyxcbiAgbW91c2VsZWF2ZTogJ3BvaW50ZXJsZWF2ZSdcbn07IiwiZXhwb3J0IHZhciB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJyc7XG52YXIgd2luZG93XyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsO1xudmFyIGdsb2JhbF8gPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbnZhciBkb2N1bWVudF8gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fTtcbmV4cG9ydCB7IHdpbmRvd18gYXMgd2luZG93LCBnbG9iYWxfIGFzIGdsb2JhbCwgZG9jdW1lbnRfIGFzIGRvY3VtZW50IH07XG52YXIgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH07XG4gIHdpbmRvd18uYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB3aW5kb3dfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbn0gY2F0Y2ggKGVycikge31cblxuZXhwb3J0IHsgcGFzc2l2ZVN1cHBvcnRlZCB9OyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHdpbmRvdywgdXNlckFnZW50LCBwYXNzaXZlU3VwcG9ydGVkIH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xudmFyIFdIRUVMX0VWRU5UUyA9IElOUFVUX0VWRU5UX1RZUEVTLldIRUVMX0VWRU5UUztcbnZhciBFVkVOVF9UWVBFID0gJ3doZWVsJztcbnZhciBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbnZhciBXSEVFTF9ERUxUQV9QRVJfTElORSA9IDQwO1xudmFyIFNISUZUX01VTFRJUExJRVIgPSAwLjI1O1xuXG52YXIgV2hlZWxJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdoZWVsSW5wdXQoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdoZWVsSW5wdXQpO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmV2ZW50cyA9IFdIRUVMX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmhhbmRsZUV2ZW50LCBwYXNzaXZlU3VwcG9ydGVkID8ge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSA6IGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXaGVlbElucHV0LCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzMi5oYW5kbGVFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRXZlbnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBldmVudC5kZWx0YVk7XG5cbiAgICAgIGlmICh3aW5kb3cuV2hlZWxFdmVudCkge1xuICAgICAgICBpZiAoZmlyZWZveCAmJiBldmVudC5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgICAgIHZhbHVlIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgICB2YWx1ZSAqPSBXSEVFTF9ERUxUQV9QRVJfTElORTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgd2hlZWxQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfTtcblxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5zaGlmdEtleSAmJiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICogU0hJRlRfTVVMVElQTElFUjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25XaGVlbChldmVudCwgLXZhbHVlLCB3aGVlbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uV2hlZWwoc3JjRXZlbnQsIGRlbHRhLCBwb3NpdGlvbikge1xuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IEVWRU5UX1RZUEUsXG4gICAgICAgIGNlbnRlcjogcG9zaXRpb24sXG4gICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgc3JjRXZlbnQ6IHNyY0V2ZW50LFxuICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgdGFyZ2V0OiBzcmNFdmVudC50YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXaGVlbElucHV0O1xufSgpO1xuXG5leHBvcnQgeyBXaGVlbElucHV0IGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgeyBJTlBVVF9FVkVOVF9UWVBFUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG52YXIgTU9VU0VfRVZFTlRTID0gSU5QVVRfRVZFTlRfVFlQRVMuTU9VU0VfRVZFTlRTO1xudmFyIE1PVkVfRVZFTlRfVFlQRSA9ICdwb2ludGVybW92ZSc7XG52YXIgT1ZFUl9FVkVOVF9UWVBFID0gJ3BvaW50ZXJvdmVyJztcbnZhciBPVVRfRVZFTlRfVFlQRSA9ICdwb2ludGVyb3V0JztcbnZhciBMRUFWRV9FVkVOVF9UWVBFID0gJ3BvaW50ZXJsZWF2ZSc7XG5cbnZhciBNb3ZlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb3ZlSW5wdXQoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdmVJbnB1dCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGVuYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuZW5hYmxlTW92ZUV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZUxlYXZlRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlT3V0RXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZW5hYmxlT3ZlckV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmV2ZW50cyA9IE1PVVNFX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNb3ZlSW5wdXQsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMyLmhhbmRsZUV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVFdmVudFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRUeXBlKGV2ZW50VHlwZSwgZW5hYmxlZCkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gTU9WRV9FVkVOVF9UWVBFKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlTW92ZUV2ZW50ID0gZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gT1ZFUl9FVkVOVF9UWVBFKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3ZlckV2ZW50ID0gZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gT1VUX0VWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVPdXRFdmVudCA9IGVuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgPT09IExFQVZFX0VWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVMZWF2ZUV2ZW50ID0gZW5hYmxlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlT3ZlckV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlT3V0RXZlbnQoZXZlbnQpO1xuICAgICAgdGhpcy5oYW5kbGVMZWF2ZUV2ZW50KGV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlT3ZlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU92ZXJFdmVudChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlT3ZlckV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VvdmVyJykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgICAgdHlwZTogT1ZFUl9FVkVOVF9UWVBFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU91dEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU91dEV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5lbmFibGVPdXRFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgICAgdHlwZTogT1VUX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTGVhdmVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5lbmFibGVMZWF2ZUV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICAgIHR5cGU6IExFQVZFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW92ZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlTW92ZUV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNT1ZFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW92ZUlucHV0O1xufSgpO1xuXG5leHBvcnQgeyBNb3ZlSW5wdXQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCB7IElOUFVUX0VWRU5UX1RZUEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbnZhciBLRVlfRVZFTlRTID0gSU5QVVRfRVZFTlRfVFlQRVMuS0VZX0VWRU5UUztcbnZhciBET1dOX0VWRU5UX1RZUEUgPSAna2V5ZG93bic7XG52YXIgVVBfRVZFTlRfVFlQRSA9ICdrZXl1cCc7XG5cbnZhciBLZXlJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleUlucHV0KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlJbnB1dCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGVuYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuZW5hYmxlRG93bkV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZVVwRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuICAgIHRoaXMuZXZlbnRzID0gS0VZX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IG9wdGlvbnMudGFiSW5kZXggfHwgMDtcbiAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhLZXlJbnB1dCwgW3tcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpczIuaGFuZGxlRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUV2ZW50VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSBET1dOX0VWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVEb3duRXZlbnQgPSBlbmFibGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRUeXBlID09PSBVUF9FVkVOVF9UWVBFKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlVXBFdmVudCA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXG4gICAgICBpZiAodGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnICYmIHRhcmdldEVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8IHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZURvd25FdmVudCAmJiBldmVudC50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgICAgdHlwZTogRE9XTl9FVkVOVF9UWVBFLFxuICAgICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW5hYmxlVXBFdmVudCAmJiBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIHR5cGU6IFVQX0VWRU5UX1RZUEUsXG4gICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlJbnB1dDtcbn0oKTtcblxuZXhwb3J0IHsgS2V5SW5wdXQgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbnZhciBFVkVOVF9UWVBFID0gJ2NvbnRleHRtZW51JztcblxudmFyIENvbnRleHRtZW51SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZXh0bWVudUlucHV0KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRleHRtZW51SW5wdXQpO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb250ZXh0bWVudUlucHV0LCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRXZlbnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50VHlwZShldmVudFR5cGUsIGVuYWJsZWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgIH0sXG4gICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGV4dG1lbnVJbnB1dDtcbn0oKTtcblxuZXhwb3J0IHsgQ29udGV4dG1lbnVJbnB1dCBhcyBkZWZhdWx0IH07IiwidmFyIERPV05fRVZFTlQgPSAxO1xudmFyIE1PVkVfRVZFTlQgPSAyO1xudmFyIFVQX0VWRU5UID0gNDtcbnZhciBNT1VTRV9FVkVOVFMgPSB7XG4gIHBvaW50ZXJkb3duOiBET1dOX0VWRU5ULFxuICBwb2ludGVybW92ZTogTU9WRV9FVkVOVCxcbiAgcG9pbnRlcnVwOiBVUF9FVkVOVCxcbiAgbW91c2Vkb3duOiBET1dOX0VWRU5ULFxuICBtb3VzZW1vdmU6IE1PVkVfRVZFTlQsXG4gIG1vdXNldXA6IFVQX0VWRU5UXG59O1xudmFyIE1PVVNFX0VWRU5UX1dISUNIX0xFRlQgPSAxO1xudmFyIE1PVVNFX0VWRU5UX1dISUNIX01JRERMRSA9IDI7XG52YXIgTU9VU0VfRVZFTlRfV0hJQ0hfUklHSFQgPSAzO1xudmFyIE1PVVNFX0VWRU5UX0JVVFRPTl9MRUZUID0gMDtcbnZhciBNT1VTRV9FVkVOVF9CVVRUT05fTUlERExFID0gMTtcbnZhciBNT1VTRV9FVkVOVF9CVVRUT05fUklHSFQgPSAyO1xudmFyIE1PVVNFX0VWRU5UX0JVVFRPTlNfTEVGVF9NQVNLID0gMTtcbnZhciBNT1VTRV9FVkVOVF9CVVRUT05TX1JJR0hUX01BU0sgPSAyO1xudmFyIE1PVVNFX0VWRU5UX0JVVFRPTlNfTUlERExFX01BU0sgPSA0O1xuZXhwb3J0IGZ1bmN0aW9uIHdoaWNoQnV0dG9ucyhldmVudCkge1xuICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfRVZFTlRTW2V2ZW50LnNyY0V2ZW50LnR5cGVdO1xuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgX2V2ZW50JHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQsXG4gICAgICBidXR0b25zID0gX2V2ZW50JHNyY0V2ZW50LmJ1dHRvbnMsXG4gICAgICBidXR0b24gPSBfZXZlbnQkc3JjRXZlbnQuYnV0dG9uLFxuICAgICAgd2hpY2ggPSBfZXZlbnQkc3JjRXZlbnQud2hpY2g7XG4gIHZhciBsZWZ0QnV0dG9uID0gZmFsc2U7XG4gIHZhciBtaWRkbGVCdXR0b24gPSBmYWxzZTtcbiAgdmFyIHJpZ2h0QnV0dG9uID0gZmFsc2U7XG5cbiAgaWYgKGV2ZW50VHlwZSA9PT0gVVBfRVZFTlQgfHwgZXZlbnRUeXBlID09PSBNT1ZFX0VWRU5UICYmICFOdW1iZXIuaXNGaW5pdGUoYnV0dG9ucykpIHtcbiAgICBsZWZ0QnV0dG9uID0gd2hpY2ggPT09IE1PVVNFX0VWRU5UX1dISUNIX0xFRlQ7XG4gICAgbWlkZGxlQnV0dG9uID0gd2hpY2ggPT09IE1PVVNFX0VWRU5UX1dISUNIX01JRERMRTtcbiAgICByaWdodEJ1dHRvbiA9IHdoaWNoID09PSBNT1VTRV9FVkVOVF9XSElDSF9SSUdIVDtcbiAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IE1PVkVfRVZFTlQpIHtcbiAgICBsZWZ0QnV0dG9uID0gQm9vbGVhbihidXR0b25zICYgTU9VU0VfRVZFTlRfQlVUVE9OU19MRUZUX01BU0spO1xuICAgIG1pZGRsZUJ1dHRvbiA9IEJvb2xlYW4oYnV0dG9ucyAmIE1PVVNFX0VWRU5UX0JVVFRPTlNfTUlERExFX01BU0spO1xuICAgIHJpZ2h0QnV0dG9uID0gQm9vbGVhbihidXR0b25zICYgTU9VU0VfRVZFTlRfQlVUVE9OU19SSUdIVF9NQVNLKTtcbiAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IERPV05fRVZFTlQpIHtcbiAgICBsZWZ0QnV0dG9uID0gYnV0dG9uID09PSBNT1VTRV9FVkVOVF9CVVRUT05fTEVGVDtcbiAgICBtaWRkbGVCdXR0b24gPSBidXR0b24gPT09IE1PVVNFX0VWRU5UX0JVVFRPTl9NSURETEU7XG4gICAgcmlnaHRCdXR0b24gPSBidXR0b24gPT09IE1PVVNFX0VWRU5UX0JVVFRPTl9SSUdIVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVmdEJ1dHRvbjogbGVmdEJ1dHRvbixcbiAgICBtaWRkbGVCdXR0b246IG1pZGRsZUJ1dHRvbixcbiAgICByaWdodEJ1dHRvbjogcmlnaHRCdXR0b25cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXRQb3NpdGlvbihldmVudCwgcm9vdEVsZW1lbnQpIHtcbiAgdmFyIHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQ7XG5cbiAgaWYgKCFldmVudC5jZW50ZXIgJiYgIU51bWJlci5pc0Zpbml0ZShzcmNFdmVudC5jbGllbnRYKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNlbnRlciA9IGV2ZW50LmNlbnRlciB8fCB7XG4gICAgeDogc3JjRXZlbnQuY2xpZW50WCxcbiAgICB5OiBzcmNFdmVudC5jbGllbnRZXG4gIH07XG4gIHZhciByZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByZWN0LndpZHRoIC8gcm9vdEVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gcm9vdEVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHZhciBvZmZzZXRDZW50ZXIgPSB7XG4gICAgeDogKGNlbnRlci54IC0gcmVjdC5sZWZ0IC0gcm9vdEVsZW1lbnQuY2xpZW50TGVmdCkgLyBzY2FsZVgsXG4gICAgeTogKGNlbnRlci55IC0gcmVjdC50b3AgLSByb290RWxlbWVudC5jbGllbnRUb3ApIC8gc2NhbGVZXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgb2Zmc2V0Q2VudGVyOiBvZmZzZXRDZW50ZXJcbiAgfTtcbn0iLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgeyB3aGljaEJ1dHRvbnMsIGdldE9mZnNldFBvc2l0aW9uIH0gZnJvbSAnLi9ldmVudC11dGlscyc7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBzcmNFbGVtZW50OiAncm9vdCcsXG4gIHByaW9yaXR5OiAwXG59O1xuXG52YXIgRXZlbnRSZWdpc3RyYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudFJlZ2lzdHJhcihldmVudE1hbmFnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRSZWdpc3RyYXIpO1xuXG4gICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuaGFuZGxlcnNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudFJlZ2lzdHJhciwgW3tcbiAgICBrZXk6IFwiaXNFbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9hY3RpdmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodHlwZSwgaGFuZGxlciwgb3B0cykge1xuICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgdmFyIHBhc3NpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycyxcbiAgICAgICAgICBoYW5kbGVyc0J5RWxlbWVudCA9IHRoaXMuaGFuZGxlcnNCeUVsZW1lbnQ7XG5cbiAgICAgIGlmIChvcHRzICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgb3B0cy5hZGRFdmVudExpc3RlbmVyKSkge1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIHNyY0VsZW1lbnQ6IG9wdHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3B0cyA9IG9wdHMgPyBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdHMpIDogREVGQVVMVF9PUFRJT05TO1xuICAgICAgdmFyIGVudHJpZXMgPSBoYW5kbGVyc0J5RWxlbWVudC5nZXQob3B0cy5zcmNFbGVtZW50KTtcblxuICAgICAgaWYgKCFlbnRyaWVzKSB7XG4gICAgICAgIGVudHJpZXMgPSBbXTtcbiAgICAgICAgaGFuZGxlcnNCeUVsZW1lbnQuc2V0KG9wdHMuc3JjRWxlbWVudCwgZW50cmllcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgc3JjRWxlbWVudDogb3B0cy5zcmNFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogb3B0cy5wcmlvcml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgZW50cnkub25jZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXNzaXZlKSB7XG4gICAgICAgIGVudHJ5LnBhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVycy5wdXNoKGVudHJ5KTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCAhZW50cnkucGFzc2l2ZTtcbiAgICAgIHZhciBpbnNlcnRQb3NpdGlvbiA9IGVudHJpZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGluc2VydFBvc2l0aW9uID49IDApIHtcbiAgICAgICAgaWYgKGVudHJpZXNbaW5zZXJ0UG9zaXRpb25dLnByaW9yaXR5ID49IGVudHJ5LnByaW9yaXR5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbnNlcnRQb3NpdGlvbi0tO1xuICAgICAgfVxuXG4gICAgICBlbnRyaWVzLnNwbGljZShpbnNlcnRQb3NpdGlvbiArIDEsIDAsIGVudHJ5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzLFxuICAgICAgICAgIGhhbmRsZXJzQnlFbGVtZW50ID0gdGhpcy5oYW5kbGVyc0J5RWxlbWVudDtcblxuICAgICAgZm9yICh2YXIgaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGhhbmRsZXJzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50eXBlID09PSB0eXBlICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBoYW5kbGVyc0J5RWxlbWVudC5nZXQoZW50cnkuc3JjRWxlbWVudCk7XG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoZW50cmllcy5pbmRleE9mKGVudHJ5KSwgMSk7XG5cbiAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGhhbmRsZXJzQnlFbGVtZW50LmRlbGV0ZShlbnRyeS5zcmNFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlID0gaGFuZGxlcnMuc29tZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICFlbnRyeS5wYXNzaXZlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWpvbG5pckV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuc3JjRXZlbnQudGFyZ2V0O1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gbWpvbG5pckV2ZW50LnJvb3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXQobWpvbG5pckV2ZW50LCB0YXJnZXQpO1xuXG4gICAgICAgIGlmIChtam9sbmlyRXZlbnQuaGFuZGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0KG1qb2xuaXJFdmVudCwgJ3Jvb3QnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXQoZXZlbnQsIHNyY0VsZW1lbnQpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5oYW5kbGVyc0J5RWxlbWVudC5nZXQoc3JjRWxlbWVudCk7XG5cbiAgICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICAgIHZhciBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgIGV2ZW50LmhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgZXZlbnQuaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZW50cmllc1RvUmVtb3ZlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbnRyaWVzJGkgPSBlbnRyaWVzW2ldLFxuICAgICAgICAgICAgICB0eXBlID0gX2VudHJpZXMkaS50eXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyID0gX2VudHJpZXMkaS5oYW5kbGVyLFxuICAgICAgICAgICAgICBvbmNlID0gX2VudHJpZXMkaS5vbmNlO1xuICAgICAgICAgIGhhbmRsZXIoT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgIGVudHJpZXNUb1JlbW92ZS5wdXNoKGVudHJpZXNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbnRyaWVzVG9SZW1vdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbnRyaWVzVG9SZW1vdmUkX2kgPSBlbnRyaWVzVG9SZW1vdmVbX2ldLFxuICAgICAgICAgICAgICBfdHlwZSA9IF9lbnRyaWVzVG9SZW1vdmUkX2kudHlwZSxcbiAgICAgICAgICAgICAgX2hhbmRsZXIgPSBfZW50cmllc1RvUmVtb3ZlJF9pLmhhbmRsZXI7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoX3R5cGUsIF9oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm9ybWFsaXplRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLmV2ZW50TWFuYWdlci5lbGVtZW50O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB3aGljaEJ1dHRvbnMoZXZlbnQpLCBnZXRPZmZzZXRQb3NpdGlvbihldmVudCwgcm9vdEVsZW1lbnQpLCB7XG4gICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICByb290RWxlbWVudDogcm9vdEVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudFJlZ2lzdHJhcjtcbn0oKTtcblxuZXhwb3J0IHsgRXZlbnRSZWdpc3RyYXIgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuaW1wb3J0IHsgTWFuYWdlciB9IGZyb20gJy4vdXRpbHMvaGFtbWVyJztcbmltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vaW5wdXRzL3doZWVsLWlucHV0JztcbmltcG9ydCBNb3ZlSW5wdXQgZnJvbSAnLi9pbnB1dHMvbW92ZS1pbnB1dCc7XG5pbXBvcnQgS2V5SW5wdXQgZnJvbSAnLi9pbnB1dHMva2V5LWlucHV0JztcbmltcG9ydCBDb250ZXh0bWVudUlucHV0IGZyb20gJy4vaW5wdXRzL2NvbnRleHRtZW51LWlucHV0JztcbmltcG9ydCBFdmVudFJlZ2lzdHJhciBmcm9tICcuL3V0aWxzL2V2ZW50LXJlZ2lzdHJhcic7XG5pbXBvcnQgeyBCQVNJQ19FVkVOVF9BTElBU0VTLCBFVkVOVF9SRUNPR05JWkVSX01BUCwgR0VTVFVSRV9FVkVOVF9BTElBU0VTLCBSRUNPR05JWkVSUywgUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUCwgUkVDT0dOSVpFUl9GQUxMQkFDS19NQVAgfSBmcm9tICcuL2NvbnN0YW50cyc7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBldmVudHM6IG51bGwsXG4gIHJlY29nbml6ZXJzOiBudWxsLFxuICByZWNvZ25pemVyT3B0aW9uczoge30sXG4gIE1hbmFnZXI6IE1hbmFnZXIsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIHRhYkluZGV4OiAwXG59O1xuXG52YXIgRXZlbnRNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKCkge1xuICAgIHZhciBlbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudE1hbmFnZXIpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSB0aGlzLl9vbkJhc2ljSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgdmFyIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5vbihldmVudHMpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudE1hbmFnZXIsIFt7XG4gICAga2V5OiBcInNldEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBNYW5hZ2VyQ2xhc3MgPSBvcHRpb25zLk1hbmFnZXI7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtcbiAgICAgICAgdG91Y2hBY3Rpb246IG9wdGlvbnMudG91Y2hBY3Rpb24sXG4gICAgICAgIHJlY29nbml6ZXJzOiBvcHRpb25zLnJlY29nbml6ZXJzIHx8IFJFQ09HTklaRVJTXG4gICAgICB9KS5vbignaGFtbWVyLmlucHV0JywgdGhpcy5fb25CYXNpY0lucHV0KTtcblxuICAgICAgaWYgKCFvcHRpb25zLnJlY29nbml6ZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgcmVjb2duaXplciA9IF90aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuXG4gICAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAob3RoZXJOYW1lKSB7XG4gICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChvdGhlck5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcmVjb2duaXplck5hbWUgaW4gb3B0aW9ucy5yZWNvZ25pemVyT3B0aW9ucykge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQocmVjb2duaXplck5hbWUpO1xuXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgdmFyIHJlY29nbml6ZXJPcHRpb24gPSBvcHRpb25zLnJlY29nbml6ZXJPcHRpb25zW3JlY29nbml6ZXJOYW1lXTtcbiAgICAgICAgICBkZWxldGUgcmVjb2duaXplck9wdGlvbi5lbmFibGU7XG4gICAgICAgICAgcmVjb2duaXplci5zZXQocmVjb2duaXplck9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53aGVlbElucHV0ID0gbmV3IFdoZWVsSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICAgIGVuYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMua2V5SW5wdXQgPSBuZXcgS2V5SW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICAgIHRhYkluZGV4OiBvcHRpb25zLnRhYkluZGV4XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGV4dG1lbnVJbnB1dCA9IG5ldyBDb250ZXh0bWVudUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZXZlbnRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGV2ZW50QWxpYXMgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZXZlbnRSZWdpc3RyYXIgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICghZXZlbnRSZWdpc3RyYXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKGV2ZW50UmVnaXN0cmFyLnJlY29nbml6ZXJOYW1lLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLndoZWVsSW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMua2V5SW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLndoZWVsSW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmVJbnB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5SW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHRtZW51SW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgb3B0cykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBmYWxzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudCwgaGFuZGxlciwgb3B0cykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2F0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2F0Y2goZXZlbnQsIGhhbmRsZXIsIG9wdHMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgb3B0cywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdG9nZ2xlUmVjb2duaXplclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlUmVjb2duaXplcihuYW1lLCBlbmFibGVkKSB7XG4gICAgICB2YXIgbWFuYWdlciA9IHRoaXMubWFuYWdlcjtcblxuICAgICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChuYW1lKTtcblxuICAgICAgaWYgKHJlY29nbml6ZXIgJiYgcmVjb2duaXplci5vcHRpb25zLmVuYWJsZSAhPT0gZW5hYmxlZCkge1xuICAgICAgICByZWNvZ25pemVyLnNldCh7XG4gICAgICAgICAgZW5hYmxlOiBlbmFibGVkXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmFsbGJhY2tSZWNvZ25pemVycyA9IFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQW25hbWVdO1xuXG4gICAgICAgIGlmIChmYWxsYmFja1JlY29nbml6ZXJzICYmICF0aGlzLm9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgICAgICBmYWxsYmFja1JlY29nbml6ZXJzLmZvckVhY2goZnVuY3Rpb24gKG90aGVyTmFtZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyUmVjb2duaXplciA9IG1hbmFnZXIuZ2V0KG90aGVyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICAgICAgcmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53aGVlbElucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICAgIHRoaXMubW92ZUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICAgIHRoaXMua2V5SW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgICAgdGhpcy5jb250ZXh0bWVudUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEV2ZW50SGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBvbmNlLCBwYXNzaXZlKSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRzID0gaGFuZGxlcjtcblxuICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdLCBvcHRzLCBvbmNlLCBwYXNzaXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzLm1hbmFnZXIsXG4gICAgICAgICAgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICB2YXIgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgICB2YXIgZXZlbnRSZWdpc3RyYXIgPSBldmVudHMuZ2V0KGV2ZW50QWxpYXMpO1xuXG4gICAgICBpZiAoIWV2ZW50UmVnaXN0cmFyKSB7XG4gICAgICAgIGV2ZW50UmVnaXN0cmFyID0gbmV3IEV2ZW50UmVnaXN0cmFyKHRoaXMpO1xuICAgICAgICBldmVudHMuc2V0KGV2ZW50QWxpYXMsIGV2ZW50UmVnaXN0cmFyKTtcbiAgICAgICAgZXZlbnRSZWdpc3RyYXIucmVjb2duaXplck5hbWUgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudEFsaWFzXSB8fCBldmVudEFsaWFzO1xuXG4gICAgICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgICAgbWFuYWdlci5vbihldmVudEFsaWFzLCBldmVudFJlZ2lzdHJhci5oYW5kbGVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnRSZWdpc3RyYXIuYWRkKGV2ZW50LCBoYW5kbGVyLCBvcHRzLCBvbmNlLCBwYXNzaXZlKTtcblxuICAgICAgaWYgKCFldmVudFJlZ2lzdHJhci5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihldmVudFJlZ2lzdHJhci5yZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVFdmVudEhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgIHZhciBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAgIHZhciBldmVudFJlZ2lzdHJhciA9IGV2ZW50cy5nZXQoZXZlbnRBbGlhcyk7XG5cbiAgICAgIGlmICghZXZlbnRSZWdpc3RyYXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudFJlZ2lzdHJhci5yZW1vdmUoZXZlbnQsIGhhbmRsZXIpO1xuXG4gICAgICBpZiAoZXZlbnRSZWdpc3RyYXIuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyTmFtZSA9IGV2ZW50UmVnaXN0cmFyLnJlY29nbml6ZXJOYW1lO1xuICAgICAgICB2YXIgaXNSZWNvZ25pemVyVXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZXZlbnRzLnZhbHVlcygpKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZWggPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChlaC5yZWNvZ25pemVyTmFtZSA9PT0gcmVjb2duaXplck5hbWUgJiYgIWVoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBpc1JlY29nbml6ZXJVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNSZWNvZ25pemVyVXNlZCkge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25CYXNpY0lucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICAgIHZhciBzcmNFdmVudCA9IGV2ZW50LnNyY0V2ZW50O1xuICAgICAgdmFyIGFsaWFzID0gQkFTSUNfRVZFTlRfQUxJQVNFU1tzcmNFdmVudC50eXBlXTtcblxuICAgICAgaWYgKGFsaWFzKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KGFsaWFzLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbk90aGVyRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uT3RoZXJFdmVudChldmVudCkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydCB7IEV2ZW50TWFuYWdlciBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCBNYXBTdGF0ZSBmcm9tICcuL21hcC1zdGF0ZSc7XG5pbXBvcnQgeyBMaW5lYXJJbnRlcnBvbGF0b3IgfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IFRyYW5zaXRpb25NYW5hZ2VyLCB7IFRSQU5TSVRJT05fRVZFTlRTIH0gZnJvbSAnLi90cmFuc2l0aW9uLW1hbmFnZXInO1xudmFyIE5PX1RSQU5TSVRJT05fUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMFxufTtcbmV4cG9ydCB2YXIgTElORUFSX1RSQU5TSVRJT05fUFJPUFMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogMzAwLFxuICB0cmFuc2l0aW9uRWFzaW5nOiBmdW5jdGlvbiB0cmFuc2l0aW9uRWFzaW5nKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogbmV3IExpbmVhckludGVycG9sYXRvcigpLFxuICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiBUUkFOU0lUSU9OX0VWRU5UUy5CUkVBS1xufTtcbnZhciBERUZBVUxUX0lORVJUSUEgPSAzMDA7XG5cbnZhciBJTkVSVElBX0VBU0lORyA9IGZ1bmN0aW9uIElORVJUSUFfRUFTSU5HKHQpIHtcbiAgcmV0dXJuIDEgLSAoMSAtIHQpICogKDEgLSB0KTtcbn07XG5cbnZhciBFVkVOVF9UWVBFUyA9IHtcbiAgV0hFRUw6IFsnd2hlZWwnXSxcbiAgUEFOOiBbJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ10sXG4gIFBJTkNIOiBbJ3BpbmNoc3RhcnQnLCAncGluY2htb3ZlJywgJ3BpbmNoZW5kJ10sXG4gIFRSSVBMRV9QQU46IFsndHJpcGFuc3RhcnQnLCAndHJpcGFubW92ZScsICd0cmlwYW5lbmQnXSxcbiAgRE9VQkxFX1RBUDogWydkb3VibGV0YXAnXSxcbiAgS0VZQk9BUkQ6IFsna2V5ZG93biddXG59O1xuXG52YXIgTWFwQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFwQ29udHJvbGxlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcENvbnRyb2xsZXIpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjcm9sbFpvb21cIiwgdHJ1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFnUGFuXCIsIHRydWUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ1JvdGF0ZVwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdWJsZUNsaWNrWm9vbVwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoWm9vbVwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoUm90YXRlXCIsIGZhbHNlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleWJvYXJkXCIsIHRydWUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVyYWN0aW9uU3RhdGVcIiwge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ldmVudHNcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NldEludGVyYWN0aW9uU3RhdGVcIiwgZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKF90aGlzLl9pbnRlcmFjdGlvblN0YXRlLCBuZXdTdGF0ZSk7XG5cbiAgICAgIGlmIChfdGhpcy5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLm9uU3RhdGVDaGFuZ2UoX3RoaXMuX2ludGVyYWN0aW9uU3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uVHJhbnNpdGlvblwiLCBmdW5jdGlvbiAobmV3Vmlld3BvcnQsIG9sZFZpZXdwb3J0KSB7XG4gICAgICBfdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0LCBfdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld3BvcnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl90cmFuc2l0aW9uTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICBvblZpZXdwb3J0Q2hhbmdlOiB0aGlzLl9vblRyYW5zaXRpb24sXG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9zZXRJbnRlcmFjdGlvblN0YXRlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIHRoaXMubWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKCk7XG4gICAgICB2YXIgZXZlbnRTdGFydEJsb2NrZWQgPSB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZDtcblxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BhbnN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uUGFuU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3Bhbm1vdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblBhbihldmVudCk7XG5cbiAgICAgICAgY2FzZSAncGFuZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25QYW5FbmQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3BpbmNoc3RhcnQnOlxuICAgICAgICAgIHJldHVybiBldmVudFN0YXJ0QmxvY2tlZCA/IGZhbHNlIDogdGhpcy5fb25QaW5jaFN0YXJ0KGV2ZW50KTtcblxuICAgICAgICBjYXNlICdwaW5jaG1vdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoKGV2ZW50KTtcblxuICAgICAgICBjYXNlICdwaW5jaGVuZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hFbmQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3RyaXBhbnN0YXJ0JzpcbiAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3RyaXBhbm1vdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblRyaXBsZVBhbihldmVudCk7XG5cbiAgICAgICAgY2FzZSAndHJpcGFuZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25UcmlwbGVQYW5FbmQoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uRG91YmxlVGFwKGV2ZW50KTtcblxuICAgICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29uV2hlZWwoZXZlbnQpO1xuXG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VudGVyKGV2ZW50KSB7XG4gICAgICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICAgICAgICB4ID0gX2V2ZW50JG9mZnNldENlbnRlci54LFxuICAgICAgICAgIHkgPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLnk7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Z1bmN0aW9uS2V5UHJlc3NlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkge1xuICAgICAgdmFyIHNyY0V2ZW50ID0gZXZlbnQuc3JjRXZlbnQ7XG4gICAgICByZXR1cm4gQm9vbGVhbihzcmNFdmVudC5tZXRhS2V5IHx8IHNyY0V2ZW50LmFsdEtleSB8fCBzcmNFdmVudC5jdHJsS2V5IHx8IHNyY0V2ZW50LnNoaWZ0S2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmxvY2tFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2tFdmVudHModGltZW91dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLl9ldmVudFN0YXJ0QmxvY2tlZCA9PT0gdGltZXIpIHtcbiAgICAgICAgICBfdGhpczIuX2V2ZW50U3RhcnRCbG9ja2VkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG4gICAgICB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZCA9IHRpbWVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgZXh0cmFQcm9wcywgaW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgICAgdmFyIG9sZFZpZXdwb3J0ID0gdGhpcy5tYXBTdGF0ZSBpbnN0YW5jZW9mIE1hcFN0YXRlID8gdGhpcy5tYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCkgOiB0aGlzLm1hcFN0YXRlO1xuXG4gICAgICB2YXIgbmV3Vmlld3BvcnQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5ld01hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKSksIGV4dHJhUHJvcHMpO1xuXG4gICAgICB2YXIgdmlld1N0YXRlQ2hhbmdlZCA9IE9iamVjdC5rZXlzKG5ld1ZpZXdwb3J0KS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9sZFZpZXdwb3J0W2tleV0gIT09IG5ld1ZpZXdwb3J0W2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV3TWFwU3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25TdGF0ZShpbnRlcmFjdGlvblN0YXRlKTtcblxuICAgICAgaWYgKHZpZXdTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0LCB0aGlzLl9pbnRlcmFjdGlvblN0YXRlLCBvbGRWaWV3cG9ydCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcFN0YXRlKG92ZXJyaWRlcykge1xuICAgICAgcmV0dXJuIG5ldyBNYXBTdGF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5tYXBTdGF0ZVByb3BzKSwgdGhpcy5fc3RhdGUpLCBvdmVycmlkZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEcmFnZ2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RyYWdnaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aW9uU3RhdGUuaXNEcmFnZ2luZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gb3B0aW9ucy5vblZpZXdwb3J0Q2hhbmdlLFxuICAgICAgICAgIG9uU3RhdGVDaGFuZ2UgPSBvcHRpb25zLm9uU3RhdGVDaGFuZ2UsXG4gICAgICAgICAgX29wdGlvbnMkZXZlbnRNYW5hZ2VyID0gb3B0aW9ucy5ldmVudE1hbmFnZXIsXG4gICAgICAgICAgZXZlbnRNYW5hZ2VyID0gX29wdGlvbnMkZXZlbnRNYW5hZ2VyID09PSB2b2lkIDAgPyB0aGlzLmV2ZW50TWFuYWdlciA6IF9vcHRpb25zJGV2ZW50TWFuYWdlcixcbiAgICAgICAgICBfb3B0aW9ucyRpc0ludGVyYWN0aXYgPSBvcHRpb25zLmlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgaXNJbnRlcmFjdGl2ZSA9IF9vcHRpb25zJGlzSW50ZXJhY3RpdiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGlzSW50ZXJhY3RpdixcbiAgICAgICAgICBfb3B0aW9ucyRzY3JvbGxab29tID0gb3B0aW9ucy5zY3JvbGxab29tLFxuICAgICAgICAgIHNjcm9sbFpvb20gPSBfb3B0aW9ucyRzY3JvbGxab29tID09PSB2b2lkIDAgPyB0aGlzLnNjcm9sbFpvb20gOiBfb3B0aW9ucyRzY3JvbGxab29tLFxuICAgICAgICAgIF9vcHRpb25zJGRyYWdQYW4gPSBvcHRpb25zLmRyYWdQYW4sXG4gICAgICAgICAgZHJhZ1BhbiA9IF9vcHRpb25zJGRyYWdQYW4gPT09IHZvaWQgMCA/IHRoaXMuZHJhZ1BhbiA6IF9vcHRpb25zJGRyYWdQYW4sXG4gICAgICAgICAgX29wdGlvbnMkZHJhZ1JvdGF0ZSA9IG9wdGlvbnMuZHJhZ1JvdGF0ZSxcbiAgICAgICAgICBkcmFnUm90YXRlID0gX29wdGlvbnMkZHJhZ1JvdGF0ZSA9PT0gdm9pZCAwID8gdGhpcy5kcmFnUm90YXRlIDogX29wdGlvbnMkZHJhZ1JvdGF0ZSxcbiAgICAgICAgICBfb3B0aW9ucyRkb3VibGVDbGlja1ogPSBvcHRpb25zLmRvdWJsZUNsaWNrWm9vbSxcbiAgICAgICAgICBkb3VibGVDbGlja1pvb20gPSBfb3B0aW9ucyRkb3VibGVDbGlja1ogPT09IHZvaWQgMCA/IHRoaXMuZG91YmxlQ2xpY2tab29tIDogX29wdGlvbnMkZG91YmxlQ2xpY2taLFxuICAgICAgICAgIF9vcHRpb25zJHRvdWNoWm9vbSA9IG9wdGlvbnMudG91Y2hab29tLFxuICAgICAgICAgIHRvdWNoWm9vbSA9IF9vcHRpb25zJHRvdWNoWm9vbSA9PT0gdm9pZCAwID8gdGhpcy50b3VjaFpvb20gOiBfb3B0aW9ucyR0b3VjaFpvb20sXG4gICAgICAgICAgX29wdGlvbnMkdG91Y2hSb3RhdGUgPSBvcHRpb25zLnRvdWNoUm90YXRlLFxuICAgICAgICAgIHRvdWNoUm90YXRlID0gX29wdGlvbnMkdG91Y2hSb3RhdGUgPT09IHZvaWQgMCA/IHRoaXMudG91Y2hSb3RhdGUgOiBfb3B0aW9ucyR0b3VjaFJvdGF0ZSxcbiAgICAgICAgICBfb3B0aW9ucyRrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQsXG4gICAgICAgICAga2V5Ym9hcmQgPSBfb3B0aW9ucyRrZXlib2FyZCA9PT0gdm9pZCAwID8gdGhpcy5rZXlib2FyZCA6IF9vcHRpb25zJGtleWJvYXJkO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlID0gb25WaWV3cG9ydENoYW5nZTtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSB0aGlzLm1hcFN0YXRlUHJvcHMgfHwge307XG4gICAgICB2YXIgZGltZW5zaW9uQ2hhbmdlZCA9IHByZXZPcHRpb25zLmhlaWdodCAhPT0gb3B0aW9ucy5oZWlnaHQgfHwgcHJldk9wdGlvbnMud2lkdGggIT09IG9wdGlvbnMud2lkdGg7XG4gICAgICB0aGlzLm1hcFN0YXRlUHJvcHMgPSBvcHRpb25zO1xuXG4gICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm1hcFN0YXRlID0gcHJldk9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3IE1hcFN0YXRlKG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJhbnNpdGlvbk1hbmFnZXIucHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlKG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIgIT09IGV2ZW50TWFuYWdlcikge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKHRoaXMuZXZlbnRzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuV0hFRUwsIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihzY3JvbGxab29tKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QQU4sIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihkcmFnUGFuIHx8IGRyYWdSb3RhdGUpKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBJTkNILCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4odG91Y2hab29tIHx8IHRvdWNoUm90YXRlKSk7XG4gICAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5UUklQTEVfUEFOLCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4odG91Y2hSb3RhdGUpKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLkRPVUJMRV9UQVAsIGlzSW50ZXJhY3RpdmUgJiYgQm9vbGVhbihkb3VibGVDbGlja1pvb20pKTtcbiAgICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLktFWUJPQVJELCBpc0ludGVyYWN0aXZlICYmIEJvb2xlYW4oa2V5Ym9hcmQpKTtcbiAgICAgIHRoaXMuc2Nyb2xsWm9vbSA9IHNjcm9sbFpvb207XG4gICAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgICAgdGhpcy5kcmFnUm90YXRlID0gZHJhZ1JvdGF0ZTtcbiAgICAgIHRoaXMuZG91YmxlQ2xpY2tab29tID0gZG91YmxlQ2xpY2tab29tO1xuICAgICAgdGhpcy50b3VjaFpvb20gPSB0b3VjaFpvb207XG4gICAgICB0aGlzLnRvdWNoUm90YXRlID0gdG91Y2hSb3RhdGU7XG4gICAgICB0aGlzLmtleWJvYXJkID0ga2V5Ym9hcmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFdmVudHMoZXZlbnROYW1lcywgZW5hYmxlZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlcikge1xuICAgICAgICBldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIGlmIChfdGhpczMuX2V2ZW50c1tldmVudE5hbWVdICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgICBfdGhpczMuX2V2ZW50c1tldmVudE5hbWVdID0gZW5hYmxlZDtcblxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmV2ZW50TWFuYWdlci5vbihldmVudE5hbWUsIF90aGlzMy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuZXZlbnRNYW5hZ2VyLm9mZihldmVudE5hbWUsIF90aGlzMy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB0aGlzLl9wYW5Sb3RhdGUgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB8fCBldmVudC5yaWdodEJ1dHRvbjtcbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMubWFwU3RhdGUucm90YXRlU3RhcnQoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSkgOiB0aGlzLm1hcFN0YXRlLnBhblN0YXJ0KHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGFuKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3BhblJvdGF0ZSA/IHRoaXMuX29uUGFuUm90YXRlKGV2ZW50KSA6IHRoaXMuX29uUGFuTW92ZShldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhbkVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcGFuUm90YXRlID8gdGhpcy5fb25QYW5Sb3RhdGVFbmQoZXZlbnQpIDogdGhpcy5fb25QYW5Nb3ZlRW5kKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5Nb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ1Bhbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNQYW5uaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QYW5Nb3ZlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhbk1vdmVFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdQYW4pIHtcbiAgICAgICAgdmFyIF90aGlzJGRyYWdQYW4kaW5lcnRpYSA9IHRoaXMuZHJhZ1Bhbi5pbmVydGlhLFxuICAgICAgICAgICAgaW5lcnRpYSA9IF90aGlzJGRyYWdQYW4kaW5lcnRpYSA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkZHJhZ1BhbiRpbmVydGlhO1xuXG4gICAgICAgIGlmIChpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5KSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSArIGV2ZW50LnZlbG9jaXR5WCAqIGluZXJ0aWEgLyAyLCBwb3NbMV0gKyBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgIHBvczogZW5kUG9zXG4gICAgICAgICAgfSkucGFuRW5kKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpLCB7fSwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhbm5pbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbkVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNQYW5uaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGFuUm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBhblJvdGF0ZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25QYW5Sb3RhdGVFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzJGRyYWdSb3RhdGUkaW5lciA9IHRoaXMuZHJhZ1JvdGF0ZS5pbmVydGlhLFxuICAgICAgICAgICAgaW5lcnRpYSA9IF90aGlzJGRyYWdSb3RhdGUkaW5lciA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkZHJhZ1JvdGF0ZSRpbmVyO1xuXG4gICAgICAgIGlmIChpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5KSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSArIGV2ZW50LnZlbG9jaXR5WCAqIGluZXJ0aWEgLyAyLCBwb3NbMV0gKyBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgICAgIHBvczogZW5kUG9zXG4gICAgICAgICAgfSkucm90YXRlRW5kKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgTElORUFSX1RSQU5TSVRJT05fUFJPUFMpLCB7fSwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc1JvdGF0aW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW5FbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25XaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25XaGVlbChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnNjcm9sbFpvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkc2Nyb2xsWm9vbSA9IHRoaXMuc2Nyb2xsWm9vbSxcbiAgICAgICAgICBfdGhpcyRzY3JvbGxab29tJHNwZWUgPSBfdGhpcyRzY3JvbGxab29tLnNwZWVkLFxuICAgICAgICAgIHNwZWVkID0gX3RoaXMkc2Nyb2xsWm9vbSRzcGVlID09PSB2b2lkIDAgPyAwLjAxIDogX3RoaXMkc2Nyb2xsWm9vbSRzcGVlLFxuICAgICAgICAgIF90aGlzJHNjcm9sbFpvb20kc21vbyA9IF90aGlzJHNjcm9sbFpvb20uc21vb3RoLFxuICAgICAgICAgIHNtb290aCA9IF90aGlzJHNjcm9sbFpvb20kc21vbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfdGhpcyRzY3JvbGxab29tJHNtb287XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHZhciBkZWx0YSA9IGV2ZW50LmRlbHRhO1xuICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhICogc3BlZWQpKSk7XG5cbiAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHtcbiAgICAgICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbSh7XG4gICAgICAgIHBvczogcG9zLFxuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgIGFyb3VuZDogcG9zXG4gICAgICAgIH0pLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IHNtb290aCA/IDI1MCA6IDFcbiAgICAgIH0pLCB7XG4gICAgICAgIGlzUGFubmluZzogdHJ1ZSxcbiAgICAgICAgaXNab29taW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25QaW5jaFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnpvb21TdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KS5yb3RhdGVTdGFydCh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXJ0UGluY2hSb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uO1xuICAgICAgdGhpcy5fbGFzdFBpbmNoRXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUGluY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUGluY2goZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMudG91Y2hab29tICYmICF0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZTtcblxuICAgICAgaWYgKHRoaXMudG91Y2hab29tKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGV2ZW50LnNjYWxlO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgICBuZXdNYXBTdGF0ZSA9IG5ld01hcFN0YXRlLnpvb20oe1xuICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG91Y2hSb3RhdGUpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gZXZlbnQucm90YXRpb247XG4gICAgICAgIG5ld01hcFN0YXRlID0gbmV3TWFwU3RhdGUucm90YXRlKHtcbiAgICAgICAgICBkZWx0YUFuZ2xlWDogdGhpcy5fc3RhcnRQaW5jaFJvdGF0aW9uIC0gcm90YXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgaXNQYW5uaW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgaXNab29taW5nOiBCb29sZWFuKHRoaXMudG91Y2hab29tKSxcbiAgICAgICAgaXNSb3RhdGluZzogQm9vbGVhbih0aGlzLnRvdWNoUm90YXRlKVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9sYXN0UGluY2hFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblBpbmNoRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBpbmNoRW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG91Y2hab29tKSB7XG4gICAgICAgIHZhciBfdGhpcyR0b3VjaFpvb20kaW5lcnQgPSB0aGlzLnRvdWNoWm9vbS5pbmVydGlhLFxuICAgICAgICAgICAgaW5lcnRpYSA9IF90aGlzJHRvdWNoWm9vbSRpbmVydCA9PT0gdm9pZCAwID8gREVGQVVMVF9JTkVSVElBIDogX3RoaXMkdG91Y2hab29tJGluZXJ0O1xuICAgICAgICB2YXIgX2xhc3RQaW5jaEV2ZW50ID0gdGhpcy5fbGFzdFBpbmNoRXZlbnQ7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgX2xhc3RQaW5jaEV2ZW50ICYmIGV2ZW50LnNjYWxlICE9PSBfbGFzdFBpbmNoRXZlbnQuc2NhbGUpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuXG4gICAgICAgICAgdmFyIF9uZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucm90YXRlRW5kKCk7XG5cbiAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nMihldmVudC5zY2FsZSk7XG5cbiAgICAgICAgICB2YXIgdmVsb2NpdHlaID0gKHogLSBNYXRoLmxvZzIoX2xhc3RQaW5jaEV2ZW50LnNjYWxlKSkgLyAoZXZlbnQuZGVsdGFUaW1lIC0gX2xhc3RQaW5jaEV2ZW50LmRlbHRhVGltZSk7XG5cbiAgICAgICAgICB2YXIgZW5kU2NhbGUgPSBNYXRoLnBvdygyLCB6ICsgdmVsb2NpdHlaICogaW5lcnRpYSAvIDIpO1xuICAgICAgICAgIF9uZXdNYXBTdGF0ZSA9IF9uZXdNYXBTdGF0ZS56b29tKHtcbiAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgc2NhbGU6IGVuZFNjYWxlXG4gICAgICAgICAgfSkuem9vbUVuZCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoX25ld01hcFN0YXRlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTKSwge30sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgICAgICBhcm91bmQ6IHBvc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFubmluZzogQm9vbGVhbih0aGlzLnRvdWNoWm9vbSksXG4gICAgICAgICAgICBpc1pvb21pbmc6IEJvb2xlYW4odGhpcy50b3VjaFpvb20pLFxuICAgICAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbUVuZCgpLnJvdGF0ZUVuZCgpO1xuICAgICAgdGhpcy5fc3RhdGUuc3RhcnRQaW5jaFJvdGF0aW9uID0gMDtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUGFubmluZzogZmFsc2UsXG4gICAgICAgIGlzWm9vbWluZzogZmFsc2UsXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N0YXJ0UGluY2hSb3RhdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0UGluY2hFdmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uVHJpcGxlUGFuU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZVN0YXJ0KHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25UcmlwbGVQYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uVHJpcGxlUGFuKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIHBvc1swXSAtPSBldmVudC5kZWx0YVg7XG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZSh7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgICAgaXNSb3RhdGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uVHJpcGxlUGFuRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRyaXBsZVBhbkVuZChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRvdWNoUm90YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyR0b3VjaFJvdGF0ZSRpbmUgPSB0aGlzLnRvdWNoUm90YXRlLmluZXJ0aWEsXG4gICAgICAgICAgICBpbmVydGlhID0gX3RoaXMkdG91Y2hSb3RhdGUkaW5lID09PSB2b2lkIDAgPyBERUZBVUxUX0lORVJUSUEgOiBfdGhpcyR0b3VjaFJvdGF0ZSRpbmU7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEgJiYgZXZlbnQudmVsb2NpdHlZKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gW3Bvc1swXSwgcG9zWzFdICs9IGV2ZW50LnZlbG9jaXR5WSAqIGluZXJ0aWEgLyAyXTtcblxuICAgICAgICAgIHZhciBfbmV3TWFwU3RhdGUyID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe1xuICAgICAgICAgICAgcG9zOiBlbmRQb3NcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoX25ld01hcFN0YXRlMiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyksIHt9LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUm90YXRpbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnJvdGF0ZUVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRvdWJsZVRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5kb3VibGVDbGlja1pvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgICAgdmFyIGlzWm9vbU91dCA9IHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpO1xuICAgICAgdmFyIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tKHtcbiAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgIHNjYWxlOiBpc1pvb21PdXQgPyAwLjUgOiAyXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIE9iamVjdC5hc3NpZ24oe30sIExJTkVBUl9UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3Ioe1xuICAgICAgICAgIGFyb3VuZDogcG9zXG4gICAgICAgIH0pXG4gICAgICB9KSwge1xuICAgICAgICBpc1pvb21pbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbktleURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmtleWJvYXJkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmNLZXkgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcbiAgICAgIHZhciBfdGhpcyRrZXlib2FyZCA9IHRoaXMua2V5Ym9hcmQsXG4gICAgICAgICAgX3RoaXMka2V5Ym9hcmQkem9vbVNwID0gX3RoaXMka2V5Ym9hcmQuem9vbVNwZWVkLFxuICAgICAgICAgIHpvb21TcGVlZCA9IF90aGlzJGtleWJvYXJkJHpvb21TcCA9PT0gdm9pZCAwID8gMiA6IF90aGlzJGtleWJvYXJkJHpvb21TcCxcbiAgICAgICAgICBfdGhpcyRrZXlib2FyZCRtb3ZlU3AgPSBfdGhpcyRrZXlib2FyZC5tb3ZlU3BlZWQsXG4gICAgICAgICAgbW92ZVNwZWVkID0gX3RoaXMka2V5Ym9hcmQkbW92ZVNwID09PSB2b2lkIDAgPyAxMDAgOiBfdGhpcyRrZXlib2FyZCRtb3ZlU3AsXG4gICAgICAgICAgX3RoaXMka2V5Ym9hcmQkcm90YXRlID0gX3RoaXMka2V5Ym9hcmQucm90YXRlU3BlZWRYLFxuICAgICAgICAgIHJvdGF0ZVNwZWVkWCA9IF90aGlzJGtleWJvYXJkJHJvdGF0ZSA9PT0gdm9pZCAwID8gMTUgOiBfdGhpcyRrZXlib2FyZCRyb3RhdGUsXG4gICAgICAgICAgX3RoaXMka2V5Ym9hcmQkcm90YXRlMiA9IF90aGlzJGtleWJvYXJkLnJvdGF0ZVNwZWVkWSxcbiAgICAgICAgICByb3RhdGVTcGVlZFkgPSBfdGhpcyRrZXlib2FyZCRyb3RhdGUyID09PSB2b2lkIDAgPyAxMCA6IF90aGlzJGtleWJvYXJkJHJvdGF0ZTI7XG4gICAgICB2YXIgbWFwU3RhdGVQcm9wcyA9IHRoaXMubWFwU3RhdGVQcm9wcztcbiAgICAgIHZhciBuZXdNYXBTdGF0ZTtcblxuICAgICAgc3dpdGNoIChldmVudC5zcmNFdmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTg5OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gLSBNYXRoLmxvZzIoem9vbVNwZWVkKSAtIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBtYXBTdGF0ZVByb3BzLnpvb20gLSBNYXRoLmxvZzIoem9vbVNwZWVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxODc6XG4gICAgICAgICAgaWYgKGZ1bmNLZXkpIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG1hcFN0YXRlUHJvcHMuem9vbSArIE1hdGgubG9nMih6b29tU3BlZWQpICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5nZXRNYXBTdGF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG1hcFN0YXRlUHJvcHMuem9vbSArIE1hdGgubG9nMih6b29tU3BlZWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBiZWFyaW5nOiBtYXBTdGF0ZVByb3BzLmJlYXJpbmcgLSByb3RhdGVTcGVlZFhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtcbiAgICAgICAgICAgICAgcG9zOiBbbW92ZVNwZWVkLCAwXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBpZiAoZnVuY0tleSkge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLmdldE1hcFN0YXRlKHtcbiAgICAgICAgICAgICAgYmVhcmluZzogbWFwU3RhdGVQcm9wcy5iZWFyaW5nICsgcm90YXRlU3BlZWRYXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWFwU3RhdGUgPSB0aGlzLm1hcFN0YXRlLnBhbih7XG4gICAgICAgICAgICAgIHBvczogWy1tb3ZlU3BlZWQsIDBdLFxuICAgICAgICAgICAgICBzdGFydFBvczogWzAsIDBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBwaXRjaDogbWFwU3RhdGVQcm9wcy5waXRjaCArIHJvdGF0ZVNwZWVkWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW4oe1xuICAgICAgICAgICAgICBwb3M6IFswLCBtb3ZlU3BlZWRdLFxuICAgICAgICAgICAgICBzdGFydFBvczogWzAsIDBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgICBuZXdNYXBTdGF0ZSA9IHRoaXMuZ2V0TWFwU3RhdGUoe1xuICAgICAgICAgICAgICBwaXRjaDogbWFwU3RhdGVQcm9wcy5waXRjaCAtIHJvdGF0ZVNwZWVkWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5wYW4oe1xuICAgICAgICAgICAgICBwb3M6IFswLCAtbW92ZVNwZWVkXSxcbiAgICAgICAgICAgICAgc3RhcnRQb3M6IFswLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcENvbnRyb2xsZXI7XG59KCk7XG5cbmV4cG9ydCB7IE1hcENvbnRyb2xsZXIgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VNZW1vLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgU3RhdGljTWFwLCB7IGdldFZpZXdwb3J0IH0gZnJvbSAnLi9zdGF0aWMtbWFwJztcbmltcG9ydCB7IE1BUEJPWF9MSU1JVFMgfSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuaW1wb3J0IFRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4uL3V0aWxzL3RyYW5zaXRpb24tbWFuYWdlcic7XG5pbXBvcnQgTWFwQ29udGV4dCwgeyBNYXBDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL21hcC1jb250ZXh0JztcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJ21qb2xuaXIuanMnO1xuaW1wb3J0IE1hcENvbnRyb2xsZXIgZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgeyBnZXRUZXJyYWluRWxldmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdGVycmFpbic7XG52YXIgcHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdGljTWFwLnByb3BUeXBlcywge1xuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uVmlld1N0YXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBQcm9wVHlwZXMub2JqZWN0LFxuICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0cmFuc2l0aW9uRWFzaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRyYW5zaXRpb25JbnRlcnJ1cHQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRyYW5zaXRpb25FbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkcmFnUGFuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkcmFnUm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICB0b3VjaFpvb206IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIHRvdWNoUm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBrZXlib2FyZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgb25Ib3ZlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRibENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Db250ZXh0TWVudTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlVXA6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblRvdWNoTW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVG91Y2hFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlT3V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25XaGVlbDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvdWNoQWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBldmVudFJlY29nbml6ZXJPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGlja1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcbiAgaW50ZXJhY3RpdmVMYXllcklkczogUHJvcFR5cGVzLmFycmF5LFxuICBnZXRDdXJzb3I6IFByb3BUeXBlcy5mdW5jLFxuICBjb250cm9sbGVyOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNYXBDb250cm9sbGVyKVxufSk7XG5cbnZhciBnZXREZWZhdWx0Q3Vyc29yID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEN1cnNvcihfcmVmKSB7XG4gIHZhciBpc0RyYWdnaW5nID0gX3JlZi5pc0RyYWdnaW5nLFxuICAgICAgaXNIb3ZlcmluZyA9IF9yZWYuaXNIb3ZlcmluZztcbiAgcmV0dXJuIGlzRHJhZ2dpbmcgPyAnZ3JhYmJpbmcnIDogaXNIb3ZlcmluZyA/ICdwb2ludGVyJyA6ICdncmFiJztcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0aWNNYXAuZGVmYXVsdFByb3BzLCBNQVBCT1hfTElNSVRTLCBUcmFuc2l0aW9uTWFuYWdlci5kZWZhdWx0UHJvcHMsIHtcbiAgb25WaWV3U3RhdGVDaGFuZ2U6IG51bGwsXG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG4gIG9uQ2xpY2s6IG51bGwsXG4gIG9uTmF0aXZlQ2xpY2s6IG51bGwsXG4gIG9uSG92ZXI6IG51bGwsXG4gIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSxcbiAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgZHJhZ1BhbjogdHJ1ZSxcbiAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICB0b3VjaFpvb206IHRydWUsXG4gIHRvdWNoUm90YXRlOiBmYWxzZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGV2ZW50UmVjb2duaXplck9wdGlvbnM6IHt9LFxuICBjbGlja1JhZGl1czogMCxcbiAgZ2V0Q3Vyc29yOiBnZXREZWZhdWx0Q3Vyc29yXG59KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmxuZ0xhdCB8fCAhZXZlbnQub2Zmc2V0Q2VudGVyKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgdmFyIF9ldmVudCRvZmZzZXRDZW50ZXIgPSBldmVudC5vZmZzZXRDZW50ZXIsXG4gICAgICB4ID0gX2V2ZW50JG9mZnNldENlbnRlci54LFxuICAgICAgeSA9IF9ldmVudCRvZmZzZXRDZW50ZXIueTtcblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgdmFyIHBvcyA9IFt4LCB5XTtcbiAgZXZlbnQucG9pbnQgPSBwb3M7XG4gIHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG4gIHZhciBsb2NhdGlvbiA9IHZpZXdwb3J0LnVucHJvamVjdChwb3MsIHtcbiAgICB0YXJnZXRaOiB2aWV3cG9ydC5tZXRlck9mZnNldFsyXVxuICB9KTtcbiAgZXZlbnQubG5nTGF0ID0gW2xvY2F0aW9uWzBdLCBsb2NhdGlvblsxXV07XG4gIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0RmVhdHVyZXMocG9zKSB7XG4gIHZhciBtYXAgPSB0aGlzLm1hcDtcblxuICBpZiAoIW1hcCB8fCAhcG9zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcXVlcnlQYXJhbXMgPSB7fTtcbiAgdmFyIHNpemUgPSB0aGlzLnByb3BzLmNsaWNrUmFkaXVzO1xuXG4gIGlmICh0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHMpIHtcbiAgICBxdWVyeVBhcmFtcy5sYXllcnMgPSB0aGlzLnByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHM7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHNpemUgPyBbW3Bvc1swXSAtIHNpemUsIHBvc1sxXSArIHNpemVdLCBbcG9zWzBdICsgc2l6ZSwgcG9zWzFdIC0gc2l6ZV1dIDogcG9zLCBxdWVyeVBhcmFtcyk7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkV2ZW50KGNhbGxiYWNrTmFtZSwgZXZlbnQpIHtcbiAgdmFyIGZ1bmMgPSB0aGlzLnByb3BzW2NhbGxiYWNrTmFtZV07XG5cbiAgaWYgKGZ1bmMpIHtcbiAgICBmdW5jKG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gIG9uRXZlbnQuY2FsbCh0aGlzLCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/ICdvblRvdWNoU3RhcnQnIDogJ29uTW91c2VEb3duJywgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICBvbkV2ZW50LmNhbGwodGhpcywgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyAnb25Ub3VjaEVuZCcgOiAnb25Nb3VzZVVwJywgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gIG9uRXZlbnQuY2FsbCh0aGlzLCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/ICdvblRvdWNoTW92ZScgOiAnb25Nb3VzZU1vdmUnLCBldmVudCk7XG5cbiAgaWYgKCF0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvbkhvdmVyID0gX3RoaXMkcHJvcHMub25Ib3ZlcixcbiAgICAgICAgaW50ZXJhY3RpdmVMYXllcklkcyA9IF90aGlzJHByb3BzLmludGVyYWN0aXZlTGF5ZXJJZHM7XG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICBpZiAoaW50ZXJhY3RpdmVMYXllcklkcyB8fCBvbkhvdmVyKSB7XG4gICAgICBmZWF0dXJlcyA9IGdldEZlYXR1cmVzLmNhbGwodGhpcywgZXZlbnQucG9pbnQpO1xuICAgIH1cblxuICAgIHZhciBpc0hvdmVyaW5nID0gQm9vbGVhbihpbnRlcmFjdGl2ZUxheWVySWRzICYmIGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aCA+IDApO1xuICAgIHZhciBpc0VudGVyaW5nID0gaXNIb3ZlcmluZyAmJiAhdGhpcy5zdGF0ZS5pc0hvdmVyaW5nO1xuICAgIHZhciBpc0V4aXRpbmcgPSAhaXNIb3ZlcmluZyAmJiB0aGlzLnN0YXRlLmlzSG92ZXJpbmc7XG5cbiAgICBpZiAob25Ib3ZlciB8fCBpc0VudGVyaW5nKSB7XG4gICAgICBldmVudC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgICBpZiAob25Ib3Zlcikge1xuICAgICAgICBvbkhvdmVyKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFbnRlcmluZykge1xuICAgICAgb25FdmVudC5jYWxsKHRoaXMsICdvbk1vdXNlRW50ZXInLCBldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRXhpdGluZykge1xuICAgICAgb25FdmVudC5jYWxsKHRoaXMsICdvbk1vdXNlTGVhdmUnLCBldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRW50ZXJpbmcgfHwgaXNFeGl0aW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNIb3ZlcmluZzogaXNIb3ZlcmluZ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUG9pbnRlckNsaWNrKGV2ZW50KSB7XG4gIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgb25DbGljayA9IF90aGlzJHByb3BzMi5vbkNsaWNrLFxuICAgICAgb25OYXRpdmVDbGljayA9IF90aGlzJHByb3BzMi5vbk5hdGl2ZUNsaWNrLFxuICAgICAgb25EYmxDbGljayA9IF90aGlzJHByb3BzMi5vbkRibENsaWNrLFxuICAgICAgZG91YmxlQ2xpY2tab29tID0gX3RoaXMkcHJvcHMyLmRvdWJsZUNsaWNrWm9vbTtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgaXNEb3VibGVDbGlja0VuYWJsZWQgPSBvbkRibENsaWNrIHx8IGRvdWJsZUNsaWNrWm9vbTtcblxuICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdhbnljbGljayc6XG4gICAgICBjYWxsYmFja3MucHVzaChvbk5hdGl2ZUNsaWNrKTtcblxuICAgICAgaWYgKCFpc0RvdWJsZUNsaWNrRW5hYmxlZCkge1xuICAgICAgICBjYWxsYmFja3MucHVzaChvbkNsaWNrKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjbGljayc6XG4gICAgICBpZiAoaXNEb3VibGVDbGlja0VuYWJsZWQpIHtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2gob25DbGljayk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgfVxuXG4gIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5maWx0ZXIoQm9vbGVhbik7XG5cbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGV2ZW50LmZlYXR1cmVzID0gZ2V0RmVhdHVyZXMuY2FsbCh0aGlzLCBldmVudC5wb2ludCk7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICByZXR1cm4gY2IoZXZlbnQpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlZkhhbmRsZXMoc3RhdGljTWFwUmVmKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0TWFwOiBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5nZXRNYXAsXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBzdGF0aWNNYXBSZWYuY3VycmVudCAmJiBzdGF0aWNNYXBSZWYuY3VycmVudC5xdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgfTtcbn1cblxudmFyIEludGVyYWN0aXZlTWFwID0gZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgcGFyZW50Q29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBjb250cm9sbGVyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzLmNvbnRyb2xsZXIgfHwgbmV3IE1hcENvbnRyb2xsZXIoKTtcbiAgfSwgW10pO1xuICB2YXIgZXZlbnRNYW5hZ2VyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudE1hbmFnZXIobnVsbCwge1xuICAgICAgdG91Y2hBY3Rpb246IHByb3BzLnRvdWNoQWN0aW9uLFxuICAgICAgcmVjb2duaXplck9wdGlvbnM6IHByb3BzLmV2ZW50UmVjb2duaXplck9wdGlvbnNcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgZXZlbnRDYW52YXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBzdGF0aWNNYXBSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdmFyIF90aGlzUmVmID0gdXNlUmVmKHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgc3RhdGU6IHtcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0aGlzUmVmID0gX3RoaXNSZWYuY3VycmVudDtcbiAgdGhpc1JlZi5wcm9wcyA9IHByb3BzO1xuICB0aGlzUmVmLm1hcCA9IHN0YXRpY01hcFJlZi5jdXJyZW50ICYmIHN0YXRpY01hcFJlZi5jdXJyZW50LmdldE1hcCgpO1xuXG4gIHRoaXNSZWYuc2V0U3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICB0aGlzUmVmLnN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzUmVmLnN0YXRlKSwgbmV3U3RhdGUpO1xuICAgIGV2ZW50Q2FudmFzUmVmLmN1cnJlbnQuc3R5bGUuY3Vyc29yID0gcHJvcHMuZ2V0Q3Vyc29yKHRoaXNSZWYuc3RhdGUpO1xuICB9O1xuXG4gIHZhciBpblJlbmRlciA9IHRydWU7XG4gIHZhciB2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZDtcbiAgdmFyIHN0YXRlVXBkYXRlUmVxdWVzdGVkO1xuXG4gIHZhciBoYW5kbGVWaWV3cG9ydENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVZpZXdwb3J0Q2hhbmdlKHZpZXdTdGF0ZSwgaW50ZXJhY3Rpb25TdGF0ZSwgb2xkVmlld1N0YXRlKSB7XG4gICAgaWYgKGluUmVuZGVyKSB7XG4gICAgICB2aWV3cG9ydFVwZGF0ZVJlcXVlc3RlZCA9IFt2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF90aGlzUmVmJHByb3BzID0gdGhpc1JlZi5wcm9wcyxcbiAgICAgICAgb25WaWV3U3RhdGVDaGFuZ2UgPSBfdGhpc1JlZiRwcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZSA9IF90aGlzUmVmJHByb3BzLm9uVmlld3BvcnRDaGFuZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpZXdTdGF0ZSwgJ3Bvc2l0aW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgZ2V0VGVycmFpbkVsZXZhdGlvbih0aGlzUmVmLm1hcCwgdmlld1N0YXRlKV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAob25WaWV3U3RhdGVDaGFuZ2UpIHtcbiAgICAgIG9uVmlld1N0YXRlQ2hhbmdlKHtcbiAgICAgICAgdmlld1N0YXRlOiB2aWV3U3RhdGUsXG4gICAgICAgIGludGVyYWN0aW9uU3RhdGU6IGludGVyYWN0aW9uU3RhdGUsXG4gICAgICAgIG9sZFZpZXdTdGF0ZTogb2xkVmlld1N0YXRlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob25WaWV3cG9ydENoYW5nZSkge1xuICAgICAgb25WaWV3cG9ydENoYW5nZSh2aWV3U3RhdGUsIGludGVyYWN0aW9uU3RhdGUsIG9sZFZpZXdTdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlZkhhbmRsZXMoc3RhdGljTWFwUmVmKTtcbiAgfSwgW10pO1xuICB2YXIgY29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudENvbnRleHQpLCB7fSwge1xuICAgICAgZXZlbnRNYW5hZ2VyOiBldmVudE1hbmFnZXIsXG4gICAgICBjb250YWluZXI6IHBhcmVudENvbnRleHQuY29udGFpbmVyIHx8IGV2ZW50Q2FudmFzUmVmLmN1cnJlbnRcbiAgICB9KTtcbiAgfSwgW3BhcmVudENvbnRleHQsIGV2ZW50Q2FudmFzUmVmLmN1cnJlbnRdKTtcbiAgY29udGV4dC5vblZpZXdwb3J0Q2hhbmdlID0gaGFuZGxlVmlld3BvcnRDaGFuZ2U7XG4gIGNvbnRleHQudmlld3BvcnQgPSBwYXJlbnRDb250ZXh0LnZpZXdwb3J0IHx8IGdldFZpZXdwb3J0KHRoaXNSZWYpO1xuICB0aGlzUmVmLnZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydDtcblxuICB2YXIgaGFuZGxlSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUludGVyYWN0aW9uU3RhdGVDaGFuZ2UoaW50ZXJhY3Rpb25TdGF0ZSkge1xuICAgIHZhciBfaW50ZXJhY3Rpb25TdGF0ZSRpc0QgPSBpbnRlcmFjdGlvblN0YXRlLmlzRHJhZ2dpbmcsXG4gICAgICAgIGlzRHJhZ2dpbmcgPSBfaW50ZXJhY3Rpb25TdGF0ZSRpc0QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2ludGVyYWN0aW9uU3RhdGUkaXNEO1xuXG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXNSZWYuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpc1JlZi5zZXRTdGF0ZSh7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpblJlbmRlcikge1xuICAgICAgc3RhdGVVcGRhdGVSZXF1ZXN0ZWQgPSBpbnRlcmFjdGlvblN0YXRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzUmVmLnByb3BzLm9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTtcblxuICAgIGlmIChvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZShpbnRlcmFjdGlvblN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUNvbnRyb2xsZXJPcHRzID0gZnVuY3Rpb24gdXBkYXRlQ29udHJvbGxlck9wdHMoKSB7XG4gICAgaWYgKHRoaXNSZWYud2lkdGggJiYgdGhpc1JlZi5oZWlnaHQpIHtcbiAgICAgIGNvbnRyb2xsZXIuc2V0T3B0aW9ucyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpc1JlZi5wcm9wcyksIHRoaXNSZWYucHJvcHMudmlld1N0YXRlKSwge30sIHtcbiAgICAgICAgaXNJbnRlcmFjdGl2ZTogQm9vbGVhbih0aGlzUmVmLnByb3BzLm9uVmlld1N0YXRlQ2hhbmdlIHx8IHRoaXNSZWYucHJvcHMub25WaWV3cG9ydENoYW5nZSksXG4gICAgICAgIG9uVmlld3BvcnRDaGFuZ2U6IGhhbmRsZVZpZXdwb3J0Q2hhbmdlLFxuICAgICAgICBvblN0YXRlQ2hhbmdlOiBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlLFxuICAgICAgICBldmVudE1hbmFnZXI6IGV2ZW50TWFuYWdlcixcbiAgICAgICAgd2lkdGg6IHRoaXNSZWYud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpc1JlZi5oZWlnaHRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHRoaXNSZWYud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzUmVmLmhlaWdodCA9IGhlaWdodDtcbiAgICB1cGRhdGVDb250cm9sbGVyT3B0cygpO1xuICAgIHRoaXNSZWYucHJvcHMub25SZXNpemUoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50TWFuYWdlci5zZXRFbGVtZW50KGV2ZW50Q2FudmFzUmVmLmN1cnJlbnQpO1xuICAgIGV2ZW50TWFuYWdlci5vbih7XG4gICAgICBwb2ludGVyZG93bjogb25Qb2ludGVyRG93bi5iaW5kKHRoaXNSZWYpLFxuICAgICAgcG9pbnRlcm1vdmU6IG9uUG9pbnRlck1vdmUuYmluZCh0aGlzUmVmKSxcbiAgICAgIHBvaW50ZXJ1cDogb25Qb2ludGVyVXAuYmluZCh0aGlzUmVmKSxcbiAgICAgIHBvaW50ZXJsZWF2ZTogb25FdmVudC5iaW5kKHRoaXNSZWYsICdvbk1vdXNlT3V0JyksXG4gICAgICBjbGljazogb25Qb2ludGVyQ2xpY2suYmluZCh0aGlzUmVmKSxcbiAgICAgIGFueWNsaWNrOiBvblBvaW50ZXJDbGljay5iaW5kKHRoaXNSZWYpLFxuICAgICAgZGJsY2xpY2s6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25EYmxDbGljaycpLFxuICAgICAgd2hlZWw6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25XaGVlbCcpLFxuICAgICAgY29udGV4dG1lbnU6IG9uRXZlbnQuYmluZCh0aGlzUmVmLCAnb25Db250ZXh0TWVudScpXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmlld3BvcnRVcGRhdGVSZXF1ZXN0ZWQpIHtcbiAgICAgIGhhbmRsZVZpZXdwb3J0Q2hhbmdlLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KHZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkKSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlVXBkYXRlUmVxdWVzdGVkKSB7XG4gICAgICBoYW5kbGVJbnRlcmFjdGlvblN0YXRlQ2hhbmdlKHN0YXRlVXBkYXRlUmVxdWVzdGVkKTtcbiAgICB9XG4gIH0pO1xuICB1cGRhdGVDb250cm9sbGVyT3B0cygpO1xuICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBnZXRDdXJzb3IgPSBwcm9wcy5nZXRDdXJzb3I7XG4gIHZhciBldmVudENhbnZhc1N0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0sIHN0eWxlKSwge30sIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpc1JlZi5zdGF0ZSlcbiAgICB9KTtcbiAgfSwgW3N0eWxlLCB3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3IsIHRoaXNSZWYuc3RhdGVdKTtcblxuICBpZiAoIXZpZXdwb3J0VXBkYXRlUmVxdWVzdGVkIHx8ICF0aGlzUmVmLl9jaGlsZCkge1xuICAgIHRoaXNSZWYuX2NoaWxkID0gUmVhY3QuY3JlYXRlRWxlbWVudChNYXBDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBrZXk6IFwiZXZlbnQtY2FudmFzXCIsXG4gICAgICByZWY6IGV2ZW50Q2FudmFzUmVmLFxuICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRpY01hcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgc3R5bGU6IG51bGwsXG4gICAgICBvblJlc2l6ZTogb25SZXNpemUsXG4gICAgICByZWY6IHN0YXRpY01hcFJlZlxuICAgIH0pKSkpO1xuICB9XG5cbiAgaW5SZW5kZXIgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXNSZWYuX2NoaWxkO1xufSk7XG5JbnRlcmFjdGl2ZU1hcC5zdXBwb3J0ZWQgPSBTdGF0aWNNYXAuc3VwcG9ydGVkO1xuSW50ZXJhY3RpdmVNYXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuSW50ZXJhY3RpdmVNYXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgSW50ZXJhY3RpdmVNYXA7IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbnZhciBzb3VyY2VDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlU291cmNlKG1hcCwgaWQsIHByb3BzKSB7XG4gIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIHByb3BzKTtcblxuICAgIGRlbGV0ZSBvcHRpb25zLmlkO1xuICAgIGRlbGV0ZSBvcHRpb25zLmNoaWxkcmVuO1xuICAgIG1hcC5hZGRTb3VyY2UoaWQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBtYXAuZ2V0U291cmNlKGlkKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTb3VyY2Uoc291cmNlLCBwcm9wcywgcHJldlByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5pZCA9PT0gcHJldlByb3BzLmlkLCAnc291cmNlIGlkIGNoYW5nZWQnKTtcbiAgYXNzZXJ0KHByb3BzLnR5cGUgPT09IHByZXZQcm9wcy50eXBlLCAnc291cmNlIHR5cGUgY2hhbmdlZCcpO1xuICB2YXIgY2hhbmdlZEtleSA9ICcnO1xuICB2YXIgY2hhbmdlZEtleUNvdW50ID0gMDtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2lkJyAmJiAhZGVlcEVxdWFsKHByZXZQcm9wc1trZXldLCBwcm9wc1trZXldKSkge1xuICAgICAgY2hhbmdlZEtleSA9IGtleTtcbiAgICAgIGNoYW5nZWRLZXlDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY2hhbmdlZEtleUNvdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuXG4gIGlmICh0eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICBzb3VyY2Uuc2V0RGF0YShwcm9wcy5kYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgc291cmNlLnVwZGF0ZUltYWdlKHtcbiAgICAgIHVybDogcHJvcHMudXJsLFxuICAgICAgY29vcmRpbmF0ZXM6IHByb3BzLmNvb3JkaW5hdGVzXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoKHR5cGUgPT09ICdjYW52YXMnIHx8IHR5cGUgPT09ICd2aWRlbycpICYmIGNoYW5nZWRLZXlDb3VudCA9PT0gMSAmJiBjaGFuZ2VkS2V5ID09PSAnY29vcmRpbmF0ZXMnKSB7XG4gICAgc291cmNlLnNldENvb3JkaW5hdGVzKHByb3BzLmNvb3JkaW5hdGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndmVjdG9yJyAmJiBzb3VyY2Uuc2V0VXJsKSB7XG4gICAgc3dpdGNoIChjaGFuZ2VkS2V5KSB7XG4gICAgICBjYXNlICd1cmwnOlxuICAgICAgICBzb3VyY2Uuc2V0VXJsKHByb3BzLnVybCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aWxlcyc6XG4gICAgICAgIHNvdXJjZS5zZXRUaWxlcyhwcm9wcy50aWxlcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gdXBkYXRlIDxTb3VyY2U+IHByb3A6IFwiLmNvbmNhdChjaGFuZ2VkS2V5KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gU291cmNlKHByb3BzKSB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFyIHByb3BzUmVmID0gdXNlUmVmKHtcbiAgICBpZDogcHJvcHMuaWQsXG4gICAgdHlwZTogcHJvcHMudHlwZVxuICB9KTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoMCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNldFN0eWxlTG9hZGVkID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgaWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvcHMuaWQgfHwgXCJqc3gtc291cmNlLVwiLmNvbmNhdChzb3VyY2VDb3VudGVyKyspO1xuICB9LCBbXSk7XG4gIHZhciBtYXAgPSBjb250ZXh0Lm1hcDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWFwKSB7XG4gICAgICB2YXIgZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNldFN0eWxlTG9hZGVkKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb24gKyAxO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG1hcC5vbignc3R5bGVkYXRhJywgZm9yY2VVcGRhdGUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFwLm9mZignc3R5bGVkYXRhJywgZm9yY2VVcGRhdGUpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChtYXAuc3R5bGUgJiYgbWFwLnN0eWxlLl9sb2FkZWQgJiYgbWFwLmdldFNvdXJjZShpZCkpIHtcbiAgICAgICAgICAgIG1hcC5yZW1vdmVTb3VyY2UoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFttYXAsIGlkXSk7XG4gIHZhciBzb3VyY2UgPSBtYXAgJiYgbWFwLnN0eWxlICYmIG1hcC5nZXRTb3VyY2UoaWQpO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICB1cGRhdGVTb3VyY2Uoc291cmNlLCBwcm9wcywgcHJvcHNSZWYuY3VycmVudCk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gY3JlYXRlU291cmNlKG1hcCwgaWQsIHByb3BzKTtcbiAgfVxuXG4gIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgcmV0dXJuIHNvdXJjZSAmJiBSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZCAmJiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHNvdXJjZTogaWRcbiAgICB9KTtcbiAgfSkgfHwgbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCIuL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghYSB8fCAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGIpIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihiKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMCwgX2FLZXlzID0gYUtleXM7IF9pIDwgX2FLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGtleSA9IF9hS2V5c1tfaV07XG5cbiAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNYXBDb250ZXh0IGZyb20gJy4vbWFwLWNvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwLWVxdWFsJztcbnZhciBMQVlFUl9UWVBFUyA9IFsnZmlsbCcsICdsaW5lJywgJ3N5bWJvbCcsICdjaXJjbGUnLCAnZmlsbC1leHRydXNpb24nLCAncmFzdGVyJywgJ2JhY2tncm91bmQnLCAnaGVhdG1hcCcsICdoaWxsc2hhZGUnLCAnc2t5J107XG52YXIgcHJvcFR5cGVzID0ge1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoTEFZRVJfVFlQRVMpLmlzUmVxdWlyZWQsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzb3VyY2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGJlZm9yZUlkOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5mdW5jdGlvbiBkaWZmTGF5ZXJTdHlsZXMobWFwLCBpZCwgcHJvcHMsIHByZXZQcm9wcykge1xuICB2YXIgX3Byb3BzJGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICAgIGxheW91dCA9IF9wcm9wcyRsYXlvdXQgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJGxheW91dCxcbiAgICAgIF9wcm9wcyRwYWludCA9IHByb3BzLnBhaW50LFxuICAgICAgcGFpbnQgPSBfcHJvcHMkcGFpbnQgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHBhaW50LFxuICAgICAgZmlsdGVyID0gcHJvcHMuZmlsdGVyLFxuICAgICAgbWluem9vbSA9IHByb3BzLm1pbnpvb20sXG4gICAgICBtYXh6b29tID0gcHJvcHMubWF4em9vbSxcbiAgICAgIGJlZm9yZUlkID0gcHJvcHMuYmVmb3JlSWQsXG4gICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJsYXlvdXRcIiwgXCJwYWludFwiLCBcImZpbHRlclwiLCBcIm1pbnpvb21cIiwgXCJtYXh6b29tXCIsIFwiYmVmb3JlSWRcIl0pO1xuXG4gIGlmIChiZWZvcmVJZCAhPT0gcHJldlByb3BzLmJlZm9yZUlkKSB7XG4gICAgbWFwLm1vdmVMYXllcihpZCwgYmVmb3JlSWQpO1xuICB9XG5cbiAgaWYgKGxheW91dCAhPT0gcHJldlByb3BzLmxheW91dCkge1xuICAgIHZhciBwcmV2TGF5b3V0ID0gcHJldlByb3BzLmxheW91dCB8fCB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBsYXlvdXQpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGxheW91dFtrZXldLCBwcmV2TGF5b3V0W2tleV0pKSB7XG4gICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShpZCwga2V5LCBsYXlvdXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2tleSBpbiBwcmV2TGF5b3V0KSB7XG4gICAgICBpZiAoIWxheW91dC5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoaWQsIF9rZXksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhaW50ICE9PSBwcmV2UHJvcHMucGFpbnQpIHtcbiAgICB2YXIgcHJldlBhaW50ID0gcHJldlByb3BzLnBhaW50IHx8IHt9O1xuXG4gICAgZm9yICh2YXIgX2tleTIgaW4gcGFpbnQpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKHBhaW50W19rZXkyXSwgcHJldlBhaW50W19rZXkyXSkpIHtcbiAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIF9rZXkyLCBwYWludFtfa2V5Ml0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rZXkzIGluIHByZXZQYWludCkge1xuICAgICAgaWYgKCFwYWludC5oYXNPd25Qcm9wZXJ0eShfa2V5MykpIHtcbiAgICAgICAgbWFwLnNldFBhaW50UHJvcGVydHkoaWQsIF9rZXkzLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghZGVlcEVxdWFsKGZpbHRlciwgcHJldlByb3BzLmZpbHRlcikpIHtcbiAgICBtYXAuc2V0RmlsdGVyKGlkLCBmaWx0ZXIpO1xuICB9XG5cbiAgaWYgKG1pbnpvb20gIT09IHByZXZQcm9wcy5taW56b29tIHx8IG1heHpvb20gIT09IHByZXZQcm9wcy5tYXh6b29tKSB7XG4gICAgbWFwLnNldExheWVyWm9vbVJhbmdlKGlkLCBtaW56b29tLCBtYXh6b29tKTtcbiAgfVxuXG4gIGZvciAodmFyIF9rZXk0IGluIG90aGVyUHJvcHMpIHtcbiAgICBpZiAoIWRlZXBFcXVhbChvdGhlclByb3BzW19rZXk0XSwgcHJldlByb3BzW19rZXk0XSkpIHtcbiAgICAgIG1hcC5zZXRMYXllclByb3BlcnR5KGlkLCBfa2V5NCwgb3RoZXJQcm9wc1tfa2V5NF0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMYXllcihtYXAsIGlkLCBwcm9wcykge1xuICBpZiAobWFwLnN0eWxlICYmIG1hcC5zdHlsZS5fbG9hZGVkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgIGlkOiBpZFxuICAgIH0pO1xuXG4gICAgZGVsZXRlIG9wdGlvbnMuYmVmb3JlSWQ7XG4gICAgbWFwLmFkZExheWVyKG9wdGlvbnMsIHByb3BzLmJlZm9yZUlkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXllcihtYXAsIGlkLCBwcm9wcywgcHJldlByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5pZCA9PT0gcHJldlByb3BzLmlkLCAnbGF5ZXIgaWQgY2hhbmdlZCcpO1xuICBhc3NlcnQocHJvcHMudHlwZSA9PT0gcHJldlByb3BzLnR5cGUsICdsYXllciB0eXBlIGNoYW5nZWQnKTtcblxuICB0cnkge1xuICAgIGRpZmZMYXllclN0eWxlcyhtYXAsIGlkLCBwcm9wcywgcHJldlByb3BzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICB9XG59XG5cbnZhciBsYXllckNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBMYXllcihwcm9wcykge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBwcm9wc1JlZiA9IHVzZVJlZih7XG4gICAgaWQ6IHByb3BzLmlkLFxuICAgIHR5cGU6IHByb3BzLnR5cGVcbiAgfSk7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKDApLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBzZXRTdHlsZUxvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzLmlkIHx8IFwianN4LWxheWVyLVwiLmNvbmNhdChsYXllckNvdW50ZXIrKyk7XG4gIH0sIFtdKTtcbiAgdmFyIG1hcCA9IGNvbnRleHQubWFwO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtYXApIHtcbiAgICAgIHZhciBmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gc2V0U3R5bGVMb2FkZWQoZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbWFwLm9uKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXAub2ZmKCdzdHlsZWRhdGEnLCBmb3JjZVVwZGF0ZSk7XG5cbiAgICAgICAgaWYgKG1hcC5zdHlsZSAmJiBtYXAuc3R5bGUuX2xvYWRlZCkge1xuICAgICAgICAgIG1hcC5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW21hcF0pO1xuICB2YXIgbGF5ZXIgPSBtYXAgJiYgbWFwLnN0eWxlICYmIG1hcC5nZXRMYXllcihpZCk7XG5cbiAgaWYgKGxheWVyKSB7XG4gICAgdXBkYXRlTGF5ZXIobWFwLCBpZCwgcHJvcHMsIHByb3BzUmVmLmN1cnJlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNyZWF0ZUxheWVyKG1hcCwgaWQsIHByb3BzKTtcbiAgfVxuXG4gIHByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgcmV0dXJuIG51bGw7XG59XG5cbkxheWVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbmV4cG9ydCBkZWZhdWx0IExheWVyOyIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE1hcENvbnRleHQgZnJvbSAnLi9tYXAtY29udGV4dCc7XG5leHBvcnQgdmFyIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogdHJ1ZSxcbiAgY2FwdHVyZUNsaWNrOiB0cnVlLFxuICBjYXB0dXJlRG91YmxlQ2xpY2s6IHRydWUsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5leHBvcnQgdmFyIG1hcENvbnRyb2xQcm9wVHlwZXMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0dXJlRHJhZzogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVDbGljazogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVEb3VibGVDbGljazogUHJvcFR5cGVzLmJvb2wsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmZ1bmN0aW9uIG9uTW91bnQodGhpc1JlZikge1xuICB2YXIgcmVmID0gdGhpc1JlZi5jb250YWluZXJSZWYuY3VycmVudDtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG5cbiAgaWYgKCFyZWYgfHwgIWV2ZW50TWFuYWdlcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlU2Nyb2xsKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm9uU2Nyb2xsKSB7XG4gICAgICAgIHByb3BzLm9uU2Nyb2xsKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYW5zdGFydDogZnVuY3Rpb24gcGFuc3RhcnQoZXZ0KSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzUmVmLnByb3BzO1xuXG4gICAgICBpZiAocHJvcHMuY2FwdHVyZURyYWcpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25EcmFnU3RhcnQpIHtcbiAgICAgICAgcHJvcHMub25EcmFnU3RhcnQoZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFueWNsaWNrOiBmdW5jdGlvbiBhbnljbGljayhldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlQ2xpY2spIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICBwcm9wcy5vbkNsaWNrKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZ0KSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzUmVmLnByb3BzO1xuXG4gICAgICBpZiAocHJvcHMuY2FwdHVyZUNsaWNrKSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgcHJvcHMub25DbGljayhldnQsIHRoaXNSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGJsY2xpY2s6IGZ1bmN0aW9uIGRibGNsaWNrKGV2dCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpc1JlZi5wcm9wcztcblxuICAgICAgaWYgKHByb3BzLmNhcHR1cmVEb3VibGVDbGljaykge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5vbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgIHByb3BzLm9uRG91YmxlQ2xpY2soZXZ0LCB0aGlzUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiBwb2ludGVybW92ZShldnQpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXNSZWYucHJvcHM7XG5cbiAgICAgIGlmIChwcm9wcy5jYXB0dXJlUG9pbnRlck1vdmUpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25Qb2ludGVyTW92ZSkge1xuICAgICAgICBwcm9wcy5vblBvaW50ZXJNb3ZlKGV2dCwgdGhpc1JlZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBldmVudE1hbmFnZXIud2F0Y2goZXZlbnRzLCByZWYpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50TWFuYWdlci5vZmYoZXZlbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTWFwQ29udHJvbCgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdGhpc1JlZiA9IHVzZVJlZih7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHN0YXRlOiB7fSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmXG4gIH0pO1xuXG4gIHZhciB0aGlzUmVmID0gX3RoaXNSZWYuY3VycmVudDtcbiAgdGhpc1JlZi5wcm9wcyA9IHByb3BzO1xuICB0aGlzUmVmLmNvbnRleHQgPSBjb250ZXh0O1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvbk1vdW50KHRoaXNSZWYpO1xuICB9LCBbY29udGV4dC5ldmVudE1hbmFnZXJdKTtcbiAgcmV0dXJuIHRoaXNSZWY7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQdXJlQ29tcG9uZW50LCBjcmVhdGVSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuXG5mdW5jdGlvbiBDb250cm9sKHByb3BzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHByb3BzLmluc3RhbmNlO1xuXG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgaW5zdGFuY2UuX2NvbnRleHQgPSBjb250ZXh0O1xuICBpbnN0YW5jZS5fY29udGFpbmVyUmVmID0gY29udGFpbmVyUmVmO1xuICByZXR1cm4gaW5zdGFuY2UuX3JlbmRlcigpO1xufVxuXG52YXIgQmFzZUNvbnRyb2wgPSBmdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJhc2VDb250cm9sLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCYXNlQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gQmFzZUNvbnRyb2woKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDb250cm9sKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2NvbnRleHRcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jb250YWluZXJSZWZcIiwgY3JlYXRlUmVmKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vblNjcm9sbFwiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29uRHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uIChldnQpIHt9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfb25EYmxDbGlja1wiLCBmdW5jdGlvbiAoZXZ0KSB7fSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX29uQ2xpY2tcIiwgZnVuY3Rpb24gKGV2dCkge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9vblBvaW50ZXJNb3ZlXCIsIGZ1bmN0aW9uIChldnQpIHt9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ29udHJvbCwgW3tcbiAgICBrZXk6IFwiX3JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcmVuZGVyKCkgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sLCBfZXh0ZW5kcyh7XG4gICAgICAgIGluc3RhbmNlOiB0aGlzXG4gICAgICB9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIG9uU2Nyb2xsOiB0aGlzLl9vblNjcm9sbCxcbiAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRibENsaWNrOiB0aGlzLl9vbkRibENsaWNrLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrLFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDb250cm9sO1xufShQdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KEJhc2VDb250cm9sLCBcInByb3BUeXBlc1wiLCBtYXBDb250cm9sUHJvcFR5cGVzKTtcblxuX2RlZmluZVByb3BlcnR5KEJhc2VDb250cm9sLCBcImRlZmF1bHRQcm9wc1wiLCBtYXBDb250cm9sRGVmYXVsdFByb3BzKTtcblxuZXhwb3J0IHsgQmFzZUNvbnRyb2wgYXMgZGVmYXVsdCB9OyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbmV4cG9ydCB2YXIgZHJhZ2dhYmxlQ29udHJvbFByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xQcm9wVHlwZXMsIHtcbiAgZHJhZ2dhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25EcmFnOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmFnRW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EcmFnU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvZmZzZXRMZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBvZmZzZXRUb3A6IFByb3BUeXBlcy5udW1iZXJcbn0pO1xuZXhwb3J0IHZhciBkcmFnZ2FibGVDb250cm9sRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwQ29udHJvbERlZmF1bHRQcm9wcywge1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuICBvZmZzZXRMZWZ0OiAwLFxuICBvZmZzZXRUb3A6IDBcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCkge1xuICB2YXIgX2V2ZW50JG9mZnNldENlbnRlciA9IGV2ZW50Lm9mZnNldENlbnRlcixcbiAgICAgIHggPSBfZXZlbnQkb2Zmc2V0Q2VudGVyLngsXG4gICAgICB5ID0gX2V2ZW50JG9mZnNldENlbnRlci55O1xuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBnZXREcmFnRXZlbnRPZmZzZXQoZXZlbnQsIGNvbnRhaW5lcikge1xuICB2YXIgX2V2ZW50JGNlbnRlciA9IGV2ZW50LmNlbnRlcixcbiAgICAgIHggPSBfZXZlbnQkY2VudGVyLngsXG4gICAgICB5ID0gX2V2ZW50JGNlbnRlci55O1xuXG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gW3JlY3QubGVmdCAtIHgsIHJlY3QudG9wIC0geV07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ0xuZ0xhdChkcmFnUG9zLCBkcmFnT2Zmc2V0LCBwcm9wcywgY29udGV4dCkge1xuICB2YXIgeCA9IGRyYWdQb3NbMF0gKyBkcmFnT2Zmc2V0WzBdIC0gcHJvcHMub2Zmc2V0TGVmdDtcbiAgdmFyIHkgPSBkcmFnUG9zWzFdICsgZHJhZ09mZnNldFsxXSAtIHByb3BzLm9mZnNldFRvcDtcbiAgcmV0dXJuIGNvbnRleHQudmlld3BvcnQudW5wcm9qZWN0KFt4LCB5XSk7XG59XG5cbmZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50LCBfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBjYWxsYmFja3MgPSBfcmVmLmNhbGxiYWNrcyxcbiAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfcmVmLmNvbnRhaW5lclJlZjtcbiAgdmFyIGRyYWdnYWJsZSA9IHByb3BzLmRyYWdnYWJsZTtcblxuICBpZiAoIWRyYWdnYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB2YXIgZHJhZ1BvcyA9IGdldERyYWdFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgdmFyIGRyYWdPZmZzZXQgPSBnZXREcmFnRXZlbnRPZmZzZXQoZXZlbnQsIGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhkcmFnUG9zKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChkcmFnT2Zmc2V0KTtcblxuICBpZiAoY2FsbGJhY2tzLm9uRHJhZ1N0YXJ0ICYmIGRyYWdPZmZzZXQpIHtcbiAgICB2YXIgY2FsbGJhY2tFdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTtcbiAgICBjYWxsYmFja0V2ZW50LmxuZ0xhdCA9IGdldERyYWdMbmdMYXQoZHJhZ1BvcywgZHJhZ09mZnNldCwgcHJvcHMsIGNvbnRleHQpO1xuICAgIGNhbGxiYWNrcy5vbkRyYWdTdGFydChjYWxsYmFja0V2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkRyYWcoZXZlbnQsIF9yZWYyKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgY2FsbGJhY2tzID0gX3JlZjIuY2FsbGJhY2tzLFxuICAgICAgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0O1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdmFyIGRyYWdQb3MgPSBnZXREcmFnRXZlbnRQb3NpdGlvbihldmVudCk7XG4gIHN0YXRlLnNldERyYWdQb3MoZHJhZ1Bvcyk7XG4gIHZhciBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcblxuICBpZiAoY2FsbGJhY2tzLm9uRHJhZyAmJiBkcmFnT2Zmc2V0KSB7XG4gICAgdmFyIGNhbGxiYWNrRXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCk7XG4gICAgY2FsbGJhY2tFdmVudC5sbmdMYXQgPSBnZXREcmFnTG5nTGF0KGRyYWdQb3MsIGRyYWdPZmZzZXQsIHByb3BzLCBjb250ZXh0KTtcbiAgICBjYWxsYmFja3Mub25EcmFnKGNhbGxiYWNrRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uRHJhZ0VuZChldmVudCwgX3JlZjMpIHtcbiAgdmFyIHByb3BzID0gX3JlZjMucHJvcHMsXG4gICAgICBjYWxsYmFja3MgPSBfcmVmMy5jYWxsYmFja3MsXG4gICAgICBzdGF0ZSA9IF9yZWYzLnN0YXRlLFxuICAgICAgY29udGV4dCA9IF9yZWYzLmNvbnRleHQ7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB2YXIgZHJhZ1BvcyA9IHN0YXRlLmRyYWdQb3MsXG4gICAgICBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcbiAgc3RhdGUuc2V0RHJhZ1BvcyhudWxsKTtcbiAgc3RhdGUuc2V0RHJhZ09mZnNldChudWxsKTtcblxuICBpZiAoY2FsbGJhY2tzLm9uRHJhZ0VuZCAmJiBkcmFnUG9zICYmIGRyYWdPZmZzZXQpIHtcbiAgICB2YXIgY2FsbGJhY2tFdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTtcbiAgICBjYWxsYmFja0V2ZW50LmxuZ0xhdCA9IGdldERyYWdMbmdMYXQoZHJhZ1BvcywgZHJhZ09mZnNldCwgcHJvcHMsIGNvbnRleHQpO1xuICAgIGNhbGxiYWNrcy5vbkRyYWdFbmQoY2FsbGJhY2tFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25EcmFnQ2FuY2VsKGV2ZW50LCBfcmVmNCkge1xuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHN0YXRlLnNldERyYWdQb3MobnVsbCk7XG4gIHN0YXRlLnNldERyYWdPZmZzZXQobnVsbCk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKHRoaXNSZWYpIHtcbiAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXNSZWYuY29udGV4dC5ldmVudE1hbmFnZXI7XG5cbiAgaWYgKCFldmVudE1hbmFnZXIgfHwgIXRoaXNSZWYuc3RhdGUuZHJhZ1Bvcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIHBhbm1vdmU6IGZ1bmN0aW9uIHBhbm1vdmUoZXZ0KSB7XG4gICAgICByZXR1cm4gb25EcmFnKGV2dCwgdGhpc1JlZik7XG4gICAgfSxcbiAgICBwYW5lbmQ6IGZ1bmN0aW9uIHBhbmVuZChldnQpIHtcbiAgICAgIHJldHVybiBvbkRyYWdFbmQoZXZ0LCB0aGlzUmVmKTtcbiAgICB9LFxuICAgIHBhbmNhbmNlbDogZnVuY3Rpb24gcGFuY2FuY2VsKGV2dCkge1xuICAgICAgcmV0dXJuIG9uRHJhZ0NhbmNlbChldnQsIHRoaXNSZWYpO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNYW5hZ2VyLndhdGNoKGV2ZW50cyk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRNYW5hZ2VyLm9mZihldmVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VEcmFnZ2FibGVDb250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgZHJhZ1BvcyA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXREcmFnUG9zID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxuICAgICAgZHJhZ09mZnNldCA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXREcmFnT2Zmc2V0ID0gX3VzZVN0YXRlNFsxXTtcblxuICB2YXIgdGhpc1JlZiA9IHVzZU1hcENvbnRyb2woX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0XG4gIH0pKTtcbiAgdGhpc1JlZi5jYWxsYmFja3MgPSBwcm9wcztcbiAgdGhpc1JlZi5zdGF0ZS5kcmFnUG9zID0gZHJhZ1BvcztcbiAgdGhpc1JlZi5zdGF0ZS5zZXREcmFnUG9zID0gc2V0RHJhZ1BvcztcbiAgdGhpc1JlZi5zdGF0ZS5kcmFnT2Zmc2V0ID0gZHJhZ09mZnNldDtcbiAgdGhpc1JlZi5zdGF0ZS5zZXREcmFnT2Zmc2V0ID0gc2V0RHJhZ09mZnNldDtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJFdmVudHModGhpc1JlZik7XG4gIH0sIFt0aGlzUmVmLmNvbnRleHQuZXZlbnRNYW5hZ2VyLCBCb29sZWFuKGRyYWdQb3MpXSk7XG4gIHJldHVybiB0aGlzUmVmO1xufSIsInZhciBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbmV4cG9ydCB2YXIgY3Jpc3BQaXhlbCA9IGZ1bmN0aW9uIGNyaXNwUGl4ZWwoc2l6ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChzaXplICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xufTtcbmV4cG9ydCB2YXIgY3Jpc3BQZXJjZW50YWdlID0gZnVuY3Rpb24gY3Jpc3BQZXJjZW50YWdlKGVsLCBwZXJjZW50YWdlKSB7XG4gIHZhciBkaW1lbnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd4JztcblxuICBpZiAoZWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gcGVyY2VudGFnZTtcbiAgfVxuXG4gIHZhciBvcmlnU2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ3gnID8gZWwub2Zmc2V0V2lkdGggOiBlbC5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBjcmlzcFBpeGVsKHBlcmNlbnRhZ2UgLyAxMDAgKiBvcmlnU2l6ZSkgLyBvcmlnU2l6ZSAqIDEwMDtcbn07IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZURyYWdnYWJsZUNvbnRyb2wsIHsgZHJhZ2dhYmxlQ29udHJvbERlZmF1bHRQcm9wcywgZHJhZ2dhYmxlQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vZHJhZ2dhYmxlLWNvbnRyb2wnO1xuaW1wb3J0IHsgY3Jpc3BQaXhlbCB9IGZyb20gJy4uL3V0aWxzL2NyaXNwLXBpeGVsJztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkcmFnZ2FibGVDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJydcbn0pO1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0O1xuICB2YXIgbG9uZ2l0dWRlID0gcHJvcHMubG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUgPSBwcm9wcy5sYXRpdHVkZSxcbiAgICAgIG9mZnNldExlZnQgPSBwcm9wcy5vZmZzZXRMZWZ0LFxuICAgICAgb2Zmc2V0VG9wID0gcHJvcHMub2Zmc2V0VG9wO1xuICB2YXIgZHJhZ1BvcyA9IHN0YXRlLmRyYWdQb3MsXG4gICAgICBkcmFnT2Zmc2V0ID0gc3RhdGUuZHJhZ09mZnNldDtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICAgIG1hcCA9IGNvbnRleHQubWFwO1xuXG4gIGlmIChkcmFnUG9zICYmIGRyYWdPZmZzZXQpIHtcbiAgICByZXR1cm4gW2RyYWdQb3NbMF0gKyBkcmFnT2Zmc2V0WzBdLCBkcmFnUG9zWzFdICsgZHJhZ09mZnNldFsxXV07XG4gIH1cblxuICB2YXIgYWx0aXR1ZGUgPSBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwge1xuICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlOiBsYXRpdHVkZVxuICB9KTtcblxuICB2YXIgX3ZpZXdwb3J0JHByb2plY3QgPSB2aWV3cG9ydC5wcm9qZWN0KFtsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZV0pLFxuICAgICAgX3ZpZXdwb3J0JHByb2plY3QyID0gX3NsaWNlZFRvQXJyYXkoX3ZpZXdwb3J0JHByb2plY3QsIDIpLFxuICAgICAgeCA9IF92aWV3cG9ydCRwcm9qZWN0MlswXSxcbiAgICAgIHkgPSBfdmlld3BvcnQkcHJvamVjdDJbMV07XG5cbiAgeCArPSBvZmZzZXRMZWZ0O1xuICB5ICs9IG9mZnNldFRvcDtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gTWFya2VyKHByb3BzKSB7XG4gIHZhciB0aGlzUmVmID0gdXNlRHJhZ2dhYmxlQ29udHJvbChwcm9wcyk7XG4gIHZhciBzdGF0ZSA9IHRoaXNSZWYuc3RhdGUsXG4gICAgICBjb250YWluZXJSZWYgPSB0aGlzUmVmLmNvbnRhaW5lclJlZjtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBkcmFnZ2FibGUgPSBwcm9wcy5kcmFnZ2FibGU7XG4gIHZhciBkcmFnUG9zID0gc3RhdGUuZHJhZ1BvcztcblxuICB2YXIgX2dldFBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpc1JlZiksXG4gICAgICBfZ2V0UG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2dldFBvc2l0aW9uLCAyKSxcbiAgICAgIHggPSBfZ2V0UG9zaXRpb24yWzBdLFxuICAgICAgeSA9IF9nZXRQb3NpdGlvbjJbMV07XG5cbiAgdmFyIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjcmlzcFBpeGVsKHgpLCBcInB4LCBcIikuY29uY2F0KGNyaXNwUGl4ZWwoeSksIFwicHgpXCIpO1xuICB2YXIgY3Vyc29yID0gZHJhZ2dhYmxlID8gZHJhZ1BvcyA/ICdncmFiYmluZycgOiAnZ3JhYicgOiAnYXV0byc7XG4gIHZhciBjb250cm9sID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBjdXJzb3I6IGN1cnNvclxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLW1hcmtlciBcIi5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICAgIHJlZjogdGhpc1JlZi5jb250YWluZXJSZWYsXG4gICAgICBzdHlsZTogY29udGFpbmVyU3R5bGVcbiAgICB9LCBjaGlsZHJlbik7XG4gIH0sIFtjaGlsZHJlbiwgY2xhc3NOYW1lXSk7XG4gIHZhciBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcblxuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBjb250YWluZXIuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5cbk1hcmtlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKE1hcmtlcik7IiwiZXhwb3J0IHZhciBBTkNIT1JfUE9TSVRJT04gPSB7XG4gIHRvcDoge1xuICAgIHg6IDAuNSxcbiAgICB5OiAwXG4gIH0sXG4gICd0b3AtbGVmdCc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgJ3RvcC1yaWdodCc6IHtcbiAgICB4OiAxLFxuICAgIHk6IDBcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgeDogMC41LFxuICAgIHk6IDFcbiAgfSxcbiAgJ2JvdHRvbS1sZWZ0Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMVxuICB9LFxuICAnYm90dG9tLXJpZ2h0Jzoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9LFxuICBsZWZ0OiB7XG4gICAgeDogMCxcbiAgICB5OiAwLjVcbiAgfSxcbiAgcmlnaHQ6IHtcbiAgICB4OiAxLFxuICAgIHk6IDAuNVxuICB9XG59O1xudmFyIEFOQ0hPUl9UWVBFUyA9IE9iamVjdC5rZXlzKEFOQ0hPUl9QT1NJVElPTik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RHluYW1pY1Bvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBzZWxmV2lkdGggPSBfcmVmLnNlbGZXaWR0aCxcbiAgICAgIHNlbGZIZWlnaHQgPSBfcmVmLnNlbGZIZWlnaHQsXG4gICAgICBhbmNob3IgPSBfcmVmLmFuY2hvcixcbiAgICAgIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBhZGRpbmc7XG4gIHZhciBfQU5DSE9SX1BPU0lUSU9OJGFuY2ggPSBBTkNIT1JfUE9TSVRJT05bYW5jaG9yXSxcbiAgICAgIGFuY2hvclggPSBfQU5DSE9SX1BPU0lUSU9OJGFuY2gueCxcbiAgICAgIGFuY2hvclkgPSBfQU5DSE9SX1BPU0lUSU9OJGFuY2gueTtcbiAgdmFyIHRvcCA9IHkgLSBhbmNob3JZICogc2VsZkhlaWdodDtcbiAgdmFyIGJvdHRvbSA9IHRvcCArIHNlbGZIZWlnaHQ7XG4gIHZhciBjdXRvZmZZID0gTWF0aC5tYXgoMCwgcGFkZGluZyAtIHRvcCkgKyBNYXRoLm1heCgwLCBib3R0b20gLSBoZWlnaHQgKyBwYWRkaW5nKTtcblxuICBpZiAoY3V0b2ZmWSA+IDApIHtcbiAgICB2YXIgYmVzdEFuY2hvclkgPSBhbmNob3JZO1xuICAgIHZhciBtaW5DdXRvZmYgPSBjdXRvZmZZO1xuXG4gICAgZm9yIChhbmNob3JZID0gMDsgYW5jaG9yWSA8PSAxOyBhbmNob3JZICs9IDAuNSkge1xuICAgICAgdG9wID0geSAtIGFuY2hvclkgKiBzZWxmSGVpZ2h0O1xuICAgICAgYm90dG9tID0gdG9wICsgc2VsZkhlaWdodDtcbiAgICAgIGN1dG9mZlkgPSBNYXRoLm1heCgwLCBwYWRkaW5nIC0gdG9wKSArIE1hdGgubWF4KDAsIGJvdHRvbSAtIGhlaWdodCArIHBhZGRpbmcpO1xuXG4gICAgICBpZiAoY3V0b2ZmWSA8IG1pbkN1dG9mZikge1xuICAgICAgICBtaW5DdXRvZmYgPSBjdXRvZmZZO1xuICAgICAgICBiZXN0QW5jaG9yWSA9IGFuY2hvclk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5jaG9yWSA9IGJlc3RBbmNob3JZO1xuICB9XG5cbiAgdmFyIHhTdGVwID0gMC41O1xuXG4gIGlmIChhbmNob3JZID09PSAwLjUpIHtcbiAgICBhbmNob3JYID0gTWF0aC5mbG9vcihhbmNob3JYKTtcbiAgICB4U3RlcCA9IDE7XG4gIH1cblxuICB2YXIgbGVmdCA9IHggLSBhbmNob3JYICogc2VsZldpZHRoO1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgc2VsZldpZHRoO1xuICB2YXIgY3V0b2ZmWCA9IE1hdGgubWF4KDAsIHBhZGRpbmcgLSBsZWZ0KSArIE1hdGgubWF4KDAsIHJpZ2h0IC0gd2lkdGggKyBwYWRkaW5nKTtcblxuICBpZiAoY3V0b2ZmWCA+IDApIHtcbiAgICB2YXIgYmVzdEFuY2hvclggPSBhbmNob3JYO1xuICAgIHZhciBfbWluQ3V0b2ZmID0gY3V0b2ZmWDtcblxuICAgIGZvciAoYW5jaG9yWCA9IDA7IGFuY2hvclggPD0gMTsgYW5jaG9yWCArPSB4U3RlcCkge1xuICAgICAgbGVmdCA9IHggLSBhbmNob3JYICogc2VsZldpZHRoO1xuICAgICAgcmlnaHQgPSBsZWZ0ICsgc2VsZldpZHRoO1xuICAgICAgY3V0b2ZmWCA9IE1hdGgubWF4KDAsIHBhZGRpbmcgLSBsZWZ0KSArIE1hdGgubWF4KDAsIHJpZ2h0IC0gd2lkdGggKyBwYWRkaW5nKTtcblxuICAgICAgaWYgKGN1dG9mZlggPCBfbWluQ3V0b2ZmKSB7XG4gICAgICAgIF9taW5DdXRvZmYgPSBjdXRvZmZYO1xuICAgICAgICBiZXN0QW5jaG9yWCA9IGFuY2hvclg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5jaG9yWCA9IGJlc3RBbmNob3JYO1xuICB9XG5cbiAgcmV0dXJuIEFOQ0hPUl9UWVBFUy5maW5kKGZ1bmN0aW9uIChwb3NpdGlvblR5cGUpIHtcbiAgICB2YXIgYW5jaG9yUG9zaXRpb24gPSBBTkNIT1JfUE9TSVRJT05bcG9zaXRpb25UeXBlXTtcbiAgICByZXR1cm4gYW5jaG9yUG9zaXRpb24ueCA9PT0gYW5jaG9yWCAmJiBhbmNob3JQb3NpdGlvbi55ID09PSBhbmNob3JZO1xuICB9KSB8fCBhbmNob3I7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuaW1wb3J0IHsgZ2V0RHluYW1pY1Bvc2l0aW9uLCBBTkNIT1JfUE9TSVRJT04gfSBmcm9tICcuLi91dGlscy9keW5hbWljLXBvc2l0aW9uJztcbmltcG9ydCB7IGdldFRlcnJhaW5FbGV2YXRpb24gfSBmcm9tICcuLi91dGlscy90ZXJyYWluJztcbmltcG9ydCB7IGNyaXNwUGVyY2VudGFnZSwgY3Jpc3BQaXhlbCB9IGZyb20gJy4uL3V0aWxzL2NyaXNwLXBpeGVsJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG9mZnNldExlZnQ6IDAsXG4gIG9mZnNldFRvcDogMCxcbiAgdGlwU2l6ZTogMTAsXG4gIGFuY2hvcjogJ2JvdHRvbScsXG4gIGR5bmFtaWNQb3NpdGlvbjogdHJ1ZSxcbiAgc29ydEJ5RGVwdGg6IGZhbHNlLFxuICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICBvbkNsb3NlOiBmdW5jdGlvbiBvbkNsb3NlKCkge31cbn0pO1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihwcm9wcywgdmlld3BvcnQsIGVsLCBfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgeCA9IF9yZWYyWzBdLFxuICAgICAgeSA9IF9yZWYyWzFdO1xuXG4gIHZhciBhbmNob3IgPSBwcm9wcy5hbmNob3IsXG4gICAgICBkeW5hbWljUG9zaXRpb24gPSBwcm9wcy5keW5hbWljUG9zaXRpb24sXG4gICAgICB0aXBTaXplID0gcHJvcHMudGlwU2l6ZTtcblxuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZHluYW1pY1Bvc2l0aW9uID8gZ2V0RHluYW1pY1Bvc2l0aW9uKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBwYWRkaW5nOiB0aXBTaXplLFxuICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICBzZWxmV2lkdGg6IGVsLmNsaWVudFdpZHRoLFxuICAgICAgc2VsZkhlaWdodDogZWwuY2xpZW50SGVpZ2h0XG4gICAgfSkgOiBhbmNob3I7XG4gIH1cblxuICByZXR1cm4gYW5jaG9yO1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTdHlsZShwcm9wcywgdmlld3BvcnQsIGVsLCBfcmVmMywgcG9zaXRpb25UeXBlKSB7XG4gIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAzKSxcbiAgICAgIHggPSBfcmVmNFswXSxcbiAgICAgIHkgPSBfcmVmNFsxXSxcbiAgICAgIHogPSBfcmVmNFsyXTtcblxuICB2YXIgb2Zmc2V0TGVmdCA9IHByb3BzLm9mZnNldExlZnQsXG4gICAgICBvZmZzZXRUb3AgPSBwcm9wcy5vZmZzZXRUb3AsXG4gICAgICBzb3J0QnlEZXB0aCA9IHByb3BzLnNvcnRCeURlcHRoO1xuICB2YXIgYW5jaG9yUG9zaXRpb24gPSBBTkNIT1JfUE9TSVRJT05bcG9zaXRpb25UeXBlXTtcbiAgdmFyIGxlZnQgPSB4ICsgb2Zmc2V0TGVmdDtcbiAgdmFyIHRvcCA9IHkgKyBvZmZzZXRUb3A7XG4gIHZhciB4UGVyY2VudGFnZSA9IGNyaXNwUGVyY2VudGFnZShlbCwgLWFuY2hvclBvc2l0aW9uLnggKiAxMDApO1xuICB2YXIgeVBlcmNlbnRhZ2UgPSBjcmlzcFBlcmNlbnRhZ2UoZWwsIC1hbmNob3JQb3NpdGlvbi55ICogMTAwLCAneScpO1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdHJhbnNmb3JtOiBcIlxcbiAgICAgIHRyYW5zbGF0ZShcIi5jb25jYXQoeFBlcmNlbnRhZ2UsIFwiJSwgXCIpLmNvbmNhdCh5UGVyY2VudGFnZSwgXCIlKVxcbiAgICAgIHRyYW5zbGF0ZShcIikuY29uY2F0KGNyaXNwUGl4ZWwobGVmdCksIFwicHgsIFwiKS5jb25jYXQoY3Jpc3BQaXhlbCh0b3ApLCBcInB4KVxcbiAgICBcIiksXG4gICAgZGlzcGxheTogdW5kZWZpbmVkLFxuICAgIHpJbmRleDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFzb3J0QnlEZXB0aCkge1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGlmICh6ID4gMSB8fCB6IDwgLTEgfHwgeCA8IDAgfHwgeCA+IHZpZXdwb3J0LndpZHRoIHx8IHkgPCAwIHx8IHkgPiB2aWV3cG9ydC5oZWlnaHQpIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnpJbmRleCA9IE1hdGguZmxvb3IoKDEgLSB6KSAvIDIgKiAxMDAwMDApO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBvbkNsaWNrKGV2dCwgX3JlZjUpIHtcbiAgdmFyIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICBjb250ZXh0ID0gX3JlZjUuY29udGV4dDtcblxuICBpZiAocHJvcHMuY2xvc2VPbkNsaWNrIHx8IGV2dC50YXJnZXQuY2xhc3NOYW1lID09PSAnbWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uJykge1xuICAgIHByb3BzLm9uQ2xvc2UoKTtcblxuICAgIGlmIChjb250ZXh0LmV2ZW50TWFuYWdlcikge1xuICAgICAgY29udGV4dC5ldmVudE1hbmFnZXIub25jZSgnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sIGV2dC50YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBQb3B1cChwcm9wcykge1xuICB2YXIgY29udGVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHRoaXNSZWYgPSB1c2VNYXBDb250cm9sKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgIG9uQ2xpY2s6IG9uQ2xpY2tcbiAgfSkpO1xuICB2YXIgY29udGV4dCA9IHRoaXNSZWYuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNldExvYWRlZCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gIH0sIFtjb250ZW50UmVmLmN1cnJlbnRdKTtcbiAgdmFyIHZpZXdwb3J0ID0gY29udGV4dC52aWV3cG9ydCxcbiAgICAgIG1hcCA9IGNvbnRleHQubWFwO1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbG9uZ2l0dWRlID0gcHJvcHMubG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUgPSBwcm9wcy5sYXRpdHVkZSxcbiAgICAgIHRpcFNpemUgPSBwcm9wcy50aXBTaXplLFxuICAgICAgY2xvc2VCdXR0b24gPSBwcm9wcy5jbG9zZUJ1dHRvbixcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBhbHRpdHVkZSA9IHByb3BzLmFsdGl0dWRlO1xuXG4gIGlmIChhbHRpdHVkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYWx0aXR1ZGUgPSBnZXRUZXJyYWluRWxldmF0aW9uKG1hcCwge1xuICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZTogbGF0aXR1ZGVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwb3NpdGlvbiA9IHZpZXdwb3J0LnByb2plY3QoW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlXSk7XG4gIHZhciBwb3NpdGlvblR5cGUgPSBnZXRQb3NpdGlvbihwcm9wcywgdmlld3BvcnQsIGNvbnRlbnRSZWYuY3VycmVudCwgcG9zaXRpb24pO1xuICB2YXIgY29udGFpbmVyU3R5bGUgPSBnZXRDb250YWluZXJTdHlsZShwcm9wcywgdmlld3BvcnQsIGNvbnRhaW5lclJlZi5jdXJyZW50LCBwb3NpdGlvbiwgcG9zaXRpb25UeXBlKTtcbiAgdmFyIG9uUmVhY3RDbGljayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuICFjb250ZXh0LmV2ZW50TWFuYWdlciAmJiBvbkNsaWNrKGUsIHRoaXNSZWYpO1xuICB9LCBbY29udGV4dC5ldmVudE1hbmFnZXJdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cCBtYXBib3hnbC1wb3B1cC1hbmNob3ItXCIuY29uY2F0KHBvc2l0aW9uVHlwZSwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpLFxuICAgIHN0eWxlOiBjb250YWluZXJTdHlsZSxcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwidGlwXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLXBvcHVwLXRpcFwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBib3JkZXJXaWR0aDogdGlwU2l6ZVxuICAgIH1cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgcmVmOiBjb250ZW50UmVmLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1wb3B1cC1jb250ZW50XCIsXG4gICAgb25DbGljazogb25SZWFjdENsaWNrXG4gIH0sIGNsb3NlQnV0dG9uICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGtleTogXCJjbG9zZS1idXR0b25cIixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uXCIsXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBcIlxceEQ3XCIpLCBjaGlsZHJlbikpO1xufVxuXG5Qb3B1cC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFBvcHVwKTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlU3RhdGUsIHVzZVJlZiwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgdG9nZ2xlTGFiZWw6ICdUb2dnbGUgQXR0cmlidXRpb24nXG59KTtcblxuZnVuY3Rpb24gc2V0dXBBdHRyaWJ1dGlvbmNvbnRyb2wob3B0cywgbWFwLCBjb250YWluZXIsIGF0dHJpYnV0aW9uQ29udGFpbmVyKSB7XG4gIHZhciBjb250cm9sID0gbmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uQ29udHJvbChvcHRzKTtcbiAgY29udHJvbC5fbWFwID0gbWFwO1xuICBjb250cm9sLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIGNvbnRyb2wuX2lubmVyQ29udGFpbmVyID0gYXR0cmlidXRpb25Db250YWluZXI7XG5cbiAgY29udHJvbC5fdXBkYXRlQXR0cmlidXRpb25zKCk7XG5cbiAgY29udHJvbC5fdXBkYXRlRWRpdExpbmsoKTtcblxuICBtYXAub24oJ3N0eWxlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuICBtYXAub24oJ3NvdXJjZWRhdGEnLCBjb250cm9sLl91cGRhdGVEYXRhKTtcbiAgcmV0dXJuIGNvbnRyb2w7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0aW9uQ29udHJvbChjb250cm9sKSB7XG4gIGNvbnRyb2wuX21hcC5vZmYoJ3N0eWxlZGF0YScsIGNvbnRyb2wuX3VwZGF0ZURhdGEpO1xuXG4gIGNvbnRyb2wuX21hcC5vZmYoJ3NvdXJjZWRhdGEnLCBjb250cm9sLl91cGRhdGVEYXRhKTtcbn1cblxuZnVuY3Rpb24gQXR0cmlidXRpb25Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIGlubmVyQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNob3dDb21wYWN0ID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFNob3dDb21wYWN0ID0gX3VzZVN0YXRlMlsxXTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250cm9sO1xuXG4gICAgaWYgKGNvbnRleHQubWFwKSB7XG4gICAgICBjb250cm9sID0gc2V0dXBBdHRyaWJ1dGlvbmNvbnRyb2woe1xuICAgICAgICBjdXN0b21BdHRyaWJ1dGlvbjogcHJvcHMuY3VzdG9tQXR0cmlidXRpb25cbiAgICAgIH0sIGNvbnRleHQubWFwLCBjb250YWluZXJSZWYuY3VycmVudCwgaW5uZXJDb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb250cm9sICYmIHJlbW92ZUF0dHJpYnV0aW9uQ29udHJvbChjb250cm9sKTtcbiAgICB9O1xuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgdmFyIGNvbXBhY3QgPSBwcm9wcy5jb21wYWN0ID09PSB1bmRlZmluZWQgPyBjb250ZXh0LnZpZXdwb3J0LndpZHRoIDw9IDY0MCA6IHByb3BzLmNvbXBhY3Q7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjb21wYWN0ICYmIHNob3dDb21wYWN0KSB7XG4gICAgICBzZXRTaG93Q29tcGFjdChmYWxzZSk7XG4gICAgfVxuICB9LCBbY29tcGFjdF0pO1xuICB2YXIgdG9nZ2xlQXR0cmlidXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFNob3dDb21wYWN0KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgXCJhcmlhLXByZXNzZWRcIjogc2hvd0NvbXBhY3QsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1hdHRyaWIgXCIuY29uY2F0KGNvbXBhY3QgPyAnbWFwYm94Z2wtY29tcGFjdCcgOiAnJywgXCIgXCIpLmNvbmNhdChzaG93Q29tcGFjdCA/ICdtYXBib3hnbC1jb21wYWN0LXNob3cnIDogJycpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtYXR0cmliLWJ1dHRvblwiLFxuICAgIHRpdGxlOiBwcm9wcy50b2dnbGVMYWJlbCxcbiAgICBvbkNsaWNrOiB0b2dnbGVBdHRyaWJ1dGlvblxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBpbm5lckNvbnRhaW5lclJlZixcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1hdHRyaWItaW5uZXJcIixcbiAgICByb2xlOiBcImxpc3RcIlxuICB9KSkpO1xufVxuXG5BdHRyaWJ1dGlvbkNvbnRyb2wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhBdHRyaWJ1dGlvbkNvbnRyb2wpOyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgeyBkb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgY29udGFpbmVyOiBudWxsLFxuICBsYWJlbDogJ1RvZ2dsZSBmdWxsc2NyZWVuJ1xufSk7XG5cbmZ1bmN0aW9uIEZ1bGxzY3JlZW5Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgaXNGdWxsc2NyZWVuID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldElzRnVsbHNjcmVlbiA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICBzaG93QnV0dG9uID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldFNob3dCdXR0b24gPSBfdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBfdXNlU3RhdGU1ID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBfdXNlU3RhdGU2ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlNSwgMiksXG4gICAgICBtYXBib3hGdWxsc2NyZWVuQ29udHJvbCA9IF91c2VTdGF0ZTZbMF0sXG4gICAgICBjcmVhdGVNYXBib3hGdWxsc2NyZWVuQ29udHJvbCA9IF91c2VTdGF0ZTZbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbCA9IG5ldyBtYXBib3hnbC5GdWxsc2NyZWVuQ29udHJvbCgpO1xuICAgIGNyZWF0ZU1hcGJveEZ1bGxzY3JlZW5Db250cm9sKGNvbnRyb2wpO1xuICAgIHNldFNob3dCdXR0b24oY29udHJvbC5fY2hlY2tGdWxsc2NyZWVuU3VwcG9ydCgpKTtcblxuICAgIHZhciBvbkZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBvbkZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gIWNvbnRyb2wuX2Z1bGxzY3JlZW47XG4gICAgICBjb250cm9sLl9mdWxsc2NyZWVuID0gbmV4dFN0YXRlO1xuICAgICAgc2V0SXNGdWxsc2NyZWVuKG5leHRTdGF0ZSk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoY29udHJvbC5fZnVsbHNjcmVlbmNoYW5nZSwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjb250cm9sLl9mdWxsc2NyZWVuY2hhbmdlLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICB2YXIgb25DbGlja0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiBvbkNsaWNrRnVsbHNjcmVlbigpIHtcbiAgICBpZiAobWFwYm94RnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEZ1bGxzY3JlZW5Db250cm9sLl9jb250YWluZXIgPSBwcm9wcy5jb250YWluZXIgfHwgY29udGV4dC5jb250YWluZXI7XG5cbiAgICAgIG1hcGJveEZ1bGxzY3JlZW5Db250cm9sLl9vbkNsaWNrRnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sIHByb3BzLnN0eWxlKTtcbiAgfSwgW3Byb3BzLnN0eWxlXSk7XG5cbiAgaWYgKCFzaG93QnV0dG9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbDtcbiAgdmFyIHR5cGUgPSBpc0Z1bGxzY3JlZW4gPyAnc2hyaW5rJyA6ICdmdWxsc2NyZWVuJztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIsXG4gICAgcmVmOiBjb250YWluZXJSZWZcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAga2V5OiB0eXBlLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb24gbWFwYm94Z2wtY3RybC1cIi5jb25jYXQodHlwZSksXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICB0aXRsZTogbGFiZWwsXG4gICAgb25DbGljazogb25DbGlja0Z1bGxzY3JlZW5cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWljb25cIixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gIH0pKSkpO1xufVxuXG5GdWxsc2NyZWVuQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEZ1bGxzY3JlZW5Db250cm9sKTsiLCJ2YXIgc3VwcG9ydGVkO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR2VvbG9jYXRpb25TdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydGVkKTtcbiAgfVxuXG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLnBlcm1pc3Npb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XG4gICAgICBuYW1lOiAnZ2VvbG9jYXRpb24nXG4gICAgfSkudGhlbihmdW5jdGlvbiAocCkge1xuICAgICAgc3VwcG9ydGVkID0gcC5zdGF0ZSAhPT0gJ2RlbmllZCc7XG4gICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH0pO1xuICB9XG5cbiAgc3VwcG9ydGVkID0gQm9vbGVhbih3aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdXBwb3J0ZWQpO1xufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9nbG9iYWxzJztcbmltcG9ydCBtYXBib3hnbCBmcm9tICcuLi91dGlscy9tYXBib3hnbCc7XG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCB7IExJTkVBUl9UUkFOU0lUSU9OX1BST1BTIH0gZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgaXNHZW9sb2NhdGlvblN1cHBvcnRlZCB9IGZyb20gJy4uL3V0aWxzL2dlb2xvY2F0ZS11dGlscyc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sRGVmYXVsdFByb3BzLCBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi91c2UtbWFwLWNvbnRyb2wnO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hcENvbnRyb2xEZWZhdWx0UHJvcHMsIHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgbGFiZWw6ICdGaW5kIE15IExvY2F0aW9uJyxcbiAgZGlzYWJsZWRMYWJlbDogJ0xvY2F0aW9uIE5vdCBBdmFpbGFibGUnLFxuICBhdXRvOiBmYWxzZSxcbiAgcG9zaXRpb25PcHRpb25zOiB7XG4gICAgZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZSxcbiAgICB0aW1lb3V0OiA2MDAwXG4gIH0sXG4gIGZpdEJvdW5kc09wdGlvbnM6IHtcbiAgICBtYXhab29tOiAxNVxuICB9LFxuICB0cmFja1VzZXJMb2NhdGlvbjogZmFsc2UsXG4gIHNob3dVc2VyTG9jYXRpb246IHRydWUsXG4gIHNob3dBY2N1cmFjeUNpcmNsZTogdHJ1ZSxcbiAgb25HZW9sb2NhdGU6IGZ1bmN0aW9uIG9uR2VvbG9jYXRlKCkge31cbn0pO1xuXG5mdW5jdGlvbiBnZXRCb3VuZHMocG9zaXRpb24pIHtcbiAgdmFyIGNlbnRlciA9IG5ldyBtYXBib3hnbC5MbmdMYXQocG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlKTtcbiAgdmFyIHJhZGl1cyA9IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeTtcbiAgdmFyIGJvdW5kcyA9IGNlbnRlci50b0JvdW5kcyhyYWRpdXMpO1xuICByZXR1cm4gW1tib3VuZHMuX25lLmxuZywgYm91bmRzLl9uZS5sYXRdLCBbYm91bmRzLl9zdy5sbmcsIGJvdW5kcy5fc3cubGF0XV07XG59XG5cbmZ1bmN0aW9uIHNldHVwTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250ZXh0LCBwcm9wcywgZ2VvbG9jYXRlQnV0dG9uKSB7XG4gIHZhciBjb250cm9sID0gbmV3IG1hcGJveGdsLkdlb2xvY2F0ZUNvbnRyb2wocHJvcHMpO1xuICBjb250cm9sLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udHJvbC5fbWFwID0ge1xuICAgIG9uOiBmdW5jdGlvbiBvbigpIHt9LFxuICAgIF9nZXRVSVN0cmluZzogZnVuY3Rpb24gX2dldFVJU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICBjb250cm9sLl9zZXR1cFVJKHRydWUpO1xuXG4gIGNvbnRyb2wuX21hcCA9IGNvbnRleHQubWFwO1xuICBjb250cm9sLl9nZW9sb2NhdGVCdXR0b24gPSBnZW9sb2NhdGVCdXR0b247XG4gIHZhciBldmVudE1hbmFnZXIgPSBjb250ZXh0LmV2ZW50TWFuYWdlcjtcblxuICBpZiAoY29udHJvbC5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uICYmIGV2ZW50TWFuYWdlcikge1xuICAgIGV2ZW50TWFuYWdlci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29udHJvbC5fd2F0Y2hTdGF0ZSA9PT0gJ0FDVElWRV9MT0NLJykge1xuICAgICAgICBjb250cm9sLl93YXRjaFN0YXRlID0gJ0JBQ0tHUk9VTkQnO1xuICAgICAgICBnZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZCcpO1xuICAgICAgICBnZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb250cm9sLm9uKCdnZW9sb2NhdGUnLCBwcm9wcy5vbkdlb2xvY2F0ZSk7XG4gIHJldHVybiBjb250cm9sO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDYW1lcmEocG9zaXRpb24sIF9yZWYpIHtcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gIHZhciBib3VuZHMgPSBnZXRCb3VuZHMocG9zaXRpb24pO1xuXG4gIHZhciBfY29udGV4dCR2aWV3cG9ydCRmaXQgPSBjb250ZXh0LnZpZXdwb3J0LmZpdEJvdW5kcyhib3VuZHMsIHByb3BzLmZpdEJvdW5kc09wdGlvbnMpLFxuICAgICAgbG9uZ2l0dWRlID0gX2NvbnRleHQkdmlld3BvcnQkZml0LmxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlID0gX2NvbnRleHQkdmlld3BvcnQkZml0LmxhdGl0dWRlLFxuICAgICAgem9vbSA9IF9jb250ZXh0JHZpZXdwb3J0JGZpdC56b29tO1xuXG4gIHZhciBuZXdWaWV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LnZpZXdwb3J0LCB7XG4gICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgIHpvb206IHpvb21cbiAgfSk7XG4gIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShuZXdWaWV3U3RhdGUpO1xuICB2YXIgdmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gcHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCBjb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgdmFyIG9uVmlld1N0YXRlQ2hhbmdlID0gcHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgdmlld1N0YXRlOiB2aWV3U3RhdGVcbiAgfSk7XG4gIG9uVmlld3BvcnRDaGFuZ2Uodmlld1N0YXRlKTtcbn1cblxuZnVuY3Rpb24gR2VvbG9jYXRlQ29udHJvbChwcm9wcykge1xuICB2YXIgdGhpc1JlZiA9IHVzZU1hcENvbnRyb2wocHJvcHMpO1xuICB2YXIgY29udGV4dCA9IHRoaXNSZWYuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IHRoaXNSZWYuY29udGFpbmVyUmVmO1xuICB2YXIgZ2VvbG9jYXRlQnV0dG9uUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgbWFwYm94R2VvbG9jYXRlQ29udHJvbCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBjcmVhdGVNYXBib3hHZW9sb2NhdGVDb250cm9sID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIHN1cHBvcnRzR2VvbG9jYXRpb24gPSBfdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0U3VwcG9ydHNHZW9sb2NhdGlvbiA9IF91c2VTdGF0ZTRbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbDtcblxuICAgIGlmIChjb250ZXh0Lm1hcCkge1xuICAgICAgaXNHZW9sb2NhdGlvblN1cHBvcnRlZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBzZXRTdXBwb3J0c0dlb2xvY2F0aW9uKHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKGdlb2xvY2F0ZUJ1dHRvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29udHJvbCA9IHNldHVwTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250ZXh0LCBwcm9wcywgZ2VvbG9jYXRlQnV0dG9uUmVmLmN1cnJlbnQpO1xuXG4gICAgICAgICAgY29udHJvbC5fdXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQ2FtZXJhKHBvc2l0aW9uLCB0aGlzUmVmKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY3JlYXRlTWFwYm94R2VvbG9jYXRlQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuX2NsZWFyV2F0Y2goKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY29udGV4dC5tYXBdKTtcbiAgdmFyIHRyaWdnZXJHZW9sb2NhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wub3B0aW9ucyA9IHRoaXNSZWYucHJvcHM7XG4gICAgICBtYXBib3hHZW9sb2NhdGVDb250cm9sLnRyaWdnZXIoKTtcbiAgICB9XG4gIH0sIFttYXBib3hHZW9sb2NhdGVDb250cm9sXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BzLmF1dG8pIHtcbiAgICAgIHRyaWdnZXJHZW9sb2NhdGUoKTtcbiAgICB9XG4gIH0sIFttYXBib3hHZW9sb2NhdGVDb250cm9sLCBwcm9wcy5hdXRvXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wpIHtcbiAgICAgIG1hcGJveEdlb2xvY2F0ZUNvbnRyb2wuX29uWm9vbSgpO1xuICAgIH1cbiAgfSwgW2NvbnRleHQudmlld3BvcnQuem9vbV0pO1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIGRpc2FibGVkTGFiZWwgPSBwcm9wcy5kaXNhYmxlZExhYmVsLFxuICAgICAgdHJhY2tVc2VyTG9jYXRpb24gPSBwcm9wcy50cmFja1VzZXJMb2NhdGlvbjtcbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJnZW9sb2NhdGUtY29udHJvbFwiLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXBcIixcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBrZXk6IFwiZ2VvbG9jYXRlXCIsXG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZVwiLFxuICAgIHJlZjogZ2VvbG9jYXRlQnV0dG9uUmVmLFxuICAgIGRpc2FibGVkOiAhc3VwcG9ydHNHZW9sb2NhdGlvbixcbiAgICBcImFyaWEtcHJlc3NlZFwiOiAhdHJhY2tVc2VyTG9jYXRpb24sXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICB0aXRsZTogc3VwcG9ydHNHZW9sb2NhdGlvbiA/IGxhYmVsIDogZGlzYWJsZWRMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxcIjogc3VwcG9ydHNHZW9sb2NhdGlvbiA/IGxhYmVsIDogZGlzYWJsZWRMYWJlbCxcbiAgICBvbkNsaWNrOiB0cmlnZ2VyR2VvbG9jYXRlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KSkpKTtcbn1cblxuR2VvbG9jYXRlQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEdlb2xvY2F0ZUNvbnRyb2wpOyIsImV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIHZhciB2MSA9ICh2ZXJzaW9uMSB8fCAnJykuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgdmFyIHYyID0gKHZlcnNpb24yIHx8ICcnKS5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdmFyIHBhcnQxID0gdjFbaV0gfHwgMDtcbiAgICB2YXIgcGFydDIgPSB2MltpXSB8fCAwO1xuXG4gICAgaWYgKHBhcnQxIDwgcGFydDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGFydDEgPiBwYXJ0Mikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5pbXBvcnQgeyBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyB9IGZyb20gJy4uL3V0aWxzL21hcC1jb250cm9sbGVyJztcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucyB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24nO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIHNob3dDb21wYXNzOiB0cnVlLFxuICBzaG93Wm9vbTogdHJ1ZSxcbiAgem9vbUluTGFiZWw6ICdab29tIEluJyxcbiAgem9vbU91dExhYmVsOiAnWm9vbSBPdXQnLFxuICBjb21wYXNzTGFiZWw6ICdSZXNldCBOb3J0aCdcbn0pO1xudmFyIFZFUlNJT05fTEVHQUNZID0gMTtcbnZhciBWRVJTSU9OXzFfNiA9IDI7XG5cbmZ1bmN0aW9uIGdldFVJVmVyc2lvbihtYXBib3hWZXJzaW9uKSB7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMobWFwYm94VmVyc2lvbiwgJzEuNi4wJykgPj0gMCA/IFZFUlNJT05fMV82IDogVkVSU0lPTl9MRUdBQ1k7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCBvcHRzKSB7XG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQ7XG4gIHZhciBtYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB2aWV3cG9ydCwgb3B0cykpO1xuICB2YXIgdmlld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpLCBMSU5FQVJfVFJBTlNJVElPTl9QUk9QUyk7XG4gIHZhciBvblZpZXdwb3J0Q2hhbmdlID0gcHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCBjb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UgfHwgbm9vcDtcbiAgdmFyIG9uVmlld1N0YXRlQ2hhbmdlID0gcHJvcHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgY29udGV4dC5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICBvblZpZXdTdGF0ZUNoYW5nZSh7XG4gICAgdmlld1N0YXRlOiB2aWV3U3RhdGVcbiAgfSk7XG4gIG9uVmlld3BvcnRDaGFuZ2Uodmlld1N0YXRlKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQnV0dG9uKHR5cGUsIGxhYmVsLCBjYWxsYmFjaywgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGtleTogdHlwZSxcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uIG1hcGJveGdsLWN0cmwtXCIuY29uY2F0KHR5cGUpLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgdGl0bGU6IGxhYmVsLFxuICAgIG9uQ2xpY2s6IGNhbGxiYWNrXG4gIH0sIGNoaWxkcmVuIHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwibWFwYm94Z2wtY3RybC1pY29uXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbXBhc3MoY29udGV4dCkge1xuICB2YXIgdWlWZXJzaW9uID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQubWFwID8gZ2V0VUlWZXJzaW9uKGNvbnRleHQubWFwLnZlcnNpb24pIDogVkVSU0lPTl8xXzY7XG4gIH0sIFtjb250ZXh0Lm1hcF0pO1xuICB2YXIgYmVhcmluZyA9IGNvbnRleHQudmlld3BvcnQuYmVhcmluZztcbiAgdmFyIHN0eWxlID0ge1xuICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoXCIuY29uY2F0KC1iZWFyaW5nLCBcImRlZylcIilcbiAgfTtcbiAgcmV0dXJuIHVpVmVyc2lvbiA9PT0gVkVSU0lPTl8xXzYgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm1hcGJveGdsLWN0cmwtaWNvblwiLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0pIDogUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsLWNvbXBhc3MtYXJyb3dcIixcbiAgICBzdHlsZTogc3R5bGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE5hdmlnYXRpb25Db250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIG9uWm9vbUluID0gZnVuY3Rpb24gb25ab29tSW4oKSB7XG4gICAgdXBkYXRlVmlld3BvcnQoY29udGV4dCwgcHJvcHMsIHtcbiAgICAgIHpvb206IGNvbnRleHQudmlld3BvcnQuem9vbSArIDFcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb25ab29tT3V0ID0gZnVuY3Rpb24gb25ab29tT3V0KCkge1xuICAgIHVwZGF0ZVZpZXdwb3J0KGNvbnRleHQsIHByb3BzLCB7XG4gICAgICB6b29tOiBjb250ZXh0LnZpZXdwb3J0Lnpvb20gLSAxXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9uUmVzZXROb3J0aCA9IGZ1bmN0aW9uIG9uUmVzZXROb3J0aCgpIHtcbiAgICB1cGRhdGVWaWV3cG9ydChjb250ZXh0LCBwcm9wcywge1xuICAgICAgYmVhcmluZzogMCxcbiAgICAgIHBpdGNoOiAwXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIHNob3dDb21wYXNzID0gcHJvcHMuc2hvd0NvbXBhc3MsXG4gICAgICBzaG93Wm9vbSA9IHByb3BzLnNob3dab29tLFxuICAgICAgem9vbUluTGFiZWwgPSBwcm9wcy56b29tSW5MYWJlbCxcbiAgICAgIHpvb21PdXRMYWJlbCA9IHByb3BzLnpvb21PdXRMYWJlbCxcbiAgICAgIGNvbXBhc3NMYWJlbCA9IHByb3BzLmNvbXBhc3NMYWJlbDtcbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXBcIixcbiAgICByZWY6IGNvbnRhaW5lclJlZlxuICB9LCBzaG93Wm9vbSAmJiByZW5kZXJCdXR0b24oJ3pvb20taW4nLCB6b29tSW5MYWJlbCwgb25ab29tSW4pLCBzaG93Wm9vbSAmJiByZW5kZXJCdXR0b24oJ3pvb20tb3V0Jywgem9vbU91dExhYmVsLCBvblpvb21PdXQpLCBzaG93Q29tcGFzcyAmJiByZW5kZXJCdXR0b24oJ2NvbXBhc3MnLCBjb21wYXNzTGFiZWwsIG9uUmVzZXROb3J0aCwgcmVuZGVyQ29tcGFzcyhjb250ZXh0KSkpKTtcbn1cblxuTmF2aWdhdGlvbkNvbnRyb2wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhOYXZpZ2F0aW9uQ29udHJvbCk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbWFwYm94Z2wgZnJvbSAnLi4vdXRpbHMvbWFwYm94Z2wnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbERlZmF1bHRQcm9wcywgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4vdXNlLW1hcC1jb250cm9sJztcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBDb250cm9sRGVmYXVsdFByb3BzLCB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG1heFdpZHRoOiAxMDAsXG4gIHVuaXQ6ICdtZXRyaWMnXG59KTtcblxuZnVuY3Rpb24gU2NhbGVDb250cm9sKHByb3BzKSB7XG4gIHZhciBfdXNlTWFwQ29udHJvbCA9IHVzZU1hcENvbnRyb2wocHJvcHMpLFxuICAgICAgY29udGV4dCA9IF91c2VNYXBDb250cm9sLmNvbnRleHQsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlTWFwQ29udHJvbC5jb250YWluZXJSZWY7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBtYXBib3hTY2FsZUNvbnRyb2wgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgY3JlYXRlTWFwYm94U2NhbGVDb250cm9sID0gX3VzZVN0YXRlMlsxXTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb250ZXh0Lm1hcCkge1xuICAgICAgdmFyIGNvbnRyb2wgPSBuZXcgbWFwYm94Z2wuU2NhbGVDb250cm9sKCk7XG4gICAgICBjb250cm9sLl9tYXAgPSBjb250ZXh0Lm1hcDtcbiAgICAgIGNvbnRyb2wuX2NvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgY3JlYXRlTWFwYm94U2NhbGVDb250cm9sKGNvbnRyb2wpO1xuICAgIH1cbiAgfSwgW2NvbnRleHQubWFwXSk7XG5cbiAgaWYgKG1hcGJveFNjYWxlQ29udHJvbCkge1xuICAgIG1hcGJveFNjYWxlQ29udHJvbC5vcHRpb25zID0gcHJvcHM7XG5cbiAgICBtYXBib3hTY2FsZUNvbnRyb2wuX29uTW92ZSgpO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBwcm9wcy5zdHlsZSk7XG4gIH0sIFtwcm9wcy5zdHlsZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIGNsYXNzTmFtZTogXCJtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtc2NhbGVcIlxuICB9KSk7XG59XG5cblNjYWxlQ29udHJvbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFNjYWxlQ29udHJvbCk7IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZU1hcENvbnRyb2wsIHsgbWFwQ29udHJvbFByb3BUeXBlcyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbnZhciBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNhcHR1cmVTY3JvbGw6IGZhbHNlLFxuICBjYXB0dXJlRHJhZzogZmFsc2UsXG4gIGNhcHR1cmVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVEb3VibGVDbGljazogZmFsc2UsXG4gIGNhcHR1cmVQb2ludGVyTW92ZTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIENhbnZhc092ZXJsYXkocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIGN0eCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXREcmF3aW5nQ29udGV4dCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXREcmF3aW5nQ29udGV4dChjb250YWluZXJSZWYuY3VycmVudC5nZXRDb250ZXh0KCcyZCcpKTtcbiAgfSwgW10pO1xuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgICAgaXNEcmFnZ2luZyA9IGNvbnRleHQuaXNEcmFnZ2luZztcblxuICBpZiAoY3R4KSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgcHJvcHMucmVkcmF3KHtcbiAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgY3R4OiBjdHgsXG4gICAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLFxuICAgICAgcHJvamVjdDogdmlld3BvcnQucHJvamVjdCxcbiAgICAgIHVucHJvamVjdDogdmlld3BvcnQudW5wcm9qZWN0XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGggKiBwaXhlbFJhdGlvLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHZpZXdwb3J0LndpZHRoLCBcInB4XCIpLFxuICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdCh2aWV3cG9ydC5oZWlnaHQsIFwicHhcIiksXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9XG4gIH0pO1xufVxuXG5DYW52YXNPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IENhbnZhc092ZXJsYXk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gSFRNTE92ZXJsYXkocHJvcHMpIHtcbiAgdmFyIF91c2VNYXBDb250cm9sID0gdXNlTWFwQ29udHJvbChwcm9wcyksXG4gICAgICBjb250ZXh0ID0gX3VzZU1hcENvbnRyb2wuY29udGV4dCxcbiAgICAgIGNvbnRhaW5lclJlZiA9IF91c2VNYXBDb250cm9sLmNvbnRhaW5lclJlZjtcblxuICB2YXIgdmlld3BvcnQgPSBjb250ZXh0LnZpZXdwb3J0LFxuICAgICAgaXNEcmFnZ2luZyA9IGNvbnRleHQuaXNEcmFnZ2luZztcblxuICB2YXIgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHRcbiAgfSwgcHJvcHMuc3R5bGUpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgcHJvcHMucmVkcmF3KHtcbiAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgaXNEcmFnZ2luZzogaXNEcmFnZ2luZyxcbiAgICBwcm9qZWN0OiB2aWV3cG9ydC5wcm9qZWN0LFxuICAgIHVucHJvamVjdDogdmlld3BvcnQudW5wcm9qZWN0XG4gIH0pKTtcbn1cblxuSFRNTE92ZXJsYXkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgSFRNTE92ZXJsYXk7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWFwQ29udHJvbCwgeyBtYXBDb250cm9sUHJvcFR5cGVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy91c2UtbWFwLWNvbnRyb2wnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY2FwdHVyZVNjcm9sbDogZmFsc2UsXG4gIGNhcHR1cmVEcmFnOiBmYWxzZSxcbiAgY2FwdHVyZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZURvdWJsZUNsaWNrOiBmYWxzZSxcbiAgY2FwdHVyZVBvaW50ZXJNb3ZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gU1ZHT3ZlcmxheShwcm9wcykge1xuICB2YXIgX3VzZU1hcENvbnRyb2wgPSB1c2VNYXBDb250cm9sKHByb3BzKSxcbiAgICAgIGNvbnRleHQgPSBfdXNlTWFwQ29udHJvbC5jb250ZXh0LFxuICAgICAgY29udGFpbmVyUmVmID0gX3VzZU1hcENvbnRyb2wuY29udGFpbmVyUmVmO1xuXG4gIHZhciB2aWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQsXG4gICAgICBpc0RyYWdnaW5nID0gY29udGV4dC5pc0RyYWdnaW5nO1xuXG4gIHZhciBzdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH0sIHByb3BzLnN0eWxlKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBwcm9wcy5yZWRyYXcoe1xuICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLFxuICAgIHByb2plY3Q6IHZpZXdwb3J0LnByb2plY3QsXG4gICAgdW5wcm9qZWN0OiB2aWV3cG9ydC51bnByb2plY3RcbiAgfSkpO1xufVxuXG5TVkdPdmVybGF5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFNWR092ZXJsYXk7IiwiaW1wb3J0IG1hcGJveGdsIGZyb20gJy4vbWFwYm94Z2wnO1xudmFyIHNldFJUTFRleHRQbHVnaW4gPSBtYXBib3hnbCA/IG1hcGJveGdsLnNldFJUTFRleHRQbHVnaW4gOiBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydCBkZWZhdWx0IHNldFJUTFRleHRQbHVnaW47IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnRlcmFjdGl2ZU1hcCB9IGZyb20gJy4vY29tcG9uZW50cy9pbnRlcmFjdGl2ZS1tYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGF0aWNNYXAgfSBmcm9tICcuL2NvbXBvbmVudHMvc3RhdGljLW1hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNvdXJjZSB9IGZyb20gJy4vY29tcG9uZW50cy9zb3VyY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXllciB9IGZyb20gJy4vY29tcG9uZW50cy9sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VDb250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL2Jhc2UtY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcmtlciB9IGZyb20gJy4vY29tcG9uZW50cy9tYXJrZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3B1cCB9IGZyb20gJy4vY29tcG9uZW50cy9wb3B1cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF0dHJpYnV0aW9uQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9hdHRyaWJ1dGlvbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVsbHNjcmVlbkNvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvZnVsbHNjcmVlbi1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2VvbG9jYXRlQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9nZW9sb2NhdGUtY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5hdmlnYXRpb25Db250cm9sIH0gZnJvbSAnLi9jb21wb25lbnRzL25hdmlnYXRpb24tY29udHJvbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjYWxlQ29udHJvbCB9IGZyb20gJy4vY29tcG9uZW50cy9zY2FsZS1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvY2FudmFzLW92ZXJsYXknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIVE1MT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvaHRtbC1vdmVybGF5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU1ZHT3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheXMvc3ZnLW92ZXJsYXknO1xuZXhwb3J0IHsgVFJBTlNJVElPTl9FVkVOVFMgfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb24tbWFuYWdlcic7XG5leHBvcnQgeyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yLCBMaW5lYXJJbnRlcnBvbGF0b3IsIFZpZXdwb3J0Rmx5VG9JbnRlcnBvbGF0b3IgYXMgRmx5VG9JbnRlcnBvbGF0b3IgfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXBDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9tYXAtY29udHJvbGxlcic7XG5leHBvcnQgeyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNldFJUTFRleHRQbHVnaW4gfSBmcm9tICcuL3V0aWxzL3NldC1ydGwtdGV4dC1wbHVnaW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXBDb250ZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL21hcC1jb250ZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX3VzZU1hcENvbnRyb2wgfSBmcm9tICcuL2NvbXBvbmVudHMvdXNlLW1hcC1jb250cm9sJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX01hcENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvbWFwLWNvbnRleHQnOyIsImltcG9ydCB7TG5nTGF0Qm91bmRzTGlrZX0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuXG4vLyBVUkxTXG5leHBvcnQgY29uc3QgRkVBVFVSRV9USUxFX0JBU0VfVVJMID0gJ2h0dHBzOi8vZDJ6amlkNm41amEycHQuY2xvdWRmcm9udC5uZXQnO1xuY29uc3QgWFlaX1NVRkZJWCA9ICd7en0ve3h9L3t5fS5wYmYnO1xuZXhwb3J0IGNvbnN0IGZlYXR1cmVVUkxGb3JUaWxlc2V0TmFtZSA9ICh0aWxlc2V0TmFtZSA6c3RyaW5nICkgOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYCR7RkVBVFVSRV9USUxFX0JBU0VfVVJMfS8ke3RpbGVzZXROYW1lfS8ke1hZWl9TVUZGSVh9YDtcbn07XG5leHBvcnQgY29uc3QgRkVBVFVSRV9USUxFX0hJR0hfWk9PTV9VUkwgPSBmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUoJzA3MTRfaGlnaCcpO1xuZXhwb3J0IGNvbnN0IEZFQVRVUkVfVElMRV9MT1dfWk9PTV9VUkwgPSBmZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUoJ3RpbGVzX2xvdycpO1xuXG5cbi8vIFBlcmZvcm1hbmNlIG1hcmtlcnNcbmV4cG9ydCBjb25zdCBQRVJGT1JNQU5DRV9NQVJLRVJfTUFQX0lETEUgPSAnTUFQX0lETEUnO1xuXG4vLyBQcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgU0NPUkVfUFJPUEVSVFlfSElHSCA9ICdTY29yZSBEIChwZXJjZW50aWxlKSc7XG5leHBvcnQgY29uc3QgU0NPUkVfUFJPUEVSVFlfTE9XID0gJ0RfU0NPUkUnO1xuZXhwb3J0IGNvbnN0IEdFT0lEX1BST1BFUlRZID0gJ0dFT0lEMTAnO1xuZXhwb3J0IGNvbnN0IEhJR0hfU0NPUkVfU09VUkNFX05BTUUgPSAnc2NvcmUtaGlnaCc7XG5leHBvcnQgY29uc3QgSElHSF9TQ09SRV9MQVlFUl9OQU1FID0gJ3Njb3JlLWhpZ2gtbGF5ZXInO1xuZXhwb3J0IGNvbnN0IExPV19TQ09SRV9TT1VSQ0VfTkFNRSA9ICdzY29yZS1sb3cnO1xuZXhwb3J0IGNvbnN0IExPV19TQ09SRV9MQVlFUl9OQU1FID0gJ3Njb3JlLWxvdy1sYXllcic7XG5leHBvcnQgY29uc3QgU0VMRUNURURfUFJPUEVSVFkgPSAnc2VsZWN0ZWQnO1xuXG4vLyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXIgd2l0aGluIHRoZSB0aWxlcyB0aGF0IGNvbnRhaW5zIHRoZSBzY29yZVxuZXhwb3J0IGNvbnN0IFNDT1JFX1NPVVJDRV9MQVlFUiA9ICdibG9ja3MnO1xuXG5leHBvcnQgdHlwZSBKNDBQcm9wZXJ0aWVzID0geyBba2V5OiBzdHJpbmddOiBhbnkgfTtcblxuXG4vLyBab29tXG5leHBvcnQgY29uc3QgR0xPQkFMX01JTl9aT09NID0gMztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT00gPSAyMjtcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUlOX1pPT01fTE9XID0gMztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT01fTE9XID0gNztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUlOX1pPT01fSElHSExJR0hUID0gOTtcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT01fSElHSExJR0hUID0gMjI7XG5leHBvcnQgY29uc3QgR0xPQkFMX01JTl9aT09NX0hJR0ggPSA3O1xuZXhwb3J0IGNvbnN0IEdMT0JBTF9NQVhfWk9PTV9ISUdIID0gMTE7XG5cbi8vIEJvdW5kc1xuZXhwb3J0IGNvbnN0IEdMT0JBTF9NQVhfQk9VTkRTIDogTG5nTGF0Qm91bmRzTGlrZSA9IFtcbiAgWy0xODAuMTE4MzA2LCA1LjQ5OTU1MF0sXG4gIFstNjUuMCwgODMuMTYyMTAyXSxcbl07XG5cbmV4cG9ydCBjb25zdCBMT1dFUl80OF9CT1VORFMgOiBMbmdMYXRCb3VuZHNMaWtlID0gW1xuICBbLTEyNC43ODQ0MDc5LCAyNC43NDMzMTk1XSxcbiAgWy02Ni45NTEzODEyLCA0OS4zNDU3ODY4XSxcbl07XG5cbmV4cG9ydCBjb25zdCBBTEFTS0FfQk9VTkRTIDogTG5nTGF0Qm91bmRzTGlrZSA9IFtcbiAgWy0xODMuODU2ODg4LCA1MC44NzUzMTFdLFxuICBbLTE0MC45MzI2MTcsIDcxLjk1ODc5N10sXG5dO1xuXG5leHBvcnQgY29uc3QgSEFXQUlJX0JPVU5EUyA6IExuZ0xhdEJvdW5kc0xpa2UgPSBbXG4gIFstMTY4LjExODMwNiwgMTguNzQ4MTE1XSxcbiAgWy0xNTQuNzU3ODgxLCAyMi4zNzg0MTNdLFxuXTtcblxuZXhwb3J0IGNvbnN0IFBVRVJUT19SSUNPX0JPVU5EUyA6IExuZ0xhdEJvdW5kc0xpa2UgPSBbXG4gIFstNjcuOTQ1NDA0LCAxNy44ODMyOF0sXG4gIFstNjUuMjIwNzAzLCAxOC41MTU2ODNdLFxuXTtcblxuZXhwb3J0IGNvbnN0IEdVQU1fQk9VTkRTIDogTG5nTGF0Qm91bmRzTGlrZSA9IFtcbiAgWy0yMTUuMzg5NzA5LCAxMy4yMjU5MDldLFxuICBbLTIxNS4wNDA4OTQsIDEzLjY2MzMzNV0sXG5dO1xuXG5leHBvcnQgY29uc3QgTUFSSUFOQV9JU0xBTkRfQk9VTkRTIDogTG5nTGF0Qm91bmRzTGlrZSA9IFtcbiAgWy0yMTUuMzEzNDQ5LCAxNC4wMDc4MDFdLFxuICBbLTIxMy43NDI0MDQsIDE5Ljc1MDMyNl0sXG5dO1xuXG5leHBvcnQgY29uc3QgQU1FUklDQU5fU0FNT0FfQk9VTkRTIDogTG5nTGF0Qm91bmRzTGlrZSA9IFtcbiAgWy0xNzEuMDg5ODc0LCAtMTQuNTQ4Njk5XSxcbiAgWy0xNjguMTQzMywgLTExLjA0NjkzNF0sXG5dO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9DRU5URVIgPSBbMzIuNDY4NzEyNiwgLTg2LjUwMjEzNl07XG5cbi8vIE9wYWNpdHlcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xBWUVSX09QQUNJVFkgPSAwLjY7XG5cbi8vIENvbG9yc1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1VUTElORV9DT0xPUiA9ICcjNEVBNUNGJztcbmV4cG9ydCBjb25zdCBNSU5fQ09MT1IgPSAnI0ZGRkZGRic7XG5leHBvcnQgY29uc3QgTUVEX0NPTE9SID0gJyNEMURBRTYnO1xuZXhwb3J0IGNvbnN0IE1BWF9DT0xPUiA9ICcjNzY4RkIzJztcbmV4cG9ydCBjb25zdCBCT1JERVJfSElHSExJR0hUX0NPTE9SID0gJyMwMEJERTMnO1xuXG4vLyBXaWR0aHNcbmV4cG9ydCBjb25zdCBISUdITElHSFRfQk9SREVSX1dJRFRIID0gNS4wO1xuXG4vLyBTY29yZSBib3VuZGFyaWVzXG5leHBvcnQgY29uc3QgU0NPUkVfQk9VTkRBUllfTE9XID0gMC4wO1xuZXhwb3J0IGNvbnN0IFNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRCA9IDAuNjtcbmV4cG9ydCBjb25zdCBTQ09SRV9CT1VOREFSWV9QUklPUklUSVpFRCA9IDAuNzU7XG5cbmV4cG9ydCBjb25zdCBpc01vYmlsZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDQwMCk7XG4iLCJpbXBvcnQge1N0eWxlLCBGaWxsUGFpbnR9IGZyb20gJ21hcGxpYnJlLWdsJztcbmltcG9ydCBjaHJvbWEgZnJvbSAnY2hyb21hLWpzJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9kYXRhL2NvbnN0YW50cyc7XG5pbXBvcnQge0ZsYWdDb250YWluZXJ9IGZyb20gJy4uL2NvbnRleHRzL0ZsYWdDb250ZXh0JztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIGhleFRvSFNMQShoZXg6c3RyaW5nLCBhbHBoYTpudW1iZXIpIHtcbiAgcmV0dXJuIGNocm9tYShoZXgpLmFscGhhKGFscGhhKS5jc3MoJ2hzbCcpO1xufVxuXG4vKipcbiAqIGBNYWtlUGFpbnRgIGdlbmVyYXRlcyBhIHpvb20tZmFkZWQgTWFwbGlicmUgc3R5bGUgZm9ybWF0dGVkIGxheWVyIGdpdmVuIGEgc2V0IG9mIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIDogdGhlIGZpZWxkIHdpdGhpbiB0aGUgZGF0YSB0byBjb25zdWx0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmFtcCA6IHRoZSBtaW5pbXVtIHZhbHVlIHRoaXMgY2FuIGFzc3VtZVxuICogQHBhcmFtIHtudW1iZXJ9IG1lZFJhbXAgOiB0aGUgbWVkaXVtIHZhbHVlIHRoaXMgY2FuIGFzc3VtZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJhbXAgOiB0aGUgbWF4aW11bSB2YWx1ZSB0aGlzIGNhbiBhc3N1bWVcbiAqIEByZXR1cm4ge0ZpbGxQYWludH0gYSBtYXBsaWJyZWdsIGZpbGwgbGF5ZXJcbiAqKi9cbmZ1bmN0aW9uIG1ha2VQYWludCh7XG4gIGZpZWxkLFxuICBtaW5SYW1wLFxuICBtZWRSYW1wLFxuICBtYXhSYW1wLFxufToge1xuICAgIGZpZWxkOiBzdHJpbmc7XG4gICAgbWluUmFtcDogbnVtYmVyO1xuICAgIG1lZFJhbXA6IG51bWJlcjtcbiAgICBtYXhSYW1wOiBudW1iZXI7XG4gIH0pOiBGaWxsUGFpbnQge1xuICBjb25zdCBwYWludERlc2NyaXB0b3IgOiBGaWxsUGFpbnQgPSB7XG4gICAgJ2ZpbGwtY29sb3InOiBbXG4gICAgICAnc3RlcCcsXG4gICAgICBbJ2dldCcsIGZpZWxkXSxcbiAgICAgIGhleFRvSFNMQShjb25zdGFudHMuTUlOX0NPTE9SLCBjb25zdGFudHMuREVGQVVMVF9MQVlFUl9PUEFDSVRZICksXG4gICAgICBtaW5SYW1wLFxuICAgICAgaGV4VG9IU0xBKGNvbnN0YW50cy5NSU5fQ09MT1IsIGNvbnN0YW50cy5ERUZBVUxUX0xBWUVSX09QQUNJVFkgKSxcbiAgICAgIG1lZFJhbXAsXG4gICAgICBoZXhUb0hTTEEoY29uc3RhbnRzLk1FRF9DT0xPUiwgY29uc3RhbnRzLkRFRkFVTFRfTEFZRVJfT1BBQ0lUWSApLFxuICAgICAgbWF4UmFtcCxcbiAgICAgIGhleFRvSFNMQShjb25zdGFudHMuTUFYX0NPTE9SLCBjb25zdGFudHMuREVGQVVMVF9MQVlFUl9PUEFDSVRZICksXG4gICAgXSxcbiAgfTtcbiAgcmV0dXJuIHBhaW50RGVzY3JpcHRvcjtcbn1cblxuY29uc3QgaW1hZ2VTdWZmaXggPSBjb25zdGFudHMuaXNNb2JpbGUgPyAnJyA6ICdAMngnO1xuXG5leHBvcnQgY29uc3QgbWFrZU1hcFN0eWxlID0gKGZsYWdDb250YWluZXI6IEZsYWdDb250YWluZXIpIDogU3R5bGUgPT4ge1xuICByZXR1cm4ge1xuICAgICd2ZXJzaW9uJzogOCxcbiAgICAnc291cmNlcyc6IHtcbiAgICAgICdjYXJ0byc6IHtcbiAgICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICAgJ3RpbGVzJzpcbiAgICAgIFtcbiAgICAgICAgYGh0dHBzOi8vYS5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ke2ltYWdlU3VmZml4fS5wbmdgLFxuICAgICAgICBgaHR0cHM6Ly9iLmJhc2VtYXBzLmNhcnRvY2RuLmNvbS9saWdodF9ub2xhYmVscy97en0ve3h9L3t5fSR7aW1hZ2VTdWZmaXh9LnBuZ2AsXG4gICAgICAgIGBodHRwczovL2MuYmFzZW1hcHMuY2FydG9jZG4uY29tL2xpZ2h0X25vbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgYGh0dHBzOi8vZC5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ke2ltYWdlU3VmZml4fS5wbmdgLFxuICAgICAgXSxcbiAgICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NLFxuICAgICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgICB9LFxuICAgICAgJ2dlbyc6IHtcbiAgICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICAgJ3RpbGVzJzogW1xuICAgICAgICAgICdodHRwczovL210MC5nb29nbGUuY29tL3Z0L2x5cnM9cCZobD1lbiZ4PXt4fSZ5PXt5fSZ6PXt6fScsXG4gICAgICAgIF0sXG4gICAgICAgICdtaW56b29tJzogY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTSxcbiAgICAgICAgJ21heHpvb20nOiBjb25zdGFudHMuR0xPQkFMX01BWF9aT09NLFxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuSElHSF9TQ09SRV9TT1VSQ0VfTkFNRV06IHtcbiAgICAgIC8vIFwiU2NvcmUtaGlnaFwiIHJlcHJlc2VudHMgdGhlIGZ1bGwgc2V0IG9mIGRhdGFcbiAgICAgIC8vIGF0IHRoZSBjZW5zdXMgYmxvY2sgZ3JvdXAgbGV2ZWwuIEl0IGlzIG9ubHkgc2hvd25cbiAgICAgIC8vIGF0IGhpZ2ggem9vbSBsZXZlbHMgdG8gYXZvaWQgcGVyZm9ybWFuY2UgaXNzdWVzIGF0IGxvd2VyIHpvb21zXG4gICAgICAgICd0eXBlJzogJ3ZlY3RvcicsXG4gICAgICAgIC8vIE91ciBjdXJyZW50IHRpcHBlY2Fub2UgY29tbWFuZCBkb2VzIG5vdCBzZXQgYW4gaWQuXG4gICAgICAgIC8vIFRoZSBiZWxvdyBsaW5lIHByb21vdGVzIHRoZSBHRU9JRDEwIHByb3BlcnR5IHRvIHRoZSBJRFxuICAgICAgICAncHJvbW90ZUlkJzogY29uc3RhbnRzLkdFT0lEX1BST1BFUlRZLFxuICAgICAgICAndGlsZXMnOiBbXG4gICAgICAgICAgJ2hpZ2hfdGlsZXMnIGluIGZsYWdDb250YWluZXIgP1xuICAgICAgICAgIGNvbnN0YW50cy5mZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUoZmxhZ0NvbnRhaW5lclsnaGlnaF90aWxlcyddKSA6XG4gICAgICAgICAgY29uc3RhbnRzLkZFQVRVUkVfVElMRV9ISUdIX1pPT01fVVJMLFxuICAgICAgICBdLFxuICAgICAgICAvLyBTZWV0aW5nIG1heHpvb20gaGVyZSBlbmFibGVzICdvdmVyem9vbWluZydcbiAgICAgICAgLy8gZS5nLiBjb250aW51ZWQgem9vbWluZyBiZXlvbmQgdGhlIG1heCBib3VuZHMuXG4gICAgICAgIC8vIE1vcmUgaGVyZTogaHR0cHM6Ly9kb2NzLm1hcGJveC5jb20vaGVscC9nbG9zc2FyeS9vdmVyem9vbS9cbiAgICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0gsXG4gICAgICAgICdtYXh6b29tJzogY29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9ISUdILFxuICAgICAgfSxcbiAgICAgIFtjb25zdGFudHMuTE9XX1NDT1JFX1NPVVJDRV9OQU1FXToge1xuICAgICAgLy8gXCJTY29yZS1sb3dcIiByZXByZXNlbnRzIGEgdGlsZXNldCBhdCB0aGUgbGV2ZWwgb2YgYnVja2V0ZWQgdHJhY3RzLlxuICAgICAgLy8gY2Vuc3VzIGJsb2NrIGdyb3VwIGluZm9ybWF0aW9uIGlzIGBkaXNzb2x2ZWBkIGludG8gdHJhY3RzLCB0aGVuXG4gICAgICAvLyBlYWNoIHRyYWN0IGlzIGBkaXNzb2x2ZWBkIGludG8gb25lIG9mIHRlbiBidWNrZXRzLiBJdCBpcyBtZWFudFxuICAgICAgLy8gdG8gZ2l2ZSB1cyBhIGZhdm9yYWJsZSB0cmFkZW9mZiBiZXR3ZWVuIHBlcmZvcm1hbmNlIGFuZCBmaWRlbGl0eS5cbiAgICAgICAgJ3R5cGUnOiAndmVjdG9yJyxcbiAgICAgICAgJ3Byb21vdGVJZCc6IGNvbnN0YW50cy5HRU9JRF9QUk9QRVJUWSxcbiAgICAgICAgJ3RpbGVzJzogW1xuICAgICAgICAgICdsb3dfdGlsZXMnIGluIGZsYWdDb250YWluZXIgP1xuICAgICAgICAgIGNvbnN0YW50cy5mZWF0dXJlVVJMRm9yVGlsZXNldE5hbWUoZmxhZ0NvbnRhaW5lclsnbG93X3RpbGVzJ10pIDpcbiAgICAgICAgICBjb25zdGFudHMuRkVBVFVSRV9USUxFX0xPV19aT09NX1VSTCxcbiAgICAgICAgLy8gRm9yIGxvY2FsIGRldmVsb3BtZW50LCB1c2U6XG4gICAgICAgIC8vICdodHRwOi8vbG9jYWxob3N0OjgwODAvZGF0YS90bF8yMDEwX2JnX3dpdGhfZGF0YS97en0ve3h9L3t5fS5wYmYnLFxuICAgICAgICBdLFxuICAgICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fTE9XLFxuICAgICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fTE9XLFxuICAgICAgfSxcbiAgICAgICdsYWJlbHMnOiB7XG4gICAgICAgICd0eXBlJzogJ3Jhc3RlcicsXG4gICAgICAgICd0aWxlcyc6IFtcbiAgICAgICAgICBgaHR0cHM6Ly9jYXJ0b2RiLWJhc2VtYXBzLWEuZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X29ubHlfbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgICBgaHR0cHM6Ly9jYXJ0b2RiLWJhc2VtYXBzLWIuZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X29ubHlfbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgICBgaHR0cHM6Ly9jYXJ0b2RiLWJhc2VtYXBzLWMuZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X29ubHlfbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgICBgaHR0cHM6Ly9jYXJ0b2RiLWJhc2VtYXBzLWQuZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X29ubHlfbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICAnbGF5ZXJzJzogW1xuICAgICAge1xuICAgICAgICAnaWQnOiAnY2FydG8nLFxuICAgICAgICAnc291cmNlJzogJ2NhcnRvJyxcbiAgICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NLFxuICAgICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAnaWQnOiAnZ2VvJyxcbiAgICAgICAgJ3NvdXJjZSc6ICdnZW8nLFxuICAgICAgICAndHlwZSc6ICdyYXN0ZXInLFxuICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAvLyBNYWtlIHRoZSBsYXllciBpbnZpc2libGUgYnkgZGVmYXVsdC5cbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICdub25lJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NLFxuICAgICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAnaWQnOiBjb25zdGFudHMuSElHSF9TQ09SRV9MQVlFUl9OQU1FLFxuICAgICAgICAnc291cmNlJzogY29uc3RhbnRzLkhJR0hfU0NPUkVfU09VUkNFX05BTUUsXG4gICAgICAgICdzb3VyY2UtbGF5ZXInOiBjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSLFxuICAgICAgICAndHlwZSc6ICdmaWxsJyxcbiAgICAgICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgICAgICBbJz4nLCBjb25zdGFudHMuU0NPUkVfUFJPUEVSVFlfSElHSCwgY29uc3RhbnRzLlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRF0sXG4gICAgICAgIF0sXG4gICAgICAgICdwYWludCc6IG1ha2VQYWludCh7XG4gICAgICAgICAgZmllbGQ6IGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWV9ISUdILFxuICAgICAgICAgIG1pblJhbXA6IGNvbnN0YW50cy5TQ09SRV9CT1VOREFSWV9MT1csXG4gICAgICAgICAgbWVkUmFtcDogY29uc3RhbnRzLlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRCxcbiAgICAgICAgICBtYXhSYW1wOiBjb25zdGFudHMuU0NPUkVfQk9VTkRBUllfUFJJT1JJVElaRUQsXG4gICAgICAgIH0pLFxuICAgICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICdpZCc6IGNvbnN0YW50cy5MT1dfU0NPUkVfTEFZRVJfTkFNRSxcbiAgICAgICAgJ3NvdXJjZSc6IGNvbnN0YW50cy5MT1dfU0NPUkVfU09VUkNFX05BTUUsXG4gICAgICAgICdzb3VyY2UtbGF5ZXInOiBjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSLFxuICAgICAgICAndHlwZSc6ICdmaWxsJyxcbiAgICAgICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgICAgICBbJz4nLCBjb25zdGFudHMuU0NPUkVfUFJPUEVSVFlfTE9XLCBjb25zdGFudHMuU0NPUkVfQk9VTkRBUllfVEhSRVNIT0xEXSxcbiAgICAgICAgXSxcbiAgICAgICAgJ3BhaW50JzogbWFrZVBhaW50KHtcbiAgICAgICAgICBmaWVsZDogY29uc3RhbnRzLlNDT1JFX1BST1BFUlRZX0xPVyxcbiAgICAgICAgICBtaW5SYW1wOiBjb25zdGFudHMuU0NPUkVfQk9VTkRBUllfTE9XLFxuICAgICAgICAgIG1lZFJhbXA6IGNvbnN0YW50cy5TQ09SRV9CT1VOREFSWV9USFJFU0hPTEQsXG4gICAgICAgICAgbWF4UmFtcDogY29uc3RhbnRzLlNDT1JFX0JPVU5EQVJZX1BSSU9SSVRJWkVELFxuICAgICAgICB9KSxcbiAgICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0xPVyxcbiAgICAgICAgJ21heHpvb20nOiBjb25zdGFudHMuR0xPQkFMX01BWF9aT09NX0xPVyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAvLyBcIlNjb3JlLWhpZ2hsaWdodHNcIiByZXByZXNlbnRzIHRoZSBib3JkZXJcbiAgICAgIC8vIGFyb3VuZCBnaXZlbiB0aWxlcyB0aGF0IGFwcGVhcnMgYXQgaGlnaGVyIHpvb21zXG4gICAgICAgICdpZCc6ICdzY29yZS1oaWdobGlnaHRzLWxheWVyJyxcbiAgICAgICAgJ3NvdXJjZSc6IGNvbnN0YW50cy5ISUdIX1NDT1JFX1NPVVJDRV9OQU1FLFxuICAgICAgICAnc291cmNlLWxheWVyJzogY29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUixcbiAgICAgICAgJ3R5cGUnOiAnbGluZScsXG4gICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCcsXG4gICAgICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICdsaW5lLWNvbG9yJzogY29uc3RhbnRzLkRFRkFVTFRfT1VUTElORV9DT0xPUixcbiAgICAgICAgICAnbGluZS13aWR0aCc6IDAuOCxcbiAgICAgICAgICAnbGluZS1vcGFjaXR5JzogMC41LFxuICAgICAgICB9LFxuICAgICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSExJR0hULFxuICAgICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fSElHSExJR0hULFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgIC8vIFwic2NvcmUtYm9yZGVyLWhpZ2hsaWdodFwiIGlzIHVzZWQgdG8gaGlnaGxpZ2h0XG4gICAgICAvLyB0aGUgY3VycmVudGx5LXNlbGVjdGVkIGZlYXR1cmVcbiAgICAgICAgJ2lkJzogJ3Njb3JlLWJvcmRlci1oaWdobGlnaHQtbGF5ZXInLFxuICAgICAgICAndHlwZSc6ICdsaW5lJyxcbiAgICAgICAgJ3NvdXJjZSc6IGNvbnN0YW50cy5ISUdIX1NDT1JFX1NPVVJDRV9OQU1FLFxuICAgICAgICAnc291cmNlLWxheWVyJzogY29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUixcbiAgICAgICAgJ2xheW91dCc6IHt9LFxuICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgJ2xpbmUtY29sb3InOiBjb25zdGFudHMuQk9SREVSX0hJR0hMSUdIVF9DT0xPUixcbiAgICAgICAgICAnbGluZS13aWR0aCc6IFtcbiAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgIFsnYm9vbGVhbicsIFsnZmVhdHVyZS1zdGF0ZScsIGNvbnN0YW50cy5TRUxFQ1RFRF9QUk9QRVJUWV0sIGZhbHNlXSxcbiAgICAgICAgICAgIGNvbnN0YW50cy5ISUdITElHSFRfQk9SREVSX1dJRFRILFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAvLyBXZSBwdXQgbGFiZWxzIGxhc3QgdG8gZW5zdXJlIHByb21pbmVuY2VcbiAgICAgICAgJ2lkJzogJ2xhYmVscy1vbmx5LWxheWVyJyxcbiAgICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICAgJ3NvdXJjZSc6ICdsYWJlbHMnLFxuICAgICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gICAgICAgICdtYXh6b29tJzogY29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn07XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBhcmVhRGV0YWlsVGFibGUgPSBcImFyZWFEZXRhaWwtbW9kdWxlLS1hcmVhRGV0YWlsVGFibGUtLTFrVzU1XCI7XG5leHBvcnQgdmFyIHRpdGxlQ29udGFpbmVyID0gXCJhcmVhRGV0YWlsLW1vZHVsZS0tdGl0bGVDb250YWluZXItLTF0VUlOXCI7XG5leHBvcnQgdmFyIHRpdGxlSW5kaWNhdG9yTmFtZSA9IFwiYXJlYURldGFpbC1tb2R1bGUtLXRpdGxlSW5kaWNhdG9yTmFtZS0tdUFuRlZcIjtcbmV4cG9ydCB2YXIgYXJlYURldGFpbENvbnRhaW5lciA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWFyZWFEZXRhaWxDb250YWluZXItLTE1YWU5XCI7XG5leHBvcnQgdmFyIGFyZWFEZXRhaWxUYWJsZUNvbnRhaW5lciA9IFwiYXJlYURldGFpbC1tb2R1bGUtLWFyZWFEZXRhaWxUYWJsZUNvbnRhaW5lci0tMWw4Y3dcIjsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vYXJlYURldGFpbC5tb2R1bGUuc2Nzcyc7XG5cbmludGVyZmFjZSBJQXJlYURldGFpbFByb3BzIHtcbiAgcHJvcGVydGllczogY29uc3RhbnRzLko0MFByb3BlcnRpZXMsXG59XG5cblxuY29uc3QgQXJlYURldGFpbCA9ICh7cHJvcGVydGllc306SUFyZWFEZXRhaWxQcm9wcykgPT4ge1xuICBjb25zdCByZWFkYWJsZVBlcmNlbnQgPSAocGVyY2VudDogbnVtYmVyKSA9PiB7XG4gICAgcmV0dXJuIGAkeyhwZXJjZW50ICogMTAwKS50b0ZpeGVkKDIpfWA7XG4gIH07XG5cbiAgY29uc3QgZ2V0Q2F0ZWdvcml6YXRpb24gPSAocGVyY2VudGlsZTogbnVtYmVyKSA9PiB7XG4gICAgbGV0IGNhdGVnb3JpemF0aW9uO1xuICAgIGlmIChwZXJjZW50aWxlID49IDAuNzUgKSB7XG4gICAgICBjYXRlZ29yaXphdGlvbiA9ICdQcmlvcml0aXplZCc7XG4gICAgfSBlbHNlIGlmICgwLjYwIDw9IHBlcmNlbnRpbGUgJiYgcGVyY2VudGlsZSA8IDAuNzUpIHtcbiAgICAgIGNhdGVnb3JpemF0aW9uID0gJ1RocmVzaG9sZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhdGVnb3JpemF0aW9uID0gJ05vbi1wcmlvcml0aXplZCc7XG4gICAgfVxuICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbiAgfTtcblxuICBjb25zdCBnZXRUaXRsZUNvbnRlbnQgPSAoKSA9PiB7XG4gICAgY29uc3QgYmxvY2tHcm91cCA9IHByb3BlcnRpZXNbY29uc3RhbnRzLkdFT0lEX1BST1BFUlRZXTtcbiAgICBjb25zdCBzY29yZSA9IHByb3BlcnRpZXNbY29uc3RhbnRzLlNDT1JFX1BST1BFUlRZX0hJR0hdIGFzIG51bWJlcjtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZUNvbnRhaW5lcn0+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMudGl0bGVJbmRpY2F0b3JOYW1lfT5DZW5zdXMgQmxvY2sgR3JvdXA6IDwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57YmxvY2tHcm91cH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlSW5kaWNhdG9yTmFtZX0+SnVzdCBQcm9ncmVzcyBDYXRlZ29yaXphdGlvbjogPC9zcGFuPlxuICAgICAgICAgIDxzcGFuPntnZXRDYXRlZ29yaXphdGlvbihzY29yZSl9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZUluZGljYXRvck5hbWV9PkN1bXVsYXRpdmUgSW5kZXggU2NvcmU6IDwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57cmVhZGFibGVQZXJjZW50KHNjb3JlKX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBnZXRCb2R5Q29udGVudCA9ICgpID0+IHtcbiAgICBjb25zdCByb3dzID0gW107XG4gICAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpLnNvcnQoKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc29ydGVkS2V5cykge1xuICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgZm9ybWF0IGZsb2F0c1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICAgIHZhbHVlID0gcmVhZGFibGVQZXJjZW50KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIG91dCBhbGwgY2Fwc1xuICAgICAgaWYgKCFrZXkubWF0Y2goL15bQS1aMC05XSskLykpIHtcbiAgICAgICAgcm93cy5wdXNoKDx0ciBrZXk9e2tleX0gPlxuICAgICAgICAgIDx0ZD57a2V5fTwvdGQ+XG4gICAgICAgICAgPHRkPnt2YWx1ZX08L3RkPlxuICAgICAgICA8L3RyPik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuXG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3Byb3BlcnRpZXMgP1xuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcmVhRGV0YWlsQ29udGFpbmVyfT5cbiAgICAgICAge2dldFRpdGxlQ29udGVudCgpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFyZWFEZXRhaWxUYWJsZUNvbnRhaW5lcn0+XG4gICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT17J3VzYS10YWJsZSB1c2EtdGFibGUtLWJvcmRlcmxlc3MgJyArIHN0eWxlcy5hcmVhRGV0YWlsVGFibGV9PlxuICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+SU5ESUNBVE9SPC90aD5cbiAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5WQUxVRTwvdGg+XG4gICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICB7Z2V0Qm9keUNvbnRlbnQoKX1cbiAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj4gOlxuICAgICcnIH1cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFyZWFEZXRhaWw7XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVyc1xuICovXG5cbi8qKlxuICogRWFydGggUmFkaXVzIHVzZWQgd2l0aCB0aGUgSGFydmVzaW5lIGZvcm11bGEgYW5kIGFwcHJveGltYXRlcyB1c2luZyBhIHNwaGVyaWNhbCAobm9uLWVsbGlwc29pZCkgRWFydGguXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgZWFydGhSYWRpdXMgPSA2MzcxMDA4Ljg7XG4vKipcbiAqIFVuaXQgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyB1c2luZyBhIHNwaGVyaWNhbCAobm9uLWVsbGlwc29pZCkgZWFydGggcmFkaXVzLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCB2YXIgZmFjdG9ycyA9IHtcbiAgY2VudGltZXRlcnM6IGVhcnRoUmFkaXVzICogMTAwLFxuICBjZW50aW1ldHJlczogZWFydGhSYWRpdXMgKiAxMDAsXG4gIGRlZ3JlZXM6IGVhcnRoUmFkaXVzIC8gMTExMzI1LFxuICBmZWV0OiBlYXJ0aFJhZGl1cyAqIDMuMjgwODQsXG4gIGluY2hlczogZWFydGhSYWRpdXMgKiAzOS4zNyxcbiAga2lsb21ldGVyczogZWFydGhSYWRpdXMgLyAxMDAwLFxuICBraWxvbWV0cmVzOiBlYXJ0aFJhZGl1cyAvIDEwMDAsXG4gIG1ldGVyczogZWFydGhSYWRpdXMsXG4gIG1ldHJlczogZWFydGhSYWRpdXMsXG4gIG1pbGVzOiBlYXJ0aFJhZGl1cyAvIDE2MDkuMzQ0LFxuICBtaWxsaW1ldGVyczogZWFydGhSYWRpdXMgKiAxMDAwLFxuICBtaWxsaW1ldHJlczogZWFydGhSYWRpdXMgKiAxMDAwLFxuICBuYXV0aWNhbG1pbGVzOiBlYXJ0aFJhZGl1cyAvIDE4NTIsXG4gIHJhZGlhbnM6IDEsXG4gIHlhcmRzOiBlYXJ0aFJhZGl1cyAqIDEuMDkzNlxufTtcbi8qKlxuICogVW5pdHMgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCB2YXIgdW5pdHNGYWN0b3JzID0ge1xuICBjZW50aW1ldGVyczogMTAwLFxuICBjZW50aW1ldHJlczogMTAwLFxuICBkZWdyZWVzOiAxIC8gMTExMzI1LFxuICBmZWV0OiAzLjI4MDg0LFxuICBpbmNoZXM6IDM5LjM3LFxuICBraWxvbWV0ZXJzOiAxIC8gMTAwMCxcbiAga2lsb21ldHJlczogMSAvIDEwMDAsXG4gIG1ldGVyczogMSxcbiAgbWV0cmVzOiAxLFxuICBtaWxlczogMSAvIDE2MDkuMzQ0LFxuICBtaWxsaW1ldGVyczogMTAwMCxcbiAgbWlsbGltZXRyZXM6IDEwMDAsXG4gIG5hdXRpY2FsbWlsZXM6IDEgLyAxODUyLFxuICByYWRpYW5zOiAxIC8gZWFydGhSYWRpdXMsXG4gIHlhcmRzOiAxLjA5MzYxMzNcbn07XG4vKipcbiAqIEFyZWEgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIHNxdWFyZSBtZXRlci5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5leHBvcnQgdmFyIGFyZWFGYWN0b3JzID0ge1xuICBhY3JlczogMC4wMDAyNDcxMDUsXG4gIGNlbnRpbWV0ZXJzOiAxMDAwMCxcbiAgY2VudGltZXRyZXM6IDEwMDAwLFxuICBmZWV0OiAxMC43NjM5MTA0MTcsXG4gIGhlY3RhcmVzOiAwLjAwMDEsXG4gIGluY2hlczogMTU1MC4wMDMxMDAwMDYsXG4gIGtpbG9tZXRlcnM6IDAuMDAwMDAxLFxuICBraWxvbWV0cmVzOiAwLjAwMDAwMSxcbiAgbWV0ZXJzOiAxLFxuICBtZXRyZXM6IDEsXG4gIG1pbGVzOiAzLjg2ZS03LFxuICBtaWxsaW1ldGVyczogMTAwMDAwMCxcbiAgbWlsbGltZXRyZXM6IDEwMDAwMDAsXG4gIHlhcmRzOiAxLjE5NTk5MDA0NlxufTtcbi8qKlxuICogV3JhcHMgYSBHZW9KU09OIHtAbGluayBHZW9tZXRyeX0gaW4gYSBHZW9KU09OIHtAbGluayBGZWF0dXJlfS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBpbnB1dCBnZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlfSBhIEdlb0pTT04gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBnZW9tZXRyeSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgXCJjb29yZGluYXRlc1wiOiBbMTEwLCA1MF1cbiAqIH07XG4gKlxuICogdmFyIGZlYXR1cmUgPSB0dXJmLmZlYXR1cmUoZ2VvbWV0cnkpO1xuICpcbiAqIC8vPWZlYXR1cmVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgZmVhdCA9IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIlxuICB9O1xuXG4gIGlmIChvcHRpb25zLmlkID09PSAwIHx8IG9wdGlvbnMuaWQpIHtcbiAgICBmZWF0LmlkID0gb3B0aW9ucy5pZDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmJib3gpIHtcbiAgICBmZWF0LmJib3ggPSBvcHRpb25zLmJib3g7XG4gIH1cblxuICBmZWF0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICBmZWF0Lmdlb21ldHJ5ID0gZ2VvbTtcbiAgcmV0dXJuIGZlYXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBHZW9KU09OIHtAbGluayBHZW9tZXRyeX0gZnJvbSBhIEdlb21ldHJ5IHN0cmluZyB0eXBlICYgY29vcmRpbmF0ZXMuXG4gKiBGb3IgR2VvbWV0cnlDb2xsZWN0aW9uIHR5cGUgdXNlIGBoZWxwZXJzLmdlb21ldHJ5Q29sbGVjdGlvbmBcbiAqXG4gKiBAbmFtZSBnZW9tZXRyeVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgR2VvbWV0cnkgVHlwZVxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBjb29yZGluYXRlcyBDb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7R2VvbWV0cnl9IGEgR2VvSlNPTiBHZW9tZXRyeVxuICogQGV4YW1wbGVcbiAqIHZhciB0eXBlID0gXCJQb2ludFwiO1xuICogdmFyIGNvb3JkaW5hdGVzID0gWzExMCwgNTBdO1xuICogdmFyIGdlb21ldHJ5ID0gdHVyZi5nZW9tZXRyeSh0eXBlLCBjb29yZGluYXRlcyk7XG4gKiAvLyA9PiBnZW9tZXRyeVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeSh0eXBlLCBjb29yZGluYXRlcywgX29wdGlvbnMpIHtcbiAgaWYgKF9vcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBfb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuXG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcblxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICByZXR1cm4gcG9seWdvbihjb29yZGluYXRlcykuZ2VvbWV0cnk7XG5cbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgcmV0dXJuIG11bHRpUG9pbnQoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuXG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgcmV0dXJuIG11bHRpTGluZVN0cmluZyhjb29yZGluYXRlcykuZ2VvbWV0cnk7XG5cbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICByZXR1cm4gbXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIGludmFsaWRcIik7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYSBQb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBwb2ludFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBsb25naXR1ZGUsIGxhdGl0dWRlIHBvc2l0aW9uIChlYWNoIGluIGRlY2ltYWwgZGVncmVlcylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXBvaW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgaXMgcmVxdWlyZWRcIik7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgfVxuXG4gIGlmIChjb29yZGluYXRlcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhdCBsZWFzdCAyIG51bWJlcnMgbG9uZ1wiKTtcbiAgfVxuXG4gIGlmICghaXNOdW1iZXIoY29vcmRpbmF0ZXNbMF0pIHx8ICFpc051bWJlcihjb29yZGluYXRlc1sxXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGNvbnRhaW4gbnVtYmVyc1wiKTtcbiAgfVxuXG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9pbnR9IHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gZnJvbSBhbiBBcnJheSBvZiBQb2ludCBjb29yZGluYXRlcy5cbiAqXG4gKiBAbmFtZSBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBUcmFuc2xhdGUgdGhlc2UgcHJvcGVydGllcyB0byBlYWNoIEZlYXR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gUG9pbnQgRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludHMgPSB0dXJmLnBvaW50cyhbXG4gKiAgIFstNzUsIDM5XSxcbiAqICAgWy04MCwgNDVdLFxuICogICBbLTc4LCA1MF1cbiAqIF0pO1xuICpcbiAqIC8vPXBvaW50c1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHJldHVybiBwb2ludChjb29yZHMsIHByb3BlcnRpZXMpO1xuICB9KSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYW4gQXJyYXkgb2YgTGluZWFyUmluZ3MuXG4gKlxuICogQG5hbWUgcG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01LCA1Ml0sIFstNCwgNTZdLCBbLTIsIDUxXSwgWy03LCA1NF0sIFstNSwgNTJdXV0sIHsgbmFtZTogJ3BvbHkxJyB9KTtcbiAqXG4gKiAvLz1wb2x5Z29uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24oY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMCwgY29vcmRpbmF0ZXNfMSA9IGNvb3JkaW5hdGVzOyBfaSA8IGNvb3JkaW5hdGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHJpbmcgPSBjb29yZGluYXRlc18xW19pXTtcblxuICAgIGlmIChyaW5nLmxlbmd0aCA8IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVhY2ggTGluZWFyUmluZyBvZiBhIFBvbHlnb24gbXVzdCBoYXZlIDQgb3IgbW9yZSBQb3NpdGlvbnMuXCIpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZ1tyaW5nLmxlbmd0aCAtIDFdLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyBDaGVjayBpZiBmaXJzdCBwb2ludCBvZiBQb2x5Z29uIGNvbnRhaW5zIHR3byBudW1iZXJzXG4gICAgICBpZiAocmluZ1tyaW5nLmxlbmd0aCAtIDFdW2pdICE9PSByaW5nWzBdW2pdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFuZCBsYXN0IFBvc2l0aW9uIGFyZSBub3QgZXF1aXZhbGVudC5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFBvbHlnb259IHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gZnJvbSBhbiBBcnJheSBvZiBQb2x5Z29uIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lIHBvbHlnb25zXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvbHlnb24gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBQb2x5Z29uIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb25zID0gdHVyZi5wb2x5Z29ucyhbXG4gKiAgIFtbWy01LCA1Ml0sIFstNCwgNTZdLCBbLTIsIDUxXSwgWy03LCA1NF0sIFstNSwgNTJdXV0sXG4gKiAgIFtbWy0xNSwgNDJdLCBbLTE0LCA0Nl0sIFstMTIsIDQxXSwgWy0xNywgNDRdLCBbLTE1LCA0Ml1dXSxcbiAqIF0pO1xuICpcbiAqIC8vPXBvbHlnb25zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25zKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICByZXR1cm4gcG9seWdvbihjb29yZHMsIHByb3BlcnRpZXMpO1xuICB9KSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30ge0BsaW5rIEZlYXR1cmV9IGZyb20gYW4gQXJyYXkgb2YgUG9zaXRpb25zLlxuICpcbiAqIEBuYW1lIGxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBMaW5lU3RyaW5nIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZXN0cmluZzEgPSB0dXJmLmxpbmVTdHJpbmcoW1stMjQsIDYzXSwgWy0yMywgNjBdLCBbLTI1LCA2NV0sIFstMjAsIDY5XV0sIHtuYW1lOiAnbGluZSAxJ30pO1xuICogdmFyIGxpbmVzdHJpbmcyID0gdHVyZi5saW5lU3RyaW5nKFtbLTE0LCA0M10sIFstMTMsIDQwXSwgWy0xNSwgNDVdLCBbLTEwLCA0OV1dLCB7bmFtZTogJ2xpbmUgMid9KTtcbiAqXG4gKiAvLz1saW5lc3RyaW5nMVxuICogLy89bGluZXN0cmluZzJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR3byBvciBtb3JlIHBvc2l0aW9uc1wiKTtcbiAgfVxuXG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICB9O1xuICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGZyb20gYW4gQXJyYXkgb2YgTGluZVN0cmluZyBjb29yZGluYXRlcy5cbiAqXG4gKiBAbmFtZSBsaW5lU3RyaW5nc1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSBMaW5lU3RyaW5nIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmVzdHJpbmdzID0gdHVyZi5saW5lU3RyaW5ncyhbXG4gKiAgIFtbLTI0LCA2M10sIFstMjMsIDYwXSwgWy0yNSwgNjVdLCBbLTIwLCA2OV1dLFxuICogICBbWy0xNCwgNDNdLCBbLTEzLCA0MF0sIFstMTUsIDQ1XSwgWy0xMCwgNDldXVxuICogXSk7XG4gKlxuICogLy89bGluZXN0cmluZ3NcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ3MoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHJldHVybiBsaW5lU3RyaW5nKGNvb3JkcywgcHJvcGVydGllcyk7XG4gIH0pLCBvcHRpb25zKTtcbn1cbi8qKlxuICogVGFrZXMgb25lIG9yIG1vcmUge0BsaW5rIEZlYXR1cmV8RmVhdHVyZXN9IGFuZCBjcmVhdGVzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtGZWF0dXJlW119IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gRmVhdHVyZUNvbGxlY3Rpb24gb2YgRmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgbG9jYXRpb25BID0gdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSwge25hbWU6ICdMb2NhdGlvbiBBJ30pO1xuICogdmFyIGxvY2F0aW9uQiA9IHR1cmYucG9pbnQoWy03NS44MzMsIDM5LjI4NF0sIHtuYW1lOiAnTG9jYXRpb24gQid9KTtcbiAqIHZhciBsb2NhdGlvbkMgPSB0dXJmLnBvaW50KFstNzUuNTM0LCAzOS4xMjNdLCB7bmFtZTogJ0xvY2F0aW9uIEMnfSk7XG4gKlxuICogdmFyIGNvbGxlY3Rpb24gPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgbG9jYXRpb25BLFxuICogICBsb2NhdGlvbkIsXG4gKiAgIGxvY2F0aW9uQ1xuICogXSk7XG4gKlxuICogLy89Y29sbGVjdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGZjID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIlxuICB9O1xuXG4gIGlmIChvcHRpb25zLmlkKSB7XG4gICAgZmMuaWQgPSBvcHRpb25zLmlkO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgIGZjLmJib3ggPSBvcHRpb25zLmJib3g7XG4gIH1cblxuICBmYy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICByZXR1cm4gZmM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpTGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVTdHJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYSBNdWx0aUxpbmVTdHJpbmcgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1tbMCwwXSxbMTAsMTBdXV0pO1xuICpcbiAqIC8vPW11bHRpTGluZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2ludD59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlQb2ludFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2ludD59IGEgTXVsdGlQb2ludCBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVB0ID0gdHVyZi5tdWx0aVBvaW50KFtbMCwwXSxbMTAsMTBdXSk7XG4gKlxuICogLy89bXVsdGlQdFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aVBvaW50KGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgZ2VvbSA9IHtcbiAgICB0eXBlOiBcIk11bHRpUG9pbnRcIixcbiAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgfTtcbiAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvbHlnb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9seWdvbj59IGEgbXVsdGlwb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtbW1swLDBdLFswLDEwXSxbMTAsMTBdLFsxMCwwXSxbMCwwXV1dXSk7XG4gKlxuICogLy89bXVsdGlQb2x5XG4gKlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBnZW9tID0ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8R2VvbWV0cnk+fSBnZW9tZXRyaWVzIGFuIGFycmF5IG9mIEdlb0pTT04gR2VvbWV0cmllc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPEdlb21ldHJ5Q29sbGVjdGlvbj59IGEgR2VvSlNPTiBHZW9tZXRyeUNvbGxlY3Rpb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHR1cmYuZ2VvbWV0cnkoXCJQb2ludFwiLCBbMTAwLCAwXSk7XG4gKiB2YXIgbGluZSA9IHR1cmYuZ2VvbWV0cnkoXCJMaW5lU3RyaW5nXCIsIFtbMTAxLCAwXSwgWzEwMiwgMV1dKTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeUNvbGxlY3Rpb24oW3B0LCBsaW5lXSk7XG4gKlxuICogLy8gPT4gY29sbGVjdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGdlb20gPSB7XG4gICAgdHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcbiAgICBnZW9tZXRyaWVzOiBnZW9tZXRyaWVzXG4gIH07XG4gIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBSb3VuZCBudW1iZXIgdG8gcHJlY2lzaW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFByZWNpc2lvblxuICogQHJldHVybnMge251bWJlcn0gcm91bmRlZCBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB0dXJmLnJvdW5kKDEyMC40MzIxKVxuICogLy89MTIwXG4gKlxuICogdHVyZi5yb3VuZCgxMjAuNDMyMSwgMilcbiAqIC8vPTEyMC40M1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChudW0sIHByZWNpc2lvbikge1xuICBpZiAocHJlY2lzaW9uID09PSB2b2lkIDApIHtcbiAgICBwcmVjaXNpb24gPSAwO1xuICB9XG5cbiAgaWYgKHByZWNpc2lvbiAmJiAhKHByZWNpc2lvbiA+PSAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByZWNpc2lvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG5cbiAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDApO1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gcmFkaWFucyB0byBhIG1vcmUgZnJpZW5kbHkgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgcmFkaWFuc1RvTGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBpbiByYWRpYW5zIGFjcm9zcyB0aGUgc3BoZXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPVwia2lsb21ldGVyc1wiXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnNUb0xlbmd0aChyYWRpYW5zLCB1bml0cykge1xuICBpZiAodW5pdHMgPT09IHZvaWQgMCkge1xuICAgIHVuaXRzID0gXCJraWxvbWV0ZXJzXCI7XG4gIH1cblxuICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0c107XG5cbiAgaWYgKCFmYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodW5pdHMgKyBcIiB1bml0cyBpcyBpbnZhbGlkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJhZGlhbnMgKiBmYWN0b3I7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byByYWRpYW5zXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBraWxvbWV0ZXJzLCBjZW50aW1ldGVycywgZmVldFxuICpcbiAqIEBuYW1lIGxlbmd0aFRvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gcmFkaWFuc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKSB7XG4gIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7XG4gICAgdW5pdHMgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuXG4gIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzXTtcblxuICBpZiAoIWZhY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcih1bml0cyArIFwiIHVuaXRzIGlzIGludmFsaWRcIik7XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byBkZWdyZWVzXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBjZW50aW1ldGVycywga2lsb21ldHJlcywgZmVldFxuICpcbiAqIEBuYW1lIGxlbmd0aFRvRGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gZGVncmVlc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhUb0RlZ3JlZXMoZGlzdGFuY2UsIHVuaXRzKSB7XG4gIHJldHVybiByYWRpYW5zVG9EZWdyZWVzKGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW55IGJlYXJpbmcgYW5nbGUgZnJvbSB0aGUgbm9ydGggbGluZSBkaXJlY3Rpb24gKHBvc2l0aXZlIGNsb2Nrd2lzZSlcbiAqIGFuZCByZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gMC0zNjAgZGVncmVlcyAocG9zaXRpdmUgY2xvY2t3aXNlKSwgMCBiZWluZyB0aGUgbm9ydGggbGluZVxuICpcbiAqIEBuYW1lIGJlYXJpbmdUb0F6aW11dGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIGFuZ2xlLCBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlc1xuICogQHJldHVybnMge251bWJlcn0gYW5nbGUgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZWFyaW5nVG9BemltdXRoKGJlYXJpbmcpIHtcbiAgdmFyIGFuZ2xlID0gYmVhcmluZyAlIDM2MDtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gMzYwO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhbmdsZSBpbiByYWRpYW5zIHRvIGRlZ3JlZXNcbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9EZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHZhciBkZWdyZWVzID0gcmFkaWFucyAlICgyICogTWF0aC5QSSk7XG4gIHJldHVybiBkZWdyZWVzICogMTgwIC8gTWF0aC5QSTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYW5nbGUgaW4gZGVncmVlcyB0byByYWRpYW5zXG4gKlxuICogQG5hbWUgZGVncmVlc1RvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgYW5nbGUgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlc1xuICogQHJldHVybnMge251bWJlcn0gYW5nbGUgaW4gcmFkaWFuc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzICUgMzYwO1xuICByZXR1cm4gcmFkaWFucyAqIE1hdGguUEkgLyAxODA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGVuZ3RoIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIG9mIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgbGVuZ3RoXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMZW5ndGgobGVuZ3RoLCBvcmlnaW5hbFVuaXQsIGZpbmFsVW5pdCkge1xuICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHtcbiAgICBvcmlnaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuXG4gIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkge1xuICAgIGZpbmFsVW5pdCA9IFwia2lsb21ldGVyc1wiO1xuICB9XG5cbiAgaWYgKCEobGVuZ3RoID49IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cblxuICByZXR1cm4gcmFkaWFuc1RvTGVuZ3RoKGxlbmd0aFRvUmFkaWFucyhsZW5ndGgsIG9yaWdpbmFsVW5pdCksIGZpbmFsVW5pdCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYXJlYSB0byB0aGUgcmVxdWVzdGVkIHVuaXQuXG4gKiBWYWxpZCB1bml0czoga2lsb21ldGVycywga2lsb21ldHJlcywgbWV0ZXJzLCBtZXRyZXMsIGNlbnRpbWV0cmVzLCBtaWxsaW1ldGVycywgYWNyZXMsIG1pbGVzLCB5YXJkcywgZmVldCwgaW5jaGVzLCBoZWN0YXJlc1xuICogQHBhcmFtIHtudW1iZXJ9IGFyZWEgdG8gYmUgY29udmVydGVkXG4gKiBAcGFyYW0ge1VuaXRzfSBbb3JpZ2luYWxVbml0PVwibWV0ZXJzXCJdIG9mIHRoZSBkaXN0YW5jZVxuICogQHBhcmFtIHtVbml0c30gW2ZpbmFsVW5pdD1cImtpbG9tZXRlcnNcIl0gcmV0dXJuZWQgdW5pdFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbnZlcnRlZCBhcmVhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRBcmVhKGFyZWEsIG9yaWdpbmFsVW5pdCwgZmluYWxVbml0KSB7XG4gIGlmIChvcmlnaW5hbFVuaXQgPT09IHZvaWQgMCkge1xuICAgIG9yaWdpbmFsVW5pdCA9IFwibWV0ZXJzXCI7XG4gIH1cblxuICBpZiAoZmluYWxVbml0ID09PSB2b2lkIDApIHtcbiAgICBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjtcbiAgfVxuXG4gIGlmICghKGFyZWEgPj0gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcmVhIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cblxuICB2YXIgc3RhcnRGYWN0b3IgPSBhcmVhRmFjdG9yc1tvcmlnaW5hbFVuaXRdO1xuXG4gIGlmICghc3RhcnRGYWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9yaWdpbmFsIHVuaXRzXCIpO1xuICB9XG5cbiAgdmFyIGZpbmFsRmFjdG9yID0gYXJlYUZhY3RvcnNbZmluYWxVbml0XTtcblxuICBpZiAoIWZpbmFsRmFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaW5hbCB1bml0c1wiKTtcbiAgfVxuXG4gIHJldHVybiBhcmVhIC8gc3RhcnRGYWN0b3IgKiBmaW5hbEZhY3Rvcjtcbn1cbi8qKlxuICogaXNOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG51bSBOdW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc051bWJlcigxMjMpXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzTnVtYmVyKCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gIHJldHVybiAhaXNOYU4obnVtKSAmJiBudW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobnVtKTtcbn1cbi8qKlxuICogaXNPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IGlucHV0IHZhcmlhYmxlIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICogQGV4YW1wbGVcbiAqIHR1cmYuaXNPYmplY3Qoe2VsZXZhdGlvbjogMTB9KVxuICogLy89dHJ1ZVxuICogdHVyZi5pc09iamVjdCgnZm9vJylcbiAqIC8vPWZhbHNlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gIHJldHVybiAhIWlucHV0ICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG4vKipcbiAqIFZhbGlkYXRlIEJCb3hcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IEJCb3ggdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyBFcnJvciBpZiBCQm94IGlzIG5vdCB2YWxpZFxuICogQGV4YW1wbGVcbiAqIHZhbGlkYXRlQkJveChbLTE4MCwgLTQwLCAxMTAsIDUwXSlcbiAqIC8vPU9LXG4gKiB2YWxpZGF0ZUJCb3goWy0xODAsIC00MF0pXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KCdGb28nKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCg1KVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveChudWxsKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCh1bmRlZmluZWQpXG4gKiAvLz1FcnJvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJCb3goYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IGlzIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGJib3gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICB9XG5cbiAgaWYgKGJib3gubGVuZ3RoICE9PSA0ICYmIGJib3gubGVuZ3RoICE9PSA2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBtdXN0IGJlIGFuIEFycmF5IG9mIDQgb3IgNiBudW1iZXJzXCIpO1xuICB9XG5cbiAgYmJveC5mb3JFYWNoKGZ1bmN0aW9uIChudW0pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG51bSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBvbmx5IGNvbnRhaW4gbnVtYmVyc1wiKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBJZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIElkIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgSWQgaXMgbm90IHZhbGlkXG4gKiBAZXhhbXBsZVxuICogdmFsaWRhdGVJZChbLTE4MCwgLTQwLCAxMTAsIDUwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQoJ0ZvbycpXG4gKiAvLz1PS1xuICogdmFsaWRhdGVJZCg1KVxuICogLy89T0tcbiAqIHZhbGlkYXRlSWQobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKHVuZGVmaW5lZClcbiAqIC8vPUVycm9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSWQoaWQpIHtcbiAgaWYgKCFpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgaWYgKFtcInN0cmluZ1wiLCBcIm51bWJlclwiXS5pbmRleE9mKHR5cGVvZiBpZCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZ1wiKTtcbiAgfVxufSIsImltcG9ydCB7IGZlYXR1cmUsIGxpbmVTdHJpbmcsIGlzT2JqZWN0LCBwb2ludCB9IGZyb20gJ0B0dXJmL2hlbHBlcnMnO1xuLyoqXG4gKiBDYWxsYmFjayBmb3IgY29vcmRFYWNoXG4gKlxuICogQGNhbGxiYWNrIGNvb3JkRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGN1cnJlbnRDb29yZCBUaGUgY3VycmVudCBjb29yZGluYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBjb29yZGluYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICpcbiAqIEBuYW1lIGNvb3JkRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZVdyYXBDb29yZD1mYWxzZV0gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge1wiZm9vXCI6IFwiYmFyXCJ9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge1wiaGVsbG9cIjogXCJ3b3JsZFwifSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuY29vcmRFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRDb29yZFxuICogICAvLz1jb29yZEluZGV4XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiB9KTtcbiAqL1xuXG5mdW5jdGlvbiBjb29yZEVhY2goZ2VvanNvbiwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgLy8gSGFuZGxlcyBudWxsIEdlb21ldHJ5IC0tIFNraXBzIHRoaXMgR2VvSlNPTlxuICBpZiAoZ2VvanNvbiA9PT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgaixcbiAgICAgIGssXG4gICAgICBsLFxuICAgICAgZ2VvbWV0cnksXG4gICAgICBzdG9wRyxcbiAgICAgIGNvb3JkcyxcbiAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgd3JhcFNocmluayA9IDAsXG4gICAgICBjb29yZEluZGV4ID0gMCxcbiAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgICAgdHlwZSA9IGdlb2pzb24udHlwZSxcbiAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSB0eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICBpc0ZlYXR1cmUgPSB0eXBlID09PSBcIkZlYXR1cmVcIixcbiAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxOyAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG5cbiAgZm9yICh2YXIgZmVhdHVyZUluZGV4ID0gMDsgZmVhdHVyZUluZGV4IDwgc3RvcDsgZmVhdHVyZUluZGV4KyspIHtcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0uZ2VvbWV0cnkgOiBpc0ZlYXR1cmUgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbjtcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA6IGZhbHNlO1xuICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICBmb3IgKHZhciBnZW9tSW5kZXggPSAwOyBnZW9tSW5kZXggPCBzdG9wRzsgZ2VvbUluZGV4KyspIHtcbiAgICAgIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IDA7XG4gICAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IDA7XG4gICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnZW9tSW5kZXhdIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247IC8vIEhhbmRsZXMgbnVsbCBHZW9tZXRyeSAtLSBTa2lwcyB0aGlzIGdlb21ldHJ5XG5cbiAgICAgIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgIHZhciBnZW9tVHlwZSA9IGdlb21ldHJ5LnR5cGU7XG4gICAgICB3cmFwU2hyaW5rID0gZXhjbHVkZVdyYXBDb29yZCAmJiAoZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiIHx8IGdlb21UeXBlID09PSBcIk11bHRpUG9seWdvblwiKSA/IDEgOiAwO1xuXG4gICAgICBzd2l0Y2ggKGdlb21UeXBlKSB7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjb29yZHNbal0sIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIk11bHRpUG9pbnRcIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzW2pdW2tdLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiUG9seWdvblwiKSBnZW9tZXRyeUluZGV4Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIlBvbHlnb25cIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGNvb3Jkc1tqXVtrXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBsKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzW2pdW2tdW2xdLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnZW9tZXRyeUluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRFYWNoKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGNhbGxiYWNrLCBleGNsdWRlV3JhcENvb3JkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvbWV0cnkgVHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgY29vcmRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudENvb3JkIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKClcbiAqXG4gKiBAbmFtZSBjb29yZFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeXxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5jb29yZFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRDb29yZFxuICogICAvLz1jb29yZEluZGV4XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50Q29vcmQ7XG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvb3JkUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUsIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGNvb3JkRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gICAgaWYgKGNvb3JkSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50Q29vcmQ7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KTtcbiAgfSwgZXhjbHVkZVdyYXBDb29yZCk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgcHJvcEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgcHJvcEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLnByb3BFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50UHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gcHJvcEVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgdmFyIGk7XG5cbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIGNhbGxiYWNrKGdlb2pzb24ucHJvcGVydGllcywgMCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIHByb3BSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7Kn0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCBpbnRvIGEgc2luZ2xlIHZhbHVlLFxuICogc2ltaWxhciB0byBob3cgQXJyYXkucmVkdWNlIHdvcmtzLiBIb3dldmVyLCBpbiB0aGlzIGNhc2Ugd2UgbGF6aWx5IHJ1blxuICogdGhlIHJlZHVjdGlvbiwgc28gYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgaXMgdW5uZWNlc3NhcnkuXG4gKlxuICogQG5hbWUgcHJvcFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5wcm9wUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudFByb3BlcnRpZXNcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gcHJvcFJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBwcm9wRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50UHJvcGVydGllcztlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmVhdHVyZUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZmVhdHVyZUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPGFueT59IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVFYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmZlYXR1cmVFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gZmVhdHVyZUVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgaWYgKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICBjYWxsYmFjayhnZW9qc29uLCAwKTtcbiAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNhbGxiYWNrKGdlb2pzb24uZmVhdHVyZXNbaV0sIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBmZWF0dXJlUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmVhdHVyZVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlUmVkdWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge1wiZm9vXCI6IFwiYmFyXCJ9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge1wiaGVsbG9cIjogXCJ3b3JsZFwifSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmVhdHVyZVJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRGZWF0dXJlXG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGZlYXR1cmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZmVhdHVyZUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpIHtcbiAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cbi8qKlxuICogR2V0IGFsbCBjb29yZGluYXRlcyBmcm9tIGFueSBHZW9KU09OIG9iamVjdC5cbiAqXG4gKiBAbmFtZSBjb29yZEFsbFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybnMge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlIHBvc2l0aW9uIGFycmF5XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB2YXIgY29vcmRzID0gdHVyZi5jb29yZEFsbChmZWF0dXJlcyk7XG4gKiAvLz0gW1syNiwgMzddLCBbMzYsIDUzXV1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvb3JkQWxsKGdlb2pzb24pIHtcbiAgdmFyIGNvb3JkcyA9IFtdO1xuICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgY29vcmRzLnB1c2goY29vcmQpO1xuICB9KTtcbiAgcmV0dXJuIGNvb3Jkcztcbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGdlb21FYWNoXG4gKlxuICogQGNhbGxiYWNrIGdlb21FYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGN1cnJlbnRHZW9tZXRyeSBUaGUgY3VycmVudCBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlUHJvcGVydGllcyBUaGUgY3VycmVudCBGZWF0dXJlIFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmZWF0dXJlQkJveCBUaGUgY3VycmVudCBGZWF0dXJlIEJCb3ggYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmZWF0dXJlSWQgVGhlIGN1cnJlbnQgRmVhdHVyZSBJZCBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBnZW9tZXRyeSBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgZ2VvbUVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZ2VvbUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAqICAgLy89Y3VycmVudEdlb21ldHJ5XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1mZWF0dXJlUHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlQkJveFxuICogICAvLz1mZWF0dXJlSWRcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gZ2VvbUVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgdmFyIGksXG4gICAgICBqLFxuICAgICAgZyxcbiAgICAgIGdlb21ldHJ5LFxuICAgICAgc3RvcEcsXG4gICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbixcbiAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgICAgZmVhdHVyZVByb3BlcnRpZXMsXG4gICAgICBmZWF0dXJlQkJveCxcbiAgICAgIGZlYXR1cmVJZCxcbiAgICAgIGZlYXR1cmVJbmRleCA9IDAsXG4gICAgICBpc0ZlYXR1cmVDb2xsZWN0aW9uID0gZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICBpc0ZlYXR1cmUgPSBnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZVwiLFxuICAgICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCA6IDE7IC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xuICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcbiAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcbiAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cblxuICBmb3IgKGkgPSAwOyBpIDwgc3RvcDsgaSsrKSB7XG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6IGlzRmVhdHVyZSA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uO1xuICAgIGZlYXR1cmVQcm9wZXJ0aWVzID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0ucHJvcGVydGllcyA6IGlzRmVhdHVyZSA/IGdlb2pzb24ucHJvcGVydGllcyA6IHt9O1xuICAgIGZlYXR1cmVCQm94ID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0uYmJveCA6IGlzRmVhdHVyZSA/IGdlb2pzb24uYmJveCA6IHVuZGVmaW5lZDtcbiAgICBmZWF0dXJlSWQgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5pZCA6IGlzRmVhdHVyZSA/IGdlb2pzb24uaWQgOiB1bmRlZmluZWQ7XG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgOiBmYWxzZTtcbiAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggOiAxO1xuXG4gICAgZm9yIChnID0gMDsgZyA8IHN0b3BHOyBnKyspIHtcbiAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2ddIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247IC8vIEhhbmRsZSBudWxsIEdlb21ldHJ5XG5cbiAgICAgIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sobnVsbCwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjayhnZW9tZXRyeS5nZW9tZXRyaWVzW2pdLCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9tZXRyeSBUeXBlXCIpO1xuICAgICAgfVxuICAgIH0gLy8gT25seSBpbmNyZWFzZSBgZmVhdHVyZUluZGV4YCBwZXIgZWFjaCBmZWF0dXJlXG5cblxuICAgIGZlYXR1cmVJbmRleCsrO1xuICB9XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBnZW9tUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBnZW9tZXRyeSBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZ2VvbVJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmdlb21SZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogICByZXR1cm4gY3VycmVudEdlb21ldHJ5XG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGdlb21SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZ2VvbUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50R2VvbWV0cnk7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmxhdHRlbkVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlbkVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBmbGF0dGVuZWQgZmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmxhdHRlbmVkIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xuICogQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBmbGF0dGVuRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLm11bHRpUG9pbnQoW1s0MCwgMzBdLCBbMzYsIDUzXV0sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmZsYXR0ZW5FYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBwcm9wZXJ0aWVzLCBiYm94LCBpZCkge1xuICAgIC8vIENhbGxiYWNrIGZvciBzaW5nbGUgZ2VvbWV0cnlcbiAgICB2YXIgdHlwZSA9IGdlb21ldHJ5ID09PSBudWxsID8gbnVsbCA6IGdlb21ldHJ5LnR5cGU7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGlmIChjYWxsYmFjayhmZWF0dXJlKGdlb21ldHJ5LCBwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfSksIGZlYXR1cmVJbmRleCwgMCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbVR5cGU7IC8vIENhbGxiYWNrIGZvciBtdWx0aS1nZW9tZXRyeVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiUG9pbnRcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgZ2VvbVR5cGUgPSBcIkxpbmVTdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgZ2VvbVR5cGUgPSBcIlBvbHlnb25cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSAwOyBtdWx0aUZlYXR1cmVJbmRleCA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgbXVsdGlGZWF0dXJlSW5kZXgrKykge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBnZW9tZXRyeS5jb29yZGluYXRlc1ttdWx0aUZlYXR1cmVJbmRleF07XG4gICAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogZ2VvbVR5cGUsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlXG4gICAgICB9O1xuICAgICAgaWYgKGNhbGxiYWNrKGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcyksIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlblJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5SZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlblJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBmbGF0dGVuUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgbXVsdGlGZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50RmVhdHVyZTtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHNlZ21lbnRFYWNoXG4gKlxuICogQGNhbGxiYWNrIHNlZ21lbnRFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudFNlZ21lbnQgVGhlIGN1cnJlbnQgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciAyLXZlcnRleCBsaW5lIHNlZ21lbnQgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICogKE11bHRpKVBvaW50IGdlb21ldHJpZXMgZG8gbm90IGNvbnRhaW4gc2VnbWVudHMgdGhlcmVmb3JlIHRoZXkgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dKTtcbiAqXG4gKiAvLyBJdGVyYXRlIG92ZXIgR2VvSlNPTiBieSAyLXZlcnRleCBzZWdtZW50c1xuICogdHVyZi5zZWdtZW50RWFjaChwb2x5Z29uLCBmdW5jdGlvbiAoY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleCkge1xuICogICAvLz1jdXJyZW50U2VnbWVudFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogICAvLz1zZWdtZW50SW5kZXhcbiAqIH0pO1xuICpcbiAqIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzXG4gKiB2YXIgdG90YWwgPSAwO1xuICogdHVyZi5zZWdtZW50RWFjaChwb2x5Z29uLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdG90YWwrKztcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gc2VnbWVudEVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gMDsgLy8gRXhjbHVkZSBudWxsIEdlb21ldHJpZXNcblxuICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSkgcmV0dXJuOyAvLyAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG5cbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJQb2ludFwiIHx8IHR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSByZXR1cm47IC8vIEdlbmVyYXRlIDItdmVydGV4IGxpbmUgc2VnbWVudHNcblxuICAgIHZhciBwcmV2aW91c0Nvb3JkcztcbiAgICB2YXIgcHJldmlvdXNGZWF0dXJlSW5kZXggPSAwO1xuICAgIHZhciBwcmV2aW91c011bHRpSW5kZXggPSAwO1xuICAgIHZhciBwcmV2R2VvbUluZGV4ID0gMDtcbiAgICBpZiAoY29vcmRFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleENvb3JkLCBtdWx0aVBhcnRJbmRleENvb3JkLCBnZW9tZXRyeUluZGV4KSB7XG4gICAgICAvLyBTaW11bGF0aW5nIGEgbWV0YS5jb29yZFJlZHVjZSgpIHNpbmNlIGByZWR1Y2VgIG9wZXJhdGlvbnMgY2Fubm90IGJlIHN0b3BwZWQgYnkgcmV0dXJuaW5nIGBmYWxzZWBcbiAgICAgIGlmIChwcmV2aW91c0Nvb3JkcyA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmVJbmRleCA+IHByZXZpb3VzRmVhdHVyZUluZGV4IHx8IG11bHRpUGFydEluZGV4Q29vcmQgPiBwcmV2aW91c011bHRpSW5kZXggfHwgZ2VvbWV0cnlJbmRleCA+IHByZXZHZW9tSW5kZXgpIHtcbiAgICAgICAgcHJldmlvdXNDb29yZHMgPSBjdXJyZW50Q29vcmQ7XG4gICAgICAgIHByZXZpb3VzRmVhdHVyZUluZGV4ID0gZmVhdHVyZUluZGV4O1xuICAgICAgICBwcmV2aW91c011bHRpSW5kZXggPSBtdWx0aVBhcnRJbmRleENvb3JkO1xuICAgICAgICBwcmV2R2VvbUluZGV4ID0gZ2VvbWV0cnlJbmRleDtcbiAgICAgICAgc2VnbWVudEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFNlZ21lbnQgPSBsaW5lU3RyaW5nKFtwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3JkXSwgZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGlmIChjYWxsYmFjayhjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHNlZ21lbnRJbmRleCsrO1xuICAgICAgcHJldmlvdXNDb29yZHMgPSBjdXJyZW50Q29vcmQ7XG4gICAgfSkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIHNlZ21lbnRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudFNlZ21lbnQgVGhlIGN1cnJlbnQgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgMi12ZXJ0ZXggbGluZSBzZWdtZW50IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKVxuICogKE11bHRpKVBvaW50IGdlb21ldHJpZXMgZG8gbm90IGNvbnRhaW4gc2VnbWVudHMgdGhlcmVmb3JlIHRoZXkgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFNlZ21lbnQsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1stNTAsIDVdLCBbLTQwLCAtMTBdLCBbLTUwLCAtMTBdLCBbLTQwLCA1XSwgWy01MCwgNV1dXSk7XG4gKlxuICogLy8gSXRlcmF0ZSBvdmVyIEdlb0pTT04gYnkgMi12ZXJ0ZXggc2VnbWVudHNcbiAqIHR1cmYuc2VnbWVudFJlZHVjZShwb2x5Z29uLCBmdW5jdGlvbiAocHJldmlvdXNTZWdtZW50LCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPSBwcmV2aW91c1NlZ21lbnRcbiAqICAgLy89IGN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPSBmZWF0dXJlSW5kZXhcbiAqICAgLy89IG11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPSBnZW9tZXRyeUluZGV4XG4gKiAgIC8vPSBzZWdtZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRTZWdtZW50XG4gKiB9KTtcbiAqXG4gKiAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50c1xuICogdmFyIGluaXRpYWxWYWx1ZSA9IDBcbiAqIHZhciB0b3RhbCA9IHR1cmYuc2VnbWVudFJlZHVjZShwb2x5Z29uLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSkge1xuICogICAgIHByZXZpb3VzVmFsdWUrKztcbiAqICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAqIH0sIGluaXRpYWxWYWx1ZSk7XG4gKi9cblxuXG5mdW5jdGlvbiBzZWdtZW50UmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG4gIHNlZ21lbnRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gICAgaWYgKHN0YXJ0ZWQgPT09IGZhbHNlICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudFNlZ21lbnQ7ZWxzZSBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudFNlZ21lbnQsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgsIHNlZ21lbnRJbmRleCk7XG4gICAgc3RhcnRlZCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVFYWNoXG4gKlxuICogQGNhbGxiYWNrIGxpbmVFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudExpbmUgVGhlIGN1cnJlbnQgTGluZVN0cmluZ3xMaW5lYXJSaW5nIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWRcbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBsaW5lIG9yIHJpbmcgY29vcmRpbmF0ZXMgaW4gTGluZVN0cmluZywgUG9seWdvbiwgTXVsdGlMaW5lU3RyaW5nLCBNdWx0aVBvbHlnb24gRmVhdHVyZXMgb3IgR2VvbWV0cmllcyxcbiAqIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBsaW5lRWFjaFxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPExpbmVTdHJpbmd8UG9seWdvbnxNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29uPn0gZ2VvanNvbiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KVxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgIFtbMjYsIDM3XSwgWzM1LCA0NV1dLFxuICogICBbWzM2LCA1M10sIFszOCwgNTBdLCBbNDEsIDU1XV1cbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZUVhY2gobXVsdGlMaW5lLCBmdW5jdGlvbiAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudExpbmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gbGluZUVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgLy8gdmFsaWRhdGlvblxuICBpZiAoIWdlb2pzb24pIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgcmVxdWlyZWRcIik7XG4gIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChmZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybjtcbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcbiAgICB2YXIgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgaWYgKGNhbGxiYWNrKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIDAsIDApID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgZm9yICh2YXIgZ2VvbWV0cnlJbmRleCA9IDA7IGdlb21ldHJ5SW5kZXggPCBjb29yZHMubGVuZ3RoOyBnZW9tZXRyeUluZGV4KyspIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sobGluZVN0cmluZyhjb29yZHNbZ2VvbWV0cnlJbmRleF0sIGZlYXR1cmUucHJvcGVydGllcyksIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBsaW5lUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRMaW5lIFRoZSBjdXJyZW50IExpbmVTdHJpbmd8TGluZWFyUmluZyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBsaW5lUmVkdWNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbXG4gKiAgIHR1cmYucG9seWdvbihbW1sxMiw0OF0sWzIsNDFdLFsyNCwzOF0sWzEyLDQ4XV0sIFtbOSw0NF0sWzEzLDQxXSxbMTMsNDVdLFs5LDQ0XV1dKSxcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzUsIDVdLCBbMCwgMF0sIFsyLCAyXSwgWzQsIDRdLCBbNSwgNV1dXSlcbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZVJlZHVjZShtdWx0aVBvbHksIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRMaW5lXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50TGluZVxuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBsaW5lUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxpbmVFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50TGluZTtlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cbi8qKlxuICogRmluZHMgYSBwYXJ0aWN1bGFyIDItdmVydGV4IExpbmVTdHJpbmcgU2VnbWVudCBmcm9tIGEgR2VvSlNPTiB1c2luZyBgQHR1cmYvbWV0YWAgaW5kZXhlcy5cbiAqXG4gKiBOZWdhdGl2ZSBpbmRleGVzIGFyZSBwZXJtaXR0ZWQuXG4gKiBQb2ludCAmIE11bHRpUG9pbnQgd2lsbCBhbHdheXMgcmV0dXJuIG51bGwuXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIEFueSBHZW9KU09OIEZlYXR1cmUgb3IgR2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZlYXR1cmVJbmRleD0wXSBGZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXg9MF0gTXVsdGktRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmdlb21ldHJ5SW5kZXg9MF0gR2VvbWV0cnkgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gU2VnbWVudCBJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSBQcm9wZXJ0aWVzIHRvIG91dHB1dCBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0JCb3h9IFtvcHRpb25zLmJib3g9e31dIFRyYW5zbGF0ZSBCQm94IHRvIG91dHB1dCBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmlkPXt9XSBUcmFuc2xhdGUgSWQgdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSAyLXZlcnRleCBHZW9KU09OIEZlYXR1cmUgTGluZVN0cmluZ1xuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgICAgW1sxMCwgMTBdLCBbNTAsIDMwXSwgWzMwLCA0MF1dLFxuICogICAgIFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdLCBbLTMwLCAtNDBdXVxuICogXSk7XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCAoZGVmYXVsdHMgYXJlIDApXG4gKiB0dXJmLmZpbmRTZWdtZW50KG11bHRpTGluZSk7XG4gKiAvLyA9PiBGZWF0dXJlPExpbmVTdHJpbmc8W1sxMCwgMTBdLCBbNTAsIDMwXV0+PlxuICpcbiAqIC8vIEZpcnN0IFNlZ21lbnQgb2YgMm5kIE11bHRpIEZlYXR1cmVcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IDF9KTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWy0xMCwgLTEwXSwgWy01MCwgLTMwXV0+PlxuICpcbiAqIC8vIExhc3QgU2VnbWVudCBvZiBMYXN0IE11bHRpIEZlYXR1cmVcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IC0xLCBzZWdtZW50SW5kZXg6IC0xfSk7XG4gKiAvLyA9PiBGZWF0dXJlPExpbmVTdHJpbmc8W1stNTAsIC0zMF0sIFstMzAsIC00MF1dPj5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRTZWdtZW50KGdlb2pzb24sIG9wdGlvbnMpIHtcbiAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBpbnZhbGlkXCIpO1xuICB2YXIgZmVhdHVyZUluZGV4ID0gb3B0aW9ucy5mZWF0dXJlSW5kZXggfHwgMDtcbiAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgZ2VvbWV0cnlJbmRleCA9IG9wdGlvbnMuZ2VvbWV0cnlJbmRleCB8fCAwO1xuICB2YXIgc2VnbWVudEluZGV4ID0gb3B0aW9ucy5zZWdtZW50SW5kZXggfHwgMDsgLy8gRmluZCBGZWF0dXJlSW5kZXhcblxuICB2YXIgcHJvcGVydGllcyA9IG9wdGlvbnMucHJvcGVydGllcztcbiAgdmFyIGdlb21ldHJ5O1xuXG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMCkgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5wcm9wZXJ0aWVzO1xuICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbiAgfSAvLyBGaW5kIFNlZ21lbnRJbmRleFxuXG5cbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhbY29vcmRzW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1tzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkc1tnZW9tZXRyeUluZGV4XS5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW2Nvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXhdLCBjb29yZHNbZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgc2VnbWVudEluZGV4IC0gMTtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF0ubGVuZ3RoIC0gc2VnbWVudEluZGV4IC0gMTtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbn1cbi8qKlxuICogRmluZHMgYSBwYXJ0aWN1bGFyIFBvaW50IGZyb20gYSBHZW9KU09OIHVzaW5nIGBAdHVyZi9tZXRhYCBpbmRleGVzLlxuICpcbiAqIE5lZ2F0aXZlIGluZGV4ZXMgYXJlIHBlcm1pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gQW55IEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmVhdHVyZUluZGV4PTBdIEZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleD0wXSBNdWx0aS1GZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZ2VvbWV0cnlJbmRleD0wXSBHZW9tZXRyeSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvb3JkSW5kZXg9MF0gQ29vcmQgSW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm9wZXJ0aWVzPXt9XSBUcmFuc2xhdGUgUHJvcGVydGllcyB0byBvdXRwdXQgUG9pbnRcbiAqIEBwYXJhbSB7QkJveH0gW29wdGlvbnMuYmJveD17fV0gVHJhbnNsYXRlIEJCb3ggdG8gb3V0cHV0IFBvaW50XG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmlkPXt9XSBUcmFuc2xhdGUgSWQgdG8gb3V0cHV0IFBvaW50XG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IDItdmVydGV4IEdlb0pTT04gRmVhdHVyZSBQb2ludFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgICAgW1sxMCwgMTBdLCBbNTAsIDMwXSwgWzMwLCA0MF1dLFxuICogICAgIFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdLCBbLTMwLCAtNDBdXVxuICogXSk7XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCAoZGVmYXVsdHMgYXJlIDApXG4gKiB0dXJmLmZpbmRQb2ludChtdWx0aUxpbmUpO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbMTAsIDEwXT4+XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCBvZiB0aGUgMm5kIE11bHRpLUZlYXR1cmVcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAxfSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFstMTAsIC0xMF0+PlxuICpcbiAqIC8vIExhc3QgU2VnbWVudCBvZiBsYXN0IE11bHRpLUZlYXR1cmVcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAtMSwgY29vcmRJbmRleDogLTF9KTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8Wy0zMCwgLTQwXT4+XG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kUG9pbnQoZ2VvanNvbiwgb3B0aW9ucykge1xuICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zIGlzIGludmFsaWRcIik7XG4gIHZhciBmZWF0dXJlSW5kZXggPSBvcHRpb25zLmZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSBvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4IHx8IDA7XG4gIHZhciBnZW9tZXRyeUluZGV4ID0gb3B0aW9ucy5nZW9tZXRyeUluZGV4IHx8IDA7XG4gIHZhciBjb29yZEluZGV4ID0gb3B0aW9ucy5jb29yZEluZGV4IHx8IDA7IC8vIEZpbmQgRmVhdHVyZUluZGV4XG5cbiAgdmFyIHByb3BlcnRpZXMgPSBvcHRpb25zLnByb3BlcnRpZXM7XG4gIHZhciBnZW9tZXRyeTtcblxuICBzd2l0Y2ggKGdlb2pzb24udHlwZSkge1xuICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgaWYgKGZlYXR1cmVJbmRleCA8IDApIGZlYXR1cmVJbmRleCA9IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoICsgZmVhdHVyZUluZGV4O1xuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLnByb3BlcnRpZXM7XG4gICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICBnZW9tZXRyeSA9IGdlb2pzb247XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG4gIH0gLy8gRmluZCBDb29yZCBJbmRleFxuXG5cbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgcmV0dXJuIHBvaW50KGNvb3JkcywgcHJvcGVydGllcywgb3B0aW9ucyk7XG5cbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMCkgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW211bHRpRmVhdHVyZUluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG5cbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICBpZiAoZ2VvbWV0cnlJbmRleCA8IDApIGdlb21ldHJ5SW5kZXggPSBjb29yZHMubGVuZ3RoICsgZ2VvbWV0cnlJbmRleDtcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMCkgY29vcmRJbmRleCA9IGNvb3Jkc1tnZW9tZXRyeUluZGV4XS5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtjb29yZEluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG5cbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMCkgY29vcmRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcblxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyBpbnZhbGlkXCIpO1xufVxuXG5leHBvcnQgeyBjb29yZEFsbCwgY29vcmRFYWNoLCBjb29yZFJlZHVjZSwgZmVhdHVyZUVhY2gsIGZlYXR1cmVSZWR1Y2UsIGZpbmRQb2ludCwgZmluZFNlZ21lbnQsIGZsYXR0ZW5FYWNoLCBmbGF0dGVuUmVkdWNlLCBnZW9tRWFjaCwgZ2VvbVJlZHVjZSwgbGluZUVhY2gsIGxpbmVSZWR1Y2UsIHByb3BFYWNoLCBwcm9wUmVkdWNlLCBzZWdtZW50RWFjaCwgc2VnbWVudFJlZHVjZSB9OyIsImltcG9ydCB7IGNvb3JkRWFjaCB9IGZyb20gXCJAdHVyZi9tZXRhXCI7XG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIGZlYXR1cmVzLCBjYWxjdWxhdGVzIHRoZSBiYm94IG9mIGFsbCBpbnB1dCBmZWF0dXJlcywgYW5kIHJldHVybnMgYSBib3VuZGluZyBib3guXG4gKlxuICogQG5hbWUgYmJveFxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybnMge0JCb3h9IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKFtbLTc0LCA0MF0sIFstNzgsIDQyXSwgWy04MiwgMzVdXSk7XG4gKiB2YXIgYmJveCA9IHR1cmYuYmJveChsaW5lKTtcbiAqIHZhciBiYm94UG9seWdvbiA9IHR1cmYuYmJveFBvbHlnb24oYmJveCk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUsIGJib3hQb2x5Z29uXVxuICovXG5cbmZ1bmN0aW9uIGJib3goZ2VvanNvbikge1xuICB2YXIgcmVzdWx0ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgaWYgKHJlc3VsdFswXSA+IGNvb3JkWzBdKSB7XG4gICAgICByZXN1bHRbMF0gPSBjb29yZFswXTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0WzFdID4gY29vcmRbMV0pIHtcbiAgICAgIHJlc3VsdFsxXSA9IGNvb3JkWzFdO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRbMl0gPCBjb29yZFswXSkge1xuICAgICAgcmVzdWx0WzJdID0gY29vcmRbMF07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdFszXSA8IGNvb3JkWzFdKSB7XG4gICAgICByZXN1bHRbM10gPSBjb29yZFsxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5iYm94W1wiZGVmYXVsdFwiXSA9IGJib3g7XG5leHBvcnQgZGVmYXVsdCBiYm94OyIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG59XG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIHRlcnJpdG9yeUZvY3VzQnV0dG9uID0gXCJ0ZXJyaXRvcnlGb2N1c0NvbnRyb2wtbW9kdWxlLS10ZXJyaXRvcnlGb2N1c0J1dHRvbi0tM3dXb1ZcIjtcbmV4cG9ydCB2YXIgdGVycml0b3J5Rm9jdXNDb250YWluZXIgPSBcInRlcnJpdG9yeUZvY3VzQ29udHJvbC1tb2R1bGUtLXRlcnJpdG9yeUZvY3VzQ29udGFpbmVyLS0zTjBYTVwiOyIsImltcG9ydCBSZWFjdCwge01vdXNlRXZlbnRIYW5kbGVyfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge191c2VNYXBDb250cm9sIGFzIHVzZU1hcENvbnRyb2x9IGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi90ZXJyaXRvcnlGb2N1c0NvbnRyb2wubW9kdWxlLnNjc3MnO1xuXG5pbnRlcmZhY2UgSVRlcnJpdG9yeUZvY3VzQ29udHJvbCB7XG4gIG9uQ2xpY2tUZXJyaXRvcnlGb2N1c0J1dHRvbiA6IE1vdXNlRXZlbnRIYW5kbGVyPEhUTUxCdXR0b25FbGVtZW50Pjtcbn1cblxuY29uc3QgVGVycml0b3J5Rm9jdXNDb250cm9sID0gKHtvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b259IDogSVRlcnJpdG9yeUZvY3VzQ29udHJvbCkgPT4ge1xuICBjb25zdCB7Y29udGFpbmVyUmVmfSA9IHVzZU1hcENvbnRyb2woe1xuICAgIC8vIEB0cy1pZ25vcmUgLy8gVHlwZXMgaGF2ZSBub3QgY2F1Z2h0IHVwIHlldCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1tYXAtZ2wvaXNzdWVzLzE0OTJcbiAgICBvbkNsaWNrOiBvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b24sXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e2NvbnRhaW5lclJlZn0gY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNDb250YWluZXJ9PlxuICAgICAgPGJ1dHRvbiBpZD17JzQ4J30gb25DbGljaz17b25DbGlja1RlcnJpdG9yeUZvY3VzQnV0dG9ufSBjbGFzc05hbWU9e3N0eWxlcy50ZXJyaXRvcnlGb2N1c0J1dHRvbn0+NDg8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gaWQ9eydBSyd9IG9uQ2xpY2s9e29uQ2xpY2tUZXJyaXRvcnlGb2N1c0J1dHRvbn0gY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNCdXR0b259PkFLPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGlkPXsnSEknfSBvbkNsaWNrPXtvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b259IGNsYXNzTmFtZT17c3R5bGVzLnRlcnJpdG9yeUZvY3VzQnV0dG9ufT5ISTwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBpZD17J1BSJ30gb25DbGljaz17b25DbGlja1RlcnJpdG9yeUZvY3VzQnV0dG9ufSBjbGFzc05hbWU9e3N0eWxlcy50ZXJyaXRvcnlGb2N1c0J1dHRvbn0+UFI8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRlcnJpdG9yeUZvY3VzQ29udHJvbDtcblxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIG1hcENvbnRhaW5lciA9IFwiSjQwTWFwLW1vZHVsZS0tbWFwQ29udGFpbmVyLS0zVTd4bFwiO1xuZXhwb3J0IHZhciBqNDBQb3B1cCA9IFwiSjQwTWFwLW1vZHVsZS0tajQwUG9wdXAtLTN5SkdyXCI7XG5leHBvcnQgdmFyIG5hdmlnYXRpb25Db250cm9sID0gXCJKNDBNYXAtbW9kdWxlLS1uYXZpZ2F0aW9uQ29udHJvbC0tMkF5YmZcIjtcbmV4cG9ydCB2YXIgZnVsbHNjcmVlbkNvbnRyb2wgPSBcIko0ME1hcC1tb2R1bGUtLWZ1bGxzY3JlZW5Db250cm9sLS0xVUJLZVwiO1xuZXhwb3J0IHZhciBnZW9sb2NhdGVDb250cm9sID0gXCJKNDBNYXAtbW9kdWxlLS1nZW9sb2NhdGVDb250cm9sLS0zS1ZBa1wiOyIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgUmVhY3QsIHtNb3VzZUV2ZW50LCB1c2VSZWYsIHVzZVN0YXRlfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge01hcCwgTWFwYm94R2VvSlNPTkZlYXR1cmUsIExuZ0xhdEJvdW5kc0xpa2V9IGZyb20gJ21hcGxpYnJlLWdsJztcbmltcG9ydCBSZWFjdE1hcEdMLCB7XG4gIE1hcEV2ZW50LFxuICBWaWV3cG9ydFByb3BzLFxuICBXZWJNZXJjYXRvclZpZXdwb3J0LFxuICBOYXZpZ2F0aW9uQ29udHJvbCxcbiAgR2VvbG9jYXRlQ29udHJvbCxcbiAgUG9wdXAsXG4gIEZseVRvSW50ZXJwb2xhdG9yLFxuICBGdWxsc2NyZWVuQ29udHJvbCxcbiAgTWFwUmVmfSBmcm9tICdyZWFjdC1tYXAtZ2wnO1xuaW1wb3J0IHttYWtlTWFwU3R5bGV9IGZyb20gJy4uL2RhdGEvbWFwU3R5bGUnO1xuaW1wb3J0IEFyZWFEZXRhaWwgZnJvbSAnLi9hcmVhRGV0YWlsJztcbmltcG9ydCBiYm94IGZyb20gJ0B0dXJmL2Jib3gnO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMtZWFzZSc7XG5pbXBvcnQge3VzZUZsYWdzfSBmcm9tICcuLi9jb250ZXh0cy9GbGFnQ29udGV4dCc7XG5pbXBvcnQgVGVycml0b3J5Rm9jdXNDb250cm9sIGZyb20gJy4vdGVycml0b3J5Rm9jdXNDb250cm9sJztcblxuaW1wb3J0ICdtYXBsaWJyZS1nbC9kaXN0L21hcGxpYnJlLWdsLmNzcyc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vSjQwTWFwLm1vZHVsZS5zY3NzJztcblxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIEN5cHJlc3M/OiBvYmplY3Q7XG4gICAgdW5kZXJseWluZ01hcDogTWFwO1xuICB9XG59XG5cblxuaW50ZXJmYWNlIElEZXRhaWxWaWV3SW50ZXJmYWNlIHtcbiAgbGF0aXR1ZGU6IG51bWJlclxuICBsb25naXR1ZGU6IG51bWJlclxuICB6b29tOiBudW1iZXJcbiAgcHJvcGVydGllczogY29uc3RhbnRzLko0MFByb3BlcnRpZXMsXG59O1xuXG5jb25zdCBKNDBNYXAgPSAoKSA9PiB7XG4gIGNvbnN0IFt2aWV3cG9ydCwgc2V0Vmlld3BvcnRdID0gdXNlU3RhdGU8Vmlld3BvcnRQcm9wcz4oe1xuICAgIGxhdGl0dWRlOiBjb25zdGFudHMuREVGQVVMVF9DRU5URVJbMF0sXG4gICAgbG9uZ2l0dWRlOiBjb25zdGFudHMuREVGQVVMVF9DRU5URVJbMV0sXG4gICAgem9vbTogY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTSxcbiAgfSk7XG5cbiAgY29uc3QgW3NlbGVjdGVkRmVhdHVyZSwgc2V0U2VsZWN0ZWRGZWF0dXJlXSA9IHVzZVN0YXRlPE1hcGJveEdlb0pTT05GZWF0dXJlPigpO1xuICBjb25zdCBbZGV0YWlsVmlld0RhdGEsIHNldERldGFpbFZpZXdEYXRhXSA9IHVzZVN0YXRlPElEZXRhaWxWaWV3SW50ZXJmYWNlPigpO1xuICBjb25zdCBbdHJhbnNpdGlvbkluUHJvZ3Jlc3MsIHNldFRyYW5zaXRpb25JblByb2dyZXNzXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2dlb2xvY2F0aW9uSW5Qcm9ncmVzcywgc2V0R2VvbG9jYXRpb25JblByb2dyZXNzXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmPE1hcFJlZj4obnVsbCk7XG4gIGNvbnN0IGZsYWdzID0gdXNlRmxhZ3MoKTtcblxuICBjb25zdCBvbkNsaWNrID0gKGV2ZW50OiBNYXBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBldmVudC5mZWF0dXJlcyAmJiBldmVudC5mZWF0dXJlc1swXTtcbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgY29uc3QgW21pbkxuZywgbWluTGF0LCBtYXhMbmcsIG1heExhdF0gPSBiYm94KGZlYXR1cmUpO1xuICAgICAgY29uc3QgbmV3Vmlld1BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7aGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQhLCB3aWR0aDogdmlld3BvcnQud2lkdGghfSk7XG4gICAgICBjb25zdCB7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0gPSBuZXdWaWV3UG9ydC5maXRCb3VuZHMoXG4gICAgICAgICAgW1xuICAgICAgICAgICAgW21pbkxuZywgbWluTGF0XSxcbiAgICAgICAgICAgIFttYXhMbmcsIG1heExhdF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYWRkaW5nOiA0MCxcbiAgICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIC8vIElmIHdlJ3ZlIHNlbGVjdGVkIGEgbmV3IGZlYXR1cmUsIHNldCAnc2VsZWN0ZWQnIHRvIGZhbHNlXG4gICAgICBpZiAoc2VsZWN0ZWRGZWF0dXJlICYmIGZlYXR1cmUuaWQgIT09IHNlbGVjdGVkRmVhdHVyZS5pZCkge1xuICAgICAgICBzZXRNYXBTZWxlY3RlZChzZWxlY3RlZEZlYXR1cmUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHNldE1hcFNlbGVjdGVkKGZlYXR1cmUsIHRydWUpO1xuICAgICAgY29uc3QgcG9wdXBJbmZvID0ge1xuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICB9O1xuICAgICAgZ29Ub1BsYWNlKFtcbiAgICAgICAgW21pbkxuZywgbWluTGF0XSxcbiAgICAgICAgW21heExuZywgbWF4TGF0XSxcbiAgICAgIF0pO1xuICAgICAgc2V0RGV0YWlsVmlld0RhdGEocG9wdXBJbmZvKTtcbiAgICB9XG4gIH07XG5cblxuICBjb25zdCBvbkxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5DeXByZXNzICYmIG1hcFJlZi5jdXJyZW50KSB7XG4gICAgICB3aW5kb3cudW5kZXJseWluZ01hcCA9IG1hcFJlZi5jdXJyZW50LmdldE1hcCgpO1xuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0IGdvVG9QbGFjZSA9IChib3VuZHM6IExuZ0xhdEJvdW5kc0xpa2UgKSA9PiB7XG4gICAgY29uc3Qge2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb219ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe2hlaWdodDogdmlld3BvcnQuaGVpZ2h0ISwgd2lkdGg6IHZpZXdwb3J0LndpZHRoIX0pXG4gICAgICAgIC5maXRCb3VuZHMoYm91bmRzIGFzIFtbbnVtYmVyLCBudW1iZXJdLCBbbnVtYmVyLCBudW1iZXJdXSwge1xuICAgICAgICAgIHBhZGRpbmc6IDIwLFxuICAgICAgICAgIG9mZnNldDogWzAsIC0xMDBdLFxuICAgICAgICB9KTtcbiAgICBzZXRWaWV3cG9ydCh7XG4gICAgICAuLi52aWV3cG9ydCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMTAwMCxcbiAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBGbHlUb0ludGVycG9sYXRvcigpLFxuICAgICAgdHJhbnNpdGlvbkVhc2luZzogZDMuZWFzZUN1YmljLFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHNldE1hcFNlbGVjdGVkID0gKGZlYXR1cmU6TWFwYm94R2VvSlNPTkZlYXR1cmUsIGlzU2VsZWN0ZWQ6Ym9vbGVhbikgOiB2b2lkID0+IHtcbiAgICAvLyBUaGUgYmVsb3cgY2FuIGJlIGNvbmZpcm1lZCBkdXJpbmcgZGVidWcgd2l0aDpcbiAgICAvLyBtYXBSZWYuY3VycmVudC5nZXRGZWF0dXJlU3RhdGUoe1wiaWRcIjpmZWF0dXJlLmlkLCBcInNvdXJjZVwiOmZlYXR1cmUuc291cmNlLCBcInNvdXJjZUxheWVyXCI6ZmVhdHVyZS5zb3VyY2VMYXllcn0pXG4gICAgbWFwUmVmLmN1cnJlbnQgJiYgbWFwUmVmLmN1cnJlbnQuZ2V0TWFwKCkuc2V0RmVhdHVyZVN0YXRlKHtcbiAgICAgIHNvdXJjZTogZmVhdHVyZS5zb3VyY2UsXG4gICAgICBzb3VyY2VMYXllcjogZmVhdHVyZS5zb3VyY2VMYXllcixcbiAgICAgIGlkOiBmZWF0dXJlLmlkLFxuICAgIH0sIHtbY29uc3RhbnRzLlNFTEVDVEVEX1BST1BFUlRZXTogaXNTZWxlY3RlZH0pO1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICBzZXRTZWxlY3RlZEZlYXR1cmUoZmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlbGVjdGVkRmVhdHVyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b24gPSAoZXZlbnQ6IE1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgYnV0dG9uSUQgPSBldmVudC50YXJnZXQgJiYgKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuaWQ7XG5cbiAgICBzd2l0Y2ggKGJ1dHRvbklEKSB7XG4gICAgICBjYXNlICc0OCc6XG4gICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuTE9XRVJfNDhfQk9VTkRTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBSyc6XG4gICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuQUxBU0tBX0JPVU5EUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSEknOlxuICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLkhBV0FJSV9CT1VORFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BSJzpcbiAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5QVUVSVE9fUklDT19CT1VORFMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uVHJhbnNpdGlvblN0YXJ0ID0gKCkgPT4ge1xuICAgIHNldFRyYW5zaXRpb25JblByb2dyZXNzKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9ICgpID0+IHtcbiAgICBzZXRUcmFuc2l0aW9uSW5Qcm9ncmVzcyhmYWxzZSk7XG4gIH07XG5cbiAgY29uc3Qgb25HZW9sb2NhdGUgPSAoKSA9PiB7XG4gICAgc2V0R2VvbG9jYXRpb25JblByb2dyZXNzKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBvbkNsaWNrR2VvbG9jYXRlID0gKCkgPT4ge1xuICAgIHNldEdlb2xvY2F0aW9uSW5Qcm9ncmVzcyh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8UmVhY3RNYXBHTFxuICAgICAgICB7Li4udmlld3BvcnR9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1hcENvbnRhaW5lcn1cbiAgICAgICAgbWFwU3R5bGU9e21ha2VNYXBTdHlsZShmbGFncyl9XG4gICAgICAgIG1pblpvb209e2NvbnN0YW50cy5HTE9CQUxfTUlOX1pPT019XG4gICAgICAgIG1heFpvb209e2NvbnN0YW50cy5HTE9CQUxfTUFYX1pPT019XG4gICAgICAgIG1hcE9wdGlvbnM9e3toYXNoOiB0cnVlfX1cbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgaGVpZ2h0PVwiNTJ2d1wiXG4gICAgICAgIGRyYWdSb3RhdGU9e2ZhbHNlfVxuICAgICAgICB0b3VjaFJvdGF0ZT17ZmFsc2V9XG4gICAgICAgIGludGVyYWN0aXZlTGF5ZXJJZHM9e1tjb25zdGFudHMuSElHSF9TQ09SRV9MQVlFUl9OQU1FXX1cbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT17c2V0Vmlld3BvcnR9XG4gICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIG9uTG9hZD17b25Mb2FkfVxuICAgICAgICBvblRyYW5zaXRpb25TdGFydD17b25UcmFuc2l0aW9uU3RhcnR9XG4gICAgICAgIG9uVHJhbnNpdGlvbkVuZD17b25UcmFuc2l0aW9uRW5kfVxuICAgICAgICByZWY9e21hcFJlZn1cbiAgICAgID5cbiAgICAgICAgeyhkZXRhaWxWaWV3RGF0YSAmJiAhdHJhbnNpdGlvbkluUHJvZ3Jlc3MpICYmIChcbiAgICAgICAgICA8UG9wdXBcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmo0MFBvcHVwfVxuICAgICAgICAgICAgdGlwU2l6ZT17NX1cbiAgICAgICAgICAgIGFuY2hvcj1cInRvcFwiXG4gICAgICAgICAgICBsb25naXR1ZGU9e2RldGFpbFZpZXdEYXRhLmxvbmdpdHVkZSF9XG4gICAgICAgICAgICBsYXRpdHVkZT17ZGV0YWlsVmlld0RhdGEubGF0aXR1ZGUhfVxuICAgICAgICAgICAgY2xvc2VPbkNsaWNrPXt0cnVlfVxuICAgICAgICAgICAgb25DbG9zZT17c2V0RGV0YWlsVmlld0RhdGF9XG4gICAgICAgICAgICBjYXB0dXJlU2Nyb2xsPXt0cnVlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxBcmVhRGV0YWlsIHByb3BlcnRpZXM9e2RldGFpbFZpZXdEYXRhLnByb3BlcnRpZXN9IC8+XG4gICAgICAgICAgPC9Qb3B1cD5cbiAgICAgICAgKX1cblxuICAgICAgICA8TmF2aWdhdGlvbkNvbnRyb2xcbiAgICAgICAgICBzaG93Q29tcGFzcz17ZmFsc2V9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubmF2aWdhdGlvbkNvbnRyb2x9XG4gICAgICAgIC8+XG4gICAgICAgIHsnZ2wnIGluIGZsYWdzID8gPEdlb2xvY2F0ZUNvbnRyb2xcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5nZW9sb2NhdGVDb250cm9sfVxuICAgICAgICAgIHBvc2l0aW9uT3B0aW9ucz17e2VuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZX19XG4gICAgICAgICAgb25HZW9sb2NhdGU9e29uR2VvbG9jYXRlfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLy8gVHlwZXMgaGF2ZSBub3QgY2F1Z2h0IHVwIHlldCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1tYXAtZ2wvaXNzdWVzLzE0OTJcbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrR2VvbG9jYXRlfVxuICAgICAgICAvPiA6ICcnfVxuICAgICAgICB7Z2VvbG9jYXRpb25JblByb2dyZXNzID8gPGRpdj5HZW9sb2NhdGlvbiBpbiBwcm9ncmVzcy4uLjwvZGl2PiA6ICcnfVxuICAgICAgICA8VGVycml0b3J5Rm9jdXNDb250cm9sIG9uQ2xpY2tUZXJyaXRvcnlGb2N1c0J1dHRvbj17b25DbGlja1RlcnJpdG9yeUZvY3VzQnV0dG9ufS8+XG4gICAgICAgIHsnZnMnIGluIGZsYWdzID8gPEZ1bGxzY3JlZW5Db250cm9sIGNsYXNzTmFtZT17c3R5bGVzLmZ1bGxzY3JlZW5Db250cm9sfS8+IDonJyB9XG4gICAgICA8L1JlYWN0TWFwR0w+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBKNDBNYXA7XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgSjQwTWFwIGZyb20gJy4vSjQwTWFwJztcblxuY29uc3QgTWFwV3JhcHBlciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAge1xuICAgICAgICA8SjQwTWFwIC8+XG4gICAgICB9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcFdyYXBwZXI7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgaG93WW91Q2FuSGVscENvbnRhaW5lciA9IFwiSG93WW91Q2FuSGVscC1tb2R1bGUtLWhvd1lvdUNhbkhlbHBDb250YWluZXItLTJrcUJhXCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0hvd1lvdUNhbkhlbHAubW9kdWxlLnNjc3MnO1xuXG5jb25zdCBIb3dZb3VDYW5IZWxwID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaG93WW91Q2FuSGVscENvbnRhaW5lcn0+XG4gICAgICA8aDI+SG93IFlvdSBDYW4gSGVscCBJbXByb3ZlIHRoZSBUb29sPC9oMj5cbiAgICAgIDx1bCBjbGFzc05hbWU9eyd1c2EtbGlzdCd9PlxuICAgICAgICA8bGk+SWYgeW91IGhhdmUgaW5mb3JtYXRpb24gdGhhdCBjb3VsZCBoZWxwLCB3ZeKAmWQgbG92ZSB0byBoZWFyIGZyb20geW91LjwvbGk+XG4gICAgICAgIDxsaT5WaWV3IG91ciBmdWxsIHNldCBvZiBkYXRhIHNvdXJjZXMgYW5kIG1ldGhvZG9sb2d5XG4gICAgICAgICAgICB3aGVyZSB5b3UgY2FuIGFkZCBvciBkb3dubG9hZCBzb3VyY2VzIGFuZCBjaGVjayBzdGF0dXNlcyBvbiBvdXIgZGF0YSByb2FkbWFwLjwvbGk+XG4gICAgICAgIDxsaT5DaGVjayBvdXQgb3VyIHRpbWVsaW5lIGFuZCBzZW5kIGZlZWRiYWNrIG9yIGF0dGVuZCByZWxldmFudCBldmVudHMuPC9saT5cbiAgICAgICAgPGxpPkNvbnRhY3QgdXMgYW5kIHNoYXJlIHRoZSBzdG9yaWVzIG9mIHlvdXIgY29tbXVuaXR5LjwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSG93WW91Q2FuSGVscDtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBsZWdlbmRDb250YWluZXIgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLWxlZ2VuZENvbnRhaW5lci0tMk4xRkNcIjtcbmV4cG9ydCB2YXIgc3dhdGNoQ29udGFpbmVyID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1zd2F0Y2hDb250YWluZXItLTF5WlgxXCI7XG5leHBvcnQgdmFyIGxlZ2VuZEl0ZW0gPSBcIm1hcExlZ2VuZC1tb2R1bGUtLWxlZ2VuZEl0ZW0tLVdlelVmXCI7XG5leHBvcnQgdmFyIGNvbG9yU3dhdGNoID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1jb2xvclN3YXRjaC0tb0JVTjJcIjtcbmV4cG9ydCB2YXIgcHJpb3JpdGl6ZWQgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLXByaW9yaXRpemVkLS0xSTUzNFwiO1xuZXhwb3J0IHZhciB0aHJlc2hvbGQgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLXRocmVzaG9sZC0tMXphbGlcIjtcbmV4cG9ydCB2YXIgbm9uUHJpb3JpdGl6ZWQgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLW5vblByaW9yaXRpemVkLS0yeTBWbVwiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9tYXBMZWdlbmQubW9kdWxlLnNjc3MnO1xuXG5jb25zdCBNYXBMZWdlbmQgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5sZWdlbmRDb250YWluZXJ9PlxuICAgICAgPGgzIGNsYXNzTmFtZT17c3R5bGVzLmxlZ2VuZEhlYWRlcn0+Q09MT1IgS0VZPC9oMz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3dhdGNoQ29udGFpbmVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5sZWdlbmRJdGVtfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbG9yU3dhdGNofSBpZD17c3R5bGVzLnByaW9yaXRpemVkfSAvPlxuICAgICAgICAgIDxzcGFuPlByaW9yaXRpemVkIENvbW11bml0eTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVnZW5kSXRlbX0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2xvclN3YXRjaH0gaWQ9e3N0eWxlcy50aHJlc2hvbGR9IC8+XG4gICAgICAgICAgPHNwYW4+VGhyZXNob2xkIENvbW11bml0eTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVnZW5kSXRlbX0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2xvclN3YXRjaH0gaWQ9e3N0eWxlcy5ub25Qcmlvcml0aXplZH0gLz5cbiAgICAgICAgICA8c3Bhbj5Ob24tUHJpb3JpdGl6ZWQgQ29tbXVuaXR5PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwTGVnZW5kO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGRvd25sb2FkQm94Q29udGFpbmVyID0gXCJkb3dubG9hZFBhY2tldC1tb2R1bGUtLWRvd25sb2FkQm94Q29udGFpbmVyLS1JZllTSVwiO1xuZXhwb3J0IHZhciBkb3dubG9hZEJveCA9IFwiZG93bmxvYWRQYWNrZXQtbW9kdWxlLS1kb3dubG9hZEJveC0tMjNxQUdcIjtcbmV4cG9ydCB2YXIgZG93bmxvYWRCb3hUZXh0Qm94ID0gXCJkb3dubG9hZFBhY2tldC1tb2R1bGUtLWRvd25sb2FkQm94VGV4dEJveC0tMkMwOElcIjtcbmV4cG9ydCB2YXIgZG93bmxvYWRCb3hUaXRsZSA9IFwiZG93bmxvYWRQYWNrZXQtbW9kdWxlLS1kb3dubG9hZEJveFRpdGxlLS0yb1FzUlwiO1xuZXhwb3J0IHZhciBkb3dubG9hZEJveFRleHQgPSBcImRvd25sb2FkUGFja2V0LW1vZHVsZS0tZG93bmxvYWRCb3hUZXh0LS1zMDlIOFwiO1xuZXhwb3J0IHZhciBkb3dubG9hZEJveEJ1dHRvbkNvbnRhaW5lciA9IFwiZG93bmxvYWRQYWNrZXQtbW9kdWxlLS1kb3dubG9hZEJveEJ1dHRvbkNvbnRhaW5lci0tRUJXVWZcIjtcbmV4cG9ydCB2YXIgZG93bmxvYWRCb3hCdXR0b24gPSBcImRvd25sb2FkUGFja2V0LW1vZHVsZS0tZG93bmxvYWRCb3hCdXR0b24tLTN3LW9rXCI7XG5leHBvcnQgdmFyIGRvd25sb2FkUGFja2V0VGV4dCA9IFwiZG93bmxvYWRQYWNrZXQtbW9kdWxlLS1kb3dubG9hZFBhY2tldFRleHQtLTJNeUVWXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR2hsYVdkb2REMGlNalFpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJMElqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEU1SURsb0xUUldNMGc1ZGpaSU5XdzNJRGNnTnkwM2VrMDFJREU0ZGpKb01UUjJMVEpJTlhvaUx6NDhMM04yWno0PVwiIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7QnV0dG9ufSBmcm9tICdAdHJ1c3N3b3Jrcy9yZWFjdC11c3dkcyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9kb3dubG9hZFBhY2tldC5tb2R1bGUuc2Nzcyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgZG93bmxvYWRJY29uIGZyb20gJy9ub2RlX21vZHVsZXMvdXN3ZHMvZGlzdC9pbWcvdXNhLWljb25zL2ZpbGVfZG93bmxvYWQuc3ZnJztcblxuZXhwb3J0IGNvbnN0IGNiZ0ZpbGVVUkwgPSAnaHR0cHM6Ly9qdXN0aWNlNDAtZGF0YS5zMy5hbWF6b25hd3MuY29tL1Njb3JlL3VzYS56aXAnO1xuXG5jb25zdCBEb3dubG9hZFBhY2tldCA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvd25sb2FkQm94Q29udGFpbmVyfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG93bmxvYWRCb3h9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvd25sb2FkQm94VGV4dEJveH0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb3dubG9hZEJveFRpdGxlfT5KdXN0IFByb2dyZXNzIFBhY2tldDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG93bmxvYWRCb3hUZXh0fT5UaGlzIGRvd25sb2FkYWJsZSBwYWNrZXQgaW5jbHVkZXMgdGhlIGxpc3Qgb2YgSnVzdCBQcm9ncmVzc1xuICAgICAgICAgIHByaW9yaXRpemVkIGNvbW11bml0aWVzICgzMCwwMjEgY2Vuc3VzIGJsb2NrIGdyb3VwcykgYW5kIDE4IGRhdGFzZXRzLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG93bmxvYWRCb3hCdXR0b25Db250YWluZXJ9PlxuICAgICAgICAgICAgPGEgaWQ9eydkb3dubG9hZC1saW5rJ30gaHJlZj17Y2JnRmlsZVVSTH0+XG4gICAgICAgICAgICAgIDxCdXR0b24gY2xhc3NOYW1lPXtzdHlsZXMuZG93bmxvYWRCb3hCdXR0b259IHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICA8ZGl2PjxpbWcgc3JjPXtkb3dubG9hZEljb259IC8+IDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG93bmxvYWRQYWNrZXRUZXh0fT5Eb3dubG9hZCBwYWNrZXQ8L2Rpdj5cbiAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEb3dubG9hZFBhY2tldDtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBkaXNjbGFpbWVyID0gXCJjZWpzdC1tb2R1bGUtLWRpc2NsYWltZXItLTNMQzF5XCI7XG5leHBvcnQgdmFyIHRleHRCb3ggPSBcImNlanN0LW1vZHVsZS0tdGV4dEJveC0tOXd1RHdcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9jb21wb25lbnRzL2xheW91dCc7XG5pbXBvcnQgTWFwV3JhcHBlciBmcm9tICcuLi9jb21wb25lbnRzL21hcFdyYXBwZXInO1xuaW1wb3J0IEhvd1lvdUNhbkhlbHAgZnJvbSAnLi4vY29tcG9uZW50cy9Ib3dZb3VDYW5IZWxwJztcbmltcG9ydCBNYXBMZWdlbmQgZnJvbSAnLi4vY29tcG9uZW50cy9tYXBMZWdlbmQnO1xuaW1wb3J0IERvd25sb2FkUGFja2V0IGZyb20gJy4uL2NvbXBvbmVudHMvZG93bmxvYWRQYWNrZXQnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vY2Vqc3QubW9kdWxlLnNjc3MnO1xuXG5pbnRlcmZhY2UgSU1hcFBhZ2VQcm9wcyB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuXG5jb25zdCBDRUpTVFBhZ2UgPSAoe2xvY2F0aW9ufTogSU1hcFBhZ2VQcm9wcykgPT4ge1xuICAvLyBXZSB0ZW1wb3JhcmlseSByZW1vdmVkIE1hcENvbnRyb2xzLCB3aGljaCB3b3VsZCBlbmFibGUgeW91IHRvIGBzZXRGZWF0dXJlc2AgYWxzbywgZm9yIG5vd1xuICAvLyAgIFdlIHdpbGwgYnJpbmcgYmFjayBsYXRlciB3aGVuIHdlIGhhdmUgaW50ZXJhY3RpdmUgY29udHJvbHMuXG4gIHJldHVybiAoXG4gICAgPExheW91dCBsb2NhdGlvbj17bG9jYXRpb259PlxuICAgICAgPG1haW4gaWQ9XCJtYWluLWNvbnRlbnRcIiByb2xlPVwibWFpblwiPlxuXG4gICAgICAgIDxzZWN0aW9uPlxuICAgICAgICAgIDxoMj5KdXN0IFByb2dyZXNzIGNvbW11bml0aWVzPC9oMj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRpc2NsYWltZXJ9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50ZXh0Qm94fT5cbiAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgSnVzdCBQcm9ncmVzcyBoZWxwcyBpZGVudGlmeSBhbmQgcHJpb3JpdGl6ZSBjb21tdW5pdGllcyBhY3Jvc3MgdGhlIFVuaXRlZCBTdGF0ZXMgYW5kIFUuUy4gdGVycml0b3JpZXNcbiAgICAgICAgICAgICAgICB0aGF0IGhhdmUgYmVlbiBoaXN0b3JpY2FsbHkgb3ZlcmJ1cmRlbmVkIGFuZCB1bmRlcnNlcnZlZC4gVGhlc2UgY29tbXVuaXRpZXMgd2lsbCByZWNlaXZlIDQwJSBvZlxuICAgICAgICAgICAgICAgIHRoZSBiZW5lZml0cyBmcm9tIGludmVzdG1lbnRzIGluIGtleSBhcmVhcyBvdXRsaW5lZCBieSB0aGVcbiAgICAgICAgICAgICAgICAmbmJzcDtcbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgaHJlZj17J2h0dHBzOi8vd3d3LndoaXRlaG91c2UuZ292L2JyaWVmaW5nLXJvb20vJyArXG4gICAgICAgICAgICAgICAgICAgICdwcmVzaWRlbnRpYWwtYWN0aW9ucy8yMDIxLzAxLzI3LycgK1xuICAgICAgICAgICAgICAgICAgICAnZXhlY3V0aXZlLW9yZGVyLW9uLXRhY2tsaW5nLXRoZS1jbGltYXRlLScgK1xuICAgICAgICAgICAgICAgICAgICAnY3Jpc2lzLWF0LWhvbWUtYW5kLWFicm9hZC8nfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0PXsnX2JsYW5rJ31cbiAgICAgICAgICAgICAgICAgIHJlbD17J25vcmVmZXJyZXInfT5cbiAgICAgICAgICAgICAgICAgIEV4ZWN1dGl2ZSBPcmRlciBvbiBUYWNrbGluZyB0aGUgQ2xpbWF0ZSBDcmlzaXMgYXQgSG9tZSBhbmQgQWJyb2FkXG4gICAgICAgICAgICAgICAgPC9hPi5cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICBEb3dubG9hZCB0aGUgSnVzdCBQcm9ncmVzcyBwYWNrZXQgb3IgZXhwbG9yZSB0aGUgbWFwIGJlbG93IHRvIHNlZSB0aGUgbGlzdCBvZiBwcmlvcml0aXplZCBjb21tdW5pdGVzLiBUb1xuICAgICAgICAgICAgICAgIGxlYXJuIG1vcmUgYWJvdXQgaG93IHRoZXNlIGNvbW11bml0aWVzIHdlcmUgcHJpb3JpdGl6ZWQgY2hlY2sgb3V0IHRoZVxuICAgICAgICAgICAgICAgICZuYnNwO1xuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICBocmVmPXsnLi9tZXRob2RvbG9neSd9PlxuICAgICAgICAgICAgICAgICAgTWV0aG9kb2xvZ3lcbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgJm5ic3A7XG4gICAgICAgICAgICAgICAgcGFnZS5cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8RG93bmxvYWRQYWNrZXQgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9zZWN0aW9uPlxuXG4gICAgICAgIDxoMj5FeHBsb3JlIHRoZSBUb29sPC9oMj5cbiAgICAgICAgPE1hcFdyYXBwZXIgLz5cbiAgICAgICAgPE1hcExlZ2VuZCAvPlxuICAgICAgICA8SG93WW91Q2FuSGVscCAvPlxuICAgICAgPC9tYWluPlxuICAgIDwvTGF5b3V0PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ0VKU1RQYWdlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2767\n')}}]);