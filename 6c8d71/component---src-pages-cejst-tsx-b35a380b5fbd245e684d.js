(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[281],{3873:function(module){eval("/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2019, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  var limit = function limit(x, min, max) {\n    if (min === void 0) min = 0;\n    if (max === void 0) max = 1;\n    return x < min ? min : x > max ? max : x;\n  };\n\n  var clip_rgb = function clip_rgb(rgb) {\n    rgb._clipped = false;\n    rgb._unclipped = rgb.slice(0);\n\n    for (var i = 0; i <= 3; i++) {\n      if (i < 3) {\n        if (rgb[i] < 0 || rgb[i] > 255) {\n          rgb._clipped = true;\n        }\n\n        rgb[i] = limit(rgb[i], 0, 255);\n      } else if (i === 3) {\n        rgb[i] = limit(rgb[i], 0, 1);\n      }\n    }\n\n    return rgb;\n  }; // ported from jQuery's $.type\n\n\n  var classToType = {};\n\n  for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\n    var name = list[i];\n    classToType[\"[object \" + name + \"]\"] = name.toLowerCase();\n  }\n\n  var type = function type(obj) {\n    return classToType[Object.prototype.toString.call(obj)] || \"object\";\n  };\n\n  var unpack = function unpack(args, keyOrder) {\n    if (keyOrder === void 0) keyOrder = null; // if called with more than 3 arguments, we return the arguments\n\n    if (args.length >= 3) {\n      return Array.prototype.slice.call(args);\n    } // with less than 3 args we check if first arg is object\n    // and use the keyOrder string to extract and sort properties\n\n\n    if (type(args[0]) == 'object' && keyOrder) {\n      return keyOrder.split('').filter(function (k) {\n        return args[0][k] !== undefined;\n      }).map(function (k) {\n        return args[0][k];\n      });\n    } // otherwise we just return the first argument\n    // (which we suppose is an array of args)\n\n\n    return args[0];\n  };\n\n  var last = function last(args) {\n    if (args.length < 2) {\n      return null;\n    }\n\n    var l = args.length - 1;\n\n    if (type(args[l]) == 'string') {\n      return args[l].toLowerCase();\n    }\n\n    return null;\n  };\n\n  var PI = Math.PI;\n  var utils = {\n    clip_rgb: clip_rgb,\n    limit: limit,\n    type: type,\n    unpack: unpack,\n    last: last,\n    PI: PI,\n    TWOPI: PI * 2,\n    PITHIRD: PI / 3,\n    DEG2RAD: PI / 180,\n    RAD2DEG: 180 / PI\n  };\n  var input = {\n    format: {},\n    autodetect: []\n  };\n  var last$1 = utils.last;\n  var clip_rgb$1 = utils.clip_rgb;\n  var type$1 = utils.type;\n\n  var Color = function Color() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var me = this;\n\n    if (type$1(args[0]) === 'object' && args[0].constructor && args[0].constructor === this.constructor) {\n      // the argument is already a Color instance\n      return args[0];\n    } // last argument could be the mode\n\n\n    var mode = last$1(args);\n    var autodetect = false;\n\n    if (!mode) {\n      autodetect = true;\n\n      if (!input.sorted) {\n        input.autodetect = input.autodetect.sort(function (a, b) {\n          return b.p - a.p;\n        });\n        input.sorted = true;\n      } // auto-detect format\n\n\n      for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n        var chk = list[i];\n        mode = chk.test.apply(chk, args);\n\n        if (mode) {\n          break;\n        }\n      }\n    }\n\n    if (input.format[mode]) {\n      var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));\n      me._rgb = clip_rgb$1(rgb);\n    } else {\n      throw new Error('unknown format: ' + args);\n    } // add alpha channel\n\n\n    if (me._rgb.length === 3) {\n      me._rgb.push(1);\n    }\n  };\n\n  Color.prototype.toString = function toString() {\n    if (type$1(this.hex) == 'function') {\n      return this.hex();\n    }\n\n    return \"[\" + this._rgb.join(',') + \"]\";\n  };\n\n  var Color_1 = Color;\n\n  var chroma = function chroma() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(chroma.Color, [null].concat(args)))();\n  };\n\n  chroma.Color = Color_1;\n  chroma.version = '2.1.2';\n  var chroma_1 = chroma;\n  var unpack$1 = utils.unpack;\n  var max = Math.max;\n\n  var rgb2cmyk = function rgb2cmyk() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$1(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    r = r / 255;\n    g = g / 255;\n    b = b / 255;\n    var k = 1 - max(r, max(g, b));\n    var f = k < 1 ? 1 / (1 - k) : 0;\n    var c = (1 - r - k) * f;\n    var m = (1 - g - k) * f;\n    var y = (1 - b - k) * f;\n    return [c, m, y, k];\n  };\n\n  var rgb2cmyk_1 = rgb2cmyk;\n  var unpack$2 = utils.unpack;\n\n  var cmyk2rgb = function cmyk2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$2(args, 'cmyk');\n    var c = args[0];\n    var m = args[1];\n    var y = args[2];\n    var k = args[3];\n    var alpha = args.length > 4 ? args[4] : 1;\n\n    if (k === 1) {\n      return [0, 0, 0, alpha];\n    }\n\n    return [c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r\n    m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g\n    y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b\n    alpha];\n  };\n\n  var cmyk2rgb_1 = cmyk2rgb;\n  var unpack$3 = utils.unpack;\n  var type$2 = utils.type;\n\n  Color_1.prototype.cmyk = function () {\n    return rgb2cmyk_1(this._rgb);\n  };\n\n  chroma_1.cmyk = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['cmyk'])))();\n  };\n\n  input.format.cmyk = cmyk2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$3(args, 'cmyk');\n\n      if (type$2(args) === 'array' && args.length === 4) {\n        return 'cmyk';\n      }\n    }\n  });\n  var unpack$4 = utils.unpack;\n  var last$2 = utils.last;\n\n  var rnd = function rnd(a) {\n    return Math.round(a * 100) / 100;\n  };\n  /*\n   * supported arguments:\n   * - hsl2css(h,s,l)\n   * - hsl2css(h,s,l,a)\n   * - hsl2css([h,s,l], mode)\n   * - hsl2css([h,s,l,a], mode)\n   * - hsl2css({h,s,l,a}, mode)\n   */\n\n\n  var hsl2css = function hsl2css() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var hsla = unpack$4(args, 'hsla');\n    var mode = last$2(args) || 'lsa';\n    hsla[0] = rnd(hsla[0] || 0);\n    hsla[1] = rnd(hsla[1] * 100) + '%';\n    hsla[2] = rnd(hsla[2] * 100) + '%';\n\n    if (mode === 'hsla' || hsla.length > 3 && hsla[3] < 1) {\n      hsla[3] = hsla.length > 3 ? hsla[3] : 1;\n      mode = 'hsla';\n    } else {\n      hsla.length = 3;\n    }\n\n    return mode + \"(\" + hsla.join(',') + \")\";\n  };\n\n  var hsl2css_1 = hsl2css;\n  var unpack$5 = utils.unpack;\n  /*\n   * supported arguments:\n   * - rgb2hsl(r,g,b)\n   * - rgb2hsl(r,g,b,a)\n   * - rgb2hsl([r,g,b])\n   * - rgb2hsl([r,g,b,a])\n   * - rgb2hsl({r,g,b,a})\n   */\n\n  var rgb2hsl = function rgb2hsl() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$5(args, 'rgba');\n    var r = args[0];\n    var g = args[1];\n    var b = args[2];\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var l = (max + min) / 2;\n    var s, h;\n\n    if (max === min) {\n      s = 0;\n      h = Number.NaN;\n    } else {\n      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n    }\n\n    if (r == max) {\n      h = (g - b) / (max - min);\n    } else if (g == max) {\n      h = 2 + (b - r) / (max - min);\n    } else if (b == max) {\n      h = 4 + (r - g) / (max - min);\n    }\n\n    h *= 60;\n\n    if (h < 0) {\n      h += 360;\n    }\n\n    if (args.length > 3 && args[3] !== undefined) {\n      return [h, s, l, args[3]];\n    }\n\n    return [h, s, l];\n  };\n\n  var rgb2hsl_1 = rgb2hsl;\n  var unpack$6 = utils.unpack;\n  var last$3 = utils.last;\n  var round = Math.round;\n  /*\n   * supported arguments:\n   * - rgb2css(r,g,b)\n   * - rgb2css(r,g,b,a)\n   * - rgb2css([r,g,b], mode)\n   * - rgb2css([r,g,b,a], mode)\n   * - rgb2css({r,g,b,a}, mode)\n   */\n\n  var rgb2css = function rgb2css() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgba = unpack$6(args, 'rgba');\n    var mode = last$3(args) || 'rgb';\n\n    if (mode.substr(0, 3) == 'hsl') {\n      return hsl2css_1(rgb2hsl_1(rgba), mode);\n    }\n\n    rgba[0] = round(rgba[0]);\n    rgba[1] = round(rgba[1]);\n    rgba[2] = round(rgba[2]);\n\n    if (mode === 'rgba' || rgba.length > 3 && rgba[3] < 1) {\n      rgba[3] = rgba.length > 3 ? rgba[3] : 1;\n      mode = 'rgba';\n    }\n\n    return mode + \"(\" + rgba.slice(0, mode === 'rgb' ? 3 : 4).join(',') + \")\";\n  };\n\n  var rgb2css_1 = rgb2css;\n  var unpack$7 = utils.unpack;\n  var round$1 = Math.round;\n\n  var hsl2rgb = function hsl2rgb() {\n    var assign;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$7(args, 'hsl');\n    var h = args[0];\n    var s = args[1];\n    var l = args[2];\n    var r, g, b;\n\n    if (s === 0) {\n      r = g = b = l * 255;\n    } else {\n      var t3 = [0, 0, 0];\n      var c = [0, 0, 0];\n      var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var t1 = 2 * l - t2;\n      var h_ = h / 360;\n      t3[0] = h_ + 1 / 3;\n      t3[1] = h_;\n      t3[2] = h_ - 1 / 3;\n\n      for (var i = 0; i < 3; i++) {\n        if (t3[i] < 0) {\n          t3[i] += 1;\n        }\n\n        if (t3[i] > 1) {\n          t3[i] -= 1;\n        }\n\n        if (6 * t3[i] < 1) {\n          c[i] = t1 + (t2 - t1) * 6 * t3[i];\n        } else if (2 * t3[i] < 1) {\n          c[i] = t2;\n        } else if (3 * t3[i] < 2) {\n          c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;\n        } else {\n          c[i] = t1;\n        }\n      }\n\n      assign = [round$1(c[0] * 255), round$1(c[1] * 255), round$1(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2];\n    }\n\n    if (args.length > 3) {\n      // keep alpha channel\n      return [r, g, b, args[3]];\n    }\n\n    return [r, g, b, 1];\n  };\n\n  var hsl2rgb_1 = hsl2rgb;\n  var RE_RGB = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n  var RE_RGBA = /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var RE_RGB_PCT = /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var RE_RGBA_PCT = /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var RE_HSL = /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var RE_HSLA = /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n  var round$2 = Math.round;\n\n  var css2rgb = function css2rgb(css) {\n    css = css.toLowerCase().trim();\n    var m;\n\n    if (input.format.named) {\n      try {\n        return input.format.named(css);\n      } catch (e) {// eslint-disable-next-line\n      }\n    } // rgb(250,20,0)\n\n\n    if (m = css.match(RE_RGB)) {\n      var rgb = m.slice(1, 4);\n\n      for (var i = 0; i < 3; i++) {\n        rgb[i] = +rgb[i];\n      }\n\n      rgb[3] = 1; // default alpha\n\n      return rgb;\n    } // rgba(250,20,0,0.4)\n\n\n    if (m = css.match(RE_RGBA)) {\n      var rgb$1 = m.slice(1, 5);\n\n      for (var i$1 = 0; i$1 < 4; i$1++) {\n        rgb$1[i$1] = +rgb$1[i$1];\n      }\n\n      return rgb$1;\n    } // rgb(100%,0%,0%)\n\n\n    if (m = css.match(RE_RGB_PCT)) {\n      var rgb$2 = m.slice(1, 4);\n\n      for (var i$2 = 0; i$2 < 3; i$2++) {\n        rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\n      }\n\n      rgb$2[3] = 1; // default alpha\n\n      return rgb$2;\n    } // rgba(100%,0%,0%,0.4)\n\n\n    if (m = css.match(RE_RGBA_PCT)) {\n      var rgb$3 = m.slice(1, 5);\n\n      for (var i$3 = 0; i$3 < 3; i$3++) {\n        rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\n      }\n\n      rgb$3[3] = +rgb$3[3];\n      return rgb$3;\n    } // hsl(0,100%,50%)\n\n\n    if (m = css.match(RE_HSL)) {\n      var hsl = m.slice(1, 4);\n      hsl[1] *= 0.01;\n      hsl[2] *= 0.01;\n      var rgb$4 = hsl2rgb_1(hsl);\n      rgb$4[3] = 1;\n      return rgb$4;\n    } // hsla(0,100%,50%,0.5)\n\n\n    if (m = css.match(RE_HSLA)) {\n      var hsl$1 = m.slice(1, 4);\n      hsl$1[1] *= 0.01;\n      hsl$1[2] *= 0.01;\n      var rgb$5 = hsl2rgb_1(hsl$1);\n      rgb$5[3] = +m[4]; // default alpha = 1\n\n      return rgb$5;\n    }\n  };\n\n  css2rgb.test = function (s) {\n    return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);\n  };\n\n  var css2rgb_1 = css2rgb;\n  var type$3 = utils.type;\n\n  Color_1.prototype.css = function (mode) {\n    return rgb2css_1(this._rgb, mode);\n  };\n\n  chroma_1.css = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['css'])))();\n  };\n\n  input.format.css = css2rgb_1;\n  input.autodetect.push({\n    p: 5,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\n        return 'css';\n      }\n    }\n  });\n  var unpack$8 = utils.unpack;\n\n  input.format.gl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgb = unpack$8(args, 'rgba');\n    rgb[0] *= 255;\n    rgb[1] *= 255;\n    rgb[2] *= 255;\n    return rgb;\n  };\n\n  chroma_1.gl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['gl'])))();\n  };\n\n  Color_1.prototype.gl = function () {\n    var rgb = this._rgb;\n    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];\n  };\n\n  var unpack$9 = utils.unpack;\n\n  var rgb2hcg = function rgb2hcg() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$9(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var c = delta * 100 / 255;\n\n    var _g = min / (255 - delta) * 100;\n\n    var h;\n\n    if (delta === 0) {\n      h = Number.NaN;\n    } else {\n      if (r === max) {\n        h = (g - b) / delta;\n      }\n\n      if (g === max) {\n        h = 2 + (b - r) / delta;\n      }\n\n      if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    }\n\n    return [h, c, _g];\n  };\n\n  var rgb2hcg_1 = rgb2hcg;\n  var unpack$a = utils.unpack;\n  var floor = Math.floor;\n  /*\n   * this is basically just HSV with some minor tweaks\n   *\n   * hue.. [0..360]\n   * chroma .. [0..1]\n   * grayness .. [0..1]\n   */\n\n  var hcg2rgb = function hcg2rgb() {\n    var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$a(args, 'hcg');\n    var h = args[0];\n    var c = args[1];\n    var _g = args[2];\n    var r, g, b;\n    _g = _g * 255;\n\n    var _c = c * 255;\n\n    if (c === 0) {\n      r = g = b = _g;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n\n      if (h > 360) {\n        h -= 360;\n      }\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      h /= 60;\n      var i = floor(h);\n      var f = h - i;\n      var p = _g * (1 - c);\n      var q = p + _c * (1 - f);\n      var t = p + _c * f;\n      var v = p + _c;\n\n      switch (i) {\n        case 0:\n          assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];\n          break;\n\n        case 1:\n          assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];\n          break;\n\n        case 2:\n          assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];\n          break;\n\n        case 3:\n          assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];\n          break;\n\n        case 4:\n          assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];\n          break;\n\n        case 5:\n          assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];\n          break;\n      }\n    }\n\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var hcg2rgb_1 = hcg2rgb;\n  var unpack$b = utils.unpack;\n  var type$4 = utils.type;\n\n  Color_1.prototype.hcg = function () {\n    return rgb2hcg_1(this._rgb);\n  };\n\n  chroma_1.hcg = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hcg'])))();\n  };\n\n  input.format.hcg = hcg2rgb_1;\n  input.autodetect.push({\n    p: 1,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$b(args, 'hcg');\n\n      if (type$4(args) === 'array' && args.length === 3) {\n        return 'hcg';\n      }\n    }\n  });\n  var unpack$c = utils.unpack;\n  var last$4 = utils.last;\n  var round$3 = Math.round;\n\n  var rgb2hex = function rgb2hex() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$c(args, 'rgba');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var a = ref[3];\n    var mode = last$4(args) || 'auto';\n\n    if (a === undefined) {\n      a = 1;\n    }\n\n    if (mode === 'auto') {\n      mode = a < 1 ? 'rgba' : 'rgb';\n    }\n\n    r = round$3(r);\n    g = round$3(g);\n    b = round$3(b);\n    var u = r << 16 | g << 8 | b;\n    var str = \"000000\" + u.toString(16); //#.toUpperCase();\n\n    str = str.substr(str.length - 6);\n    var hxa = '0' + round$3(a * 255).toString(16);\n    hxa = hxa.substr(hxa.length - 2);\n\n    switch (mode.toLowerCase()) {\n      case 'rgba':\n        return \"#\" + str + hxa;\n\n      case 'argb':\n        return \"#\" + hxa + str;\n\n      default:\n        return \"#\" + str;\n    }\n  };\n\n  var rgb2hex_1 = rgb2hex;\n  var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n  var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n  var hex2rgb = function hex2rgb(hex) {\n    if (hex.match(RE_HEX)) {\n      // remove optional leading #\n      if (hex.length === 4 || hex.length === 7) {\n        hex = hex.substr(1);\n      } // expand short-notation to full six-digit\n\n\n      if (hex.length === 3) {\n        hex = hex.split('');\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n      }\n\n      var u = parseInt(hex, 16);\n      var r = u >> 16;\n      var g = u >> 8 & 0xFF;\n      var b = u & 0xFF;\n      return [r, g, b, 1];\n    } // match rgba hex format, eg #FF000077\n\n\n    if (hex.match(RE_HEXA)) {\n      if (hex.length === 5 || hex.length === 9) {\n        // remove optional leading #\n        hex = hex.substr(1);\n      } // expand short-notation to full eight-digit\n\n\n      if (hex.length === 4) {\n        hex = hex.split('');\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n      }\n\n      var u$1 = parseInt(hex, 16);\n      var r$1 = u$1 >> 24 & 0xFF;\n      var g$1 = u$1 >> 16 & 0xFF;\n      var b$1 = u$1 >> 8 & 0xFF;\n      var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\n      return [r$1, g$1, b$1, a];\n    } // we used to check for css colors here\n    // if _input.css? and rgb = _input.css hex\n    //     return rgb\n\n\n    throw new Error(\"unknown hex color: \" + hex);\n  };\n\n  var hex2rgb_1 = hex2rgb;\n  var type$5 = utils.type;\n\n  Color_1.prototype.hex = function (mode) {\n    return rgb2hex_1(this._rgb, mode);\n  };\n\n  chroma_1.hex = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hex'])))();\n  };\n\n  input.format.hex = hex2rgb_1;\n  input.autodetect.push({\n    p: 4,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$5(h) === 'string' && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {\n        return 'hex';\n      }\n    }\n  });\n  var unpack$d = utils.unpack;\n  var TWOPI = utils.TWOPI;\n  var min = Math.min;\n  var sqrt = Math.sqrt;\n  var acos = Math.acos;\n\n  var rgb2hsi = function rgb2hsi() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n    */\n\n\n    var ref = unpack$d(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var h;\n    var min_ = min(r, g, b);\n    var i = (r + g + b) / 3;\n    var s = i > 0 ? 1 - min_ / i : 0;\n\n    if (s === 0) {\n      h = NaN;\n    } else {\n      h = (r - g + (r - b)) / 2;\n      h /= sqrt((r - g) * (r - g) + (r - b) * (g - b));\n      h = acos(h);\n\n      if (b > g) {\n        h = TWOPI - h;\n      }\n\n      h /= TWOPI;\n    }\n\n    return [h * 360, s, i];\n  };\n\n  var rgb2hsi_1 = rgb2hsi;\n  var unpack$e = utils.unpack;\n  var limit$1 = utils.limit;\n  var TWOPI$1 = utils.TWOPI;\n  var PITHIRD = utils.PITHIRD;\n  var cos = Math.cos;\n  /*\n   * hue [0..360]\n   * saturation [0..1]\n   * intensity [0..1]\n   */\n\n  var hsi2rgb = function hsi2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n    */\n\n\n    args = unpack$e(args, 'hsi');\n    var h = args[0];\n    var s = args[1];\n    var i = args[2];\n    var r, g, b;\n\n    if (isNaN(h)) {\n      h = 0;\n    }\n\n    if (isNaN(s)) {\n      s = 0;\n    } // normalize hue\n\n\n    if (h > 360) {\n      h -= 360;\n    }\n\n    if (h < 0) {\n      h += 360;\n    }\n\n    h /= 360;\n\n    if (h < 1 / 3) {\n      b = (1 - s) / 3;\n      r = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      g = 1 - (b + r);\n    } else if (h < 2 / 3) {\n      h -= 1 / 3;\n      r = (1 - s) / 3;\n      g = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      b = 1 - (r + g);\n    } else {\n      h -= 2 / 3;\n      g = (1 - s) / 3;\n      b = (1 + s * cos(TWOPI$1 * h) / cos(PITHIRD - TWOPI$1 * h)) / 3;\n      r = 1 - (g + b);\n    }\n\n    r = limit$1(i * r * 3);\n    g = limit$1(i * g * 3);\n    b = limit$1(i * b * 3);\n    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];\n  };\n\n  var hsi2rgb_1 = hsi2rgb;\n  var unpack$f = utils.unpack;\n  var type$6 = utils.type;\n\n  Color_1.prototype.hsi = function () {\n    return rgb2hsi_1(this._rgb);\n  };\n\n  chroma_1.hsi = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsi'])))();\n  };\n\n  input.format.hsi = hsi2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$f(args, 'hsi');\n\n      if (type$6(args) === 'array' && args.length === 3) {\n        return 'hsi';\n      }\n    }\n  });\n  var unpack$g = utils.unpack;\n  var type$7 = utils.type;\n\n  Color_1.prototype.hsl = function () {\n    return rgb2hsl_1(this._rgb);\n  };\n\n  chroma_1.hsl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsl'])))();\n  };\n\n  input.format.hsl = hsl2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$g(args, 'hsl');\n\n      if (type$7(args) === 'array' && args.length === 3) {\n        return 'hsl';\n      }\n    }\n  });\n  var unpack$h = utils.unpack;\n  var min$1 = Math.min;\n  var max$1 = Math.max;\n  /*\n   * supported arguments:\n   * - rgb2hsv(r,g,b)\n   * - rgb2hsv([r,g,b])\n   * - rgb2hsv({r,g,b})\n   */\n\n  var rgb2hsl$1 = function rgb2hsl$1() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$h(args, 'rgb');\n    var r = args[0];\n    var g = args[1];\n    var b = args[2];\n    var min_ = min$1(r, g, b);\n    var max_ = max$1(r, g, b);\n    var delta = max_ - min_;\n    var h, s, v;\n    v = max_ / 255.0;\n\n    if (max_ === 0) {\n      h = Number.NaN;\n      s = 0;\n    } else {\n      s = delta / max_;\n\n      if (r === max_) {\n        h = (g - b) / delta;\n      }\n\n      if (g === max_) {\n        h = 2 + (b - r) / delta;\n      }\n\n      if (b === max_) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    }\n\n    return [h, s, v];\n  };\n\n  var rgb2hsv = rgb2hsl$1;\n  var unpack$i = utils.unpack;\n  var floor$1 = Math.floor;\n\n  var hsv2rgb = function hsv2rgb() {\n    var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$i(args, 'hsv');\n    var h = args[0];\n    var s = args[1];\n    var v = args[2];\n    var r, g, b;\n    v *= 255;\n\n    if (s === 0) {\n      r = g = b = v;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n\n      if (h > 360) {\n        h -= 360;\n      }\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      h /= 60;\n      var i = floor$1(h);\n      var f = h - i;\n      var p = v * (1 - s);\n      var q = v * (1 - s * f);\n      var t = v * (1 - s * (1 - f));\n\n      switch (i) {\n        case 0:\n          assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];\n          break;\n\n        case 1:\n          assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];\n          break;\n\n        case 2:\n          assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];\n          break;\n\n        case 3:\n          assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];\n          break;\n\n        case 4:\n          assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];\n          break;\n\n        case 5:\n          assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];\n          break;\n      }\n    }\n\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var hsv2rgb_1 = hsv2rgb;\n  var unpack$j = utils.unpack;\n  var type$8 = utils.type;\n\n  Color_1.prototype.hsv = function () {\n    return rgb2hsv(this._rgb);\n  };\n\n  chroma_1.hsv = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hsv'])))();\n  };\n\n  input.format.hsv = hsv2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$j(args, 'hsv');\n\n      if (type$8(args) === 'array' && args.length === 3) {\n        return 'hsv';\n      }\n    }\n  });\n  var labConstants = {\n    // Corresponds roughly to RGB brighter/darker\n    Kn: 18,\n    // D65 standard referent\n    Xn: 0.950470,\n    Yn: 1,\n    Zn: 1.088830,\n    t0: 0.137931034,\n    // 4 / 29\n    t1: 0.206896552,\n    // 6 / 29\n    t2: 0.12841855,\n    // 3 * t1 * t1\n    t3: 0.008856452 // t1 * t1 * t1\n\n  };\n  var unpack$k = utils.unpack;\n  var pow = Math.pow;\n\n  var rgb2lab = function rgb2lab() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$k(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var ref$1 = rgb2xyz(r, g, b);\n    var x = ref$1[0];\n    var y = ref$1[1];\n    var z = ref$1[2];\n    var l = 116 * y - 16;\n    return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\n  };\n\n  var rgb_xyz = function rgb_xyz(r) {\n    if ((r /= 255) <= 0.04045) {\n      return r / 12.92;\n    }\n\n    return pow((r + 0.055) / 1.055, 2.4);\n  };\n\n  var xyz_lab = function xyz_lab(t) {\n    if (t > labConstants.t3) {\n      return pow(t, 1 / 3);\n    }\n\n    return t / labConstants.t2 + labConstants.t0;\n  };\n\n  var rgb2xyz = function rgb2xyz(r, g, b) {\n    r = rgb_xyz(r);\n    g = rgb_xyz(g);\n    b = rgb_xyz(b);\n    var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\n    var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\n    var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\n    return [x, y, z];\n  };\n\n  var rgb2lab_1 = rgb2lab;\n  var unpack$l = utils.unpack;\n  var pow$1 = Math.pow;\n  /*\n   * L* [0..100]\n   * a [-100..100]\n   * b [-100..100]\n   */\n\n  var lab2rgb = function lab2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$l(args, 'lab');\n    var l = args[0];\n    var a = args[1];\n    var b = args[2];\n    var x, y, z, r, g, b_;\n    y = (l + 16) / 116;\n    x = isNaN(a) ? y : y + a / 500;\n    z = isNaN(b) ? y : y - b / 200;\n    y = labConstants.Yn * lab_xyz(y);\n    x = labConstants.Xn * lab_xyz(x);\n    z = labConstants.Zn * lab_xyz(z);\n    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z); // D65 -> sRGB\n\n    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n    b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n    return [r, g, b_, args.length > 3 ? args[3] : 1];\n  };\n\n  var xyz_rgb = function xyz_rgb(r) {\n    return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055);\n  };\n\n  var lab_xyz = function lab_xyz(t) {\n    return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0);\n  };\n\n  var lab2rgb_1 = lab2rgb;\n  var unpack$m = utils.unpack;\n  var type$9 = utils.type;\n\n  Color_1.prototype.lab = function () {\n    return rgb2lab_1(this._rgb);\n  };\n\n  chroma_1.lab = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['lab'])))();\n  };\n\n  input.format.lab = lab2rgb_1;\n  input.autodetect.push({\n    p: 2,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$m(args, 'lab');\n\n      if (type$9(args) === 'array' && args.length === 3) {\n        return 'lab';\n      }\n    }\n  });\n  var unpack$n = utils.unpack;\n  var RAD2DEG = utils.RAD2DEG;\n  var sqrt$1 = Math.sqrt;\n  var atan2 = Math.atan2;\n  var round$4 = Math.round;\n\n  var lab2lch = function lab2lch() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$n(args, 'lab');\n    var l = ref[0];\n    var a = ref[1];\n    var b = ref[2];\n    var c = sqrt$1(a * a + b * b);\n    var h = (atan2(b, a) * RAD2DEG + 360) % 360;\n\n    if (round$4(c * 10000) === 0) {\n      h = Number.NaN;\n    }\n\n    return [l, c, h];\n  };\n\n  var lab2lch_1 = lab2lch;\n  var unpack$o = utils.unpack;\n\n  var rgb2lch = function rgb2lch() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$o(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var ref$1 = rgb2lab_1(r, g, b);\n    var l = ref$1[0];\n    var a = ref$1[1];\n    var b_ = ref$1[2];\n    return lab2lch_1(l, a, b_);\n  };\n\n  var rgb2lch_1 = rgb2lch;\n  var unpack$p = utils.unpack;\n  var DEG2RAD = utils.DEG2RAD;\n  var sin = Math.sin;\n  var cos$1 = Math.cos;\n\n  var lch2lab = function lch2lab() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n     A saturation multiplier was added by Gregor Aisch\n    */\n\n\n    var ref = unpack$p(args, 'lch');\n    var l = ref[0];\n    var c = ref[1];\n    var h = ref[2];\n\n    if (isNaN(h)) {\n      h = 0;\n    }\n\n    h = h * DEG2RAD;\n    return [l, cos$1(h) * c, sin(h) * c];\n  };\n\n  var lch2lab_1 = lch2lab;\n  var unpack$q = utils.unpack;\n\n  var lch2rgb = function lch2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    args = unpack$q(args, 'lch');\n    var l = args[0];\n    var c = args[1];\n    var h = args[2];\n    var ref = lch2lab_1(l, c, h);\n    var L = ref[0];\n    var a = ref[1];\n    var b_ = ref[2];\n    var ref$1 = lab2rgb_1(L, a, b_);\n    var r = ref$1[0];\n    var g = ref$1[1];\n    var b = ref$1[2];\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n  };\n\n  var lch2rgb_1 = lch2rgb;\n  var unpack$r = utils.unpack;\n\n  var hcl2rgb = function hcl2rgb() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var hcl = unpack$r(args, 'hcl').reverse();\n    return lch2rgb_1.apply(void 0, hcl);\n  };\n\n  var hcl2rgb_1 = hcl2rgb;\n  var unpack$s = utils.unpack;\n  var type$a = utils.type;\n\n  Color_1.prototype.lch = function () {\n    return rgb2lch_1(this._rgb);\n  };\n\n  Color_1.prototype.hcl = function () {\n    return rgb2lch_1(this._rgb).reverse();\n  };\n\n  chroma_1.lch = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['lch'])))();\n  };\n\n  chroma_1.hcl = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['hcl'])))();\n  };\n\n  input.format.lch = lch2rgb_1;\n  input.format.hcl = hcl2rgb_1;\n  ['lch', 'hcl'].forEach(function (m) {\n    return input.autodetect.push({\n      p: 2,\n      test: function test() {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) {\n          args[len] = arguments[len];\n        }\n\n        args = unpack$s(args, m);\n\n        if (type$a(args) === 'array' && args.length === 3) {\n          return m;\n        }\n      }\n    });\n  });\n  /**\n  \tX11 color names\n   \thttp://www.w3.org/TR/css3-color/#svg-color\n  */\n\n  var w3cx11 = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflower: '#6495ed',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    laserlemon: '#ffff54',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrod: '#fafad2',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    maroon2: '#7f0000',\n    maroon3: '#b03060',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    purple2: '#7f007f',\n    purple3: '#a020f0',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32'\n  };\n  var w3cx11_1 = w3cx11;\n  var type$b = utils.type;\n\n  Color_1.prototype.name = function () {\n    var hex = rgb2hex_1(this._rgb, 'rgb');\n\n    for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\n      var n = list[i];\n\n      if (w3cx11_1[n] === hex) {\n        return n.toLowerCase();\n      }\n    }\n\n    return hex;\n  };\n\n  input.format.named = function (name) {\n    name = name.toLowerCase();\n\n    if (w3cx11_1[name]) {\n      return hex2rgb_1(w3cx11_1[name]);\n    }\n\n    throw new Error('unknown color name: ' + name);\n  };\n\n  input.autodetect.push({\n    p: 5,\n    test: function test(h) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        rest[len] = arguments[len + 1];\n      }\n\n      if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\n        return 'named';\n      }\n    }\n  });\n  var unpack$t = utils.unpack;\n\n  var rgb2num = function rgb2num() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var ref = unpack$t(args, 'rgb');\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    return (r << 16) + (g << 8) + b;\n  };\n\n  var rgb2num_1 = rgb2num;\n  var type$c = utils.type;\n\n  var num2rgb = function num2rgb(num) {\n    if (type$c(num) == \"number\" && num >= 0 && num <= 0xFFFFFF) {\n      var r = num >> 16;\n      var g = num >> 8 & 0xFF;\n      var b = num & 0xFF;\n      return [r, g, b, 1];\n    }\n\n    throw new Error(\"unknown num color: \" + num);\n  };\n\n  var num2rgb_1 = num2rgb;\n  var type$d = utils.type;\n\n  Color_1.prototype.num = function () {\n    return rgb2num_1(this._rgb);\n  };\n\n  chroma_1.num = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['num'])))();\n  };\n\n  input.format.num = num2rgb_1;\n  input.autodetect.push({\n    p: 5,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\n        return 'num';\n      }\n    }\n  });\n  var unpack$u = utils.unpack;\n  var type$e = utils.type;\n  var round$5 = Math.round;\n\n  Color_1.prototype.rgb = function (rnd) {\n    if (rnd === void 0) rnd = true;\n\n    if (rnd === false) {\n      return this._rgb.slice(0, 3);\n    }\n\n    return this._rgb.slice(0, 3).map(round$5);\n  };\n\n  Color_1.prototype.rgba = function (rnd) {\n    if (rnd === void 0) rnd = true;\n    return this._rgb.slice(0, 4).map(function (v, i) {\n      return i < 3 ? rnd === false ? v : round$5(v) : v;\n    });\n  };\n\n  chroma_1.rgb = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['rgb'])))();\n  };\n\n  input.format.rgb = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgba = unpack$u(args, 'rgba');\n\n    if (rgba[3] === undefined) {\n      rgba[3] = 1;\n    }\n\n    return rgba;\n  };\n\n  input.autodetect.push({\n    p: 3,\n    test: function test() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      args = unpack$u(args, 'rgba');\n\n      if (type$e(args) === 'array' && (args.length === 3 || args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\n        return 'rgb';\n      }\n    }\n  });\n  /*\n   * Based on implementation by Neil Bartlett\n   * https://github.com/neilbartlett/color-temperature\n   */\n\n  var log = Math.log;\n\n  var temperature2rgb = function temperature2rgb(kelvin) {\n    var temp = kelvin / 100;\n    var r, g, b;\n\n    if (temp < 66) {\n      r = 255;\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);\n      b = 255;\n    }\n\n    return [r, g, b, 1];\n  };\n\n  var temperature2rgb_1 = temperature2rgb;\n  /*\n   * Based on implementation by Neil Bartlett\n   * https://github.com/neilbartlett/color-temperature\n   **/\n\n  var unpack$v = utils.unpack;\n  var round$6 = Math.round;\n\n  var rgb2temperature = function rgb2temperature() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    var rgb = unpack$v(args, 'rgb');\n    var r = rgb[0],\n        b = rgb[2];\n    var minTemp = 1000;\n    var maxTemp = 40000;\n    var eps = 0.4;\n    var temp;\n\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      var rgb$1 = temperature2rgb_1(temp);\n\n      if (rgb$1[2] / rgb$1[0] >= b / r) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n\n    return round$6(temp);\n  };\n\n  var rgb2temperature_1 = rgb2temperature;\n\n  Color_1.prototype.temp = Color_1.prototype.kelvin = Color_1.prototype.temperature = function () {\n    return rgb2temperature_1(this._rgb);\n  };\n\n  chroma_1.temp = chroma_1.kelvin = chroma_1.temperature = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return new (Function.prototype.bind.apply(Color_1, [null].concat(args, ['temp'])))();\n  };\n\n  input.format.temp = input.format.kelvin = input.format.temperature = temperature2rgb_1;\n  var type$f = utils.type;\n\n  Color_1.prototype.alpha = function (a, mutate) {\n    if (mutate === void 0) mutate = false;\n\n    if (a !== undefined && type$f(a) === 'number') {\n      if (mutate) {\n        this._rgb[3] = a;\n        return this;\n      }\n\n      return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n    }\n\n    return this._rgb[3];\n  };\n\n  Color_1.prototype.clipped = function () {\n    return this._rgb._clipped || false;\n  };\n\n  Color_1.prototype.darken = function (amount) {\n    if (amount === void 0) amount = 1;\n    var me = this;\n    var lab = me.lab();\n    lab[0] -= labConstants.Kn * amount;\n    return new Color_1(lab, 'lab').alpha(me.alpha(), true);\n  };\n\n  Color_1.prototype.brighten = function (amount) {\n    if (amount === void 0) amount = 1;\n    return this.darken(-amount);\n  };\n\n  Color_1.prototype.darker = Color_1.prototype.darken;\n  Color_1.prototype.brighter = Color_1.prototype.brighten;\n\n  Color_1.prototype.get = function (mc) {\n    var ref = mc.split('.');\n    var mode = ref[0];\n    var channel = ref[1];\n    var src = this[mode]();\n\n    if (channel) {\n      var i = mode.indexOf(channel);\n\n      if (i > -1) {\n        return src[i];\n      }\n\n      throw new Error(\"unknown channel \" + channel + \" in mode \" + mode);\n    } else {\n      return src;\n    }\n  };\n\n  var type$g = utils.type;\n  var pow$2 = Math.pow;\n  var EPS = 1e-7;\n  var MAX_ITER = 20;\n\n  Color_1.prototype.luminance = function (lum) {\n    if (lum !== undefined && type$g(lum) === 'number') {\n      if (lum === 0) {\n        // return pure black\n        return new Color_1([0, 0, 0, this._rgb[3]], 'rgb');\n      }\n\n      if (lum === 1) {\n        // return pure white\n        return new Color_1([255, 255, 255, this._rgb[3]], 'rgb');\n      } // compute new color using...\n\n\n      var cur_lum = this.luminance();\n      var mode = 'rgb';\n      var max_iter = MAX_ITER;\n\n      var test = function test(low, high) {\n        var mid = low.interpolate(high, 0.5, mode);\n        var lm = mid.luminance();\n\n        if (Math.abs(lum - lm) < EPS || !max_iter--) {\n          // close enough\n          return mid;\n        }\n\n        return lm > lum ? test(low, mid) : test(mid, high);\n      };\n\n      var rgb = (cur_lum > lum ? test(new Color_1([0, 0, 0]), this) : test(this, new Color_1([255, 255, 255]))).rgb();\n      return new Color_1(rgb.concat([this._rgb[3]]));\n    }\n\n    return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));\n  };\n\n  var rgb2luminance = function rgb2luminance(r, g, b) {\n    // relative luminance\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    r = luminance_x(r);\n    g = luminance_x(g);\n    b = luminance_x(b);\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n  };\n\n  var luminance_x = function luminance_x(x) {\n    x /= 255;\n    return x <= 0.03928 ? x / 12.92 : pow$2((x + 0.055) / 1.055, 2.4);\n  };\n\n  var interpolator = {};\n  var type$h = utils.type;\n\n  var mix = function mix(col1, col2, f) {\n    if (f === void 0) f = 0.5;\n    var rest = [],\n        len = arguments.length - 3;\n\n    while (len-- > 0) {\n      rest[len] = arguments[len + 3];\n    }\n\n    var mode = rest[0] || 'lrgb';\n\n    if (!interpolator[mode] && !rest.length) {\n      // fall back to the first supported mode\n      mode = Object.keys(interpolator)[0];\n    }\n\n    if (!interpolator[mode]) {\n      throw new Error(\"interpolation mode \" + mode + \" is not defined\");\n    }\n\n    if (type$h(col1) !== 'object') {\n      col1 = new Color_1(col1);\n    }\n\n    if (type$h(col2) !== 'object') {\n      col2 = new Color_1(col2);\n    }\n\n    return interpolator[mode](col1, col2, f).alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\n  };\n\n  Color_1.prototype.mix = Color_1.prototype.interpolate = function (col2, f) {\n    if (f === void 0) f = 0.5;\n    var rest = [],\n        len = arguments.length - 2;\n\n    while (len-- > 0) {\n      rest[len] = arguments[len + 2];\n    }\n\n    return mix.apply(void 0, [this, col2, f].concat(rest));\n  };\n\n  Color_1.prototype.premultiply = function (mutate) {\n    if (mutate === void 0) mutate = false;\n    var rgb = this._rgb;\n    var a = rgb[3];\n\n    if (mutate) {\n      this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];\n      return this;\n    } else {\n      return new Color_1([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');\n    }\n  };\n\n  Color_1.prototype.saturate = function (amount) {\n    if (amount === void 0) amount = 1;\n    var me = this;\n    var lch = me.lch();\n    lch[1] += labConstants.Kn * amount;\n\n    if (lch[1] < 0) {\n      lch[1] = 0;\n    }\n\n    return new Color_1(lch, 'lch').alpha(me.alpha(), true);\n  };\n\n  Color_1.prototype.desaturate = function (amount) {\n    if (amount === void 0) amount = 1;\n    return this.saturate(-amount);\n  };\n\n  var type$i = utils.type;\n\n  Color_1.prototype.set = function (mc, value, mutate) {\n    if (mutate === void 0) mutate = false;\n    var ref = mc.split('.');\n    var mode = ref[0];\n    var channel = ref[1];\n    var src = this[mode]();\n\n    if (channel) {\n      var i = mode.indexOf(channel);\n\n      if (i > -1) {\n        if (type$i(value) == 'string') {\n          switch (value.charAt(0)) {\n            case '+':\n              src[i] += +value;\n              break;\n\n            case '-':\n              src[i] += +value;\n              break;\n\n            case '*':\n              src[i] *= +value.substr(1);\n              break;\n\n            case '/':\n              src[i] /= +value.substr(1);\n              break;\n\n            default:\n              src[i] = +value;\n          }\n        } else if (type$i(value) === 'number') {\n          src[i] = value;\n        } else {\n          throw new Error(\"unsupported value for Color.set\");\n        }\n\n        var out = new Color_1(src, mode);\n\n        if (mutate) {\n          this._rgb = out._rgb;\n          return this;\n        }\n\n        return out;\n      }\n\n      throw new Error(\"unknown channel \" + channel + \" in mode \" + mode);\n    } else {\n      return src;\n    }\n  };\n\n  var rgb$1 = function rgb$1(col1, col2, f) {\n    var xyz0 = col1._rgb;\n    var xyz1 = col2._rgb;\n    return new Color_1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), 'rgb');\n  }; // register interpolator\n\n\n  interpolator.rgb = rgb$1;\n  var sqrt$2 = Math.sqrt;\n  var pow$3 = Math.pow;\n\n  var lrgb = function lrgb(col1, col2, f) {\n    var ref = col1._rgb;\n    var x1 = ref[0];\n    var y1 = ref[1];\n    var z1 = ref[2];\n    var ref$1 = col2._rgb;\n    var x2 = ref$1[0];\n    var y2 = ref$1[1];\n    var z2 = ref$1[2];\n    return new Color_1(sqrt$2(pow$3(x1, 2) * (1 - f) + pow$3(x2, 2) * f), sqrt$2(pow$3(y1, 2) * (1 - f) + pow$3(y2, 2) * f), sqrt$2(pow$3(z1, 2) * (1 - f) + pow$3(z2, 2) * f), 'rgb');\n  }; // register interpolator\n\n\n  interpolator.lrgb = lrgb;\n\n  var lab$1 = function lab$1(col1, col2, f) {\n    var xyz0 = col1.lab();\n    var xyz1 = col2.lab();\n    return new Color_1(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), 'lab');\n  }; // register interpolator\n\n\n  interpolator.lab = lab$1;\n\n  var _hsx = function _hsx(col1, col2, f, m) {\n    var assign, assign$1;\n    var xyz0, xyz1;\n\n    if (m === 'hsl') {\n      xyz0 = col1.hsl();\n      xyz1 = col2.hsl();\n    } else if (m === 'hsv') {\n      xyz0 = col1.hsv();\n      xyz1 = col2.hsv();\n    } else if (m === 'hcg') {\n      xyz0 = col1.hcg();\n      xyz1 = col2.hcg();\n    } else if (m === 'hsi') {\n      xyz0 = col1.hsi();\n      xyz1 = col2.hsi();\n    } else if (m === 'lch' || m === 'hcl') {\n      m = 'hcl';\n      xyz0 = col1.hcl();\n      xyz1 = col2.hcl();\n    }\n\n    var hue0, hue1, sat0, sat1, lbv0, lbv1;\n\n    if (m.substr(0, 1) === 'h') {\n      assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];\n      assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];\n    }\n\n    var sat, hue, lbv, dh;\n\n    if (!isNaN(hue0) && !isNaN(hue1)) {\n      // both colors have hue\n      if (hue1 > hue0 && hue1 - hue0 > 180) {\n        dh = hue1 - (hue0 + 360);\n      } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n        dh = hue1 + 360 - hue0;\n      } else {\n        dh = hue1 - hue0;\n      }\n\n      hue = hue0 + f * dh;\n    } else if (!isNaN(hue0)) {\n      hue = hue0;\n\n      if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') {\n        sat = sat0;\n      }\n    } else if (!isNaN(hue1)) {\n      hue = hue1;\n\n      if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') {\n        sat = sat1;\n      }\n    } else {\n      hue = Number.NaN;\n    }\n\n    if (sat === undefined) {\n      sat = sat0 + f * (sat1 - sat0);\n    }\n\n    lbv = lbv0 + f * (lbv1 - lbv0);\n    return new Color_1([hue, sat, lbv], m);\n  };\n\n  var lch$1 = function lch$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'lch');\n  }; // register interpolator\n\n\n  interpolator.lch = lch$1;\n  interpolator.hcl = lch$1;\n\n  var num$1 = function num$1(col1, col2, f) {\n    var c1 = col1.num();\n    var c2 = col2.num();\n    return new Color_1(c1 + f * (c2 - c1), 'num');\n  }; // register interpolator\n\n\n  interpolator.num = num$1;\n\n  var hcg$1 = function hcg$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hcg');\n  }; // register interpolator\n\n\n  interpolator.hcg = hcg$1;\n\n  var hsi$1 = function hsi$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsi');\n  }; // register interpolator\n\n\n  interpolator.hsi = hsi$1;\n\n  var hsl$1 = function hsl$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsl');\n  }; // register interpolator\n\n\n  interpolator.hsl = hsl$1;\n\n  var hsv$1 = function hsv$1(col1, col2, f) {\n    return _hsx(col1, col2, f, 'hsv');\n  }; // register interpolator\n\n\n  interpolator.hsv = hsv$1;\n  var clip_rgb$2 = utils.clip_rgb;\n  var pow$4 = Math.pow;\n  var sqrt$3 = Math.sqrt;\n  var PI$1 = Math.PI;\n  var cos$2 = Math.cos;\n  var sin$1 = Math.sin;\n  var atan2$1 = Math.atan2;\n\n  var average = function average(colors, mode, weights) {\n    if (mode === void 0) mode = 'lrgb';\n    if (weights === void 0) weights = null;\n    var l = colors.length;\n\n    if (!weights) {\n      weights = Array.from(new Array(l)).map(function () {\n        return 1;\n      });\n    } // normalize weights\n\n\n    var k = l / weights.reduce(function (a, b) {\n      return a + b;\n    });\n    weights.forEach(function (w, i) {\n      weights[i] *= k;\n    }); // convert colors to Color objects\n\n    colors = colors.map(function (c) {\n      return new Color_1(c);\n    });\n\n    if (mode === 'lrgb') {\n      return _average_lrgb(colors, weights);\n    }\n\n    var first = colors.shift();\n    var xyz = first.get(mode);\n    var cnt = [];\n    var dx = 0;\n    var dy = 0; // initial color\n\n    for (var i = 0; i < xyz.length; i++) {\n      xyz[i] = (xyz[i] || 0) * weights[0];\n      cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n\n      if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n        var A = xyz[i] / 180 * PI$1;\n        dx += cos$2(A) * weights[0];\n        dy += sin$1(A) * weights[0];\n      }\n    }\n\n    var alpha = first.alpha() * weights[0];\n    colors.forEach(function (c, ci) {\n      var xyz2 = c.get(mode);\n      alpha += c.alpha() * weights[ci + 1];\n\n      for (var i = 0; i < xyz.length; i++) {\n        if (!isNaN(xyz2[i])) {\n          cnt[i] += weights[ci + 1];\n\n          if (mode.charAt(i) === 'h') {\n            var A = xyz2[i] / 180 * PI$1;\n            dx += cos$2(A) * weights[ci + 1];\n            dy += sin$1(A) * weights[ci + 1];\n          } else {\n            xyz[i] += xyz2[i] * weights[ci + 1];\n          }\n        }\n      }\n    });\n\n    for (var i$1 = 0; i$1 < xyz.length; i$1++) {\n      if (mode.charAt(i$1) === 'h') {\n        var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\n\n        while (A$1 < 0) {\n          A$1 += 360;\n        }\n\n        while (A$1 >= 360) {\n          A$1 -= 360;\n        }\n\n        xyz[i$1] = A$1;\n      } else {\n        xyz[i$1] = xyz[i$1] / cnt[i$1];\n      }\n    }\n\n    alpha /= l;\n    return new Color_1(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);\n  };\n\n  var _average_lrgb = function _average_lrgb(colors, weights) {\n    var l = colors.length;\n    var xyz = [0, 0, 0, 0];\n\n    for (var i = 0; i < colors.length; i++) {\n      var col = colors[i];\n      var f = weights[i] / l;\n      var rgb = col._rgb;\n      xyz[0] += pow$4(rgb[0], 2) * f;\n      xyz[1] += pow$4(rgb[1], 2) * f;\n      xyz[2] += pow$4(rgb[2], 2) * f;\n      xyz[3] += rgb[3] * f;\n    }\n\n    xyz[0] = sqrt$3(xyz[0]);\n    xyz[1] = sqrt$3(xyz[1]);\n    xyz[2] = sqrt$3(xyz[2]);\n\n    if (xyz[3] > 0.9999999) {\n      xyz[3] = 1;\n    }\n\n    return new Color_1(clip_rgb$2(xyz));\n  }; // minimal multi-purpose interface\n  // @requires utils color analyze\n\n\n  var type$j = utils.type;\n  var pow$5 = Math.pow;\n\n  var scale = function scale(colors) {\n    // constructor\n    var _mode = 'rgb';\n\n    var _nacol = chroma_1('#ccc');\n\n    var _spread = 0; // const _fixed = false;\n\n    var _domain = [0, 1];\n    var _pos = [];\n    var _padding = [0, 0];\n    var _classes = false;\n    var _colors = [];\n    var _out = false;\n    var _min = 0;\n    var _max = 1;\n    var _correctLightness = false;\n    var _colorCache = {};\n    var _useCache = true;\n    var _gamma = 1; // private methods\n\n    var setColors = function setColors(colors) {\n      colors = colors || ['#fff', '#000'];\n\n      if (colors && type$j(colors) === 'string' && chroma_1.brewer && chroma_1.brewer[colors.toLowerCase()]) {\n        colors = chroma_1.brewer[colors.toLowerCase()];\n      }\n\n      if (type$j(colors) === 'array') {\n        // handle single color\n        if (colors.length === 1) {\n          colors = [colors[0], colors[0]];\n        } // make a copy of the colors\n\n\n        colors = colors.slice(0); // convert to chroma classes\n\n        for (var c = 0; c < colors.length; c++) {\n          colors[c] = chroma_1(colors[c]);\n        } // auto-fill color position\n\n\n        _pos.length = 0;\n\n        for (var c$1 = 0; c$1 < colors.length; c$1++) {\n          _pos.push(c$1 / (colors.length - 1));\n        }\n      }\n\n      resetCache();\n      return _colors = colors;\n    };\n\n    var getClass = function getClass(value) {\n      if (_classes != null) {\n        var n = _classes.length - 1;\n        var i = 0;\n\n        while (i < n && value >= _classes[i]) {\n          i++;\n        }\n\n        return i - 1;\n      }\n\n      return 0;\n    };\n\n    var tMapLightness = function tMapLightness(t) {\n      return t;\n    };\n\n    var tMapDomain = function tMapDomain(t) {\n      return t;\n    }; // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n\n    var getColor = function getColor(val, bypassMap) {\n      var col, t;\n\n      if (bypassMap == null) {\n        bypassMap = false;\n      }\n\n      if (isNaN(val) || val === null) {\n        return _nacol;\n      }\n\n      if (!bypassMap) {\n        if (_classes && _classes.length > 2) {\n          // find the class\n          var c = getClass(val);\n          t = c / (_classes.length - 2);\n        } else if (_max !== _min) {\n          // just interpolate between min/max\n          t = (val - _min) / (_max - _min);\n        } else {\n          t = 1;\n        }\n      } else {\n        t = val;\n      } // domain map\n\n\n      t = tMapDomain(t);\n\n      if (!bypassMap) {\n        t = tMapLightness(t); // lightness correction\n      }\n\n      if (_gamma !== 1) {\n        t = pow$5(t, _gamma);\n      }\n\n      t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n      t = Math.min(1, Math.max(0, t));\n      var k = Math.floor(t * 10000);\n\n      if (_useCache && _colorCache[k]) {\n        col = _colorCache[k];\n      } else {\n        if (type$j(_colors) === 'array') {\n          //for i in [0.._pos.length-1]\n          for (var i = 0; i < _pos.length; i++) {\n            var p = _pos[i];\n\n            if (t <= p) {\n              col = _colors[i];\n              break;\n            }\n\n            if (t >= p && i === _pos.length - 1) {\n              col = _colors[i];\n              break;\n            }\n\n            if (t > p && t < _pos[i + 1]) {\n              t = (t - p) / (_pos[i + 1] - p);\n              col = chroma_1.interpolate(_colors[i], _colors[i + 1], t, _mode);\n              break;\n            }\n          }\n        } else if (type$j(_colors) === 'function') {\n          col = _colors(t);\n        }\n\n        if (_useCache) {\n          _colorCache[k] = col;\n        }\n      }\n\n      return col;\n    };\n\n    var resetCache = function resetCache() {\n      return _colorCache = {};\n    };\n\n    setColors(colors); // public interface\n\n    var f = function f(v) {\n      var c = chroma_1(getColor(v));\n\n      if (_out && c[_out]) {\n        return c[_out]();\n      } else {\n        return c;\n      }\n    };\n\n    f.classes = function (classes) {\n      if (classes != null) {\n        if (type$j(classes) === 'array') {\n          _classes = classes;\n          _domain = [classes[0], classes[classes.length - 1]];\n        } else {\n          var d = chroma_1.analyze(_domain);\n\n          if (classes === 0) {\n            _classes = [d.min, d.max];\n          } else {\n            _classes = chroma_1.limits(d, 'e', classes);\n          }\n        }\n\n        return f;\n      }\n\n      return _classes;\n    };\n\n    f.domain = function (domain) {\n      if (!arguments.length) {\n        return _domain;\n      }\n\n      _min = domain[0];\n      _max = domain[domain.length - 1];\n      _pos = [];\n      var k = _colors.length;\n\n      if (domain.length === k && _min !== _max) {\n        // update positions\n        for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n          var d = list[i];\n\n          _pos.push((d - _min) / (_max - _min));\n        }\n      } else {\n        for (var c = 0; c < k; c++) {\n          _pos.push(c / (k - 1));\n        }\n\n        if (domain.length > 2) {\n          // set domain map\n          var tOut = domain.map(function (d, i) {\n            return i / (domain.length - 1);\n          });\n          var tBreaks = domain.map(function (d) {\n            return (d - _min) / (_max - _min);\n          });\n\n          if (!tBreaks.every(function (val, i) {\n            return tOut[i] === val;\n          })) {\n            tMapDomain = function tMapDomain(t) {\n              if (t <= 0 || t >= 1) {\n                return t;\n              }\n\n              var i = 0;\n\n              while (t >= tBreaks[i + 1]) {\n                i++;\n              }\n\n              var f = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n              var out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n              return out;\n            };\n          }\n        }\n      }\n\n      _domain = [_min, _max];\n      return f;\n    };\n\n    f.mode = function (_m) {\n      if (!arguments.length) {\n        return _mode;\n      }\n\n      _mode = _m;\n      resetCache();\n      return f;\n    };\n\n    f.range = function (colors, _pos) {\n      setColors(colors, _pos);\n      return f;\n    };\n\n    f.out = function (_o) {\n      _out = _o;\n      return f;\n    };\n\n    f.spread = function (val) {\n      if (!arguments.length) {\n        return _spread;\n      }\n\n      _spread = val;\n      return f;\n    };\n\n    f.correctLightness = function (v) {\n      if (v == null) {\n        v = true;\n      }\n\n      _correctLightness = v;\n      resetCache();\n\n      if (_correctLightness) {\n        tMapLightness = function tMapLightness(t) {\n          var L0 = getColor(0, true).lab()[0];\n          var L1 = getColor(1, true).lab()[0];\n          var pol = L0 > L1;\n          var L_actual = getColor(t, true).lab()[0];\n          var L_ideal = L0 + (L1 - L0) * t;\n          var L_diff = L_actual - L_ideal;\n          var t0 = 0;\n          var t1 = 1;\n          var max_iter = 20;\n\n          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n            (function () {\n              if (pol) {\n                L_diff *= -1;\n              }\n\n              if (L_diff < 0) {\n                t0 = t;\n                t += (t1 - t) * 0.5;\n              } else {\n                t1 = t;\n                t += (t0 - t) * 0.5;\n              }\n\n              L_actual = getColor(t, true).lab()[0];\n              return L_diff = L_actual - L_ideal;\n            })();\n          }\n\n          return t;\n        };\n      } else {\n        tMapLightness = function tMapLightness(t) {\n          return t;\n        };\n      }\n\n      return f;\n    };\n\n    f.padding = function (p) {\n      if (p != null) {\n        if (type$j(p) === 'number') {\n          p = [p, p];\n        }\n\n        _padding = p;\n        return f;\n      } else {\n        return _padding;\n      }\n    };\n\n    f.colors = function (numColors, out) {\n      // If no arguments are given, return the original colors that were provided\n      if (arguments.length < 2) {\n        out = 'hex';\n      }\n\n      var result = [];\n\n      if (arguments.length === 0) {\n        result = _colors.slice(0);\n      } else if (numColors === 1) {\n        result = [f(0.5)];\n      } else if (numColors > 1) {\n        var dm = _domain[0];\n        var dd = _domain[1] - dm;\n        result = __range__(0, numColors, false).map(function (i) {\n          return f(dm + i / (numColors - 1) * dd);\n        });\n      } else {\n        // returns all colors based on the defined classes\n        colors = [];\n        var samples = [];\n\n        if (_classes && _classes.length > 2) {\n          for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n            samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n          }\n        } else {\n          samples = _domain;\n        }\n\n        result = samples.map(function (v) {\n          return f(v);\n        });\n      }\n\n      if (chroma_1[out]) {\n        result = result.map(function (c) {\n          return c[out]();\n        });\n      }\n\n      return result;\n    };\n\n    f.cache = function (c) {\n      if (c != null) {\n        _useCache = c;\n        return f;\n      } else {\n        return _useCache;\n      }\n    };\n\n    f.gamma = function (g) {\n      if (g != null) {\n        _gamma = g;\n        return f;\n      } else {\n        return _gamma;\n      }\n    };\n\n    f.nodata = function (d) {\n      if (d != null) {\n        _nacol = chroma_1(d);\n        return f;\n      } else {\n        return _nacol;\n      }\n    };\n\n    return f;\n  };\n\n  function __range__(left, right, inclusive) {\n    var range = [];\n    var ascending = left < right;\n    var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n    for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n      range.push(i);\n    }\n\n    return range;\n  } //\n  // interpolates between a set of colors uzing a bezier spline\n  //\n  // @requires utils lab\n\n\n  var bezier = function bezier(colors) {\n    var assign, assign$1, assign$2;\n    var I, lab0, lab1, lab2;\n    colors = colors.map(function (c) {\n      return new Color_1(c);\n    });\n\n    if (colors.length === 2) {\n      // linear interpolation\n      assign = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign[0], lab1 = assign[1];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return lab0[i] + t * (lab1[i] - lab0[i]);\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 3) {\n      // quadratic bezier interpolation\n      assign$1 = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return (1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i];\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 4) {\n      // cubic bezier interpolation\n      var lab3;\n      assign$2 = colors.map(function (c) {\n        return c.lab();\n      }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];\n\n      I = function I(t) {\n        var lab = [0, 1, 2].map(function (i) {\n          return (1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i];\n        });\n        return new Color_1(lab, 'lab');\n      };\n    } else if (colors.length === 5) {\n      var I0 = bezier(colors.slice(0, 3));\n      var I1 = bezier(colors.slice(2, 5));\n\n      I = function I(t) {\n        if (t < 0.5) {\n          return I0(t * 2);\n        } else {\n          return I1((t - 0.5) * 2);\n        }\n      };\n    }\n\n    return I;\n  };\n\n  var bezier_1 = function bezier_1(colors) {\n    var f = bezier(colors);\n\n    f.scale = function () {\n      return scale(f);\n    };\n\n    return f;\n  };\n  /*\n   * interpolates between a set of colors uzing a bezier spline\n   * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n   */\n\n\n  var blend = function blend(bottom, top, mode) {\n    if (!blend[mode]) {\n      throw new Error('unknown blend mode ' + mode);\n    }\n\n    return blend[mode](bottom, top);\n  };\n\n  var blend_f = function blend_f(f) {\n    return function (bottom, top) {\n      var c0 = chroma_1(top).rgb();\n      var c1 = chroma_1(bottom).rgb();\n      return chroma_1.rgb(f(c0, c1));\n    };\n  };\n\n  var each = function each(f) {\n    return function (c0, c1) {\n      var out = [];\n      out[0] = f(c0[0], c1[0]);\n      out[1] = f(c0[1], c1[1]);\n      out[2] = f(c0[2], c1[2]);\n      return out;\n    };\n  };\n\n  var normal = function normal(a) {\n    return a;\n  };\n\n  var multiply = function multiply(a, b) {\n    return a * b / 255;\n  };\n\n  var darken$1 = function darken$1(a, b) {\n    return a > b ? b : a;\n  };\n\n  var lighten = function lighten(a, b) {\n    return a > b ? a : b;\n  };\n\n  var screen = function screen(a, b) {\n    return 255 * (1 - (1 - a / 255) * (1 - b / 255));\n  };\n\n  var overlay = function overlay(a, b) {\n    return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\n  };\n\n  var burn = function burn(a, b) {\n    return 255 * (1 - (1 - b / 255) / (a / 255));\n  };\n\n  var dodge = function dodge(a, b) {\n    if (a === 255) {\n      return 255;\n    }\n\n    a = 255 * (b / 255) / (1 - a / 255);\n    return a > 255 ? 255 : a;\n  }; // # add = (a,b) ->\n  // #     if (a + b > 255) then 255 else a + b\n\n\n  blend.normal = blend_f(each(normal));\n  blend.multiply = blend_f(each(multiply));\n  blend.screen = blend_f(each(screen));\n  blend.overlay = blend_f(each(overlay));\n  blend.darken = blend_f(each(darken$1));\n  blend.lighten = blend_f(each(lighten));\n  blend.dodge = blend_f(each(dodge));\n  blend.burn = blend_f(each(burn)); // blend.add = blend_f(each(add));\n\n  var blend_1 = blend; // cubehelix interpolation\n  // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n  // http://astron-soc.in/bulletin/11June/289392011.pdf\n\n  var type$k = utils.type;\n  var clip_rgb$3 = utils.clip_rgb;\n  var TWOPI$2 = utils.TWOPI;\n  var pow$6 = Math.pow;\n  var sin$2 = Math.sin;\n  var cos$3 = Math.cos;\n\n  var cubehelix = function cubehelix(start, rotations, hue, gamma, lightness) {\n    if (start === void 0) start = 300;\n    if (rotations === void 0) rotations = -1.5;\n    if (hue === void 0) hue = 1;\n    if (gamma === void 0) gamma = 1;\n    if (lightness === void 0) lightness = [0, 1];\n    var dh = 0,\n        dl;\n\n    if (type$k(lightness) === 'array') {\n      dl = lightness[1] - lightness[0];\n    } else {\n      dl = 0;\n      lightness = [lightness, lightness];\n    }\n\n    var f = function f(fract) {\n      var a = TWOPI$2 * ((start + 120) / 360 + rotations * fract);\n      var l = pow$6(lightness[0] + dl * fract, gamma);\n      var h = dh !== 0 ? hue[0] + fract * dh : hue;\n      var amp = h * l * (1 - l) / 2;\n      var cos_a = cos$3(a);\n      var sin_a = sin$2(a);\n      var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n      var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n      var b = l + amp * (+1.97294 * cos_a);\n      return chroma_1(clip_rgb$3([r * 255, g * 255, b * 255, 1]));\n    };\n\n    f.start = function (s) {\n      if (s == null) {\n        return start;\n      }\n\n      start = s;\n      return f;\n    };\n\n    f.rotations = function (r) {\n      if (r == null) {\n        return rotations;\n      }\n\n      rotations = r;\n      return f;\n    };\n\n    f.gamma = function (g) {\n      if (g == null) {\n        return gamma;\n      }\n\n      gamma = g;\n      return f;\n    };\n\n    f.hue = function (h) {\n      if (h == null) {\n        return hue;\n      }\n\n      hue = h;\n\n      if (type$k(hue) === 'array') {\n        dh = hue[1] - hue[0];\n\n        if (dh === 0) {\n          hue = hue[1];\n        }\n      } else {\n        dh = 0;\n      }\n\n      return f;\n    };\n\n    f.lightness = function (h) {\n      if (h == null) {\n        return lightness;\n      }\n\n      if (type$k(h) === 'array') {\n        lightness = h;\n        dl = h[1] - h[0];\n      } else {\n        lightness = [h, h];\n        dl = 0;\n      }\n\n      return f;\n    };\n\n    f.scale = function () {\n      return chroma_1.scale(f);\n    };\n\n    f.hue(hue);\n    return f;\n  };\n\n  var digits = '0123456789abcdef';\n  var floor$2 = Math.floor;\n  var random = Math.random;\n\n  var random_1 = function random_1() {\n    var code = '#';\n\n    for (var i = 0; i < 6; i++) {\n      code += digits.charAt(floor$2(random() * 16));\n    }\n\n    return new Color_1(code, 'hex');\n  };\n\n  var log$1 = Math.log;\n  var pow$7 = Math.pow;\n  var floor$3 = Math.floor;\n  var abs = Math.abs;\n\n  var analyze = function analyze(data, key) {\n    if (key === void 0) key = null;\n    var r = {\n      min: Number.MAX_VALUE,\n      max: Number.MAX_VALUE * -1,\n      sum: 0,\n      values: [],\n      count: 0\n    };\n\n    if (type(data) === 'object') {\n      data = Object.values(data);\n    }\n\n    data.forEach(function (val) {\n      if (key && type(val) === 'object') {\n        val = val[key];\n      }\n\n      if (val !== undefined && val !== null && !isNaN(val)) {\n        r.values.push(val);\n        r.sum += val;\n\n        if (val < r.min) {\n          r.min = val;\n        }\n\n        if (val > r.max) {\n          r.max = val;\n        }\n\n        r.count += 1;\n      }\n    });\n    r.domain = [r.min, r.max];\n\n    r.limits = function (mode, num) {\n      return limits(r, mode, num);\n    };\n\n    return r;\n  };\n\n  var limits = function limits(data, mode, num) {\n    if (mode === void 0) mode = 'equal';\n    if (num === void 0) num = 7;\n\n    if (type(data) == 'array') {\n      data = analyze(data);\n    }\n\n    var min = data.min;\n    var max = data.max;\n    var values = data.values.sort(function (a, b) {\n      return a - b;\n    });\n\n    if (num === 1) {\n      return [min, max];\n    }\n\n    var limits = [];\n\n    if (mode.substr(0, 1) === 'c') {\n      // continuous\n      limits.push(min);\n      limits.push(max);\n    }\n\n    if (mode.substr(0, 1) === 'e') {\n      // equal interval\n      limits.push(min);\n\n      for (var i = 1; i < num; i++) {\n        limits.push(min + i / num * (max - min));\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n      // log scale\n      if (min <= 0) {\n        throw new Error('Logarithmic scales are only possible for values > 0');\n      }\n\n      var min_log = Math.LOG10E * log$1(min);\n      var max_log = Math.LOG10E * log$1(max);\n      limits.push(min);\n\n      for (var i$1 = 1; i$1 < num; i$1++) {\n        limits.push(pow$7(10, min_log + i$1 / num * (max_log - min_log)));\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n      // quantile scale\n      limits.push(min);\n\n      for (var i$2 = 1; i$2 < num; i$2++) {\n        var p = (values.length - 1) * i$2 / num;\n        var pb = floor$3(p);\n\n        if (pb === p) {\n          limits.push(values[pb]);\n        } else {\n          // p > pb\n          var pr = p - pb;\n          limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n        }\n      }\n\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n      // k-means clustering\n\n      /*\n      implementation based on\n      http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n      simplified for 1-d input values\n      */\n      var cluster;\n      var n = values.length;\n      var assignments = new Array(n);\n      var clusterSizes = new Array(num);\n      var repeat = true;\n      var nb_iters = 0;\n      var centroids = null; // get seed values\n\n      centroids = [];\n      centroids.push(min);\n\n      for (var i$3 = 1; i$3 < num; i$3++) {\n        centroids.push(min + i$3 / num * (max - min));\n      }\n\n      centroids.push(max);\n\n      while (repeat) {\n        // assignment step\n        for (var j = 0; j < num; j++) {\n          clusterSizes[j] = 0;\n        }\n\n        for (var i$4 = 0; i$4 < n; i$4++) {\n          var value = values[i$4];\n          var mindist = Number.MAX_VALUE;\n          var best = void 0;\n\n          for (var j$1 = 0; j$1 < num; j$1++) {\n            var dist = abs(centroids[j$1] - value);\n\n            if (dist < mindist) {\n              mindist = dist;\n              best = j$1;\n            }\n\n            clusterSizes[best]++;\n            assignments[i$4] = best;\n          }\n        } // update centroids step\n\n\n        var newCentroids = new Array(num);\n\n        for (var j$2 = 0; j$2 < num; j$2++) {\n          newCentroids[j$2] = null;\n        }\n\n        for (var i$5 = 0; i$5 < n; i$5++) {\n          cluster = assignments[i$5];\n\n          if (newCentroids[cluster] === null) {\n            newCentroids[cluster] = values[i$5];\n          } else {\n            newCentroids[cluster] += values[i$5];\n          }\n        }\n\n        for (var j$3 = 0; j$3 < num; j$3++) {\n          newCentroids[j$3] *= 1 / clusterSizes[j$3];\n        } // check convergence\n\n\n        repeat = false;\n\n        for (var j$4 = 0; j$4 < num; j$4++) {\n          if (newCentroids[j$4] !== centroids[j$4]) {\n            repeat = true;\n            break;\n          }\n        }\n\n        centroids = newCentroids;\n        nb_iters++;\n\n        if (nb_iters > 200) {\n          repeat = false;\n        }\n      } // finished k-means clustering\n      // the next part is borrowed from gabrielflor.it\n\n\n      var kClusters = {};\n\n      for (var j$5 = 0; j$5 < num; j$5++) {\n        kClusters[j$5] = [];\n      }\n\n      for (var i$6 = 0; i$6 < n; i$6++) {\n        cluster = assignments[i$6];\n        kClusters[cluster].push(values[i$6]);\n      }\n\n      var tmpKMeansBreaks = [];\n\n      for (var j$6 = 0; j$6 < num; j$6++) {\n        tmpKMeansBreaks.push(kClusters[j$6][0]);\n        tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);\n      }\n\n      tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) {\n        return a - b;\n      });\n      limits.push(tmpKMeansBreaks[0]);\n\n      for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {\n        var v = tmpKMeansBreaks[i$7];\n\n        if (!isNaN(v) && limits.indexOf(v) === -1) {\n          limits.push(v);\n        }\n      }\n    }\n\n    return limits;\n  };\n\n  var analyze_1 = {\n    analyze: analyze,\n    limits: limits\n  };\n\n  var contrast = function contrast(a, b) {\n    // WCAG contrast ratio\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var l1 = a.luminance();\n    var l2 = b.luminance();\n    return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n  };\n\n  var sqrt$4 = Math.sqrt;\n  var atan2$2 = Math.atan2;\n  var abs$1 = Math.abs;\n  var cos$4 = Math.cos;\n  var PI$2 = Math.PI;\n\n  var deltaE = function deltaE(a, b, L, C) {\n    if (L === void 0) L = 1;\n    if (C === void 0) C = 1; // Delta E (CMC)\n    // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\n\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var ref = Array.from(a.lab());\n    var L1 = ref[0];\n    var a1 = ref[1];\n    var b1 = ref[2];\n    var ref$1 = Array.from(b.lab());\n    var L2 = ref$1[0];\n    var a2 = ref$1[1];\n    var b2 = ref$1[2];\n    var c1 = sqrt$4(a1 * a1 + b1 * b1);\n    var c2 = sqrt$4(a2 * a2 + b2 * b2);\n    var sl = L1 < 16.0 ? 0.511 : 0.040975 * L1 / (1.0 + 0.01765 * L1);\n    var sc = 0.0638 * c1 / (1.0 + 0.0131 * c1) + 0.638;\n    var h1 = c1 < 0.000001 ? 0.0 : atan2$2(b1, a1) * 180.0 / PI$2;\n\n    while (h1 < 0) {\n      h1 += 360;\n    }\n\n    while (h1 >= 360) {\n      h1 -= 360;\n    }\n\n    var t = h1 >= 164.0 && h1 <= 345.0 ? 0.56 + abs$1(0.2 * cos$4(PI$2 * (h1 + 168.0) / 180.0)) : 0.36 + abs$1(0.4 * cos$4(PI$2 * (h1 + 35.0) / 180.0));\n    var c4 = c1 * c1 * c1 * c1;\n    var f = sqrt$4(c4 / (c4 + 1900.0));\n    var sh = sc * (f * t + 1.0 - f);\n    var delL = L1 - L2;\n    var delC = c1 - c2;\n    var delA = a1 - a2;\n    var delB = b1 - b2;\n    var dH2 = delA * delA + delB * delB - delC * delC;\n    var v1 = delL / (L * sl);\n    var v2 = delC / (C * sc);\n    var v3 = sh;\n    return sqrt$4(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));\n  }; // simple Euclidean distance\n\n\n  var distance = function distance(a, b, mode) {\n    if (mode === void 0) mode = 'lab'; // Delta E (CIE 1976)\n    // see http://www.brucelindbloom.com/index.html?Equations.html\n\n    a = new Color_1(a);\n    b = new Color_1(b);\n    var l1 = a.get(mode);\n    var l2 = b.get(mode);\n    var sum_sq = 0;\n\n    for (var i in l1) {\n      var d = (l1[i] || 0) - (l2[i] || 0);\n      sum_sq += d * d;\n    }\n\n    return Math.sqrt(sum_sq);\n  };\n\n  var valid = function valid() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    try {\n      new (Function.prototype.bind.apply(Color_1, [null].concat(args)))();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // some pre-defined color scales:\n\n\n  var scales = {\n    cool: function cool() {\n      return scale([chroma_1.hsl(180, 1, .9), chroma_1.hsl(250, .7, .4)]);\n    },\n    hot: function hot() {\n      return scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');\n    }\n  };\n  /**\n      ColorBrewer colors for chroma.js\n       Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n      Pennsylvania State University.\n       Licensed under the Apache License, Version 2.0 (the \"License\");\n      you may not use this file except in compliance with the License.\n      You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n       Unless required by applicable law or agreed to in writing, software distributed\n      under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n      CONDITIONS OF ANY KIND, either express or implied. See the License for the\n      specific language governing permissions and limitations under the License.\n  */\n\n  var colorbrewer = {\n    // sequential\n    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n    Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n    // diverging\n    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n    // qualitative\n    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n  }; // add lowercase aliases for case-insensitive matches\n\n  for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\n    var key = list$1[i$1];\n    colorbrewer[key.toLowerCase()] = colorbrewer[key];\n  }\n\n  var colorbrewer_1 = colorbrewer; // feel free to comment out anything to rollup\n  // a smaller chroma.js built\n  // io --\x3e convert colors\n  // operators --\x3e modify existing Colors\n  // interpolators\n  // generators -- > create new colors\n\n  chroma_1.average = average;\n  chroma_1.bezier = bezier_1;\n  chroma_1.blend = blend_1;\n  chroma_1.cubehelix = cubehelix;\n  chroma_1.mix = chroma_1.interpolate = mix;\n  chroma_1.random = random_1;\n  chroma_1.scale = scale; // other utility methods\n\n  chroma_1.analyze = analyze_1.analyze;\n  chroma_1.contrast = contrast;\n  chroma_1.deltaE = deltaE;\n  chroma_1.distance = distance;\n  chroma_1.limits = analyze_1.limits;\n  chroma_1.valid = valid; // scale\n\n  chroma_1.scales = scales; // colors\n\n  chroma_1.colors = w3cx11_1;\n  chroma_1.brewer = colorbrewer_1;\n  var chroma_js = chroma_1;\n  return chroma_js;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9jaHJvbWEtanMvY2hyb21hLmpzP2JmNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBNEQsZ0NBQWdDLENBQXdGO0FBQ3RMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQSxxSEFBcUgsaUJBQWlCO0FBQ3RJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxFQUFFLGFBQWEsRUFBRTtBQUNqRCxpQ0FBaUMsRUFBRSxhQUFhLEVBQUU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxpQkFBaUI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkMsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUEseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsdUJBQXVCLDhCQUE4QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMzg3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY2hyb21hLmpzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjb2xvciBjb252ZXJzaW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE5LCBHcmVnb3IgQWlzY2hcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIFRoZSBuYW1lIEdyZWdvciBBaXNjaCBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHUkVHT1IgQUlTQ0ggT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxuICogQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gKiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBjaHJvbWEuanMgaW5jbHVkZXMgY29sb3JzIGZyb20gY29sb3JicmV3ZXIyLm9yZywgd2hpY2ggYXJlIHJlbGVhc2VkIHVuZGVyXG4gKiB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLFxuICogYW5kIFRoZSBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCxcbiAqIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIE5hbWVkIGNvbG9ycyBhcmUgdGFrZW4gZnJvbSBYMTEgQ29sb3IgTmFtZXMuXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAqXG4gKiBAcHJlc2VydmVcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiBnbG9iYWwuY2hyb21hID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGxpbWl0ID0gZnVuY3Rpb24gbGltaXQoeCwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApIG1pbiA9IDA7XG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKSBtYXggPSAxO1xuICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeCA+IG1heCA/IG1heCA6IHg7XG4gIH07XG5cbiAgdmFyIGNsaXBfcmdiID0gZnVuY3Rpb24gY2xpcF9yZ2IocmdiKSB7XG4gICAgcmdiLl9jbGlwcGVkID0gZmFsc2U7XG4gICAgcmdiLl91bmNsaXBwZWQgPSByZ2Iuc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgIGlmIChpIDwgMykge1xuICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHtcbiAgICAgICAgICByZ2IuX2NsaXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmdiW2ldID0gbGltaXQocmdiW2ldLCAwLCAyNTUpO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYjtcbiAgfTsgLy8gcG9ydGVkIGZyb20galF1ZXJ5J3MgJC50eXBlXG5cblxuICB2YXIgY2xhc3NUb1R5cGUgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IFsnQm9vbGVhbicsICdOdW1iZXInLCAnU3RyaW5nJywgJ0Z1bmN0aW9uJywgJ0FycmF5JywgJ0RhdGUnLCAnUmVnRXhwJywgJ1VuZGVmaW5lZCcsICdOdWxsJ107IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuICAgIGNsYXNzVG9UeXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZ1bmN0aW9uIHR5cGUob2JqKSB7XG4gICAgcmV0dXJuIGNsYXNzVG9UeXBlW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiO1xuICB9O1xuXG4gIHZhciB1bnBhY2sgPSBmdW5jdGlvbiB1bnBhY2soYXJncywga2V5T3JkZXIpIHtcbiAgICBpZiAoa2V5T3JkZXIgPT09IHZvaWQgMCkga2V5T3JkZXIgPSBudWxsOyAvLyBpZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gMyBhcmd1bWVudHMsIHdlIHJldHVybiB0aGUgYXJndW1lbnRzXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIH0gLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAvLyBhbmQgdXNlIHRoZSBrZXlPcmRlciBzdHJpbmcgdG8gZXh0cmFjdCBhbmQgc29ydCBwcm9wZXJ0aWVzXG5cblxuICAgIGlmICh0eXBlKGFyZ3NbMF0pID09ICdvYmplY3QnICYmIGtleU9yZGVyKSB7XG4gICAgICByZXR1cm4ga2V5T3JkZXIuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdW2tdO1xuICAgICAgfSk7XG4gICAgfSAvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgLy8gKHdoaWNoIHdlIHN1cHBvc2UgaXMgYW4gYXJyYXkgb2YgYXJncylcblxuXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH07XG5cbiAgdmFyIGxhc3QgPSBmdW5jdGlvbiBsYXN0KGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0eXBlKGFyZ3NbbF0pID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXJnc1tsXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBQSSA9IE1hdGguUEk7XG4gIHZhciB1dGlscyA9IHtcbiAgICBjbGlwX3JnYjogY2xpcF9yZ2IsXG4gICAgbGltaXQ6IGxpbWl0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdW5wYWNrOiB1bnBhY2ssXG4gICAgbGFzdDogbGFzdCxcbiAgICBQSTogUEksXG4gICAgVFdPUEk6IFBJICogMixcbiAgICBQSVRISVJEOiBQSSAvIDMsXG4gICAgREVHMlJBRDogUEkgLyAxODAsXG4gICAgUkFEMkRFRzogMTgwIC8gUElcbiAgfTtcbiAgdmFyIGlucHV0ID0ge1xuICAgIGZvcm1hdDoge30sXG4gICAgYXV0b2RldGVjdDogW11cbiAgfTtcbiAgdmFyIGxhc3QkMSA9IHV0aWxzLmxhc3Q7XG4gIHZhciBjbGlwX3JnYiQxID0gdXRpbHMuY2xpcF9yZ2I7XG4gIHZhciB0eXBlJDEgPSB1dGlscy50eXBlO1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZiAodHlwZSQxKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgPT09IHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIC8vIHRoZSBhcmd1bWVudCBpcyBhbHJlYWR5IGEgQ29sb3IgaW5zdGFuY2VcbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH0gLy8gbGFzdCBhcmd1bWVudCBjb3VsZCBiZSB0aGUgbW9kZVxuXG5cbiAgICB2YXIgbW9kZSA9IGxhc3QkMShhcmdzKTtcbiAgICB2YXIgYXV0b2RldGVjdCA9IGZhbHNlO1xuXG4gICAgaWYgKCFtb2RlKSB7XG4gICAgICBhdXRvZGV0ZWN0ID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpbnB1dC5zb3J0ZWQpIHtcbiAgICAgICAgaW5wdXQuYXV0b2RldGVjdCA9IGlucHV0LmF1dG9kZXRlY3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBiLnAgLSBhLnA7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5zb3J0ZWQgPSB0cnVlO1xuICAgICAgfSAvLyBhdXRvLWRldGVjdCBmb3JtYXRcblxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGlucHV0LmF1dG9kZXRlY3Q7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGsgPSBsaXN0W2ldO1xuICAgICAgICBtb2RlID0gY2hrLnRlc3QuYXBwbHkoY2hrLCBhcmdzKTtcblxuICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgdmFyIHJnYiA9IGlucHV0LmZvcm1hdFttb2RlXS5hcHBseShudWxsLCBhdXRvZGV0ZWN0ID8gYXJncyA6IGFyZ3Muc2xpY2UoMCwgLTEpKTtcbiAgICAgIG1lLl9yZ2IgPSBjbGlwX3JnYiQxKHJnYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmb3JtYXQ6ICcgKyBhcmdzKTtcbiAgICB9IC8vIGFkZCBhbHBoYSBjaGFubmVsXG5cblxuICAgIGlmIChtZS5fcmdiLmxlbmd0aCA9PT0gMykge1xuICAgICAgbWUuX3JnYi5wdXNoKDEpO1xuICAgIH1cbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodHlwZSQxKHRoaXMuaGV4KSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZXgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLl9yZ2Iuam9pbignLCcpICsgXCJdXCI7XG4gIH07XG5cbiAgdmFyIENvbG9yXzEgPSBDb2xvcjtcblxuICB2YXIgY2hyb21hID0gZnVuY3Rpb24gY2hyb21hKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGNocm9tYS5Db2xvciwgW251bGxdLmNvbmNhdChhcmdzKSkpKCk7XG4gIH07XG5cbiAgY2hyb21hLkNvbG9yID0gQ29sb3JfMTtcbiAgY2hyb21hLnZlcnNpb24gPSAnMi4xLjInO1xuICB2YXIgY2hyb21hXzEgPSBjaHJvbWE7XG4gIHZhciB1bnBhY2skMSA9IHV0aWxzLnVucGFjaztcbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuXG4gIHZhciByZ2IyY215ayA9IGZ1bmN0aW9uIHJnYjJjbXlrKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciByZWYgPSB1bnBhY2skMShhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgciA9IHIgLyAyNTU7XG4gICAgZyA9IGcgLyAyNTU7XG4gICAgYiA9IGIgLyAyNTU7XG4gICAgdmFyIGsgPSAxIC0gbWF4KHIsIG1heChnLCBiKSk7XG4gICAgdmFyIGYgPSBrIDwgMSA/IDEgLyAoMSAtIGspIDogMDtcbiAgICB2YXIgYyA9ICgxIC0gciAtIGspICogZjtcbiAgICB2YXIgbSA9ICgxIC0gZyAtIGspICogZjtcbiAgICB2YXIgeSA9ICgxIC0gYiAtIGspICogZjtcbiAgICByZXR1cm4gW2MsIG0sIHksIGtdO1xuICB9O1xuXG4gIHZhciByZ2IyY215a18xID0gcmdiMmNteWs7XG4gIHZhciB1bnBhY2skMiA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgY215azJyZ2IgPSBmdW5jdGlvbiBjbXlrMnJnYigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDIoYXJncywgJ2NteWsnKTtcbiAgICB2YXIgYyA9IGFyZ3NbMF07XG4gICAgdmFyIG0gPSBhcmdzWzFdO1xuICAgIHZhciB5ID0gYXJnc1syXTtcbiAgICB2YXIgayA9IGFyZ3NbM107XG4gICAgdmFyIGFscGhhID0gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IDE7XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCBhbHBoYV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjID49IDEgPyAwIDogMjU1ICogKDEgLSBjKSAqICgxIC0gayksIC8vIHJcbiAgICBtID49IDEgPyAwIDogMjU1ICogKDEgLSBtKSAqICgxIC0gayksIC8vIGdcbiAgICB5ID49IDEgPyAwIDogMjU1ICogKDEgLSB5KSAqICgxIC0gayksIC8vIGJcbiAgICBhbHBoYV07XG4gIH07XG5cbiAgdmFyIGNteWsycmdiXzEgPSBjbXlrMnJnYjtcbiAgdmFyIHVucGFjayQzID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSQyID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyY215a18xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnY215ayddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmNteWsgPSBjbXlrMnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gdW5wYWNrJDMoYXJncywgJ2NteWsnKTtcblxuICAgICAgaWYgKHR5cGUkMihhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ2NteWsnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skNCA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGxhc3QkMiA9IHV0aWxzLmxhc3Q7XG5cbiAgdmFyIHJuZCA9IGZ1bmN0aW9uIHJuZChhKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqIDEwMCkgLyAxMDA7XG4gIH07XG4gIC8qXG4gICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICogLSBoc2wyY3NzKGgscyxsLGEpXG4gICAqIC0gaHNsMmNzcyhbaCxzLGxdLCBtb2RlKVxuICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgKiAtIGhzbDJjc3Moe2gscyxsLGF9LCBtb2RlKVxuICAgKi9cblxuXG4gIHZhciBoc2wyY3NzID0gZnVuY3Rpb24gaHNsMmNzcygpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgaHNsYSA9IHVucGFjayQ0KGFyZ3MsICdoc2xhJyk7XG4gICAgdmFyIG1vZGUgPSBsYXN0JDIoYXJncykgfHwgJ2xzYSc7XG4gICAgaHNsYVswXSA9IHJuZChoc2xhWzBdIHx8IDApO1xuICAgIGhzbGFbMV0gPSBybmQoaHNsYVsxXSAqIDEwMCkgKyAnJSc7XG4gICAgaHNsYVsyXSA9IHJuZChoc2xhWzJdICogMTAwKSArICclJztcblxuICAgIGlmIChtb2RlID09PSAnaHNsYScgfHwgaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM10gPCAxKSB7XG4gICAgICBoc2xhWzNdID0gaHNsYS5sZW5ndGggPiAzID8gaHNsYVszXSA6IDE7XG4gICAgICBtb2RlID0gJ2hzbGEnO1xuICAgIH0gZWxzZSB7XG4gICAgICBoc2xhLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGUgKyBcIihcIiArIGhzbGEuam9pbignLCcpICsgXCIpXCI7XG4gIH07XG5cbiAgdmFyIGhzbDJjc3NfMSA9IGhzbDJjc3M7XG4gIHZhciB1bnBhY2skNSA9IHV0aWxzLnVucGFjaztcbiAgLypcbiAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICogLSByZ2IyaHNsKHIsZyxiKVxuICAgKiAtIHJnYjJoc2wocixnLGIsYSlcbiAgICogLSByZ2IyaHNsKFtyLGcsYl0pXG4gICAqIC0gcmdiMmhzbChbcixnLGIsYV0pXG4gICAqIC0gcmdiMmhzbCh7cixnLGIsYX0pXG4gICAqL1xuXG4gIHZhciByZ2IyaHNsID0gZnVuY3Rpb24gcmdiMmhzbCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDUoYXJncywgJ3JnYmEnKTtcbiAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgIHZhciBiID0gYXJnc1syXTtcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIHZhciBzLCBoO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBzID0gMDtcbiAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gbCA8IDAuNSA/IChtYXggLSBtaW4pIC8gKG1heCArIG1pbikgOiAobWF4IC0gbWluKSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICB9XG5cbiAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gKG1heCAtIG1pbik7XG4gICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gKG1heCAtIG1pbik7XG4gICAgfSBlbHNlIGlmIChiID09IG1heCkge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gKG1heCAtIG1pbik7XG4gICAgfVxuXG4gICAgaCAqPSA2MDtcblxuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAzNjA7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMyAmJiBhcmdzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYXJnc1szXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfTtcblxuICB2YXIgcmdiMmhzbF8xID0gcmdiMmhzbDtcbiAgdmFyIHVucGFjayQ2ID0gdXRpbHMudW5wYWNrO1xuICB2YXIgbGFzdCQzID0gdXRpbHMubGFzdDtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgLypcbiAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICogLSByZ2IyY3NzKHIsZyxiKVxuICAgKiAtIHJnYjJjc3MocixnLGIsYSlcbiAgICogLSByZ2IyY3NzKFtyLGcsYl0sIG1vZGUpXG4gICAqIC0gcmdiMmNzcyhbcixnLGIsYV0sIG1vZGUpXG4gICAqIC0gcmdiMmNzcyh7cixnLGIsYX0sIG1vZGUpXG4gICAqL1xuXG4gIHZhciByZ2IyY3NzID0gZnVuY3Rpb24gcmdiMmNzcygpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgcmdiYSA9IHVucGFjayQ2KGFyZ3MsICdyZ2JhJyk7XG4gICAgdmFyIG1vZGUgPSBsYXN0JDMoYXJncykgfHwgJ3JnYic7XG5cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT0gJ2hzbCcpIHtcbiAgICAgIHJldHVybiBoc2wyY3NzXzEocmdiMmhzbF8xKHJnYmEpLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZ2JhWzBdID0gcm91bmQocmdiYVswXSk7XG4gICAgcmdiYVsxXSA9IHJvdW5kKHJnYmFbMV0pO1xuICAgIHJnYmFbMl0gPSByb3VuZChyZ2JhWzJdKTtcblxuICAgIGlmIChtb2RlID09PSAncmdiYScgfHwgcmdiYS5sZW5ndGggPiAzICYmIHJnYmFbM10gPCAxKSB7XG4gICAgICByZ2JhWzNdID0gcmdiYS5sZW5ndGggPiAzID8gcmdiYVszXSA6IDE7XG4gICAgICBtb2RlID0gJ3JnYmEnO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlICsgXCIoXCIgKyByZ2JhLnNsaWNlKDAsIG1vZGUgPT09ICdyZ2InID8gMyA6IDQpLmpvaW4oJywnKSArIFwiKVwiO1xuICB9O1xuXG4gIHZhciByZ2IyY3NzXzEgPSByZ2IyY3NzO1xuICB2YXIgdW5wYWNrJDcgPSB1dGlscy51bnBhY2s7XG4gIHZhciByb3VuZCQxID0gTWF0aC5yb3VuZDtcblxuICB2YXIgaHNsMnJnYiA9IGZ1bmN0aW9uIGhzbDJyZ2IoKSB7XG4gICAgdmFyIGFzc2lnbjtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJDcoYXJncywgJ2hzbCcpO1xuICAgIHZhciBoID0gYXJnc1swXTtcbiAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgdmFyIGwgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGwgKiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0MyA9IFswLCAwLCAwXTtcbiAgICAgIHZhciBjID0gWzAsIDAsIDBdO1xuICAgICAgdmFyIHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgIHZhciB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICB2YXIgaF8gPSBoIC8gMzYwO1xuICAgICAgdDNbMF0gPSBoXyArIDEgLyAzO1xuICAgICAgdDNbMV0gPSBoXztcbiAgICAgIHQzWzJdID0gaF8gLSAxIC8gMztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgaWYgKHQzW2ldIDwgMCkge1xuICAgICAgICAgIHQzW2ldICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodDNbaV0gPiAxKSB7XG4gICAgICAgICAgdDNbaV0gLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICg2ICogdDNbaV0gPCAxKSB7XG4gICAgICAgICAgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldO1xuICAgICAgICB9IGVsc2UgaWYgKDIgKiB0M1tpXSA8IDEpIHtcbiAgICAgICAgICBjW2ldID0gdDI7XG4gICAgICAgIH0gZWxzZSBpZiAoMyAqIHQzW2ldIDwgMikge1xuICAgICAgICAgIGNbaV0gPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzW2ldKSAqIDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY1tpXSA9IHQxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFzc2lnbiA9IFtyb3VuZCQxKGNbMF0gKiAyNTUpLCByb3VuZCQxKGNbMV0gKiAyNTUpLCByb3VuZCQxKGNbMl0gKiAyNTUpXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgIHJldHVybiBbciwgZywgYiwgYXJnc1szXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgfTtcblxuICB2YXIgaHNsMnJnYl8xID0gaHNsMnJnYjtcbiAgdmFyIFJFX1JHQiA9IC9ecmdiXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKlxcKSQvO1xuICB2YXIgUkVfUkdCQSA9IC9ecmdiYVxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgdmFyIFJFX1JHQl9QQ1QgPSAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIFJFX1JHQkFfUENUID0gL15yZ2JhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuICB2YXIgUkVfSFNMID0gL15oc2xcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIFJFX0hTTEEgPSAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgdmFyIHJvdW5kJDIgPSBNYXRoLnJvdW5kO1xuXG4gIHZhciBjc3MycmdiID0gZnVuY3Rpb24gY3NzMnJnYihjc3MpIHtcbiAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgdmFyIG07XG5cbiAgICBpZiAoaW5wdXQuZm9ybWF0Lm5hbWVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZm9ybWF0Lm5hbWVkKGNzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB9XG4gICAgfSAvLyByZ2IoMjUwLDIwLDApXG5cblxuICAgIGlmIChtID0gY3NzLm1hdGNoKFJFX1JHQikpIHtcbiAgICAgIHZhciByZ2IgPSBtLnNsaWNlKDEsIDQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZ2JbaV0gPSArcmdiW2ldO1xuICAgICAgfVxuXG4gICAgICByZ2JbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG5cbiAgICAgIHJldHVybiByZ2I7XG4gICAgfSAvLyByZ2JhKDI1MCwyMCwwLDAuNClcblxuXG4gICAgaWYgKG0gPSBjc3MubWF0Y2goUkVfUkdCQSkpIHtcbiAgICAgIHZhciByZ2IkMSA9IG0uc2xpY2UoMSwgNSk7XG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDQ7IGkkMSsrKSB7XG4gICAgICAgIHJnYiQxW2kkMV0gPSArcmdiJDFbaSQxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJnYiQxO1xuICAgIH0gLy8gcmdiKDEwMCUsMCUsMCUpXG5cblxuICAgIGlmIChtID0gY3NzLm1hdGNoKFJFX1JHQl9QQ1QpKSB7XG4gICAgICB2YXIgcmdiJDIgPSBtLnNsaWNlKDEsIDQpO1xuXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCAzOyBpJDIrKykge1xuICAgICAgICByZ2IkMltpJDJdID0gcm91bmQkMihyZ2IkMltpJDJdICogMi41NSk7XG4gICAgICB9XG5cbiAgICAgIHJnYiQyWzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuXG4gICAgICByZXR1cm4gcmdiJDI7XG4gICAgfSAvLyByZ2JhKDEwMCUsMCUsMCUsMC40KVxuXG5cbiAgICBpZiAobSA9IGNzcy5tYXRjaChSRV9SR0JBX1BDVCkpIHtcbiAgICAgIHZhciByZ2IkMyA9IG0uc2xpY2UoMSwgNSk7XG5cbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IDM7IGkkMysrKSB7XG4gICAgICAgIHJnYiQzW2kkM10gPSByb3VuZCQyKHJnYiQzW2kkM10gKiAyLjU1KTtcbiAgICAgIH1cblxuICAgICAgcmdiJDNbM10gPSArcmdiJDNbM107XG4gICAgICByZXR1cm4gcmdiJDM7XG4gICAgfSAvLyBoc2woMCwxMDAlLDUwJSlcblxuXG4gICAgaWYgKG0gPSBjc3MubWF0Y2goUkVfSFNMKSkge1xuICAgICAgdmFyIGhzbCA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICBoc2xbMV0gKj0gMC4wMTtcbiAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgdmFyIHJnYiQ0ID0gaHNsMnJnYl8xKGhzbCk7XG4gICAgICByZ2IkNFszXSA9IDE7XG4gICAgICByZXR1cm4gcmdiJDQ7XG4gICAgfSAvLyBoc2xhKDAsMTAwJSw1MCUsMC41KVxuXG5cbiAgICBpZiAobSA9IGNzcy5tYXRjaChSRV9IU0xBKSkge1xuICAgICAgdmFyIGhzbCQxID0gbS5zbGljZSgxLCA0KTtcbiAgICAgIGhzbCQxWzFdICo9IDAuMDE7XG4gICAgICBoc2wkMVsyXSAqPSAwLjAxO1xuICAgICAgdmFyIHJnYiQ1ID0gaHNsMnJnYl8xKGhzbCQxKTtcbiAgICAgIHJnYiQ1WzNdID0gK21bNF07IC8vIGRlZmF1bHQgYWxwaGEgPSAxXG5cbiAgICAgIHJldHVybiByZ2IkNTtcbiAgICB9XG4gIH07XG5cbiAgY3NzMnJnYi50ZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gUkVfUkdCLnRlc3QocykgfHwgUkVfUkdCQS50ZXN0KHMpIHx8IFJFX1JHQl9QQ1QudGVzdChzKSB8fCBSRV9SR0JBX1BDVC50ZXN0KHMpIHx8IFJFX0hTTC50ZXN0KHMpIHx8IFJFX0hTTEEudGVzdChzKTtcbiAgfTtcblxuICB2YXIgY3NzMnJnYl8xID0gY3NzMnJnYjtcbiAgdmFyIHR5cGUkMyA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICByZXR1cm4gcmdiMmNzc18xKHRoaXMuX3JnYiwgbW9kZSk7XG4gIH07XG5cbiAgY2hyb21hXzEuY3NzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydjc3MnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5jc3MgPSBjc3MycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogNSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KGgpIHtcbiAgICAgIHZhciByZXN0ID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW4tLSA+IDApIHtcbiAgICAgICAgcmVzdFtsZW5dID0gYXJndW1lbnRzW2xlbiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkMyhoKSA9PT0gJ3N0cmluZycgJiYgY3NzMnJnYl8xLnRlc3QoaCkpIHtcbiAgICAgICAgcmV0dXJuICdjc3MnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skOCA9IHV0aWxzLnVucGFjaztcblxuICBpbnB1dC5mb3JtYXQuZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IHVucGFjayQ4KGFyZ3MsICdyZ2JhJyk7XG4gICAgcmdiWzBdICo9IDI1NTtcbiAgICByZ2JbMV0gKj0gMjU1O1xuICAgIHJnYlsyXSAqPSAyNTU7XG4gICAgcmV0dXJuIHJnYjtcbiAgfTtcblxuICBjaHJvbWFfMS5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnZ2wnXSkpKSgpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmdsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUsIHJnYlsxXSAvIDI1NSwgcmdiWzJdIC8gMjU1LCByZ2JbM11dO1xuICB9O1xuXG4gIHZhciB1bnBhY2skOSA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMmhjZyA9IGZ1bmN0aW9uIHJnYjJoY2coKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayQ5KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICB2YXIgYyA9IGRlbHRhICogMTAwIC8gMjU1O1xuXG4gICAgdmFyIF9nID0gbWluIC8gKDI1NSAtIGRlbHRhKSAqIDEwMDtcblxuICAgIHZhciBoO1xuXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA9PT0gbWF4KSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoICo9IDYwO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBjLCBfZ107XG4gIH07XG5cbiAgdmFyIHJnYjJoY2dfMSA9IHJnYjJoY2c7XG4gIHZhciB1bnBhY2skYSA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgLypcbiAgICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICAgKlxuICAgKiBodWUuLiBbMC4uMzYwXVxuICAgKiBjaHJvbWEgLi4gWzAuLjFdXG4gICAqIGdyYXluZXNzIC4uIFswLi4xXVxuICAgKi9cblxuICB2YXIgaGNnMnJnYiA9IGZ1bmN0aW9uIGhjZzJyZ2IoKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skYShhcmdzLCAnaGNnJyk7XG4gICAgdmFyIGggPSBhcmdzWzBdO1xuICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICB2YXIgX2cgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuICAgIF9nID0gX2cgKiAyNTU7XG5cbiAgICB2YXIgX2MgPSBjICogMjU1O1xuXG4gICAgaWYgKGMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IF9nO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaCA9PT0gMzYwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCA+IDM2MCkge1xuICAgICAgICBoIC09IDM2MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBoIC89IDYwO1xuICAgICAgdmFyIGkgPSBmbG9vcihoKTtcbiAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICB2YXIgcCA9IF9nICogKDEgLSBjKTtcbiAgICAgIHZhciBxID0gcCArIF9jICogKDEgLSBmKTtcbiAgICAgIHZhciB0ID0gcCArIF9jICogZjtcbiAgICAgIHZhciB2ID0gcCArIF9jO1xuXG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYXNzaWduJDEgPSBbcSwgdiwgcF0sIHIgPSBhc3NpZ24kMVswXSwgZyA9IGFzc2lnbiQxWzFdLCBiID0gYXNzaWduJDFbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGFzc2lnbiQyID0gW3AsIHYsIHRdLCByID0gYXNzaWduJDJbMF0sIGcgPSBhc3NpZ24kMlsxXSwgYiA9IGFzc2lnbiQyWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgYXNzaWduJDQgPSBbdCwgcCwgdl0sIHIgPSBhc3NpZ24kNFswXSwgZyA9IGFzc2lnbiQ0WzFdLCBiID0gYXNzaWduJDRbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGFzc2lnbiQ1ID0gW3YsIHAsIHFdLCByID0gYXNzaWduJDVbMF0sIGcgPSBhc3NpZ24kNVsxXSwgYiA9IGFzc2lnbiQ1WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICB9O1xuXG4gIHZhciBoY2cycmdiXzEgPSBoY2cycmdiO1xuICB2YXIgdW5wYWNrJGIgPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDQgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhjZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhjZ18xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoY2cnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oY2cgPSBoY2cycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skYihhcmdzLCAnaGNnJyk7XG5cbiAgICAgIGlmICh0eXBlJDQoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoY2cnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skYyA9IHV0aWxzLnVucGFjaztcbiAgdmFyIGxhc3QkNCA9IHV0aWxzLmxhc3Q7XG4gIHZhciByb3VuZCQzID0gTWF0aC5yb3VuZDtcblxuICB2YXIgcmdiMmhleCA9IGZ1bmN0aW9uIHJnYjJoZXgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRjKGFyZ3MsICdyZ2JhJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGEgPSByZWZbM107XG4gICAgdmFyIG1vZGUgPSBsYXN0JDQoYXJncykgfHwgJ2F1dG8nO1xuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdhdXRvJykge1xuICAgICAgbW9kZSA9IGEgPCAxID8gJ3JnYmEnIDogJ3JnYic7XG4gICAgfVxuXG4gICAgciA9IHJvdW5kJDMocik7XG4gICAgZyA9IHJvdW5kJDMoZyk7XG4gICAgYiA9IHJvdW5kJDMoYik7XG4gICAgdmFyIHUgPSByIDw8IDE2IHwgZyA8PCA4IHwgYjtcbiAgICB2YXIgc3RyID0gXCIwMDAwMDBcIiArIHUudG9TdHJpbmcoMTYpOyAvLyMudG9VcHBlckNhc2UoKTtcblxuICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDYpO1xuICAgIHZhciBoeGEgPSAnMCcgKyByb3VuZCQzKGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICBoeGEgPSBoeGEuc3Vic3RyKGh4YS5sZW5ndGggLSAyKTtcblxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgc3RyICsgaHhhO1xuXG4gICAgICBjYXNlICdhcmdiJzpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgaHhhICsgc3RyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCIjXCIgKyBzdHI7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZ2IyaGV4XzEgPSByZ2IyaGV4O1xuICB2YXIgUkVfSEVYID0gL14jPyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkLztcbiAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gIHZhciBoZXgycmdiID0gZnVuY3Rpb24gaGV4MnJnYihoZXgpIHtcbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWCkpIHtcbiAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgIH0gLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgc2l4LWRpZ2l0XG5cblxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgaGV4ID0gaGV4WzBdICsgaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgdmFyIHIgPSB1ID4+IDE2O1xuICAgICAgdmFyIGcgPSB1ID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSB1ICYgMHhGRjtcbiAgICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gICAgfSAvLyBtYXRjaCByZ2JhIGhleCBmb3JtYXQsIGVnICNGRjAwMDA3N1xuXG5cbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWEEpKSB7XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNSB8fCBoZXgubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgIH0gLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgZWlnaHQtZGlnaXRcblxuXG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICBoZXggPSBoZXhbMF0gKyBoZXhbMF0gKyBoZXhbMV0gKyBoZXhbMV0gKyBoZXhbMl0gKyBoZXhbMl0gKyBoZXhbM10gKyBoZXhbM107XG4gICAgICB9XG5cbiAgICAgIHZhciB1JDEgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgIHZhciByJDEgPSB1JDEgPj4gMjQgJiAweEZGO1xuICAgICAgdmFyIGckMSA9IHUkMSA+PiAxNiAmIDB4RkY7XG4gICAgICB2YXIgYiQxID0gdSQxID4+IDggJiAweEZGO1xuICAgICAgdmFyIGEgPSBNYXRoLnJvdW5kKCh1JDEgJiAweEZGKSAvIDB4RkYgKiAxMDApIC8gMTAwO1xuICAgICAgcmV0dXJuIFtyJDEsIGckMSwgYiQxLCBhXTtcbiAgICB9IC8vIHdlIHVzZWQgdG8gY2hlY2sgZm9yIGNzcyBjb2xvcnMgaGVyZVxuICAgIC8vIGlmIF9pbnB1dC5jc3M/IGFuZCByZ2IgPSBfaW5wdXQuY3NzIGhleFxuICAgIC8vICAgICByZXR1cm4gcmdiXG5cblxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gaGV4IGNvbG9yOiBcIiArIGhleCk7XG4gIH07XG5cbiAgdmFyIGhleDJyZ2JfMSA9IGhleDJyZ2I7XG4gIHZhciB0eXBlJDUgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIHJnYjJoZXhfMSh0aGlzLl9yZ2IsIG1vZGUpO1xuICB9O1xuXG4gIGNocm9tYV8xLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnaGV4J10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQuaGV4ID0gaGV4MnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDQsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdChoKSB7XG4gICAgICB2YXIgcmVzdCA9IFtdLFxuICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICAgIHJlc3RbbGVuXSA9IGFyZ3VtZW50c1tsZW4gKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJDUoaCkgPT09ICdzdHJpbmcnICYmIFszLCA0LCA1LCA2LCA3LCA4LCA5XS5pbmRleE9mKGgubGVuZ3RoKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnaGV4JztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgdW5wYWNrJGQgPSB1dGlscy51bnBhY2s7XG4gIHZhciBUV09QSSA9IHV0aWxzLlRXT1BJO1xuICB2YXIgbWluID0gTWF0aC5taW47XG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgYWNvcyA9IE1hdGguYWNvcztcblxuICB2YXIgcmdiMmhzaSA9IGZ1bmN0aW9uIHJnYjJoc2koKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9yZ2IyaHNpLmNwcFxuICAgICovXG5cblxuICAgIHZhciByZWYgPSB1bnBhY2skZChhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSByZWZbMF07XG4gICAgdmFyIGcgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgdmFyIGg7XG4gICAgdmFyIG1pbl8gPSBtaW4ociwgZywgYik7XG4gICAgdmFyIGkgPSAociArIGcgKyBiKSAvIDM7XG4gICAgdmFyIHMgPSBpID4gMCA/IDEgLSBtaW5fIC8gaSA6IDA7XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgaCA9IE5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IChyIC0gZyArIChyIC0gYikpIC8gMjtcbiAgICAgIGggLz0gc3FydCgociAtIGcpICogKHIgLSBnKSArIChyIC0gYikgKiAoZyAtIGIpKTtcbiAgICAgIGggPSBhY29zKGgpO1xuXG4gICAgICBpZiAoYiA+IGcpIHtcbiAgICAgICAgaCA9IFRXT1BJIC0gaDtcbiAgICAgIH1cblxuICAgICAgaCAvPSBUV09QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2ggKiAzNjAsIHMsIGldO1xuICB9O1xuXG4gIHZhciByZ2IyaHNpXzEgPSByZ2IyaHNpO1xuICB2YXIgdW5wYWNrJGUgPSB1dGlscy51bnBhY2s7XG4gIHZhciBsaW1pdCQxID0gdXRpbHMubGltaXQ7XG4gIHZhciBUV09QSSQxID0gdXRpbHMuVFdPUEk7XG4gIHZhciBQSVRISVJEID0gdXRpbHMuUElUSElSRDtcbiAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAvKlxuICAgKiBodWUgWzAuLjM2MF1cbiAgICogc2F0dXJhdGlvbiBbMC4uMV1cbiAgICogaW50ZW5zaXR5IFswLi4xXVxuICAgKi9cblxuICB2YXIgaHNpMnJnYiA9IGZ1bmN0aW9uIGhzaTJyZ2IoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9oc2kycmdiLmNwcFxuICAgICovXG5cblxuICAgIGFyZ3MgPSB1bnBhY2skZShhcmdzLCAnaHNpJyk7XG4gICAgdmFyIGggPSBhcmdzWzBdO1xuICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICB2YXIgaSA9IGFyZ3NbMl07XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAoaXNOYU4oaCkpIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihzKSkge1xuICAgICAgcyA9IDA7XG4gICAgfSAvLyBub3JtYWxpemUgaHVlXG5cblxuICAgIGlmIChoID4gMzYwKSB7XG4gICAgICBoIC09IDM2MDtcbiAgICB9XG5cbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMzYwO1xuICAgIH1cblxuICAgIGggLz0gMzYwO1xuXG4gICAgaWYgKGggPCAxIC8gMykge1xuICAgICAgYiA9ICgxIC0gcykgLyAzO1xuICAgICAgciA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgZyA9IDEgLSAoYiArIHIpO1xuICAgIH0gZWxzZSBpZiAoaCA8IDIgLyAzKSB7XG4gICAgICBoIC09IDEgLyAzO1xuICAgICAgciA9ICgxIC0gcykgLyAzO1xuICAgICAgZyA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgYiA9IDEgLSAociArIGcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoIC09IDIgLyAzO1xuICAgICAgZyA9ICgxIC0gcykgLyAzO1xuICAgICAgYiA9ICgxICsgcyAqIGNvcyhUV09QSSQxICogaCkgLyBjb3MoUElUSElSRCAtIFRXT1BJJDEgKiBoKSkgLyAzO1xuICAgICAgciA9IDEgLSAoZyArIGIpO1xuICAgIH1cblxuICAgIHIgPSBsaW1pdCQxKGkgKiByICogMyk7XG4gICAgZyA9IGxpbWl0JDEoaSAqIGcgKiAzKTtcbiAgICBiID0gbGltaXQkMShpICogYiAqIDMpO1xuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICB9O1xuXG4gIHZhciBoc2kycmdiXzEgPSBoc2kycmdiO1xuICB2YXIgdW5wYWNrJGYgPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDYgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhzaSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhzaV8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaHNpID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoc2knXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oc2kgPSBoc2kycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skZihhcmdzLCAnaHNpJyk7XG5cbiAgICAgIGlmICh0eXBlJDYoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoc2knO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skZyA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHR5cGUkNyA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHNsXzEodGhpcy5fcmdiKTtcbiAgfTtcblxuICBjaHJvbWFfMS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ2hzbCddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmhzbCA9IGhzbDJyZ2JfMTtcbiAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAyLFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IHVucGFjayRnKGFyZ3MsICdoc2wnKTtcblxuICAgICAgaWYgKHR5cGUkNyhhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ2hzbCc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHVucGFjayRoID0gdXRpbHMudW5wYWNrO1xuICB2YXIgbWluJDEgPSBNYXRoLm1pbjtcbiAgdmFyIG1heCQxID0gTWF0aC5tYXg7XG4gIC8qXG4gICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAqIC0gcmdiMmhzdihyLGcsYilcbiAgICogLSByZ2IyaHN2KFtyLGcsYl0pXG4gICAqIC0gcmdiMmhzdih7cixnLGJ9KVxuICAgKi9cblxuICB2YXIgcmdiMmhzbCQxID0gZnVuY3Rpb24gcmdiMmhzbCQxKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skaChhcmdzLCAncmdiJyk7XG4gICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICB2YXIgYiA9IGFyZ3NbMl07XG4gICAgdmFyIG1pbl8gPSBtaW4kMShyLCBnLCBiKTtcbiAgICB2YXIgbWF4XyA9IG1heCQxKHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heF8gLSBtaW5fO1xuICAgIHZhciBoLCBzLCB2O1xuICAgIHYgPSBtYXhfIC8gMjU1LjA7XG5cbiAgICBpZiAobWF4XyA9PT0gMCkge1xuICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4XztcblxuICAgICAgaWYgKHIgPT09IG1heF8pIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGcgPT09IG1heF8pIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiID09PSBtYXhfKSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoICo9IDYwO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCB2XTtcbiAgfTtcblxuICB2YXIgcmdiMmhzdiA9IHJnYjJoc2wkMTtcbiAgdmFyIHVucGFjayRpID0gdXRpbHMudW5wYWNrO1xuICB2YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIGhzdjJyZ2IgPSBmdW5jdGlvbiBoc3YycmdiKCkge1xuICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMiwgYXNzaWduJDMsIGFzc2lnbiQ0LCBhc3NpZ24kNTtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICBhcmdzID0gdW5wYWNrJGkoYXJncywgJ2hzdicpO1xuICAgIHZhciBoID0gYXJnc1swXTtcbiAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgdmFyIHYgPSBhcmdzWzJdO1xuICAgIHZhciByLCBnLCBiO1xuICAgIHYgKj0gMjU1O1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoID09PSAzNjApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoID4gMzYwKSB7XG4gICAgICAgIGggLT0gMzYwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG5cbiAgICAgIGggLz0gNjA7XG4gICAgICB2YXIgaSA9IGZsb29yJDEoaCk7XG4gICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgdmFyIHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gIH07XG5cbiAgdmFyIGhzdjJyZ2JfMSA9IGhzdjJyZ2I7XG4gIHZhciB1bnBhY2skaiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHR5cGUkOCA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHN2KHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydoc3YnXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5oc3YgPSBoc3YycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skaihhcmdzLCAnaHN2Jyk7XG5cbiAgICAgIGlmICh0eXBlJDgoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBsYWJDb25zdGFudHMgPSB7XG4gICAgLy8gQ29ycmVzcG9uZHMgcm91Z2hseSB0byBSR0IgYnJpZ2h0ZXIvZGFya2VyXG4gICAgS246IDE4LFxuICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgIFhuOiAwLjk1MDQ3MCxcbiAgICBZbjogMSxcbiAgICBabjogMS4wODg4MzAsXG4gICAgdDA6IDAuMTM3OTMxMDM0LFxuICAgIC8vIDQgLyAyOVxuICAgIHQxOiAwLjIwNjg5NjU1MixcbiAgICAvLyA2IC8gMjlcbiAgICB0MjogMC4xMjg0MTg1NSxcbiAgICAvLyAzICogdDEgKiB0MVxuICAgIHQzOiAwLjAwODg1NjQ1MiAvLyB0MSAqIHQxICogdDFcblxuICB9O1xuICB2YXIgdW5wYWNrJGsgPSB1dGlscy51bnBhY2s7XG4gIHZhciBwb3cgPSBNYXRoLnBvdztcblxuICB2YXIgcmdiMmxhYiA9IGZ1bmN0aW9uIHJnYjJsYWIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRrKGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSByZ2IyeHl6KHIsIGcsIGIpO1xuICAgIHZhciB4ID0gcmVmJDFbMF07XG4gICAgdmFyIHkgPSByZWYkMVsxXTtcbiAgICB2YXIgeiA9IHJlZiQxWzJdO1xuICAgIHZhciBsID0gMTE2ICogeSAtIDE2O1xuICAgIHJldHVybiBbbCA8IDAgPyAwIDogbCwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KV07XG4gIH07XG5cbiAgdmFyIHJnYl94eXogPSBmdW5jdGlvbiByZ2JfeHl6KHIpIHtcbiAgICBpZiAoKHIgLz0gMjU1KSA8PSAwLjA0MDQ1KSB7XG4gICAgICByZXR1cm4gciAvIDEyLjkyO1xuICAgIH1cblxuICAgIHJldHVybiBwb3coKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcblxuICB2YXIgeHl6X2xhYiA9IGZ1bmN0aW9uIHh5el9sYWIodCkge1xuICAgIGlmICh0ID4gbGFiQ29uc3RhbnRzLnQzKSB7XG4gICAgICByZXR1cm4gcG93KHQsIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdCAvIGxhYkNvbnN0YW50cy50MiArIGxhYkNvbnN0YW50cy50MDtcbiAgfTtcblxuICB2YXIgcmdiMnh5eiA9IGZ1bmN0aW9uIHJnYjJ4eXoociwgZywgYikge1xuICAgIHIgPSByZ2JfeHl6KHIpO1xuICAgIGcgPSByZ2JfeHl6KGcpO1xuICAgIGIgPSByZ2JfeHl6KGIpO1xuICAgIHZhciB4ID0geHl6X2xhYigoMC40MTI0NTY0ICogciArIDAuMzU3NTc2MSAqIGcgKyAwLjE4MDQzNzUgKiBiKSAvIGxhYkNvbnN0YW50cy5Ybik7XG4gICAgdmFyIHkgPSB4eXpfbGFiKCgwLjIxMjY3MjkgKiByICsgMC43MTUxNTIyICogZyArIDAuMDcyMTc1MCAqIGIpIC8gbGFiQ29uc3RhbnRzLlluKTtcbiAgICB2YXIgeiA9IHh5el9sYWIoKDAuMDE5MzMzOSAqIHIgKyAwLjExOTE5MjAgKiBnICsgMC45NTAzMDQxICogYikgLyBsYWJDb25zdGFudHMuWm4pO1xuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH07XG5cbiAgdmFyIHJnYjJsYWJfMSA9IHJnYjJsYWI7XG4gIHZhciB1bnBhY2skbCA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHBvdyQxID0gTWF0aC5wb3c7XG4gIC8qXG4gICAqIEwqIFswLi4xMDBdXG4gICAqIGEgWy0xMDAuLjEwMF1cbiAgICogYiBbLTEwMC4uMTAwXVxuICAgKi9cblxuICB2YXIgbGFiMnJnYiA9IGZ1bmN0aW9uIGxhYjJyZ2IoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgYXJncyA9IHVucGFjayRsKGFyZ3MsICdsYWInKTtcbiAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgdmFyIGEgPSBhcmdzWzFdO1xuICAgIHZhciBiID0gYXJnc1syXTtcbiAgICB2YXIgeCwgeSwgeiwgciwgZywgYl87XG4gICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgIHggPSBpc05hTihhKSA/IHkgOiB5ICsgYSAvIDUwMDtcbiAgICB6ID0gaXNOYU4oYikgPyB5IDogeSAtIGIgLyAyMDA7XG4gICAgeSA9IGxhYkNvbnN0YW50cy5ZbiAqIGxhYl94eXooeSk7XG4gICAgeCA9IGxhYkNvbnN0YW50cy5YbiAqIGxhYl94eXooeCk7XG4gICAgeiA9IGxhYkNvbnN0YW50cy5abiAqIGxhYl94eXooeik7XG4gICAgciA9IHh5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KTsgLy8gRDY1IC0+IHNSR0JcblxuICAgIGcgPSB4eXpfcmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopO1xuICAgIGJfID0geHl6X3JnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopO1xuICAgIHJldHVybiBbciwgZywgYl8sIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgfTtcblxuICB2YXIgeHl6X3JnYiA9IGZ1bmN0aW9uIHh5el9yZ2Iocikge1xuICAgIHJldHVybiAyNTUgKiAociA8PSAwLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBwb3ckMShyLCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgfTtcblxuICB2YXIgbGFiX3h5eiA9IGZ1bmN0aW9uIGxhYl94eXoodCkge1xuICAgIHJldHVybiB0ID4gbGFiQ29uc3RhbnRzLnQxID8gdCAqIHQgKiB0IDogbGFiQ29uc3RhbnRzLnQyICogKHQgLSBsYWJDb25zdGFudHMudDApO1xuICB9O1xuXG4gIHZhciBsYWIycmdiXzEgPSBsYWIycmdiO1xuICB2YXIgdW5wYWNrJG0gPSB1dGlscy51bnBhY2s7XG4gIHZhciB0eXBlJDkgPSB1dGlscy50eXBlO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmxhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxhYl8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEubGFiID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWydsYWInXSkpKSgpO1xuICB9O1xuXG4gIGlucHV0LmZvcm1hdC5sYWIgPSBsYWIycmdiXzE7XG4gIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSB1bnBhY2skbShhcmdzLCAnbGFiJyk7XG5cbiAgICAgIGlmICh0eXBlJDkoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdsYWInO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skbiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIFJBRDJERUcgPSB1dGlscy5SQUQyREVHO1xuICB2YXIgc3FydCQxID0gTWF0aC5zcXJ0O1xuICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICB2YXIgcm91bmQkNCA9IE1hdGgucm91bmQ7XG5cbiAgdmFyIGxhYjJsY2ggPSBmdW5jdGlvbiBsYWIybGNoKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHZhciByZWYgPSB1bnBhY2skbihhcmdzLCAnbGFiJyk7XG4gICAgdmFyIGwgPSByZWZbMF07XG4gICAgdmFyIGEgPSByZWZbMV07XG4gICAgdmFyIGIgPSByZWZbMl07XG4gICAgdmFyIGMgPSBzcXJ0JDEoYSAqIGEgKyBiICogYik7XG4gICAgdmFyIGggPSAoYXRhbjIoYiwgYSkgKiBSQUQyREVHICsgMzYwKSAlIDM2MDtcblxuICAgIGlmIChyb3VuZCQ0KGMgKiAxMDAwMCkgPT09IDApIHtcbiAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH1cblxuICAgIHJldHVybiBbbCwgYywgaF07XG4gIH07XG5cbiAgdmFyIGxhYjJsY2hfMSA9IGxhYjJsY2g7XG4gIHZhciB1bnBhY2skbyA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMmxjaCA9IGZ1bmN0aW9uIHJnYjJsY2goKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayRvKGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSByZ2IybGFiXzEociwgZywgYik7XG4gICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICB2YXIgYSA9IHJlZiQxWzFdO1xuICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgIHJldHVybiBsYWIybGNoXzEobCwgYSwgYl8pO1xuICB9O1xuXG4gIHZhciByZ2IybGNoXzEgPSByZ2IybGNoO1xuICB2YXIgdW5wYWNrJHAgPSB1dGlscy51bnBhY2s7XG4gIHZhciBERUcyUkFEID0gdXRpbHMuREVHMlJBRDtcbiAgdmFyIHNpbiA9IE1hdGguc2luO1xuICB2YXIgY29zJDEgPSBNYXRoLmNvcztcblxuICB2YXIgbGNoMmxhYiA9IGZ1bmN0aW9uIGxjaDJsYWIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuICAgIC8qXG4gICAgQ29udmVydCBmcm9tIGEgcXVhbGl0YXRpdmUgcGFyYW1ldGVyIGggYW5kIGEgcXVhbnRpdGF0aXZlIHBhcmFtZXRlciBsIHRvIGEgMjQtYml0IHBpeGVsLlxuICAgIFRoZXNlIGZvcm11bGFzIHdlcmUgaW52ZW50ZWQgYnkgRGF2aWQgRGFscnltcGxlIHRvIG9idGFpbiBtYXhpbXVtIGNvbnRyYXN0IHdpdGhvdXQgZ29pbmdcbiAgICBvdXQgb2YgZ2FtdXQgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGluIHRoZSByYW5nZSAwLTEuXG4gICAgIEEgc2F0dXJhdGlvbiBtdWx0aXBsaWVyIHdhcyBhZGRlZCBieSBHcmVnb3IgQWlzY2hcbiAgICAqL1xuXG5cbiAgICB2YXIgcmVmID0gdW5wYWNrJHAoYXJncywgJ2xjaCcpO1xuICAgIHZhciBsID0gcmVmWzBdO1xuICAgIHZhciBjID0gcmVmWzFdO1xuICAgIHZhciBoID0gcmVmWzJdO1xuXG4gICAgaWYgKGlzTmFOKGgpKSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICBoID0gaCAqIERFRzJSQUQ7XG4gICAgcmV0dXJuIFtsLCBjb3MkMShoKSAqIGMsIHNpbihoKSAqIGNdO1xuICB9O1xuXG4gIHZhciBsY2gybGFiXzEgPSBsY2gybGFiO1xuICB2YXIgdW5wYWNrJHEgPSB1dGlscy51bnBhY2s7XG5cbiAgdmFyIGxjaDJyZ2IgPSBmdW5jdGlvbiBsY2gycmdiKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIGFyZ3MgPSB1bnBhY2skcShhcmdzLCAnbGNoJyk7XG4gICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgdmFyIHJlZiA9IGxjaDJsYWJfMShsLCBjLCBoKTtcbiAgICB2YXIgTCA9IHJlZlswXTtcbiAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICB2YXIgYl8gPSByZWZbMl07XG4gICAgdmFyIHJlZiQxID0gbGFiMnJnYl8xKEwsIGEsIGJfKTtcbiAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgdmFyIGIgPSByZWYkMVsyXTtcbiAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgfTtcblxuICB2YXIgbGNoMnJnYl8xID0gbGNoMnJnYjtcbiAgdmFyIHVucGFjayRyID0gdXRpbHMudW5wYWNrO1xuXG4gIHZhciBoY2wycmdiID0gZnVuY3Rpb24gaGNsMnJnYigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgaGNsID0gdW5wYWNrJHIoYXJncywgJ2hjbCcpLnJldmVyc2UoKTtcbiAgICByZXR1cm4gbGNoMnJnYl8xLmFwcGx5KHZvaWQgMCwgaGNsKTtcbiAgfTtcblxuICB2YXIgaGNsMnJnYl8xID0gaGNsMnJnYjtcbiAgdmFyIHVucGFjayRzID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSRhID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5sY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJsY2hfMSh0aGlzLl9yZ2IpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxjaF8xKHRoaXMuX3JnYikucmV2ZXJzZSgpO1xuICB9O1xuXG4gIGNocm9tYV8xLmxjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnbGNoJ10pKSkoKTtcbiAgfTtcblxuICBjaHJvbWFfMS5oY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ2hjbCddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LmxjaCA9IGxjaDJyZ2JfMTtcbiAgaW5wdXQuZm9ybWF0LmhjbCA9IGhjbDJyZ2JfMTtcbiAgWydsY2gnLCAnaGNsJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgcDogMixcbiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRzKGFyZ3MsIG0pO1xuXG4gICAgICAgIGlmICh0eXBlJGEoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gIFx0WDExIGNvbG9yIG5hbWVzXG4gICBcdGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAqL1xuXG4gIHZhciB3M2N4MTEgPSB7XG4gICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgYXF1YTogJyMwMGZmZmYnLFxuICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JyxcbiAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgIGJsdWU6ICcjMDAwMGZmJyxcbiAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICBidXJseXdvb2Q6ICcjZGViODg3JyxcbiAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgY2hvY29sYXRlOiAnI2QyNjkxZScsXG4gICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICBjb3JuZmxvd2VyOiAnIzY0OTVlZCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcbiAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxuICAgIGNyaW1zb246ICcjZGMxNDNjJyxcbiAgICBjeWFuOiAnIzAwZmZmZicsXG4gICAgZGFya2JsdWU6ICcjMDAwMDhiJyxcbiAgICBkYXJrY3lhbjogJyMwMDhiOGInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJyxcbiAgICBkYXJrZ3JheTogJyNhOWE5YTknLFxuICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLFxuICAgIGRhcmtncmV5OiAnI2E5YTlhOScsXG4gICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsXG4gICAgZGFya3JlZDogJyM4YjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJyxcbiAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJyxcbiAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLFxuICAgIGRhcmtzbGF0ZWdyZXk6ICcjMmY0ZjRmJyxcbiAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsXG4gICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLFxuICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsXG4gICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcbiAgICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogJyM2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJyxcbiAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLFxuICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsXG4gICAgZnVjaHNpYTogJyNmZjAwZmYnLFxuICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLFxuICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJyxcbiAgICBnb2xkOiAnI2ZmZDcwMCcsXG4gICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsXG4gICAgZ3JheTogJyM4MDgwODAnLFxuICAgIGdyZWVuOiAnIzAwODAwMCcsXG4gICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJyxcbiAgICBncmV5OiAnIzgwODA4MCcsXG4gICAgaG9uZXlkZXc6ICcjZjBmZmYwJyxcbiAgICBob3RwaW5rOiAnI2ZmNjliNCcsXG4gICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgaW5kaWdvOiAnIzRiMDA4MicsXG4gICAgaXZvcnk6ICcjZmZmZmYwJyxcbiAgICBraGFraTogJyNmMGU2OGMnLFxuICAgIGxhc2VybGVtb246ICcjZmZmZjU0JyxcbiAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLFxuICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JyxcbiAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcbiAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJyxcbiAgICBsaWdodGJsdWU6ICcjYWRkOGU2JyxcbiAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsXG4gICAgbGlnaHRnb2xkZW5yb2Q6ICcjZmFmYWQyJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLFxuICAgIGxpZ2h0Z3JheTogJyNkM2QzZDMnLFxuICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJyxcbiAgICBsaWdodGdyZXk6ICcjZDNkM2QzJyxcbiAgICBsaWdodHBpbms6ICcjZmZiNmMxJyxcbiAgICBsaWdodHNhbG1vbjogJyNmZmEwN2EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJyxcbiAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJyxcbiAgICBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLFxuICAgIGxpZ2h0c2xhdGVncmV5OiAnIzc3ODg5OScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcbiAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxuICAgIGxpbWU6ICcjMDBmZjAwJyxcbiAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcbiAgICBsaW5lbjogJyNmYWYwZTYnLFxuICAgIG1hZ2VudGE6ICcjZmYwMGZmJyxcbiAgICBtYXJvb246ICcjODAwMDAwJyxcbiAgICBtYXJvb24yOiAnIzdmMDAwMCcsXG4gICAgbWFyb29uMzogJyNiMDMwNjAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJyxcbiAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXG4gICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXG4gICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkYicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJyxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxuICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLFxuICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxuICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXG4gICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJyxcbiAgICBuYXZ5OiAnIzAwMDA4MCcsXG4gICAgb2xkbGFjZTogJyNmZGY1ZTYnLFxuICAgIG9saXZlOiAnIzgwODAwMCcsXG4gICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsXG4gICAgb3JhbmdlOiAnI2ZmYTUwMCcsXG4gICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXG4gICAgb3JjaGlkOiAnI2RhNzBkNicsXG4gICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLFxuICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJyxcbiAgICBwYWxldmlvbGV0cmVkOiAnI2RiNzA5MycsXG4gICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLFxuICAgIHBlYWNocHVmZjogJyNmZmRhYjknLFxuICAgIHBlcnU6ICcjY2Q4NTNmJyxcbiAgICBwaW5rOiAnI2ZmYzBjYicsXG4gICAgcGx1bTogJyNkZGEwZGQnLFxuICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JyxcbiAgICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgICBwdXJwbGUyOiAnIzdmMDA3ZicsXG4gICAgcHVycGxlMzogJyNhMDIwZjAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICcjNjYzMzk5JyxcbiAgICByZWQ6ICcjZmYwMDAwJyxcbiAgICByb3N5YnJvd246ICcjYmM4ZjhmJyxcbiAgICByb3lhbGJsdWU6ICcjNDE2OWUxJyxcbiAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLFxuICAgIHNhbG1vbjogJyNmYTgwNzInLFxuICAgIHNhbmR5YnJvd246ICcjZjRhNDYwJyxcbiAgICBzZWFncmVlbjogJyMyZThiNTcnLFxuICAgIHNlYXNoZWxsOiAnI2ZmZjVlZScsXG4gICAgc2llbm5hOiAnI2EwNTIyZCcsXG4gICAgc2lsdmVyOiAnI2MwYzBjMCcsXG4gICAgc2t5Ymx1ZTogJyM4N2NlZWInLFxuICAgIHNsYXRlYmx1ZTogJyM2YTVhY2QnLFxuICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLFxuICAgIHNsYXRlZ3JleTogJyM3MDgwOTAnLFxuICAgIHNub3c6ICcjZmZmYWZhJyxcbiAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLFxuICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLFxuICAgIHRhbjogJyNkMmI0OGMnLFxuICAgIHRlYWw6ICcjMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsXG4gICAgdG9tYXRvOiAnI2ZmNjM0NycsXG4gICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsXG4gICAgdmlvbGV0OiAnI2VlODJlZScsXG4gICAgd2hlYXQ6ICcjZjVkZWIzJyxcbiAgICB3aGl0ZTogJyNmZmZmZmYnLFxuICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JyxcbiAgICB5ZWxsb3c6ICcjZmZmZjAwJyxcbiAgICB5ZWxsb3dncmVlbjogJyM5YWNkMzInXG4gIH07XG4gIHZhciB3M2N4MTFfMSA9IHczY3gxMTtcbiAgdmFyIHR5cGUkYiA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGV4ID0gcmdiMmhleF8xKHRoaXMuX3JnYiwgJ3JnYicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh3M2N4MTFfMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbiA9IGxpc3RbaV07XG5cbiAgICAgIGlmICh3M2N4MTFfMVtuXSA9PT0gaGV4KSB7XG4gICAgICAgIHJldHVybiBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQubmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodzNjeDExXzFbbmFtZV0pIHtcbiAgICAgIHJldHVybiBoZXgycmdiXzEodzNjeDExXzFbbmFtZV0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb2xvciBuYW1lOiAnICsgbmFtZSk7XG4gIH07XG5cbiAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiA1LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoaCkge1xuICAgICAgdmFyIHJlc3QgPSBbXSxcbiAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgICByZXN0W2xlbl0gPSBhcmd1bWVudHNbbGVuICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRiKGgpID09PSAnc3RyaW5nJyAmJiB3M2N4MTFfMVtoLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHJldHVybiAnbmFtZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bnBhY2skdCA9IHV0aWxzLnVucGFjaztcblxuICB2YXIgcmdiMm51bSA9IGZ1bmN0aW9uIHJnYjJudW0oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHVucGFjayR0KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJlZlswXTtcbiAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xuICB9O1xuXG4gIHZhciByZ2IybnVtXzEgPSByZ2IybnVtO1xuICB2YXIgdHlwZSRjID0gdXRpbHMudHlwZTtcblxuICB2YXIgbnVtMnJnYiA9IGZ1bmN0aW9uIG51bTJyZ2IobnVtKSB7XG4gICAgaWYgKHR5cGUkYyhudW0pID09IFwibnVtYmVyXCIgJiYgbnVtID49IDAgJiYgbnVtIDw9IDB4RkZGRkZGKSB7XG4gICAgICB2YXIgciA9IG51bSA+PiAxNjtcbiAgICAgIHZhciBnID0gbnVtID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSBudW0gJiAweEZGO1xuICAgICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG51bSBjb2xvcjogXCIgKyBudW0pO1xuICB9O1xuXG4gIHZhciBudW0ycmdiXzEgPSBudW0ycmdiO1xuICB2YXIgdHlwZSRkID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5udW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJudW1fMSh0aGlzLl9yZ2IpO1xuICB9O1xuXG4gIGNocm9tYV8xLm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb2xvcl8xLCBbbnVsbF0uY29uY2F0KGFyZ3MsIFsnbnVtJ10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQubnVtID0gbnVtMnJnYl8xO1xuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDUsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZSRkKGFyZ3NbMF0pID09PSAnbnVtYmVyJyAmJiBhcmdzWzBdID49IDAgJiYgYXJnc1swXSA8PSAweEZGRkZGRikge1xuICAgICAgICByZXR1cm4gJ251bSc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHVucGFjayR1ID0gdXRpbHMudW5wYWNrO1xuICB2YXIgdHlwZSRlID0gdXRpbHMudHlwZTtcbiAgdmFyIHJvdW5kJDUgPSBNYXRoLnJvdW5kO1xuXG4gIENvbG9yXzEucHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uIChybmQpIHtcbiAgICBpZiAocm5kID09PSB2b2lkIDApIHJuZCA9IHRydWU7XG5cbiAgICBpZiAocm5kID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDMpLm1hcChyb3VuZCQ1KTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5yZ2JhID0gZnVuY3Rpb24gKHJuZCkge1xuICAgIGlmIChybmQgPT09IHZvaWQgMCkgcm5kID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDQpLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIGkgPCAzID8gcm5kID09PSBmYWxzZSA/IHYgOiByb3VuZCQ1KHYpIDogdjtcbiAgICB9KTtcbiAgfTtcblxuICBjaHJvbWFfMS5yZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoQ29sb3JfMSwgW251bGxdLmNvbmNhdChhcmdzLCBbJ3JnYiddKSkpKCk7XG4gIH07XG5cbiAgaW5wdXQuZm9ybWF0LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgcmdiYSA9IHVucGFjayR1KGFyZ3MsICdyZ2JhJyk7XG5cbiAgICBpZiAocmdiYVszXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZ2JhWzNdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmdiYTtcbiAgfTtcblxuICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDMsXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gdW5wYWNrJHUoYXJncywgJ3JnYmEnKTtcblxuICAgICAgaWYgKHR5cGUkZShhcmdzKSA9PT0gJ2FycmF5JyAmJiAoYXJncy5sZW5ndGggPT09IDMgfHwgYXJncy5sZW5ndGggPT09IDQgJiYgdHlwZSRlKGFyZ3NbM10pID09ICdudW1iZXInICYmIGFyZ3NbM10gPj0gMCAmJiBhcmdzWzNdIDw9IDEpKSB7XG4gICAgICAgIHJldHVybiAncmdiJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKlxuICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICovXG5cbiAgdmFyIGxvZyA9IE1hdGgubG9nO1xuXG4gIHZhciB0ZW1wZXJhdHVyZTJyZ2IgPSBmdW5jdGlvbiB0ZW1wZXJhdHVyZTJyZ2Ioa2VsdmluKSB7XG4gICAgdmFyIHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICByID0gMjU1O1xuICAgICAgZyA9IC0xNTUuMjU0ODU1NjI3MDkxNzkgLSAwLjQ0NTk2OTUwNDY5NTc5MTMzICogKGcgPSB0ZW1wIC0gMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2coZyk7XG4gICAgICBiID0gdGVtcCA8IDIwID8gMCA6IC0yNTQuNzY5MzUxODQxMjA5MDIgKyAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAgLSAxMCkgKyAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2coYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAzNTEuOTc2OTA1NjY4MDU2OTMgKyAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcCAtIDU1KSAtIDQwLjI1MzY2MzA5MzMyMTI3ICogbG9nKHIpO1xuICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcCAtIDUwKSAtIDI4LjA4NTI5NjM1MDc5NTcgKiBsb2coZyk7XG4gICAgICBiID0gMjU1O1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gIH07XG5cbiAgdmFyIHRlbXBlcmF0dXJlMnJnYl8xID0gdGVtcGVyYXR1cmUycmdiO1xuICAvKlxuICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICoqL1xuXG4gIHZhciB1bnBhY2skdiA9IHV0aWxzLnVucGFjaztcbiAgdmFyIHJvdW5kJDYgPSBNYXRoLnJvdW5kO1xuXG4gIHZhciByZ2IydGVtcGVyYXR1cmUgPSBmdW5jdGlvbiByZ2IydGVtcGVyYXR1cmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IHVucGFjayR2KGFyZ3MsICdyZ2InKTtcbiAgICB2YXIgciA9IHJnYlswXSxcbiAgICAgICAgYiA9IHJnYlsyXTtcbiAgICB2YXIgbWluVGVtcCA9IDEwMDA7XG4gICAgdmFyIG1heFRlbXAgPSA0MDAwMDtcbiAgICB2YXIgZXBzID0gMC40O1xuICAgIHZhciB0ZW1wO1xuXG4gICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgIHZhciByZ2IkMSA9IHRlbXBlcmF0dXJlMnJnYl8xKHRlbXApO1xuXG4gICAgICBpZiAocmdiJDFbMl0gLyByZ2IkMVswXSA+PSBiIC8gcikge1xuICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3VuZCQ2KHRlbXApO1xuICB9O1xuXG4gIHZhciByZ2IydGVtcGVyYXR1cmVfMSA9IHJnYjJ0ZW1wZXJhdHVyZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS50ZW1wID0gQ29sb3JfMS5wcm90b3R5cGUua2VsdmluID0gQ29sb3JfMS5wcm90b3R5cGUudGVtcGVyYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJ0ZW1wZXJhdHVyZV8xKHRoaXMuX3JnYik7XG4gIH07XG5cbiAgY2hyb21hXzEudGVtcCA9IGNocm9tYV8xLmtlbHZpbiA9IGNocm9tYV8xLnRlbXBlcmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncywgWyd0ZW1wJ10pKSkoKTtcbiAgfTtcblxuICBpbnB1dC5mb3JtYXQudGVtcCA9IGlucHV0LmZvcm1hdC5rZWx2aW4gPSBpbnB1dC5mb3JtYXQudGVtcGVyYXR1cmUgPSB0ZW1wZXJhdHVyZTJyZ2JfMTtcbiAgdmFyIHR5cGUkZiA9IHV0aWxzLnR5cGU7XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbiAoYSwgbXV0YXRlKSB7XG4gICAgaWYgKG11dGF0ZSA9PT0gdm9pZCAwKSBtdXRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgdHlwZSRmKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICB0aGlzLl9yZ2JbM10gPSBhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFt0aGlzLl9yZ2JbMF0sIHRoaXMuX3JnYlsxXSwgdGhpcy5fcmdiWzJdLCBhXSwgJ3JnYicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZ2JbM107XG4gIH07XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuY2xpcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkIHx8IGZhbHNlO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIGFtb3VudCA9IDE7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbGFiID0gbWUubGFiKCk7XG4gICAgbGFiWzBdIC09IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcbiAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gIH07XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW4gPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSBhbW91bnQgPSAxO1xuICAgIHJldHVybiB0aGlzLmRhcmtlbigtYW1vdW50KTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZXIgPSBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZW47XG4gIENvbG9yXzEucHJvdG90eXBlLmJyaWdodGVyID0gQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW47XG5cbiAgQ29sb3JfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG1jKSB7XG4gICAgdmFyIHJlZiA9IG1jLnNwbGl0KCcuJyk7XG4gICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgdmFyIHNyYyA9IHRoaXNbbW9kZV0oKTtcblxuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICByZXR1cm4gc3JjW2ldO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdHlwZSRnID0gdXRpbHMudHlwZTtcbiAgdmFyIHBvdyQyID0gTWF0aC5wb3c7XG4gIHZhciBFUFMgPSAxZS03O1xuICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5sdW1pbmFuY2UgPSBmdW5jdGlvbiAobHVtKSB7XG4gICAgaWYgKGx1bSAhPT0gdW5kZWZpbmVkICYmIHR5cGUkZyhsdW0pID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGx1bSA9PT0gMCkge1xuICAgICAgICAvLyByZXR1cm4gcHVyZSBibGFja1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzAsIDAsIDAsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGx1bSA9PT0gMSkge1xuICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzI1NSwgMjU1LCAyNTUsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgIH0gLy8gY29tcHV0ZSBuZXcgY29sb3IgdXNpbmcuLi5cblxuXG4gICAgICB2YXIgY3VyX2x1bSA9IHRoaXMubHVtaW5hbmNlKCk7XG4gICAgICB2YXIgbW9kZSA9ICdyZ2InO1xuICAgICAgdmFyIG1heF9pdGVyID0gTUFYX0lURVI7XG5cbiAgICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gdGVzdChsb3csIGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICB2YXIgbG0gPSBtaWQubHVtaW5hbmNlKCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGx1bSAtIGxtKSA8IEVQUyB8fCAhbWF4X2l0ZXItLSkge1xuICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZ2IgPSAoY3VyX2x1bSA+IGx1bSA/IHRlc3QobmV3IENvbG9yXzEoWzAsIDAsIDBdKSwgdGhpcykgOiB0ZXN0KHRoaXMsIG5ldyBDb2xvcl8xKFsyNTUsIDI1NSwgMjU1XSkpKS5yZ2IoKTtcbiAgICAgIHJldHVybiBuZXcgQ29sb3JfMShyZ2IuY29uY2F0KFt0aGlzLl9yZ2JbM11dKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UuYXBwbHkodm9pZCAwLCB0aGlzLl9yZ2Iuc2xpY2UoMCwgMykpO1xuICB9O1xuXG4gIHZhciByZ2IybHVtaW5hbmNlID0gZnVuY3Rpb24gcmdiMmx1bWluYW5jZShyLCBnLCBiKSB7XG4gICAgLy8gcmVsYXRpdmUgbHVtaW5hbmNlXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICByID0gbHVtaW5hbmNlX3gocik7XG4gICAgZyA9IGx1bWluYW5jZV94KGcpO1xuICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuICB9O1xuXG4gIHZhciBsdW1pbmFuY2VfeCA9IGZ1bmN0aW9uIGx1bWluYW5jZV94KHgpIHtcbiAgICB4IC89IDI1NTtcbiAgICByZXR1cm4geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogcG93JDIoKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcblxuICB2YXIgaW50ZXJwb2xhdG9yID0ge307XG4gIHZhciB0eXBlJGggPSB1dGlscy50eXBlO1xuXG4gIHZhciBtaXggPSBmdW5jdGlvbiBtaXgoY29sMSwgY29sMiwgZikge1xuICAgIGlmIChmID09PSB2b2lkIDApIGYgPSAwLjU7XG4gICAgdmFyIHJlc3QgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDM7XG5cbiAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICByZXN0W2xlbl0gPSBhcmd1bWVudHNbbGVuICsgM107XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSByZXN0WzBdIHx8ICdscmdiJztcblxuICAgIGlmICghaW50ZXJwb2xhdG9yW21vZGVdICYmICFyZXN0Lmxlbmd0aCkge1xuICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgbW9kZVxuICAgICAgbW9kZSA9IE9iamVjdC5rZXlzKGludGVycG9sYXRvcilbMF07XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVycG9sYXRpb24gbW9kZSBcIiArIG1vZGUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSRoKGNvbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29sMSA9IG5ldyBDb2xvcl8xKGNvbDEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlJGgoY29sMikgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb2wyID0gbmV3IENvbG9yXzEoY29sMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRvclttb2RlXShjb2wxLCBjb2wyLCBmKS5hbHBoYShjb2wxLmFscGhhKCkgKyBmICogKGNvbDIuYWxwaGEoKSAtIGNvbDEuYWxwaGEoKSkpO1xuICB9O1xuXG4gIENvbG9yXzEucHJvdG90eXBlLm1peCA9IENvbG9yXzEucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGNvbDIsIGYpIHtcbiAgICBpZiAoZiA9PT0gdm9pZCAwKSBmID0gMC41O1xuICAgIHZhciByZXN0ID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgcmVzdFtsZW5dID0gYXJndW1lbnRzW2xlbiArIDJdO1xuICAgIH1cblxuICAgIHJldHVybiBtaXguYXBwbHkodm9pZCAwLCBbdGhpcywgY29sMiwgZl0uY29uY2F0KHJlc3QpKTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uIChtdXRhdGUpIHtcbiAgICBpZiAobXV0YXRlID09PSB2b2lkIDApIG11dGF0ZSA9IGZhbHNlO1xuICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgdmFyIGEgPSByZ2JbM107XG5cbiAgICBpZiAobXV0YXRlKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBbcmdiWzBdICogYSwgcmdiWzFdICogYSwgcmdiWzJdICogYSwgYV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFtyZ2JbMF0gKiBhLCByZ2JbMV0gKiBhLCByZ2JbMl0gKiBhLCBhXSwgJ3JnYicpO1xuICAgIH1cbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIGFtb3VudCA9IDE7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbGNoID0gbWUubGNoKCk7XG4gICAgbGNoWzFdICs9IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcblxuICAgIGlmIChsY2hbMV0gPCAwKSB7XG4gICAgICBsY2hbMV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sb3JfMShsY2gsICdsY2gnKS5hbHBoYShtZS5hbHBoYSgpLCB0cnVlKTtcbiAgfTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkgYW1vdW50ID0gMTtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0ZSgtYW1vdW50KTtcbiAgfTtcblxuICB2YXIgdHlwZSRpID0gdXRpbHMudHlwZTtcblxuICBDb2xvcl8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobWMsIHZhbHVlLCBtdXRhdGUpIHtcbiAgICBpZiAobXV0YXRlID09PSB2b2lkIDApIG11dGF0ZSA9IGZhbHNlO1xuICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgIHZhciBtb2RlID0gcmVmWzBdO1xuICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG5cbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCk7XG5cbiAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgaWYgKHR5cGUkaSh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICBzcmNbaV0gKj0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBzcmNbaV0gLz0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNyY1tpXSA9ICt2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSRpKHZhbHVlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzcmNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB2YWx1ZSBmb3IgQ29sb3Iuc2V0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBDb2xvcl8xKHNyYywgbW9kZSk7XG5cbiAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3JnYiA9IG91dC5fcmdiO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGluIG1vZGUgXCIgKyBtb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJnYiQxID0gZnVuY3Rpb24gcmdiJDEoY29sMSwgY29sMiwgZikge1xuICAgIHZhciB4eXowID0gY29sMS5fcmdiO1xuICAgIHZhciB4eXoxID0gY29sMi5fcmdiO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMSh4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSwgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLCAncmdiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLnJnYiA9IHJnYiQxO1xuICB2YXIgc3FydCQyID0gTWF0aC5zcXJ0O1xuICB2YXIgcG93JDMgPSBNYXRoLnBvdztcblxuICB2YXIgbHJnYiA9IGZ1bmN0aW9uIGxyZ2IoY29sMSwgY29sMiwgZikge1xuICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgdmFyIHgxID0gcmVmWzBdO1xuICAgIHZhciB5MSA9IHJlZlsxXTtcbiAgICB2YXIgejEgPSByZWZbMl07XG4gICAgdmFyIHJlZiQxID0gY29sMi5fcmdiO1xuICAgIHZhciB4MiA9IHJlZiQxWzBdO1xuICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgIHZhciB6MiA9IHJlZiQxWzJdO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMShzcXJ0JDIocG93JDMoeDEsIDIpICogKDEgLSBmKSArIHBvdyQzKHgyLCAyKSAqIGYpLCBzcXJ0JDIocG93JDMoeTEsIDIpICogKDEgLSBmKSArIHBvdyQzKHkyLCAyKSAqIGYpLCBzcXJ0JDIocG93JDMoejEsIDIpICogKDEgLSBmKSArIHBvdyQzKHoyLCAyKSAqIGYpLCAncmdiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLmxyZ2IgPSBscmdiO1xuXG4gIHZhciBsYWIkMSA9IGZ1bmN0aW9uIGxhYiQxKGNvbDEsIGNvbDIsIGYpIHtcbiAgICB2YXIgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgdmFyIHh5ejEgPSBjb2wyLmxhYigpO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMSh4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSwgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLCAnbGFiJyk7XG4gIH07IC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuXG5cbiAgaW50ZXJwb2xhdG9yLmxhYiA9IGxhYiQxO1xuXG4gIHZhciBfaHN4ID0gZnVuY3Rpb24gX2hzeChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG4gICAgdmFyIHh5ejAsIHh5ejE7XG5cbiAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnaHN2Jykge1xuICAgICAgeHl6MCA9IGNvbDEuaHN2KCk7XG4gICAgICB4eXoxID0gY29sMi5oc3YoKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdoY2cnKSB7XG4gICAgICB4eXowID0gY29sMS5oY2coKTtcbiAgICAgIHh5ejEgPSBjb2wyLmhjZygpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnbGNoJyB8fCBtID09PSAnaGNsJykge1xuICAgICAgbSA9ICdoY2wnO1xuICAgICAgeHl6MCA9IGNvbDEuaGNsKCk7XG4gICAgICB4eXoxID0gY29sMi5oY2woKTtcbiAgICB9XG5cbiAgICB2YXIgaHVlMCwgaHVlMSwgc2F0MCwgc2F0MSwgbGJ2MCwgbGJ2MTtcblxuICAgIGlmIChtLnN1YnN0cigwLCAxKSA9PT0gJ2gnKSB7XG4gICAgICBhc3NpZ24gPSB4eXowLCBodWUwID0gYXNzaWduWzBdLCBzYXQwID0gYXNzaWduWzFdLCBsYnYwID0gYXNzaWduWzJdO1xuICAgICAgYXNzaWduJDEgPSB4eXoxLCBodWUxID0gYXNzaWduJDFbMF0sIHNhdDEgPSBhc3NpZ24kMVsxXSwgbGJ2MSA9IGFzc2lnbiQxWzJdO1xuICAgIH1cblxuICAgIHZhciBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgIGlmICghaXNOYU4oaHVlMCkgJiYgIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAvLyBib3RoIGNvbG9ycyBoYXZlIGh1ZVxuICAgICAgaWYgKGh1ZTEgPiBodWUwICYmIGh1ZTEgLSBodWUwID4gMTgwKSB7XG4gICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgIH0gZWxzZSBpZiAoaHVlMSA8IGh1ZTAgJiYgaHVlMCAtIGh1ZTEgPiAxODApIHtcbiAgICAgICAgZGggPSBodWUxICsgMzYwIC0gaHVlMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRoID0gaHVlMSAtIGh1ZTA7XG4gICAgICB9XG5cbiAgICAgIGh1ZSA9IGh1ZTAgKyBmICogZGg7XG4gICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMCkpIHtcbiAgICAgIGh1ZSA9IGh1ZTA7XG5cbiAgICAgIGlmICgobGJ2MSA9PSAxIHx8IGxidjEgPT0gMCkgJiYgbSAhPSAnaHN2Jykge1xuICAgICAgICBzYXQgPSBzYXQwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTEpKSB7XG4gICAgICBodWUgPSBodWUxO1xuXG4gICAgICBpZiAoKGxidjAgPT0gMSB8fCBsYnYwID09IDApICYmIG0gIT0gJ2hzdicpIHtcbiAgICAgICAgc2F0ID0gc2F0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaHVlID0gTnVtYmVyLk5hTjtcbiAgICB9XG5cbiAgICBpZiAoc2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTtcbiAgICB9XG5cbiAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgcmV0dXJuIG5ldyBDb2xvcl8xKFtodWUsIHNhdCwgbGJ2XSwgbSk7XG4gIH07XG5cbiAgdmFyIGxjaCQxID0gZnVuY3Rpb24gbGNoJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdsY2gnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IubGNoID0gbGNoJDE7XG4gIGludGVycG9sYXRvci5oY2wgPSBsY2gkMTtcblxuICB2YXIgbnVtJDEgPSBmdW5jdGlvbiBudW0kMShjb2wxLCBjb2wyLCBmKSB7XG4gICAgdmFyIGMxID0gY29sMS5udW0oKTtcbiAgICB2YXIgYzIgPSBjb2wyLm51bSgpO1xuICAgIHJldHVybiBuZXcgQ29sb3JfMShjMSArIGYgKiAoYzIgLSBjMSksICdudW0nKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IubnVtID0gbnVtJDE7XG5cbiAgdmFyIGhjZyQxID0gZnVuY3Rpb24gaGNnJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoY2cnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaGNnID0gaGNnJDE7XG5cbiAgdmFyIGhzaSQxID0gZnVuY3Rpb24gaHNpJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2knKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHNpID0gaHNpJDE7XG5cbiAgdmFyIGhzbCQxID0gZnVuY3Rpb24gaHNsJDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2wnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHNsID0gaHNsJDE7XG5cbiAgdmFyIGhzdiQxID0gZnVuY3Rpb24gaHN2JDEoY29sMSwgY29sMiwgZikge1xuICAgIHJldHVybiBfaHN4KGNvbDEsIGNvbDIsIGYsICdoc3YnKTtcbiAgfTsgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5cblxuICBpbnRlcnBvbGF0b3IuaHN2ID0gaHN2JDE7XG4gIHZhciBjbGlwX3JnYiQyID0gdXRpbHMuY2xpcF9yZ2I7XG4gIHZhciBwb3ckNCA9IE1hdGgucG93O1xuICB2YXIgc3FydCQzID0gTWF0aC5zcXJ0O1xuICB2YXIgUEkkMSA9IE1hdGguUEk7XG4gIHZhciBjb3MkMiA9IE1hdGguY29zO1xuICB2YXIgc2luJDEgPSBNYXRoLnNpbjtcbiAgdmFyIGF0YW4yJDEgPSBNYXRoLmF0YW4yO1xuXG4gIHZhciBhdmVyYWdlID0gZnVuY3Rpb24gYXZlcmFnZShjb2xvcnMsIG1vZGUsIHdlaWdodHMpIHtcbiAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSBtb2RlID0gJ2xyZ2InO1xuICAgIGlmICh3ZWlnaHRzID09PSB2b2lkIDApIHdlaWdodHMgPSBudWxsO1xuICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGlmICghd2VpZ2h0cykge1xuICAgICAgd2VpZ2h0cyA9IEFycmF5LmZyb20obmV3IEFycmF5KGwpKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuICAgIH0gLy8gbm9ybWFsaXplIHdlaWdodHNcblxuXG4gICAgdmFyIGsgPSBsIC8gd2VpZ2h0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9KTtcbiAgICB3ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHcsIGkpIHtcbiAgICAgIHdlaWdodHNbaV0gKj0gaztcbiAgICB9KTsgLy8gY29udmVydCBjb2xvcnMgdG8gQ29sb3Igb2JqZWN0c1xuXG4gICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKGMpO1xuICAgIH0pO1xuXG4gICAgaWYgKG1vZGUgPT09ICdscmdiJykge1xuICAgICAgcmV0dXJuIF9hdmVyYWdlX2xyZ2IoY29sb3JzLCB3ZWlnaHRzKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3QgPSBjb2xvcnMuc2hpZnQoKTtcbiAgICB2YXIgeHl6ID0gZmlyc3QuZ2V0KG1vZGUpO1xuICAgIHZhciBjbnQgPSBbXTtcbiAgICB2YXIgZHggPSAwO1xuICAgIHZhciBkeSA9IDA7IC8vIGluaXRpYWwgY29sb3JcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG5cbiAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnICYmICFpc05hTih4eXpbaV0pKSB7XG4gICAgICAgIHZhciBBID0geHl6W2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICBkeSArPSBzaW4kMShBKSAqIHdlaWdodHNbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGMsIGNpKSB7XG4gICAgICB2YXIgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSArIDFdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgY250W2ldICs9IHdlaWdodHNbY2kgKyAxXTtcblxuICAgICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnKSB7XG4gICAgICAgICAgICB2YXIgQSA9IHh5ejJbaV0gLyAxODAgKiBQSSQxO1xuICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgICBkeSArPSBzaW4kMShBKSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHl6W2ldICs9IHh5ejJbaV0gKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICB2YXIgQSQxID0gYXRhbjIkMShkeSAvIGNudFtpJDFdLCBkeCAvIGNudFtpJDFdKSAvIFBJJDEgKiAxODA7XG5cbiAgICAgICAgd2hpbGUgKEEkMSA8IDApIHtcbiAgICAgICAgICBBJDEgKz0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKEEkMSA+PSAzNjApIHtcbiAgICAgICAgICBBJDEgLT0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgeHl6W2kkMV0gPSBBJDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4eXpbaSQxXSA9IHh5eltpJDFdIC8gY250W2kkMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWxwaGEgLz0gbDtcbiAgICByZXR1cm4gbmV3IENvbG9yXzEoeHl6LCBtb2RlKS5hbHBoYShhbHBoYSA+IDAuOTk5OTkgPyAxIDogYWxwaGEsIHRydWUpO1xuICB9O1xuXG4gIHZhciBfYXZlcmFnZV9scmdiID0gZnVuY3Rpb24gX2F2ZXJhZ2VfbHJnYihjb2xvcnMsIHdlaWdodHMpIHtcbiAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgdmFyIHh5eiA9IFswLCAwLCAwLCAwXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29sID0gY29sb3JzW2ldO1xuICAgICAgdmFyIGYgPSB3ZWlnaHRzW2ldIC8gbDtcbiAgICAgIHZhciByZ2IgPSBjb2wuX3JnYjtcbiAgICAgIHh5elswXSArPSBwb3ckNChyZ2JbMF0sIDIpICogZjtcbiAgICAgIHh5elsxXSArPSBwb3ckNChyZ2JbMV0sIDIpICogZjtcbiAgICAgIHh5elsyXSArPSBwb3ckNChyZ2JbMl0sIDIpICogZjtcbiAgICAgIHh5elszXSArPSByZ2JbM10gKiBmO1xuICAgIH1cblxuICAgIHh5elswXSA9IHNxcnQkMyh4eXpbMF0pO1xuICAgIHh5elsxXSA9IHNxcnQkMyh4eXpbMV0pO1xuICAgIHh5elsyXSA9IHNxcnQkMyh4eXpbMl0pO1xuXG4gICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkge1xuICAgICAgeHl6WzNdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbG9yXzEoY2xpcF9yZ2IkMih4eXopKTtcbiAgfTsgLy8gbWluaW1hbCBtdWx0aS1wdXJwb3NlIGludGVyZmFjZVxuICAvLyBAcmVxdWlyZXMgdXRpbHMgY29sb3IgYW5hbHl6ZVxuXG5cbiAgdmFyIHR5cGUkaiA9IHV0aWxzLnR5cGU7XG4gIHZhciBwb3ckNSA9IE1hdGgucG93O1xuXG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKGNvbG9ycykge1xuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgdmFyIF9tb2RlID0gJ3JnYic7XG5cbiAgICB2YXIgX25hY29sID0gY2hyb21hXzEoJyNjY2MnKTtcblxuICAgIHZhciBfc3ByZWFkID0gMDsgLy8gY29uc3QgX2ZpeGVkID0gZmFsc2U7XG5cbiAgICB2YXIgX2RvbWFpbiA9IFswLCAxXTtcbiAgICB2YXIgX3BvcyA9IFtdO1xuICAgIHZhciBfcGFkZGluZyA9IFswLCAwXTtcbiAgICB2YXIgX2NsYXNzZXMgPSBmYWxzZTtcbiAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgIHZhciBfb3V0ID0gZmFsc2U7XG4gICAgdmFyIF9taW4gPSAwO1xuICAgIHZhciBfbWF4ID0gMTtcbiAgICB2YXIgX2NvcnJlY3RMaWdodG5lc3MgPSBmYWxzZTtcbiAgICB2YXIgX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICB2YXIgX2dhbW1hID0gMTsgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICB2YXIgc2V0Q29sb3JzID0gZnVuY3Rpb24gc2V0Q29sb3JzKGNvbG9ycykge1xuICAgICAgY29sb3JzID0gY29sb3JzIHx8IFsnI2ZmZicsICcjMDAwJ107XG5cbiAgICAgIGlmIChjb2xvcnMgJiYgdHlwZSRqKGNvbG9ycykgPT09ICdzdHJpbmcnICYmIGNocm9tYV8xLmJyZXdlciAmJiBjaHJvbWFfMS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIGNvbG9ycyA9IGNocm9tYV8xLmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlJGooY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAvLyBoYW5kbGUgc2luZ2xlIGNvbG9yXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29sb3JzID0gW2NvbG9yc1swXSwgY29sb3JzWzBdXTtcbiAgICAgICAgfSAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG5cblxuICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCk7IC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbG9ycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGNvbG9yc1tjXSA9IGNocm9tYV8xKGNvbG9yc1tjXSk7XG4gICAgICAgIH0gLy8gYXV0by1maWxsIGNvbG9yIHBvc2l0aW9uXG5cblxuICAgICAgICBfcG9zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgYyQxID0gMDsgYyQxIDwgY29sb3JzLmxlbmd0aDsgYyQxKyspIHtcbiAgICAgICAgICBfcG9zLnB1c2goYyQxIC8gKGNvbG9ycy5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgcmV0dXJuIF9jb2xvcnMgPSBjb2xvcnM7XG4gICAgfTtcblxuICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzKHZhbHVlKSB7XG4gICAgICBpZiAoX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IF9jbGFzc2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAoaSA8IG4gJiYgdmFsdWUgPj0gX2NsYXNzZXNbaV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICB2YXIgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHZhciB0TWFwRG9tYWluID0gZnVuY3Rpb24gdE1hcERvbWFpbih0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9OyAvLyBjb25zdCBjbGFzc2lmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgIC8vICAgICBpZiAoX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgIC8vICAgICAgICAgY29uc3QgbiA9IF9jbGFzc2VzLmxlbmd0aC0xO1xuICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAvLyAgICAgICAgIGNvbnN0IG1pbmMgPSBfY2xhc3Nlc1swXSArICgoX2NsYXNzZXNbMV0tX2NsYXNzZXNbMF0pICogKDAgKyAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiAxc3QgY2xhc3NcbiAgICAvLyAgICAgICAgIGNvbnN0IG1heGMgPSBfY2xhc3Nlc1tuLTFdICsgKChfY2xhc3Nlc1tuXS1fY2xhc3Nlc1tuLTFdKSAqICgxIC0gKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgbGFzdCBjbGFzc1xuICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gdmFsO1xuICAgIC8vIH07XG5cblxuICAgIHZhciBnZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yKHZhbCwgYnlwYXNzTWFwKSB7XG4gICAgICB2YXIgY29sLCB0O1xuXG4gICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHtcbiAgICAgICAgYnlwYXNzTWFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICBpZiAoX2NsYXNzZXMgJiYgX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgIC8vIGZpbmQgdGhlIGNsYXNzXG4gICAgICAgICAgdmFyIGMgPSBnZXRDbGFzcyh2YWwpO1xuICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKF9tYXggIT09IF9taW4pIHtcbiAgICAgICAgICAvLyBqdXN0IGludGVycG9sYXRlIGJldHdlZW4gbWluL21heFxuICAgICAgICAgIHQgPSAodmFsIC0gX21pbikgLyAoX21heCAtIF9taW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdmFsO1xuICAgICAgfSAvLyBkb21haW4gbWFwXG5cblxuICAgICAgdCA9IHRNYXBEb21haW4odCk7XG5cbiAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgIHQgPSB0TWFwTGlnaHRuZXNzKHQpOyAvLyBsaWdodG5lc3MgY29ycmVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAoX2dhbW1hICE9PSAxKSB7XG4gICAgICAgIHQgPSBwb3ckNSh0LCBfZ2FtbWEpO1xuICAgICAgfVxuXG4gICAgICB0ID0gX3BhZGRpbmdbMF0gKyB0ICogKDEgLSBfcGFkZGluZ1swXSAtIF9wYWRkaW5nWzFdKTtcbiAgICAgIHQgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB0KSk7XG4gICAgICB2YXIgayA9IE1hdGguZmxvb3IodCAqIDEwMDAwKTtcblxuICAgICAgaWYgKF91c2VDYWNoZSAmJiBfY29sb3JDYWNoZVtrXSkge1xuICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlJGooX2NvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBfcG9zW2ldO1xuXG4gICAgICAgICAgICBpZiAodCA8PSBwKSB7XG4gICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodCA+PSBwICYmIGkgPT09IF9wb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2kgKyAxXSkge1xuICAgICAgICAgICAgICB0ID0gKHQgLSBwKSAvIChfcG9zW2kgKyAxXSAtIHApO1xuICAgICAgICAgICAgICBjb2wgPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZShfY29sb3JzW2ldLCBfY29sb3JzW2kgKyAxXSwgdCwgX21vZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSRqKF9jb2xvcnMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29sID0gX2NvbG9ycyh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdXNlQ2FjaGUpIHtcbiAgICAgICAgICBfY29sb3JDYWNoZVtrXSA9IGNvbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH07XG5cbiAgICB2YXIgcmVzZXRDYWNoZSA9IGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgICByZXR1cm4gX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICB9O1xuXG4gICAgc2V0Q29sb3JzKGNvbG9ycyk7IC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgIHZhciBmID0gZnVuY3Rpb24gZih2KSB7XG4gICAgICB2YXIgYyA9IGNocm9tYV8xKGdldENvbG9yKHYpKTtcblxuICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkge1xuICAgICAgICByZXR1cm4gY1tfb3V0XSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICBpZiAoY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlJGooY2xhc3NlcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICBfY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkID0gY2hyb21hXzEuYW5hbHl6ZShfZG9tYWluKTtcblxuICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY2xhc3NlcyA9IGNocm9tYV8xLmxpbWl0cyhkLCAnZScsIGNsYXNzZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2NsYXNzZXM7XG4gICAgfTtcblxuICAgIGYuZG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfZG9tYWluO1xuICAgICAgfVxuXG4gICAgICBfbWluID0gZG9tYWluWzBdO1xuICAgICAgX21heCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgICBfcG9zID0gW107XG4gICAgICB2YXIgayA9IF9jb2xvcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gayAmJiBfbWluICE9PSBfbWF4KSB7XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBBcnJheS5mcm9tKGRvbWFpbik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIGQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgX3Bvcy5wdXNoKChkIC0gX21pbikgLyAoX21heCAtIF9taW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBrOyBjKyspIHtcbiAgICAgICAgICBfcG9zLnB1c2goYyAvIChrIC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbi5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgLy8gc2V0IGRvbWFpbiBtYXBcbiAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC8gKGRvbWFpbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdEJyZWFrcyA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoZCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdEJyZWFrcy5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gdE91dFtpXSA9PT0gdmFsO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0TWFwRG9tYWluID0gZnVuY3Rpb24gdE1hcERvbWFpbih0KSB7XG4gICAgICAgICAgICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZiA9ICh0IC0gdEJyZWFrc1tpXSkgLyAodEJyZWFrc1tpICsgMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgdmFyIG91dCA9IHRPdXRbaV0gKyBmICogKHRPdXRbaSArIDFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZG9tYWluID0gW19taW4sIF9tYXhdO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYubW9kZSA9IGZ1bmN0aW9uIChfbSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgIH1cblxuICAgICAgX21vZGUgPSBfbTtcbiAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnJhbmdlID0gZnVuY3Rpb24gKGNvbG9ycywgX3Bvcykge1xuICAgICAgc2V0Q29sb3JzKGNvbG9ycywgX3Bvcyk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5vdXQgPSBmdW5jdGlvbiAoX28pIHtcbiAgICAgIF9vdXQgPSBfbztcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnNwcmVhZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX3NwcmVhZDtcbiAgICAgIH1cblxuICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmNvcnJlY3RMaWdodG5lc3MgPSBmdW5jdGlvbiAodikge1xuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX2NvcnJlY3RMaWdodG5lc3MgPSB2O1xuICAgICAgcmVzZXRDYWNoZSgpO1xuXG4gICAgICBpZiAoX2NvcnJlY3RMaWdodG5lc3MpIHtcbiAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBMMSA9IGdldENvbG9yKDEsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBwb2wgPSBMMCA+IEwxO1xuICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgIHZhciBMX2lkZWFsID0gTDAgKyAoTDEgLSBMMCkgKiB0O1xuICAgICAgICAgIHZhciBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgdmFyIHQwID0gMDtcbiAgICAgICAgICB2YXIgdDEgPSAxO1xuICAgICAgICAgIHZhciBtYXhfaXRlciA9IDIwO1xuXG4gICAgICAgICAgd2hpbGUgKE1hdGguYWJzKExfZGlmZikgPiAxZS0yICYmIG1heF9pdGVyLS0gPiAwKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAocG9sKSB7XG4gICAgICAgICAgICAgICAgTF9kaWZmICo9IC0xO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICB0MCA9IHQ7XG4gICAgICAgICAgICAgICAgdCArPSAodDEgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MSA9IHQ7XG4gICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIExfYWN0dWFsID0gZ2V0Q29sb3IodCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgIHJldHVybiBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uIHRNYXBMaWdodG5lc3ModCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5wYWRkaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUkaihwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwID0gW3AsIHBdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhZGRpbmcgPSBwO1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5jb2xvcnMgPSBmdW5jdGlvbiAobnVtQ29sb3JzLCBvdXQpIHtcbiAgICAgIC8vIElmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW4sIHJldHVybiB0aGUgb3JpZ2luYWwgY29sb3JzIHRoYXQgd2VyZSBwcm92aWRlZFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIG91dCA9ICdoZXgnO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG4gICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA9PT0gMSkge1xuICAgICAgICByZXN1bHQgPSBbZigwLjUpXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICB2YXIgZG0gPSBfZG9tYWluWzBdO1xuICAgICAgICB2YXIgZGQgPSBfZG9tYWluWzFdIC0gZG07XG4gICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMsIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gZihkbSArIGkgLyAobnVtQ29sb3JzIC0gMSkgKiBkZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV0dXJucyBhbGwgY29sb3JzIGJhc2VkIG9uIHRoZSBkZWZpbmVkIGNsYXNzZXNcbiAgICAgICAgY29sb3JzID0gW107XG4gICAgICAgIHZhciBzYW1wbGVzID0gW107XG5cbiAgICAgICAgaWYgKF9jbGFzc2VzICYmIF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDsgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xuICAgICAgICAgICAgc2FtcGxlcy5wdXNoKChfY2xhc3Nlc1tpIC0gMV0gKyBfY2xhc3Nlc1tpXSkgKiAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1wbGVzID0gX2RvbWFpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGYodik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hyb21hXzFbb3V0XSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGNbb3V0XSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZi5jYWNoZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIF91c2VDYWNoZSA9IGM7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5nYW1tYSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nYW1tYTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5ub2RhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICBfbmFjb2wgPSBjaHJvbWFfMShkKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICBmdW5jdGlvbiBfX3JhbmdlX18obGVmdCwgcmlnaHQsIGluY2x1c2l2ZSkge1xuICAgIHZhciByYW5nZSA9IFtdO1xuICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgdmFyIGVuZCA9ICFpbmNsdXNpdmUgPyByaWdodCA6IGFzY2VuZGluZyA/IHJpZ2h0ICsgMSA6IHJpZ2h0IC0gMTtcblxuICAgIGZvciAodmFyIGkgPSBsZWZ0OyBhc2NlbmRpbmcgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjZW5kaW5nID8gaSsrIDogaS0tKSB7XG4gICAgICByYW5nZS5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfSAvL1xuICAvLyBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4gIC8vXG4gIC8vIEByZXF1aXJlcyB1dGlscyBsYWJcblxuXG4gIHZhciBiZXppZXIgPSBmdW5jdGlvbiBiZXppZXIoY29sb3JzKSB7XG4gICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyO1xuICAgIHZhciBJLCBsYWIwLCBsYWIxLCBsYWIyO1xuICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sb3JfMShjKTtcbiAgICB9KTtcblxuICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgYXNzaWduID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5sYWIoKTtcbiAgICAgIH0pLCBsYWIwID0gYXNzaWduWzBdLCBsYWIxID0gYXNzaWduWzFdO1xuXG4gICAgICBJID0gZnVuY3Rpb24gSSh0KSB7XG4gICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYjBbaV0gKyB0ICogKGxhYjFbaV0gLSBsYWIwW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShsYWIsICdsYWInKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBxdWFkcmF0aWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgIGFzc2lnbiQxID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5sYWIoKTtcbiAgICAgIH0pLCBsYWIwID0gYXNzaWduJDFbMF0sIGxhYjEgPSBhc3NpZ24kMVsxXSwgbGFiMiA9IGFzc2lnbiQxWzJdO1xuXG4gICAgICBJID0gZnVuY3Rpb24gSSh0KSB7XG4gICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogbGFiMFtpXSArIDIgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gKyB0ICogdCAqIGxhYjJbaV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgIHZhciBsYWIzO1xuICAgICAgYXNzaWduJDIgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLmxhYigpO1xuICAgICAgfSksIGxhYjAgPSBhc3NpZ24kMlswXSwgbGFiMSA9IGFzc2lnbiQyWzFdLCBsYWIyID0gYXNzaWduJDJbMl0sIGxhYjMgPSBhc3NpZ24kMlszXTtcblxuICAgICAgSSA9IGZ1bmN0aW9uIEkodCkge1xuICAgICAgICB2YXIgbGFiID0gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgKiBsYWIwW2ldICsgMyAqICgxIC0gdCkgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gKyAzICogKDEgLSB0KSAqIHQgKiB0ICogbGFiMltpXSArIHQgKiB0ICogdCAqIGxhYjNbaV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdmFyIEkwID0gYmV6aWVyKGNvbG9ycy5zbGljZSgwLCAzKSk7XG4gICAgICB2YXIgSTEgPSBiZXppZXIoY29sb3JzLnNsaWNlKDIsIDUpKTtcblxuICAgICAgSSA9IGZ1bmN0aW9uIEkodCkge1xuICAgICAgICBpZiAodCA8IDAuNSkge1xuICAgICAgICAgIHJldHVybiBJMCh0ICogMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEkxKCh0IC0gMC41KSAqIDIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBJO1xuICB9O1xuXG4gIHZhciBiZXppZXJfMSA9IGZ1bmN0aW9uIGJlemllcl8xKGNvbG9ycykge1xuICAgIHZhciBmID0gYmV6aWVyKGNvbG9ycyk7XG5cbiAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNjYWxlKGYpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfTtcbiAgLypcbiAgICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgKiBibGVuZCBtb2RlIGZvcm11bGFzIHRha2VuIGZyb20gaHR0cDovL3d3dy52ZW50dXJlLXdhcmUuY29tL2tldmluL2NvZGluZy9sZXRzLWxlYXJuLW1hdGgtcGhvdG9zaG9wLWJsZW5kLW1vZGVzL1xuICAgKi9cblxuXG4gIHZhciBibGVuZCA9IGZ1bmN0aW9uIGJsZW5kKGJvdHRvbSwgdG9wLCBtb2RlKSB7XG4gICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gIH07XG5cbiAgdmFyIGJsZW5kX2YgPSBmdW5jdGlvbiBibGVuZF9mKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJvdHRvbSwgdG9wKSB7XG4gICAgICB2YXIgYzAgPSBjaHJvbWFfMSh0b3ApLnJnYigpO1xuICAgICAgdmFyIGMxID0gY2hyb21hXzEoYm90dG9tKS5yZ2IoKTtcbiAgICAgIHJldHVybiBjaHJvbWFfMS5yZ2IoZihjMCwgYzEpKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBlYWNoID0gZnVuY3Rpb24gZWFjaChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgIG91dFsyXSA9IGYoYzBbMl0sIGMxWzJdKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gbm9ybWFsKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICB2YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiIC8gMjU1O1xuICB9O1xuXG4gIHZhciBkYXJrZW4kMSA9IGZ1bmN0aW9uIGRhcmtlbiQxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyBiIDogYTtcbiAgfTtcblxuICB2YXIgbGlnaHRlbiA9IGZ1bmN0aW9uIGxpZ2h0ZW4oYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IGEgOiBiO1xuICB9O1xuXG4gIHZhciBzY3JlZW4gPSBmdW5jdGlvbiBzY3JlZW4oYSwgYikge1xuICAgIHJldHVybiAyNTUgKiAoMSAtICgxIC0gYSAvIDI1NSkgKiAoMSAtIGIgLyAyNTUpKTtcbiAgfTtcblxuICB2YXIgb3ZlcmxheSA9IGZ1bmN0aW9uIG92ZXJsYXkoYSwgYikge1xuICAgIHJldHVybiBiIDwgMTI4ID8gMiAqIGEgKiBiIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1KSAqICgxIC0gYiAvIDI1NSkpO1xuICB9O1xuXG4gIHZhciBidXJuID0gZnVuY3Rpb24gYnVybihhLCBiKSB7XG4gICAgcmV0dXJuIDI1NSAqICgxIC0gKDEgLSBiIC8gMjU1KSAvIChhIC8gMjU1KSk7XG4gIH07XG5cbiAgdmFyIGRvZGdlID0gZnVuY3Rpb24gZG9kZ2UoYSwgYikge1xuICAgIGlmIChhID09PSAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuXG4gICAgYSA9IDI1NSAqIChiIC8gMjU1KSAvICgxIC0gYSAvIDI1NSk7XG4gICAgcmV0dXJuIGEgPiAyNTUgPyAyNTUgOiBhO1xuICB9OyAvLyAjIGFkZCA9IChhLGIpIC0+XG4gIC8vICMgICAgIGlmIChhICsgYiA+IDI1NSkgdGhlbiAyNTUgZWxzZSBhICsgYlxuXG5cbiAgYmxlbmQubm9ybWFsID0gYmxlbmRfZihlYWNoKG5vcm1hbCkpO1xuICBibGVuZC5tdWx0aXBseSA9IGJsZW5kX2YoZWFjaChtdWx0aXBseSkpO1xuICBibGVuZC5zY3JlZW4gPSBibGVuZF9mKGVhY2goc2NyZWVuKSk7XG4gIGJsZW5kLm92ZXJsYXkgPSBibGVuZF9mKGVhY2gob3ZlcmxheSkpO1xuICBibGVuZC5kYXJrZW4gPSBibGVuZF9mKGVhY2goZGFya2VuJDEpKTtcbiAgYmxlbmQubGlnaHRlbiA9IGJsZW5kX2YoZWFjaChsaWdodGVuKSk7XG4gIGJsZW5kLmRvZGdlID0gYmxlbmRfZihlYWNoKGRvZGdlKSk7XG4gIGJsZW5kLmJ1cm4gPSBibGVuZF9mKGVhY2goYnVybikpOyAvLyBibGVuZC5hZGQgPSBibGVuZF9mKGVhY2goYWRkKSk7XG5cbiAgdmFyIGJsZW5kXzEgPSBibGVuZDsgLy8gY3ViZWhlbGl4IGludGVycG9sYXRpb25cbiAgLy8gYmFzZWQgb24gRC5BLiBHcmVlbiBcIkEgY29sb3VyIHNjaGVtZSBmb3IgdGhlIGRpc3BsYXkgb2YgYXN0cm9ub21pY2FsIGludGVuc2l0eSBpbWFnZXNcIlxuICAvLyBodHRwOi8vYXN0cm9uLXNvYy5pbi9idWxsZXRpbi8xMUp1bmUvMjg5MzkyMDExLnBkZlxuXG4gIHZhciB0eXBlJGsgPSB1dGlscy50eXBlO1xuICB2YXIgY2xpcF9yZ2IkMyA9IHV0aWxzLmNsaXBfcmdiO1xuICB2YXIgVFdPUEkkMiA9IHV0aWxzLlRXT1BJO1xuICB2YXIgcG93JDYgPSBNYXRoLnBvdztcbiAgdmFyIHNpbiQyID0gTWF0aC5zaW47XG4gIHZhciBjb3MkMyA9IE1hdGguY29zO1xuXG4gIHZhciBjdWJlaGVsaXggPSBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIHJvdGF0aW9ucywgaHVlLCBnYW1tYSwgbGlnaHRuZXNzKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHN0YXJ0ID0gMzAwO1xuICAgIGlmIChyb3RhdGlvbnMgPT09IHZvaWQgMCkgcm90YXRpb25zID0gLTEuNTtcbiAgICBpZiAoaHVlID09PSB2b2lkIDApIGh1ZSA9IDE7XG4gICAgaWYgKGdhbW1hID09PSB2b2lkIDApIGdhbW1hID0gMTtcbiAgICBpZiAobGlnaHRuZXNzID09PSB2b2lkIDApIGxpZ2h0bmVzcyA9IFswLCAxXTtcbiAgICB2YXIgZGggPSAwLFxuICAgICAgICBkbDtcblxuICAgIGlmICh0eXBlJGsobGlnaHRuZXNzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgZGwgPSBsaWdodG5lc3NbMV0gLSBsaWdodG5lc3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRsID0gMDtcbiAgICAgIGxpZ2h0bmVzcyA9IFtsaWdodG5lc3MsIGxpZ2h0bmVzc107XG4gICAgfVxuXG4gICAgdmFyIGYgPSBmdW5jdGlvbiBmKGZyYWN0KSB7XG4gICAgICB2YXIgYSA9IFRXT1BJJDIgKiAoKHN0YXJ0ICsgMTIwKSAvIDM2MCArIHJvdGF0aW9ucyAqIGZyYWN0KTtcbiAgICAgIHZhciBsID0gcG93JDYobGlnaHRuZXNzWzBdICsgZGwgKiBmcmFjdCwgZ2FtbWEpO1xuICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIGZyYWN0ICogZGggOiBodWU7XG4gICAgICB2YXIgYW1wID0gaCAqIGwgKiAoMSAtIGwpIC8gMjtcbiAgICAgIHZhciBjb3NfYSA9IGNvcyQzKGEpO1xuICAgICAgdmFyIHNpbl9hID0gc2luJDIoYSk7XG4gICAgICB2YXIgciA9IGwgKyBhbXAgKiAoLTAuMTQ4NjEgKiBjb3NfYSArIDEuNzgyNzcgKiBzaW5fYSk7XG4gICAgICB2YXIgZyA9IGwgKyBhbXAgKiAoLTAuMjkyMjcgKiBjb3NfYSAtIDAuOTA2NDkgKiBzaW5fYSk7XG4gICAgICB2YXIgYiA9IGwgKyBhbXAgKiAoKzEuOTcyOTQgKiBjb3NfYSk7XG4gICAgICByZXR1cm4gY2hyb21hXzEoY2xpcF9yZ2IkMyhbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgMV0pKTtcbiAgICB9O1xuXG4gICAgZi5zdGFydCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBzO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYucm90YXRpb25zID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9ucztcbiAgICAgIH1cblxuICAgICAgcm90YXRpb25zID0gcjtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmdhbW1hID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgIGlmIChnID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdhbW1hO1xuICAgICAgfVxuXG4gICAgICBnYW1tYSA9IGc7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5odWUgPSBmdW5jdGlvbiAoaCkge1xuICAgICAgaWYgKGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaHVlO1xuICAgICAgfVxuXG4gICAgICBodWUgPSBoO1xuXG4gICAgICBpZiAodHlwZSRrKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgZGggPSBodWVbMV0gLSBodWVbMF07XG5cbiAgICAgICAgaWYgKGRoID09PSAwKSB7XG4gICAgICAgICAgaHVlID0gaHVlWzFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmxpZ2h0bmVzcyA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICBpZiAoaCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaWdodG5lc3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlJGsoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgbGlnaHRuZXNzID0gaDtcbiAgICAgICAgZGwgPSBoWzFdIC0gaFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpZ2h0bmVzcyA9IFtoLCBoXTtcbiAgICAgICAgZGwgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjaHJvbWFfMS5zY2FsZShmKTtcbiAgICB9O1xuXG4gICAgZi5odWUoaHVlKTtcbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICB2YXIgZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICB2YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG4gIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICB2YXIgcmFuZG9tXzEgPSBmdW5jdGlvbiByYW5kb21fMSgpIHtcbiAgICB2YXIgY29kZSA9ICcjJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb2RlICs9IGRpZ2l0cy5jaGFyQXQoZmxvb3IkMihyYW5kb20oKSAqIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xvcl8xKGNvZGUsICdoZXgnKTtcbiAgfTtcblxuICB2YXIgbG9nJDEgPSBNYXRoLmxvZztcbiAgdmFyIHBvdyQ3ID0gTWF0aC5wb3c7XG4gIHZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gIHZhciBhbmFseXplID0gZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSB2b2lkIDApIGtleSA9IG51bGw7XG4gICAgdmFyIHIgPSB7XG4gICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICBtYXg6IE51bWJlci5NQVhfVkFMVUUgKiAtMSxcbiAgICAgIHN1bTogMCxcbiAgICAgIHZhbHVlczogW10sXG4gICAgICBjb3VudDogMFxuICAgIH07XG5cbiAgICBpZiAodHlwZShkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKGRhdGEpO1xuICAgIH1cblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAoa2V5ICYmIHR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsID0gdmFsW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgci52YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICByLnN1bSArPSB2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA8IHIubWluKSB7XG4gICAgICAgICAgci5taW4gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID4gci5tYXgpIHtcbiAgICAgICAgICByLm1heCA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuY291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgci5saW1pdHMgPSBmdW5jdGlvbiAobW9kZSwgbnVtKSB7XG4gICAgICByZXR1cm4gbGltaXRzKHIsIG1vZGUsIG51bSk7XG4gICAgfTtcblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIHZhciBsaW1pdHMgPSBmdW5jdGlvbiBsaW1pdHMoZGF0YSwgbW9kZSwgbnVtKSB7XG4gICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgbW9kZSA9ICdlcXVhbCc7XG4gICAgaWYgKG51bSA9PT0gdm9pZCAwKSBudW0gPSA3O1xuXG4gICAgaWYgKHR5cGUoZGF0YSkgPT0gJ2FycmF5Jykge1xuICAgICAgZGF0YSA9IGFuYWx5emUoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IGRhdGEubWluO1xuICAgIHZhciBtYXggPSBkYXRhLm1heDtcbiAgICB2YXIgdmFsdWVzID0gZGF0YS52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bSA9PT0gMSkge1xuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgdmFyIGxpbWl0cyA9IFtdO1xuXG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnYycpIHtcbiAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH1cblxuICAgIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2UnKSB7XG4gICAgICAvLyBlcXVhbCBpbnRlcnZhbFxuICAgICAgbGltaXRzLnB1c2gobWluKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICBsaW1pdHMucHVzaChtaW4gKyBpIC8gbnVtICogKG1heCAtIG1pbikpO1xuICAgICAgfVxuXG4gICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdsJykge1xuICAgICAgLy8gbG9nIHNjYWxlXG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbl9sb2cgPSBNYXRoLkxPRzEwRSAqIGxvZyQxKG1pbik7XG4gICAgICB2YXIgbWF4X2xvZyA9IE1hdGguTE9HMTBFICogbG9nJDEobWF4KTtcbiAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IG51bTsgaSQxKyspIHtcbiAgICAgICAgbGltaXRzLnB1c2gocG93JDcoMTAsIG1pbl9sb2cgKyBpJDEgLyBudW0gKiAobWF4X2xvZyAtIG1pbl9sb2cpKSk7XG4gICAgICB9XG5cbiAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ3EnKSB7XG4gICAgICAvLyBxdWFudGlsZSBzY2FsZVxuICAgICAgbGltaXRzLnB1c2gobWluKTtcblxuICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgbnVtOyBpJDIrKykge1xuICAgICAgICB2YXIgcCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBpJDIgLyBudW07XG4gICAgICAgIHZhciBwYiA9IGZsb29yJDMocCk7XG5cbiAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgbGltaXRzLnB1c2godmFsdWVzW3BiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcCA+IHBiXG4gICAgICAgICAgdmFyIHByID0gcCAtIHBiO1xuICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0gKiAoMSAtIHByKSArIHZhbHVlc1twYiArIDFdICogcHIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2snKSB7XG4gICAgICAvLyBrLW1lYW5zIGNsdXN0ZXJpbmdcblxuICAgICAgLypcbiAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgIHNpbXBsaWZpZWQgZm9yIDEtZCBpbnB1dCB2YWx1ZXNcbiAgICAgICovXG4gICAgICB2YXIgY2x1c3RlcjtcbiAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBhc3NpZ25tZW50cyA9IG5ldyBBcnJheShuKTtcbiAgICAgIHZhciBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgIHZhciByZXBlYXQgPSB0cnVlO1xuICAgICAgdmFyIG5iX2l0ZXJzID0gMDtcbiAgICAgIHZhciBjZW50cm9pZHMgPSBudWxsOyAvLyBnZXQgc2VlZCB2YWx1ZXNcblxuICAgICAgY2VudHJvaWRzID0gW107XG4gICAgICBjZW50cm9pZHMucHVzaChtaW4pO1xuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxOyBpJDMgPCBudW07IGkkMysrKSB7XG4gICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArIGkkMyAvIG51bSAqIChtYXggLSBtaW4pKTtcbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzLnB1c2gobWF4KTtcblxuICAgICAgd2hpbGUgKHJlcGVhdCkge1xuICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgIGNsdXN0ZXJTaXplc1tqXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBuOyBpJDQrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpJDRdO1xuICAgICAgICAgIHZhciBtaW5kaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICB2YXIgYmVzdCA9IHZvaWQgMDtcblxuICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IG51bTsgaiQxKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gYWJzKGNlbnRyb2lkc1tqJDFdIC0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgIGJlc3QgPSBqJDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tiZXN0XSsrO1xuICAgICAgICAgICAgYXNzaWdubWVudHNbaSQ0XSA9IGJlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBjZW50cm9pZHMgc3RlcFxuXG5cbiAgICAgICAgdmFyIG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuXG4gICAgICAgIGZvciAodmFyIGokMiA9IDA7IGokMiA8IG51bTsgaiQyKyspIHtcbiAgICAgICAgICBuZXdDZW50cm9pZHNbaiQyXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBuOyBpJDUrKykge1xuICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpJDVdO1xuXG4gICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSArPSB2YWx1ZXNbaSQ1XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqJDMgPSAwOyBqJDMgPCBudW07IGokMysrKSB7XG4gICAgICAgICAgbmV3Q2VudHJvaWRzW2okM10gKj0gMSAvIGNsdXN0ZXJTaXplc1tqJDNdO1xuICAgICAgICB9IC8vIGNoZWNrIGNvbnZlcmdlbmNlXG5cblxuICAgICAgICByZXBlYXQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqJDQgPSAwOyBqJDQgPCBudW07IGokNCsrKSB7XG4gICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tqJDRdICE9PSBjZW50cm9pZHNbaiQ0XSkge1xuICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgbmJfaXRlcnMrKztcblxuICAgICAgICBpZiAobmJfaXRlcnMgPiAyMDApIHtcbiAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmaW5pc2hlZCBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgIC8vIHRoZSBuZXh0IHBhcnQgaXMgYm9ycm93ZWQgZnJvbSBnYWJyaWVsZmxvci5pdFxuXG5cbiAgICAgIHZhciBrQ2x1c3RlcnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiQ1ID0gMDsgaiQ1IDwgbnVtOyBqJDUrKykge1xuICAgICAgICBrQ2x1c3RlcnNbaiQ1XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpJDYgPSAwOyBpJDYgPCBuOyBpJDYrKykge1xuICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ2XTtcbiAgICAgICAga0NsdXN0ZXJzW2NsdXN0ZXJdLnB1c2godmFsdWVzW2kkNl0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG1wS01lYW5zQnJlYWtzID0gW107XG5cbiAgICAgIGZvciAodmFyIGokNiA9IDA7IGokNiA8IG51bTsgaiQ2KyspIHtcbiAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1bMF0pO1xuICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbaiQ2XVtrQ2x1c3RlcnNbaiQ2XS5sZW5ndGggLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHRtcEtNZWFuc0JyZWFrcyA9IHRtcEtNZWFuc0JyZWFrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pO1xuICAgICAgbGltaXRzLnB1c2godG1wS01lYW5zQnJlYWtzWzBdKTtcblxuICAgICAgZm9yICh2YXIgaSQ3ID0gMTsgaSQ3IDwgdG1wS01lYW5zQnJlYWtzLmxlbmd0aDsgaSQ3ICs9IDIpIHtcbiAgICAgICAgdmFyIHYgPSB0bXBLTWVhbnNCcmVha3NbaSQ3XTtcblxuICAgICAgICBpZiAoIWlzTmFOKHYpICYmIGxpbWl0cy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgIGxpbWl0cy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbWl0cztcbiAgfTtcblxuICB2YXIgYW5hbHl6ZV8xID0ge1xuICAgIGFuYWx5emU6IGFuYWx5emUsXG4gICAgbGltaXRzOiBsaW1pdHNcbiAgfTtcblxuICB2YXIgY29udHJhc3QgPSBmdW5jdGlvbiBjb250cmFzdChhLCBiKSB7XG4gICAgLy8gV0NBRyBjb250cmFzdCByYXRpb1xuICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICB2YXIgbDEgPSBhLmx1bWluYW5jZSgpO1xuICAgIHZhciBsMiA9IGIubHVtaW5hbmNlKCk7XG4gICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbiAgfTtcblxuICB2YXIgc3FydCQ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgYXRhbjIkMiA9IE1hdGguYXRhbjI7XG4gIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuICB2YXIgY29zJDQgPSBNYXRoLmNvcztcbiAgdmFyIFBJJDIgPSBNYXRoLlBJO1xuXG4gIHZhciBkZWx0YUUgPSBmdW5jdGlvbiBkZWx0YUUoYSwgYiwgTCwgQykge1xuICAgIGlmIChMID09PSB2b2lkIDApIEwgPSAxO1xuICAgIGlmIChDID09PSB2b2lkIDApIEMgPSAxOyAvLyBEZWx0YSBFIChDTUMpXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DTUMuaHRtbFxuXG4gICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICB2YXIgcmVmID0gQXJyYXkuZnJvbShhLmxhYigpKTtcbiAgICB2YXIgTDEgPSByZWZbMF07XG4gICAgdmFyIGExID0gcmVmWzFdO1xuICAgIHZhciBiMSA9IHJlZlsyXTtcbiAgICB2YXIgcmVmJDEgPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgIHZhciBMMiA9IHJlZiQxWzBdO1xuICAgIHZhciBhMiA9IHJlZiQxWzFdO1xuICAgIHZhciBiMiA9IHJlZiQxWzJdO1xuICAgIHZhciBjMSA9IHNxcnQkNChhMSAqIGExICsgYjEgKiBiMSk7XG4gICAgdmFyIGMyID0gc3FydCQ0KGEyICogYTIgKyBiMiAqIGIyKTtcbiAgICB2YXIgc2wgPSBMMSA8IDE2LjAgPyAwLjUxMSA6IDAuMDQwOTc1ICogTDEgLyAoMS4wICsgMC4wMTc2NSAqIEwxKTtcbiAgICB2YXIgc2MgPSAwLjA2MzggKiBjMSAvICgxLjAgKyAwLjAxMzEgKiBjMSkgKyAwLjYzODtcbiAgICB2YXIgaDEgPSBjMSA8IDAuMDAwMDAxID8gMC4wIDogYXRhbjIkMihiMSwgYTEpICogMTgwLjAgLyBQSSQyO1xuXG4gICAgd2hpbGUgKGgxIDwgMCkge1xuICAgICAgaDEgKz0gMzYwO1xuICAgIH1cblxuICAgIHdoaWxlIChoMSA+PSAzNjApIHtcbiAgICAgIGgxIC09IDM2MDtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGgxID49IDE2NC4wICYmIGgxIDw9IDM0NS4wID8gMC41NiArIGFicyQxKDAuMiAqIGNvcyQ0KFBJJDIgKiAoaDEgKyAxNjguMCkgLyAxODAuMCkpIDogMC4zNiArIGFicyQxKDAuNCAqIGNvcyQ0KFBJJDIgKiAoaDEgKyAzNS4wKSAvIDE4MC4wKSk7XG4gICAgdmFyIGM0ID0gYzEgKiBjMSAqIGMxICogYzE7XG4gICAgdmFyIGYgPSBzcXJ0JDQoYzQgLyAoYzQgKyAxOTAwLjApKTtcbiAgICB2YXIgc2ggPSBzYyAqIChmICogdCArIDEuMCAtIGYpO1xuICAgIHZhciBkZWxMID0gTDEgLSBMMjtcbiAgICB2YXIgZGVsQyA9IGMxIC0gYzI7XG4gICAgdmFyIGRlbEEgPSBhMSAtIGEyO1xuICAgIHZhciBkZWxCID0gYjEgLSBiMjtcbiAgICB2YXIgZEgyID0gZGVsQSAqIGRlbEEgKyBkZWxCICogZGVsQiAtIGRlbEMgKiBkZWxDO1xuICAgIHZhciB2MSA9IGRlbEwgLyAoTCAqIHNsKTtcbiAgICB2YXIgdjIgPSBkZWxDIC8gKEMgKiBzYyk7XG4gICAgdmFyIHYzID0gc2g7XG4gICAgcmV0dXJuIHNxcnQkNCh2MSAqIHYxICsgdjIgKiB2MiArIGRIMiAvICh2MyAqIHYzKSk7XG4gIH07IC8vIHNpbXBsZSBFdWNsaWRlYW4gZGlzdGFuY2VcblxuXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIsIG1vZGUpIHtcbiAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSBtb2RlID0gJ2xhYic7IC8vIERlbHRhIEUgKENJRSAxOTc2KVxuICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG5cbiAgICBhID0gbmV3IENvbG9yXzEoYSk7XG4gICAgYiA9IG5ldyBDb2xvcl8xKGIpO1xuICAgIHZhciBsMSA9IGEuZ2V0KG1vZGUpO1xuICAgIHZhciBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgIHZhciBzdW1fc3EgPSAwO1xuXG4gICAgZm9yICh2YXIgaSBpbiBsMSkge1xuICAgICAgdmFyIGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICBzdW1fc3EgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChzdW1fc3EpO1xuICB9O1xuXG4gIHZhciB2YWxpZCA9IGZ1bmN0aW9uIHZhbGlkKCkge1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KENvbG9yXzEsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTsgLy8gc29tZSBwcmUtZGVmaW5lZCBjb2xvciBzY2FsZXM6XG5cblxuICB2YXIgc2NhbGVzID0ge1xuICAgIGNvb2w6IGZ1bmN0aW9uIGNvb2woKSB7XG4gICAgICByZXR1cm4gc2NhbGUoW2Nocm9tYV8xLmhzbCgxODAsIDEsIC45KSwgY2hyb21hXzEuaHNsKDI1MCwgLjcsIC40KV0pO1xuICAgIH0sXG4gICAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgICByZXR1cm4gc2NhbGUoWycjMDAwJywgJyNmMDAnLCAnI2ZmMCcsICcjZmZmJ10sIFswLCAuMjUsIC43NSwgMV0pLm1vZGUoJ3JnYicpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuICAgICAgIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlciwgYW5kIFRoZVxuICAgICAgUGVubnN5bHZhbmlhIFN0YXRlIFVuaXZlcnNpdHkuXG4gICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZFxuICAgICAgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1JcbiAgICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgICBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAqL1xuXG4gIHZhciBjb2xvcmJyZXdlciA9IHtcbiAgICAvLyBzZXF1ZW50aWFsXG4gICAgT3JSZDogWycjZmZmN2VjJywgJyNmZWU4YzgnLCAnI2ZkZDQ5ZScsICcjZmRiYjg0JywgJyNmYzhkNTknLCAnI2VmNjU0OCcsICcjZDczMDFmJywgJyNiMzAwMDAnLCAnIzdmMDAwMCddLFxuICAgIFB1QnU6IFsnI2ZmZjdmYicsICcjZWNlN2YyJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNzRhOWNmJywgJyMzNjkwYzAnLCAnIzA1NzBiMCcsICcjMDQ1YThkJywgJyMwMjM4NTgnXSxcbiAgICBCdVB1OiBbJyNmN2ZjZmQnLCAnI2UwZWNmNCcsICcjYmZkM2U2JywgJyM5ZWJjZGEnLCAnIzhjOTZjNicsICcjOGM2YmIxJywgJyM4ODQxOWQnLCAnIzgxMGY3YycsICcjNGQwMDRiJ10sXG4gICAgT3JhbmdlczogWycjZmZmNWViJywgJyNmZWU2Y2UnLCAnI2ZkZDBhMicsICcjZmRhZTZiJywgJyNmZDhkM2MnLCAnI2YxNjkxMycsICcjZDk0ODAxJywgJyNhNjM2MDMnLCAnIzdmMjcwNCddLFxuICAgIEJ1R246IFsnI2Y3ZmNmZCcsICcjZTVmNWY5JywgJyNjY2VjZTYnLCAnIzk5ZDhjOScsICcjNjZjMmE0JywgJyM0MWFlNzYnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICBZbE9yQnI6IFsnI2ZmZmZlNScsICcjZmZmN2JjJywgJyNmZWUzOTEnLCAnI2ZlYzQ0ZicsICcjZmU5OTI5JywgJyNlYzcwMTQnLCAnI2NjNGMwMicsICcjOTkzNDA0JywgJyM2NjI1MDYnXSxcbiAgICBZbEduOiBbJyNmZmZmZTUnLCAnI2Y3ZmNiOScsICcjZDlmMGEzJywgJyNhZGRkOGUnLCAnIzc4YzY3OScsICcjNDFhYjVkJywgJyMyMzg0NDMnLCAnIzAwNjgzNycsICcjMDA0NTI5J10sXG4gICAgUmVkczogWycjZmZmNWYwJywgJyNmZWUwZDInLCAnI2ZjYmJhMScsICcjZmM5MjcyJywgJyNmYjZhNGEnLCAnI2VmM2IyYycsICcjY2IxODFkJywgJyNhNTBmMTUnLCAnIzY3MDAwZCddLFxuICAgIFJkUHU6IFsnI2ZmZjdmMycsICcjZmRlMGRkJywgJyNmY2M1YzAnLCAnI2ZhOWZiNScsICcjZjc2OGExJywgJyNkZDM0OTcnLCAnI2FlMDE3ZScsICcjN2EwMTc3JywgJyM0OTAwNmEnXSxcbiAgICBHcmVlbnM6IFsnI2Y3ZmNmNScsICcjZTVmNWUwJywgJyNjN2U5YzAnLCAnI2ExZDk5YicsICcjNzRjNDc2JywgJyM0MWFiNWQnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICBZbEduQnU6IFsnI2ZmZmZkOScsICcjZWRmOGIxJywgJyNjN2U5YjQnLCAnIzdmY2RiYicsICcjNDFiNmM0JywgJyMxZDkxYzAnLCAnIzIyNWVhOCcsICcjMjUzNDk0JywgJyMwODFkNTgnXSxcbiAgICBQdXJwbGVzOiBbJyNmY2ZiZmQnLCAnI2VmZWRmNScsICcjZGFkYWViJywgJyNiY2JkZGMnLCAnIzllOWFjOCcsICcjODA3ZGJhJywgJyM2YTUxYTMnLCAnIzU0Mjc4ZicsICcjM2YwMDdkJ10sXG4gICAgR25CdTogWycjZjdmY2YwJywgJyNlMGYzZGInLCAnI2NjZWJjNScsICcjYThkZGI1JywgJyM3YmNjYzQnLCAnIzRlYjNkMycsICcjMmI4Y2JlJywgJyMwODY4YWMnLCAnIzA4NDA4MSddLFxuICAgIEdyZXlzOiBbJyNmZmZmZmYnLCAnI2YwZjBmMCcsICcjZDlkOWQ5JywgJyNiZGJkYmQnLCAnIzk2OTY5NicsICcjNzM3MzczJywgJyM1MjUyNTInLCAnIzI1MjUyNScsICcjMDAwMDAwJ10sXG4gICAgWWxPclJkOiBbJyNmZmZmY2MnLCAnI2ZmZWRhMCcsICcjZmVkOTc2JywgJyNmZWIyNGMnLCAnI2ZkOGQzYycsICcjZmM0ZTJhJywgJyNlMzFhMWMnLCAnI2JkMDAyNicsICcjODAwMDI2J10sXG4gICAgUHVSZDogWycjZjdmNGY5JywgJyNlN2UxZWYnLCAnI2Q0YjlkYScsICcjYzk5NGM3JywgJyNkZjY1YjAnLCAnI2U3Mjk4YScsICcjY2UxMjU2JywgJyM5ODAwNDMnLCAnIzY3MDAxZiddLFxuICAgIEJsdWVzOiBbJyNmN2ZiZmYnLCAnI2RlZWJmNycsICcjYzZkYmVmJywgJyM5ZWNhZTEnLCAnIzZiYWVkNicsICcjNDI5MmM2JywgJyMyMTcxYjUnLCAnIzA4NTE5YycsICcjMDgzMDZiJ10sXG4gICAgUHVCdUduOiBbJyNmZmY3ZmInLCAnI2VjZTJmMCcsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzY3YTljZicsICcjMzY5MGMwJywgJyMwMjgxOGEnLCAnIzAxNmM1OScsICcjMDE0NjM2J10sXG4gICAgVmlyaWRpczogWycjNDQwMTU0JywgJyM0ODI3NzcnLCAnIzNmNGE4YScsICcjMzE2NzhlJywgJyMyNjgzOGYnLCAnIzFmOWQ4YScsICcjNmNjZTVhJywgJyNiNmRlMmInLCAnI2ZlZTgyNSddLFxuICAgIC8vIGRpdmVyZ2luZ1xuICAgIFNwZWN0cmFsOiBbJyM5ZTAxNDInLCAnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNlNmY1OTgnLCAnI2FiZGRhNCcsICcjNjZjMmE1JywgJyMzMjg4YmQnLCAnIzVlNGZhMiddLFxuICAgIFJkWWxHbjogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZDllZjhiJywgJyNhNmQ5NmEnLCAnIzY2YmQ2MycsICcjMWE5ODUwJywgJyMwMDY4MzcnXSxcbiAgICBSZEJ1OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZjdmN2Y3JywgJyNkMWU1ZjAnLCAnIzkyYzVkZScsICcjNDM5M2MzJywgJyMyMTY2YWMnLCAnIzA1MzA2MSddLFxuICAgIFBpWUc6IFsnIzhlMDE1MicsICcjYzUxYjdkJywgJyNkZTc3YWUnLCAnI2YxYjZkYScsICcjZmRlMGVmJywgJyNmN2Y3ZjcnLCAnI2U2ZjVkMCcsICcjYjhlMTg2JywgJyM3ZmJjNDEnLCAnIzRkOTIyMScsICcjMjc2NDE5J10sXG4gICAgUFJHbjogWycjNDAwMDRiJywgJyM3NjJhODMnLCAnIzk5NzBhYicsICcjYzJhNWNmJywgJyNlN2Q0ZTgnLCAnI2Y3ZjdmNycsICcjZDlmMGQzJywgJyNhNmRiYTAnLCAnIzVhYWU2MScsICcjMWI3ODM3JywgJyMwMDQ0MWInXSxcbiAgICBSZFlsQnU6IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDkwJywgJyNmZmZmYmYnLCAnI2UwZjNmOCcsICcjYWJkOWU5JywgJyM3NGFkZDEnLCAnIzQ1NzViNCcsICcjMzEzNjk1J10sXG4gICAgQnJCRzogWycjNTQzMDA1JywgJyM4YzUxMGEnLCAnI2JmODEyZCcsICcjZGZjMjdkJywgJyNmNmU4YzMnLCAnI2Y1ZjVmNScsICcjYzdlYWU1JywgJyM4MGNkYzEnLCAnIzM1OTc4ZicsICcjMDE2NjVlJywgJyMwMDNjMzAnXSxcbiAgICBSZEd5OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZmZmZmZmJywgJyNlMGUwZTAnLCAnI2JhYmFiYScsICcjODc4Nzg3JywgJyM0ZDRkNGQnLCAnIzFhMWExYSddLFxuICAgIFB1T3I6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG4gICAgLy8gcXVhbGl0YXRpdmVcbiAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgIEFjY2VudDogWycjN2ZjOTdmJywgJyNiZWFlZDQnLCAnI2ZkYzA4NicsICcjZmZmZjk5JywgJyMzODZjYjAnLCAnI2YwMDI3ZicsICcjYmY1YjE3JywgJyM2NjY2NjYnXSxcbiAgICBTZXQxOiBbJyNlNDFhMWMnLCAnIzM3N2ViOCcsICcjNGRhZjRhJywgJyM5ODRlYTMnLCAnI2ZmN2YwMCcsICcjZmZmZjMzJywgJyNhNjU2MjgnLCAnI2Y3ODFiZicsICcjOTk5OTk5J10sXG4gICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgIERhcmsyOiBbJyMxYjllNzcnLCAnI2Q5NWYwMicsICcjNzU3MGIzJywgJyNlNzI5OGEnLCAnIzY2YTYxZScsICcjZTZhYjAyJywgJyNhNjc2MWQnLCAnIzY2NjY2NiddLFxuICAgIFBhaXJlZDogWycjYTZjZWUzJywgJyMxZjc4YjQnLCAnI2IyZGY4YScsICcjMzNhMDJjJywgJyNmYjlhOTknLCAnI2UzMWExYycsICcjZmRiZjZmJywgJyNmZjdmMDAnLCAnI2NhYjJkNicsICcjNmEzZDlhJywgJyNmZmZmOTknLCAnI2IxNTkyOCddLFxuICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgUGFzdGVsMTogWycjZmJiNGFlJywgJyNiM2NkZTMnLCAnI2NjZWJjNScsICcjZGVjYmU0JywgJyNmZWQ5YTYnLCAnI2ZmZmZjYycsICcjZTVkOGJkJywgJyNmZGRhZWMnLCAnI2YyZjJmMiddXG4gIH07IC8vIGFkZCBsb3dlcmNhc2UgYWxpYXNlcyBmb3IgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGVzXG5cbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gT2JqZWN0LmtleXMoY29sb3JicmV3ZXIpOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgIHZhciBrZXkgPSBsaXN0JDFbaSQxXTtcbiAgICBjb2xvcmJyZXdlcltrZXkudG9Mb3dlckNhc2UoKV0gPSBjb2xvcmJyZXdlcltrZXldO1xuICB9XG5cbiAgdmFyIGNvbG9yYnJld2VyXzEgPSBjb2xvcmJyZXdlcjsgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAvLyBhIHNtYWxsZXIgY2hyb21hLmpzIGJ1aWx0XG4gIC8vIGlvIC0tPiBjb252ZXJ0IGNvbG9yc1xuICAvLyBvcGVyYXRvcnMgLS0+IG1vZGlmeSBleGlzdGluZyBDb2xvcnNcbiAgLy8gaW50ZXJwb2xhdG9yc1xuICAvLyBnZW5lcmF0b3JzIC0tID4gY3JlYXRlIG5ldyBjb2xvcnNcblxuICBjaHJvbWFfMS5hdmVyYWdlID0gYXZlcmFnZTtcbiAgY2hyb21hXzEuYmV6aWVyID0gYmV6aWVyXzE7XG4gIGNocm9tYV8xLmJsZW5kID0gYmxlbmRfMTtcbiAgY2hyb21hXzEuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuICBjaHJvbWFfMS5taXggPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZSA9IG1peDtcbiAgY2hyb21hXzEucmFuZG9tID0gcmFuZG9tXzE7XG4gIGNocm9tYV8xLnNjYWxlID0gc2NhbGU7IC8vIG90aGVyIHV0aWxpdHkgbWV0aG9kc1xuXG4gIGNocm9tYV8xLmFuYWx5emUgPSBhbmFseXplXzEuYW5hbHl6ZTtcbiAgY2hyb21hXzEuY29udHJhc3QgPSBjb250cmFzdDtcbiAgY2hyb21hXzEuZGVsdGFFID0gZGVsdGFFO1xuICBjaHJvbWFfMS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICBjaHJvbWFfMS5saW1pdHMgPSBhbmFseXplXzEubGltaXRzO1xuICBjaHJvbWFfMS52YWxpZCA9IHZhbGlkOyAvLyBzY2FsZVxuXG4gIGNocm9tYV8xLnNjYWxlcyA9IHNjYWxlczsgLy8gY29sb3JzXG5cbiAgY2hyb21hXzEuY29sb3JzID0gdzNjeDExXzE7XG4gIGNocm9tYV8xLmJyZXdlciA9IGNvbG9yYnJld2VyXzE7XG4gIHZhciBjaHJvbWFfanMgPSBjaHJvbWFfMTtcbiAgcmV0dXJuIGNocm9tYV9qcztcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3873\n")},5438:function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval("var $ = __webpack_require__(2109);\n\n// eslint-disable-next-line es/no-math-hypot -- required for testing\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.es/ecma262/#sec-math.hypot\n$({ target: 'Math', stat: true, forced: BUGGY }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  hypot: function hypot(value1, value2) {\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5oeXBvdC5qcz80MDU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFFBQVEsbUJBQU8sQ0FBQyxJQUFxQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNTQzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC1oeXBvdCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyICRoeXBvdCA9IE1hdGguaHlwb3Q7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLy8gQ2hyb21lIDc3IGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTU0NlxudmFyIEJVR0dZID0gISEkaHlwb3QgJiYgJGh5cG90KEluZmluaXR5LCBOYU4pICE9PSBJbmZpbml0eTtcblxuLy8gYE1hdGguaHlwb3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLmh5cG90XG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogQlVHR1kgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIHNxcnQoc3VtKTtcbiAgfVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5438\n")},6468:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": function() { return /* binding */ cejst; }\n});\n\n// NAMESPACE OBJECT: ./src/components/mapLegend.module.scss\nvar mapLegend_module_namespaceObject = {};\n__webpack_require__.r(mapLegend_module_namespaceObject);\n__webpack_require__.d(mapLegend_module_namespaceObject, {\n  \"Ww\": function() { return colorSwatch; },\n  \"nm\": function() { return legendContainer; },\n  \"oI\": function() { return legendItem; },\n  \"KW\": function() { return nonPrioritized; },\n  \"ah\": function() { return prioritized; },\n  \"VV\": function() { return swatchContainer; },\n  \"Lj\": function() { return threshold; }\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./src/components/layout.tsx + 8 modules\nvar layout = __webpack_require__(6515);\n// EXTERNAL MODULE: ./node_modules/maplibre-gl/dist/maplibre-gl.js\nvar maplibre_gl = __webpack_require__(9910);\n// EXTERNAL MODULE: ./node_modules/chroma-js/chroma.js\nvar chroma = __webpack_require__(3873);\nvar chroma_default = /*#__PURE__*/__webpack_require__.n(chroma);\n;// CONCATENATED MODULE: ./src/data/constants.tsx\n// URLS\nvar FEATURE_TILE_BASE_URL='https://d2zjid6n5ja2pt.cloudfront.net';var XYZ_SUFFIX='{z}/{x}/{y}.pbf';var FEATURE_TILE_HIGH_ZOOM_URL=FEATURE_TILE_BASE_URL+\"/0629_demo/\"+XYZ_SUFFIX;var FEATURE_TILE_LOW_ZOOM_URL=FEATURE_TILE_BASE_URL+\"/tiles_low/\"+XYZ_SUFFIX;// Performance markers\nvar PERFORMANCE_MARKER_MAP_IDLE='MAP_IDLE';// Properties\nvar SCORE_PROPERTY_HIGH='Score D (percentile)';var SCORE_PROPERTY_LOW='D_SCORE';var GEOID_PROPERTY='GEOID10';var HIGH_SCORE_SOURCE_NAME='score-high';var HIGH_SCORE_LAYER_NAME='score-high-layer';var LOW_SCORE_SOURCE_NAME='score-low';var LOW_SCORE_LAYER_NAME='score-low-layer';var SELECTED_PROPERTY='selected';// The name of the layer within the tiles that contains the score\nvar SCORE_SOURCE_LAYER='blocks';// Zoom\nvar GLOBAL_MIN_ZOOM=3;var GLOBAL_MAX_ZOOM=22;var GLOBAL_MIN_ZOOM_LOW=3;var GLOBAL_MAX_ZOOM_LOW=7;var GLOBAL_MIN_ZOOM_HIGHLIGHT=9;var GLOBAL_MAX_ZOOM_HIGHLIGHT=22;var GLOBAL_MIN_ZOOM_HIGH=7;var GLOBAL_MAX_ZOOM_HIGH=11;// Bounds\nvar GLOBAL_MAX_BOUNDS=[[-180.118306,5.499550],[-65.0,83.162102]];var LOWER_48_BOUNDS=[[-124.7844079,24.7433195],[-66.9513812,49.3457868]];var ALASKA_BOUNDS=[[-183.856888,50.875311],[-140.932617,71.958797]];var HAWAII_BOUNDS=[[-168.118306,18.748115],[-154.757881,22.378413]];var PUERTO_RICO_BOUNDS=[[-67.945404,17.88328],[-65.220703,18.515683]];var GUAM_BOUNDS=(/* unused pure expression or super */ null && ([[-215.389709,13.225909],[-215.040894,13.663335]]));var MARIANA_ISLAND_BOUNDS=(/* unused pure expression or super */ null && ([[-215.313449,14.007801],[-213.742404,19.750326]]));var AMERICAN_SAMOA_BOUNDS=(/* unused pure expression or super */ null && ([[-171.089874,-14.548699],[-168.1433,-11.046934]]));var DEFAULT_CENTER=[32.4687126,-86.502136];// Opacity\nvar DEFAULT_LAYER_OPACITY=0.6;// Colors\nvar DEFAULT_OUTLINE_COLOR='#4EA5CF';var MIN_COLOR='#FFFFFF';var MED_COLOR='#D1DAE6';var MAX_COLOR='#768FB3';var BORDER_HIGHLIGHT_COLOR='#00BDE3';// Widths\nvar HIGHLIGHT_BORDER_WIDTH=5.0;// Score boundaries\nvar SCORE_BOUNDARY_LOW=0.0;var SCORE_BOUNDARY_THRESHOLD=0.6;var SCORE_BOUNDARY_PRIORITIZED=0.75;var isMobile=typeof window!=='undefined'&&window.innerWidth<400;\n;// CONCATENATED MODULE: ./src/data/mapStyle.tsx\nvar _sources;// eslint-disable-next-line require-jsdoc\nfunction hexToHSLA(hex,alpha){return chroma_default()(hex).alpha(alpha).css('hsl');}/**\n * `MakePaint` generates a zoom-faded Maplibre style formatted layer given a set of parameters.\n *\n * @param {string} field : the field within the data to consult\n * @param {number} minRamp : the minimum value this can assume\n * @param {number} medRamp : the medium value this can assume\n * @param {number} maxRamp : the maximum value this can assume\n * @return {FillPaint} a maplibregl fill layer\n **/function makePaint(_ref){var field=_ref.field,minRamp=_ref.minRamp,medRamp=_ref.medRamp,maxRamp=_ref.maxRamp;var paintDescriptor={'fill-color':['step',['get',field],hexToHSLA(MIN_COLOR,DEFAULT_LAYER_OPACITY),minRamp,hexToHSLA(MIN_COLOR,DEFAULT_LAYER_OPACITY),medRamp,hexToHSLA(MED_COLOR,DEFAULT_LAYER_OPACITY),maxRamp,hexToHSLA(MAX_COLOR,DEFAULT_LAYER_OPACITY)]};return paintDescriptor;}var imageSuffix=isMobile?'':'@2x';var mapStyle={'version':8,'sources':(_sources={'carto':{'type':'raster','tiles':[\"https://a.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}\"+imageSuffix+\".png\",\"https://b.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}\"+imageSuffix+\".png\",\"https://c.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}\"+imageSuffix+\".png\",\"https://d.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}\"+imageSuffix+\".png\"],'minzoom':GLOBAL_MIN_ZOOM,'maxzoom':GLOBAL_MAX_ZOOM},'geo':{'type':'raster','tiles':['https://mt0.google.com/vt/lyrs=p&hl=en&x={x}&y={y}&z={z}'],'minzoom':GLOBAL_MIN_ZOOM,'maxzoom':GLOBAL_MAX_ZOOM}},_sources[HIGH_SCORE_SOURCE_NAME]={// \"Score-high\" represents the full set of data\n// at the census block group level. It is only shown\n// at high zoom levels to avoid performance issues at lower zooms\n'type':'vector',// Our current tippecanoe command does not set an id.\n// The below line promotes the GEOID10 property to the ID\n'promoteId':GEOID_PROPERTY,'tiles':[FEATURE_TILE_HIGH_ZOOM_URL],// Seeting maxzoom here enables 'overzooming'\n// e.g. continued zooming beyond the max bounds.\n// More here: https://docs.mapbox.com/help/glossary/overzoom/\n'minzoom':GLOBAL_MIN_ZOOM_HIGH,'maxzoom':GLOBAL_MAX_ZOOM_HIGH},_sources[LOW_SCORE_SOURCE_NAME]={// \"Score-low\" represents a tileset at the level of bucketed tracts.\n// census block group information is `dissolve`d into tracts, then\n// each tract is `dissolve`d into one of ten buckets. It is meant\n// to give us a favorable tradeoff between performance and fidelity.\n'type':'vector','promoteId':GEOID_PROPERTY,'tiles':[FEATURE_TILE_LOW_ZOOM_URL// For local development, use:\n// 'http://localhost:8080/data/tl_2010_bg_with_data/{z}/{x}/{y}.pbf',\n],'minzoom':GLOBAL_MIN_ZOOM_LOW,'maxzoom':GLOBAL_MAX_ZOOM_LOW},_sources['labels']={'type':'raster','tiles':[\"https://cartodb-basemaps-a.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}\"+imageSuffix+\".png\",\"https://cartodb-basemaps-b.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}\"+imageSuffix+\".png\",\"https://cartodb-basemaps-c.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}\"+imageSuffix+\".png\",\"https://cartodb-basemaps-d.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}\"+imageSuffix+\".png\"]},_sources),'layers':[{'id':'carto','source':'carto','type':'raster','minzoom':GLOBAL_MIN_ZOOM,'maxzoom':GLOBAL_MAX_ZOOM},{'id':'geo','source':'geo','type':'raster','layout':{// Make the layer invisible by default.\n'visibility':'none'},'minzoom':GLOBAL_MIN_ZOOM,'maxzoom':GLOBAL_MAX_ZOOM},{'id':HIGH_SCORE_LAYER_NAME,'source':HIGH_SCORE_SOURCE_NAME,'source-layer':SCORE_SOURCE_LAYER,'type':'fill','filter':['all',['>',SCORE_PROPERTY_HIGH,SCORE_BOUNDARY_THRESHOLD]],'paint':makePaint({field:SCORE_PROPERTY_HIGH,minRamp:SCORE_BOUNDARY_LOW,medRamp:SCORE_BOUNDARY_THRESHOLD,maxRamp:SCORE_BOUNDARY_PRIORITIZED}),'minzoom':GLOBAL_MIN_ZOOM_HIGH},{'id':LOW_SCORE_LAYER_NAME,'source':LOW_SCORE_SOURCE_NAME,'source-layer':SCORE_SOURCE_LAYER,'type':'fill','filter':['all',['>',SCORE_PROPERTY_LOW,SCORE_BOUNDARY_THRESHOLD]],'paint':makePaint({field:SCORE_PROPERTY_LOW,minRamp:SCORE_BOUNDARY_LOW,medRamp:SCORE_BOUNDARY_THRESHOLD,maxRamp:SCORE_BOUNDARY_PRIORITIZED}),'minzoom':GLOBAL_MIN_ZOOM_LOW,'maxzoom':GLOBAL_MAX_ZOOM_LOW},{// \"Score-highlights\" represents the border\n// around given tiles that appears at higher zooms\n'id':'score-highlights-layer','source':HIGH_SCORE_SOURCE_NAME,'source-layer':SCORE_SOURCE_LAYER,'type':'line','layout':{'visibility':'visible','line-join':'round','line-cap':'round'},'paint':{'line-color':DEFAULT_OUTLINE_COLOR,'line-width':0.8,'line-opacity':0.5},'minzoom':GLOBAL_MIN_ZOOM_HIGHLIGHT,'maxzoom':GLOBAL_MAX_ZOOM_HIGHLIGHT},{// \"score-border-highlight\" is used to highlight\n// the currently-selected feature\n'id':'score-border-highlight-layer','type':'line','source':HIGH_SCORE_SOURCE_NAME,'source-layer':SCORE_SOURCE_LAYER,'layout':{},'paint':{'line-color':BORDER_HIGHLIGHT_COLOR,'line-width':['case',['boolean',['feature-state',SELECTED_PROPERTY],false],HIGHLIGHT_BORDER_WIDTH,0]},'minzoom':GLOBAL_MIN_ZOOM_HIGH,'maxzoom':GLOBAL_MAX_ZOOM_HIGH},{// We put labels last to ensure prominence\n'id':'labels-only-layer','type':'raster','source':'labels','minzoom':GLOBAL_MIN_ZOOM,'maxzoom':GLOBAL_MAX_ZOOM}]};/* harmony default export */ var data_mapStyle = (mapStyle);\n;// CONCATENATED MODULE: ./src/components/popupContent.module.scss\n// extracted by mini-css-extract-plugin\nvar popupContentTable = \"popupContent-module--popupContentTable--1y4c9\";\nvar titleContainer = \"popupContent-module--titleContainer--17Oy9\";\nvar titleIndicatorName = \"popupContent-module--titleIndicatorName--3yoDh\";\n;// CONCATENATED MODULE: ./src/components/popupContent.tsx\nfunction _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var PopupContent=function PopupContent(_ref){var properties=_ref.properties;var readablePercent=function readablePercent(percent){return\"\"+(percent*100).toFixed(2);};var getCategorization=function getCategorization(percentile){var categorization;if(percentile>=0.75){categorization='Prioritized';}else if(0.60<=percentile&&percentile<0.75){categorization='Threshold';}else{categorization='Non-prioritized';}return categorization;};var getTitleContent=function getTitleContent(properties){var blockGroup=properties[GEOID_PROPERTY];var score=properties[SCORE_PROPERTY_HIGH];return/*#__PURE__*/react.createElement(\"div\",{className:titleContainer},/*#__PURE__*/react.createElement(\"div\",null,/*#__PURE__*/react.createElement(\"span\",{className:titleIndicatorName},\"Census Block Group: \"),/*#__PURE__*/react.createElement(\"span\",null,blockGroup)),/*#__PURE__*/react.createElement(\"div\",null,/*#__PURE__*/react.createElement(\"span\",{className:titleIndicatorName},\"Just Progress Categorization: \"),/*#__PURE__*/react.createElement(\"span\",null,getCategorization(score))),/*#__PURE__*/react.createElement(\"div\",null,/*#__PURE__*/react.createElement(\"span\",{className:titleIndicatorName},\"Cumulative Index Score: \"),/*#__PURE__*/react.createElement(\"span\",null,readablePercent(score))));};var getBodyContent=function getBodyContent(properties){var rows=[];var sortedKeys=Object.entries(properties).sort();for(var _iterator=_createForOfIteratorHelperLoose(sortedKeys),_step;!(_step=_iterator()).done;){var _step$value=_step.value,key=_step$value[0],value=_step$value[1];// We should only format floats\nif(typeof value==='number'&&value%1!==0){value=readablePercent(value);}// Filter out all caps\nif(!key.match(/^[A-Z0-9]+$/)){rows.push(/*#__PURE__*/react.createElement(\"tr\",{key:key},/*#__PURE__*/react.createElement(\"td\",null,key),/*#__PURE__*/react.createElement(\"td\",null,value)));}}return rows;};return/*#__PURE__*/react.createElement(react.Fragment,null,properties?/*#__PURE__*/react.createElement(\"div\",{id:\"popupContainer\"},getTitleContent(properties),/*#__PURE__*/react.createElement(\"table\",{className:'usa-table usa-table--borderless '+popupContentTable},/*#__PURE__*/react.createElement(\"thead\",null,/*#__PURE__*/react.createElement(\"tr\",null,/*#__PURE__*/react.createElement(\"th\",{scope:\"col\"},\"INDICATOR\"),/*#__PURE__*/react.createElement(\"th\",{scope:\"col\"},\"VALUE\"))),/*#__PURE__*/react.createElement(\"tbody\",null,getBodyContent(properties)))):'');};/* harmony default export */ var popupContent = (PopupContent);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(3935);\n;// CONCATENATED MODULE: ./src/components/J40Map.module.scss\n// extracted by mini-css-extract-plugin\nvar J40Map_module_mapContainer = \"J40Map-module--mapContainer--3U7xl\";\nvar j40Popup = \"J40Map-module--j40Popup--3yJGr\";\nvar territoryFocusButton = \"J40Map-module--territoryFocusButton--3t42l\";\nvar territoryFocusContainer = \"J40Map-module--territoryFocusContainer--slib-\";\n;// CONCATENATED MODULE: ./src/components/J40Map.tsx\n/* eslint-disable no-unused-vars */var J40Map=function J40Map(){var mapContainer=react.useRef(null);var mapRef=(0,react.useRef)();var selectedFeature=(0,react.useRef)();var _useState=(0,react.useState)(GLOBAL_MIN_ZOOM),zoom=_useState[0],setZoom=_useState[1];(0,react.useEffect)(function(){var initialMap=new maplibre_gl.Map({container:mapContainer.current,style:data_mapStyle,center:DEFAULT_CENTER,zoom:zoom,minZoom:GLOBAL_MIN_ZOOM,maxBounds:GLOBAL_MAX_BOUNDS,hash:true// Adds hash of zoom/lat/long to the url\n});// disable map rotation using right click + drag\ninitialMap.dragRotate.disable();// disable map rotation using touch rotation gesture\ninitialMap.touchZoomRotate.disableRotation();setZoom(initialMap.getZoom());initialMap.on('load',function(){if(window.Cypress){window.underlyingMap=initialMap;}});initialMap.on('click',handleClick);initialMap.addControl(new maplibre_gl.NavigationControl({showCompass:false}),'top-left');mapRef.current=initialMap;},[]);var setMapSelected=function setMapSelected(feature,isSelected){var _mapRef$current$setFe;// The below can be confirmed during debug with:\n// mapRef.current.getFeatureState({\"id\":feature.id, \"source\":feature.source, \"sourceLayer\":feature.sourceLayer})\nmapRef.current.setFeatureState({source:feature.source,sourceLayer:feature.sourceLayer,id:feature.id},(_mapRef$current$setFe={},_mapRef$current$setFe[SELECTED_PROPERTY]=isSelected,_mapRef$current$setFe));if(isSelected){selectedFeature.current=feature;}else{selectedFeature.current=undefined;}};var handleClick=function handleClick(e){var map=e.target;var clickedCoord=e.point;var features=map.queryRenderedFeatures(clickedCoord,{layers:[HIGH_SCORE_LAYER_NAME]});var feature=features&&features[0];if(feature){var placeholder=document.createElement('div');// If we've selected a new feature, set 'selected' to false\nif(selectedFeature.current&&feature.id!==selectedFeature.current.id){setMapSelected(selectedFeature.current,false);}setMapSelected(feature,true);react_dom.render(/*#__PURE__*/react.createElement(popupContent,{properties:feature.properties}),placeholder);var options={offset:[0,0],className:j40Popup,focusAfterOpen:false};new maplibre_gl.Popup(options).setLngLat(e.lngLat).setDOMContent(placeholder).on('close',function(){setMapSelected(feature,false);}).addTo(map);}};(0,react.useEffect)(function(){mapRef.current.on('move',function(){setZoom(mapRef.current.getZoom());});mapRef.current.on('mouseenter',HIGH_SCORE_LAYER_NAME,function(){mapRef.current.getCanvas().style.cursor='pointer';});mapRef.current.on('mouseleave',HIGH_SCORE_LAYER_NAME,function(){mapRef.current.getCanvas().style.cursor='';});},[mapRef]);var goToPlace=function goToPlace(bounds){mapRef.current.fitBounds(bounds);};var onClickTerritoryFocusButton=function onClickTerritoryFocusButton(event){// currentTarget always refers to the element to which the event handler\n// has been attached, as opposed to Event.target, which identifies\n// the element on which the event occurred and which may be its descendant.\nvar buttonID=event.target&&event.currentTarget.id;switch(buttonID){case'48':goToPlace(LOWER_48_BOUNDS);break;case'AK':goToPlace(ALASKA_BOUNDS);break;case'HI':goToPlace(HAWAII_BOUNDS);break;case'PR':goToPlace(PUERTO_RICO_BOUNDS);break;default:break;}};return/*#__PURE__*/react.createElement(\"div\",null,/*#__PURE__*/react.createElement(\"div\",{className:territoryFocusContainer},/*#__PURE__*/react.createElement(\"button\",{id:'48',onClick:onClickTerritoryFocusButton,className:territoryFocusButton,\"aria-label\":\"Zoom to Lower 48\"},\"48\"),/*#__PURE__*/react.createElement(\"button\",{id:'AK',onClick:onClickTerritoryFocusButton,className:territoryFocusButton,\"aria-label\":\"Zoom to Alaska\"},\"AK\"),/*#__PURE__*/react.createElement(\"button\",{id:'HI',onClick:onClickTerritoryFocusButton,className:territoryFocusButton,\"aria-label\":\"Zoom to Hawaii\"},\"HI\"),/*#__PURE__*/react.createElement(\"button\",{id:'PR',onClick:onClickTerritoryFocusButton,className:territoryFocusButton,\"aria-label\":\"Zoom to Puerto Rico\"},\"PR\")),/*#__PURE__*/react.createElement(\"div\",{ref:mapContainer,className:J40Map_module_mapContainer}));};/* harmony default export */ var components_J40Map = (J40Map);\n;// CONCATENATED MODULE: ./src/components/mapWrapper.tsx\nvar MapWrapper=function MapWrapper(){return/*#__PURE__*/react.createElement(\"div\",null,/*#__PURE__*/react.createElement(components_J40Map,null));};/* harmony default export */ var mapWrapper = (MapWrapper);\n;// CONCATENATED MODULE: ./src/components/HowYouCanHelp.module.scss\n// extracted by mini-css-extract-plugin\nvar howYouCanHelpContainer = \"HowYouCanHelp-module--howYouCanHelpContainer--2kqBa\";\n;// CONCATENATED MODULE: ./src/components/HowYouCanHelp.tsx\nvar HowYouCanHelp=function HowYouCanHelp(){return/*#__PURE__*/react.createElement(\"div\",{className:howYouCanHelpContainer},/*#__PURE__*/react.createElement(\"h2\",null,\"How You Can Help Improve the Tool\"),/*#__PURE__*/react.createElement(\"ul\",{className:'usa-list'},/*#__PURE__*/react.createElement(\"li\",null,\"If you have information that could help, we\\u2019d love to hear from you.\"),/*#__PURE__*/react.createElement(\"li\",null,\"View our full set of data sources and methodology where you can add or download sources and check statuses on our data roadmap.\"),/*#__PURE__*/react.createElement(\"li\",null,\"Check out our timeline and send feedback or attend relevant events.\"),/*#__PURE__*/react.createElement(\"li\",null,\"Contact us and share the stories of your community.\")));};/* harmony default export */ var components_HowYouCanHelp = (HowYouCanHelp);\n;// CONCATENATED MODULE: ./src/components/mapLegend.module.scss\n// extracted by mini-css-extract-plugin\nvar legendContainer = \"mapLegend-module--legendContainer--2N1FC\";\nvar swatchContainer = \"mapLegend-module--swatchContainer--1yZX1\";\nvar legendItem = \"mapLegend-module--legendItem--WezUf\";\nvar colorSwatch = \"mapLegend-module--colorSwatch--oBUN2\";\nvar prioritized = \"mapLegend-module--prioritized--1I534\";\nvar threshold = \"mapLegend-module--threshold--1zali\";\nvar nonPrioritized = \"mapLegend-module--nonPrioritized--2y0Vm\";\n;// CONCATENATED MODULE: ./src/components/mapLegend.tsx\nvar MapLegend=function MapLegend(){return/*#__PURE__*/react.createElement(\"div\",{className:legendContainer},/*#__PURE__*/react.createElement(\"h3\",{className:mapLegend_module_namespaceObject.legendHeader},\"COLOR KEY\"),/*#__PURE__*/react.createElement(\"div\",{className:swatchContainer},/*#__PURE__*/react.createElement(\"div\",{className:legendItem},/*#__PURE__*/react.createElement(\"div\",{className:colorSwatch,id:prioritized}),/*#__PURE__*/react.createElement(\"span\",null,\"Prioritized Community\")),/*#__PURE__*/react.createElement(\"div\",{className:legendItem},/*#__PURE__*/react.createElement(\"div\",{className:colorSwatch,id:threshold}),/*#__PURE__*/react.createElement(\"span\",null,\"Threshold Community\")),/*#__PURE__*/react.createElement(\"div\",{className:legendItem},/*#__PURE__*/react.createElement(\"div\",{className:colorSwatch,id:nonPrioritized}),/*#__PURE__*/react.createElement(\"span\",null,\"Non-Prioritized Community\"))));};/* harmony default export */ var mapLegend = (MapLegend);\n;// CONCATENATED MODULE: ./src/pages/cejst.module.scss\n// extracted by mini-css-extract-plugin\nvar disclaimer = \"cejst-module--disclaimer--3LC1y\";\n;// CONCATENATED MODULE: ./src/pages/cejst.tsx\nvar CEJSTPage=function CEJSTPage(_ref){var location=_ref.location;// We temporarily removed MapControls, which would enable you to `setFeatures` also, for now\n//   We will bring back later when we have interactive controls.\nreturn/*#__PURE__*/react.createElement(layout/* default */.Z,{location:location},/*#__PURE__*/react.createElement(\"main\",{id:\"main-content\",role:\"main\"},/*#__PURE__*/react.createElement(\"h2\",null,\"Just Progress communities\"),/*#__PURE__*/react.createElement(\"p\",{className:disclaimer},\"Just Progress helps identify and prioritize communities across the United States and U.S. territories that have been historically overburdened and underserved. These communities will receive 40% of the benefits from investments in key areas outlined by the\",/*#__PURE__*/react.createElement(\"a\",{href:'https://www.whitehouse.gov/briefing-room/'+'presidential-actions/2021/01/27/'+'executive-order-on-tackling-the-climate-'+'crisis-at-home-and-abroad/',target:'_blank',rel:'noreferrer'},\"Executive Order on Tackling the Climate Crisis at Home and Abroad\"),\".\"),/*#__PURE__*/react.createElement(\"h2\",null,\"Explore the Tool\"),/*#__PURE__*/react.createElement(mapWrapper,null),/*#__PURE__*/react.createElement(mapLegend,null),/*#__PURE__*/react.createElement(components_HowYouCanHelp,null)));};/* harmony default export */ var cejst = (CEJSTPage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9kYXRhL2NvbnN0YW50cy50c3g/YmU1YSIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9kYXRhL21hcFN0eWxlLnRzeD85ZDk2Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvcG9wdXBDb250ZW50Lm1vZHVsZS5zY3NzP2Y2NmIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9wb3B1cENvbnRlbnQudHN4PzEwYjIiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9KNDBNYXAubW9kdWxlLnNjc3M/YjdkYiIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL0o0ME1hcC50c3g/YWY3NyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9jb21wb25lbnRzL21hcFdyYXBwZXIudHN4PzE1YjgiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Ib3dZb3VDYW5IZWxwLm1vZHVsZS5zY3NzP2NjY2IiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9Ib3dZb3VDYW5IZWxwLnRzeD85MGI0Iiwid2VicGFjazovL2p1c3RpY2U0MC10b29sLy4vc3JjL2NvbXBvbmVudHMvbWFwTGVnZW5kLm1vZHVsZS5zY3NzP2JjYmMiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvY29tcG9uZW50cy9tYXBMZWdlbmQudHN4PzgxNjEiLCJ3ZWJwYWNrOi8vanVzdGljZTQwLXRvb2wvLi9zcmMvcGFnZXMvY2Vqc3QubW9kdWxlLnNjc3M/NjFlMyIsIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL3NyYy9wYWdlcy9jZWpzdC50c3g/ZTFkZiJdLCJuYW1lcyI6WyJGRUFUVVJFX1RJTEVfQkFTRV9VUkwiLCJYWVpfU1VGRklYIiwiRkVBVFVSRV9USUxFX0hJR0hfWk9PTV9VUkwiLCJGRUFUVVJFX1RJTEVfTE9XX1pPT01fVVJMIiwiUEVSRk9STUFOQ0VfTUFSS0VSX01BUF9JRExFIiwiU0NPUkVfUFJPUEVSVFlfSElHSCIsIlNDT1JFX1BST1BFUlRZX0xPVyIsIkdFT0lEX1BST1BFUlRZIiwiSElHSF9TQ09SRV9TT1VSQ0VfTkFNRSIsIkhJR0hfU0NPUkVfTEFZRVJfTkFNRSIsIkxPV19TQ09SRV9TT1VSQ0VfTkFNRSIsIkxPV19TQ09SRV9MQVlFUl9OQU1FIiwiU0VMRUNURURfUFJPUEVSVFkiLCJTQ09SRV9TT1VSQ0VfTEFZRVIiLCJHTE9CQUxfTUlOX1pPT00iLCJHTE9CQUxfTUFYX1pPT00iLCJHTE9CQUxfTUlOX1pPT01fTE9XIiwiR0xPQkFMX01BWF9aT09NX0xPVyIsIkdMT0JBTF9NSU5fWk9PTV9ISUdITElHSFQiLCJHTE9CQUxfTUFYX1pPT01fSElHSExJR0hUIiwiR0xPQkFMX01JTl9aT09NX0hJR0giLCJHTE9CQUxfTUFYX1pPT01fSElHSCIsIkdMT0JBTF9NQVhfQk9VTkRTIiwiTE9XRVJfNDhfQk9VTkRTIiwiQUxBU0tBX0JPVU5EUyIsIkhBV0FJSV9CT1VORFMiLCJQVUVSVE9fUklDT19CT1VORFMiLCJHVUFNX0JPVU5EUyIsIk1BUklBTkFfSVNMQU5EX0JPVU5EUyIsIkFNRVJJQ0FOX1NBTU9BX0JPVU5EUyIsIkRFRkFVTFRfQ0VOVEVSIiwiREVGQVVMVF9MQVlFUl9PUEFDSVRZIiwiREVGQVVMVF9PVVRMSU5FX0NPTE9SIiwiTUlOX0NPTE9SIiwiTUVEX0NPTE9SIiwiTUFYX0NPTE9SIiwiQk9SREVSX0hJR0hMSUdIVF9DT0xPUiIsIkhJR0hMSUdIVF9CT1JERVJfV0lEVEgiLCJTQ09SRV9CT1VOREFSWV9MT1ciLCJTQ09SRV9CT1VOREFSWV9USFJFU0hPTEQiLCJTQ09SRV9CT1VOREFSWV9QUklPUklUSVpFRCIsImlzTW9iaWxlIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhleFRvSFNMQSIsImhleCIsImFscGhhIiwiY2hyb21hIiwiY3NzIiwibWFrZVBhaW50IiwiZmllbGQiLCJtaW5SYW1wIiwibWVkUmFtcCIsIm1heFJhbXAiLCJwYWludERlc2NyaXB0b3IiLCJjb25zdGFudHMiLCJpbWFnZVN1ZmZpeCIsIm1hcFN0eWxlIiwiUG9wdXBDb250ZW50IiwicHJvcGVydGllcyIsInJlYWRhYmxlUGVyY2VudCIsInBlcmNlbnQiLCJ0b0ZpeGVkIiwiZ2V0Q2F0ZWdvcml6YXRpb24iLCJwZXJjZW50aWxlIiwiY2F0ZWdvcml6YXRpb24iLCJnZXRUaXRsZUNvbnRlbnQiLCJibG9ja0dyb3VwIiwic2NvcmUiLCJzdHlsZXMiLCJnZXRCb2R5Q29udGVudCIsInJvd3MiLCJzb3J0ZWRLZXlzIiwiT2JqZWN0IiwiZW50cmllcyIsInNvcnQiLCJrZXkiLCJ2YWx1ZSIsIm1hdGNoIiwicHVzaCIsIko0ME1hcCIsIm1hcENvbnRhaW5lciIsIlJlYWN0IiwibWFwUmVmIiwidXNlUmVmIiwic2VsZWN0ZWRGZWF0dXJlIiwidXNlU3RhdGUiLCJ6b29tIiwic2V0Wm9vbSIsInVzZUVmZmVjdCIsImluaXRpYWxNYXAiLCJNYXAiLCJjb250YWluZXIiLCJjdXJyZW50Iiwic3R5bGUiLCJjZW50ZXIiLCJtaW5ab29tIiwibWF4Qm91bmRzIiwiaGFzaCIsImRyYWdSb3RhdGUiLCJkaXNhYmxlIiwidG91Y2hab29tUm90YXRlIiwiZGlzYWJsZVJvdGF0aW9uIiwiZ2V0Wm9vbSIsIm9uIiwiQ3lwcmVzcyIsInVuZGVybHlpbmdNYXAiLCJoYW5kbGVDbGljayIsImFkZENvbnRyb2wiLCJOYXZpZ2F0aW9uQ29udHJvbCIsInNob3dDb21wYXNzIiwic2V0TWFwU2VsZWN0ZWQiLCJmZWF0dXJlIiwiaXNTZWxlY3RlZCIsInNldEZlYXR1cmVTdGF0ZSIsInNvdXJjZSIsInNvdXJjZUxheWVyIiwiaWQiLCJ1bmRlZmluZWQiLCJlIiwibWFwIiwidGFyZ2V0IiwiY2xpY2tlZENvb3JkIiwicG9pbnQiLCJmZWF0dXJlcyIsInF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyIsImxheWVycyIsInBsYWNlaG9sZGVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiUmVhY3RET00iLCJvcHRpb25zIiwib2Zmc2V0IiwiY2xhc3NOYW1lIiwiZm9jdXNBZnRlck9wZW4iLCJQb3B1cCIsInNldExuZ0xhdCIsImxuZ0xhdCIsInNldERPTUNvbnRlbnQiLCJhZGRUbyIsImdldENhbnZhcyIsImN1cnNvciIsImdvVG9QbGFjZSIsImJvdW5kcyIsImZpdEJvdW5kcyIsIm9uQ2xpY2tUZXJyaXRvcnlGb2N1c0J1dHRvbiIsImV2ZW50IiwiYnV0dG9uSUQiLCJjdXJyZW50VGFyZ2V0IiwiTWFwV3JhcHBlciIsIkhvd1lvdUNhbkhlbHAiLCJNYXBMZWdlbmQiLCJDRUpTVFBhZ2UiLCJsb2NhdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ08sR0FBTUEsc0JBQXFCLENBQUcsdUNBQTlCLENBQ1AsR0FBTUMsV0FBVSxDQUFHLGlCQUFuQixDQUNPLEdBQU1DLDJCQUEwQixDQUFNRixxQkFBTixlQUF5Q0MsVUFBekUsQ0FDQSxHQUFNRSwwQkFBeUIsQ0FBTUgscUJBQU4sZUFBeUNDLFVBQXhFLENBR1A7QUFDTyxHQUFNRyw0QkFBMkIsQ0FBRyxVQUFwQyxDQUVQO0FBQ08sR0FBTUMsb0JBQW1CLENBQUcsc0JBQTVCLENBQ0EsR0FBTUMsbUJBQWtCLENBQUcsU0FBM0IsQ0FDQSxHQUFNQyxlQUFjLENBQUcsU0FBdkIsQ0FDQSxHQUFNQyx1QkFBc0IsQ0FBRyxZQUEvQixDQUNBLEdBQU1DLHNCQUFxQixDQUFHLGtCQUE5QixDQUNBLEdBQU1DLHNCQUFxQixDQUFHLFdBQTlCLENBQ0EsR0FBTUMscUJBQW9CLENBQUcsaUJBQTdCLENBQ0EsR0FBTUMsa0JBQWlCLENBQUcsVUFBMUIsQ0FFUDtBQUNPLEdBQU1DLG1CQUFrQixDQUFHLFFBQTNCLENBS1A7QUFDTyxHQUFNQyxnQkFBZSxDQUFHLENBQXhCLENB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O0FDV1AsR0FBTUMsVUFBUyxDQUFHLFFBQVpBLFVBQVksTUFBK0IsSUFBN0JDLFNBQTZCLE1BQTdCQSxRQUE2QixDQUMvQztBQUNBO0FBQ0EsbUJBQ0Usb0JBQUMscUJBQUQsRUFBUSxRQUFRLENBQUVBLFFBQWxCLGVBQ0UsNEJBQU0sRUFBRSxDQUFDLGNBQVQsQ0FBd0IsSUFBSSxDQUFDLE1BQTdCLGVBQ0UsMERBREYsY0FFRSx5QkFBRyxTQUFTLENBQUVwRixVQUFkLGtSQUtFLHlCQUNFLElBQUksQ0FBRSw0Q0FDTixrQ0FETSxDQUVOLDBDQUZNLENBR04sNEJBSkYsQ0FLRSxNQUFNLENBQUUsUUFMVixDQU1FLEdBQUcsQ0FBRSxZQU5QLHNFQUxGLEtBRkYsY0FpQkUsaURBakJGLGNBa0JFLG9CQUFDLFVBQUQsTUFsQkYsY0FtQkUsb0JBQUMsU0FBRCxNQW5CRixjQW9CRSxvQkFBQyx3QkFBRCxNQXBCRixDQURGLENBREYsQ0EwQkQsQ0E3QkQsQ0ErQkEsMENBQWVtRixTQUFmIiwiZmlsZSI6IjY0NjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVUkxTXG5leHBvcnQgY29uc3QgRkVBVFVSRV9USUxFX0JBU0VfVVJMID0gJ2h0dHBzOi8vZDJ6amlkNm41amEycHQuY2xvdWRmcm9udC5uZXQnO1xuY29uc3QgWFlaX1NVRkZJWCA9ICd7en0ve3h9L3t5fS5wYmYnO1xuZXhwb3J0IGNvbnN0IEZFQVRVUkVfVElMRV9ISUdIX1pPT01fVVJMID0gYCR7RkVBVFVSRV9USUxFX0JBU0VfVVJMfS8wNjI5X2RlbW8vJHtYWVpfU1VGRklYfWA7XG5leHBvcnQgY29uc3QgRkVBVFVSRV9USUxFX0xPV19aT09NX1VSTCA9IGAke0ZFQVRVUkVfVElMRV9CQVNFX1VSTH0vdGlsZXNfbG93LyR7WFlaX1NVRkZJWH1gO1xuXG5cbi8vIFBlcmZvcm1hbmNlIG1hcmtlcnNcbmV4cG9ydCBjb25zdCBQRVJGT1JNQU5DRV9NQVJLRVJfTUFQX0lETEUgPSAnTUFQX0lETEUnO1xuXG4vLyBQcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgU0NPUkVfUFJPUEVSVFlfSElHSCA9ICdTY29yZSBEIChwZXJjZW50aWxlKSc7XG5leHBvcnQgY29uc3QgU0NPUkVfUFJPUEVSVFlfTE9XID0gJ0RfU0NPUkUnO1xuZXhwb3J0IGNvbnN0IEdFT0lEX1BST1BFUlRZID0gJ0dFT0lEMTAnO1xuZXhwb3J0IGNvbnN0IEhJR0hfU0NPUkVfU09VUkNFX05BTUUgPSAnc2NvcmUtaGlnaCc7XG5leHBvcnQgY29uc3QgSElHSF9TQ09SRV9MQVlFUl9OQU1FID0gJ3Njb3JlLWhpZ2gtbGF5ZXInO1xuZXhwb3J0IGNvbnN0IExPV19TQ09SRV9TT1VSQ0VfTkFNRSA9ICdzY29yZS1sb3cnO1xuZXhwb3J0IGNvbnN0IExPV19TQ09SRV9MQVlFUl9OQU1FID0gJ3Njb3JlLWxvdy1sYXllcic7XG5leHBvcnQgY29uc3QgU0VMRUNURURfUFJPUEVSVFkgPSAnc2VsZWN0ZWQnO1xuXG4vLyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXIgd2l0aGluIHRoZSB0aWxlcyB0aGF0IGNvbnRhaW5zIHRoZSBzY29yZVxuZXhwb3J0IGNvbnN0IFNDT1JFX1NPVVJDRV9MQVlFUiA9ICdibG9ja3MnO1xuXG5leHBvcnQgdHlwZSBKNDBQcm9wZXJ0aWVzID0geyBba2V5OiBzdHJpbmddOiBhbnkgfTtcblxuXG4vLyBab29tXG5leHBvcnQgY29uc3QgR0xPQkFMX01JTl9aT09NID0gMztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT00gPSAyMjtcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUlOX1pPT01fTE9XID0gMztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT01fTE9XID0gNztcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUlOX1pPT01fSElHSExJR0hUID0gOTtcbmV4cG9ydCBjb25zdCBHTE9CQUxfTUFYX1pPT01fSElHSExJR0hUID0gMjI7XG5leHBvcnQgY29uc3QgR0xPQkFMX01JTl9aT09NX0hJR0ggPSA3O1xuZXhwb3J0IGNvbnN0IEdMT0JBTF9NQVhfWk9PTV9ISUdIID0gMTE7XG5cbi8vIEJvdW5kc1xuZXhwb3J0IGNvbnN0IEdMT0JBTF9NQVhfQk9VTkRTID0gW1xuICBbLTE4MC4xMTgzMDYsIDUuNDk5NTUwXSxcbiAgWy02NS4wLCA4My4xNjIxMDJdLFxuXTtcblxuZXhwb3J0IGNvbnN0IExPV0VSXzQ4X0JPVU5EUyA9IFtcbiAgWy0xMjQuNzg0NDA3OSwgMjQuNzQzMzE5NV0sXG4gIFstNjYuOTUxMzgxMiwgNDkuMzQ1Nzg2OF0sXG5dO1xuXG5leHBvcnQgY29uc3QgQUxBU0tBX0JPVU5EUyA9IFtcbiAgWy0xODMuODU2ODg4LCA1MC44NzUzMTFdLFxuICBbLTE0MC45MzI2MTcsIDcxLjk1ODc5N10sXG5dO1xuXG5leHBvcnQgY29uc3QgSEFXQUlJX0JPVU5EUyA9IFtcbiAgWy0xNjguMTE4MzA2LCAxOC43NDgxMTVdLFxuICBbLTE1NC43NTc4ODEsIDIyLjM3ODQxM10sXG5dO1xuXG5leHBvcnQgY29uc3QgUFVFUlRPX1JJQ09fQk9VTkRTID0gW1xuICBbLTY3Ljk0NTQwNCwgMTcuODgzMjhdLFxuICBbLTY1LjIyMDcwMywgMTguNTE1NjgzXSxcbl07XG5cbmV4cG9ydCBjb25zdCBHVUFNX0JPVU5EUyA9IFtcbiAgWy0yMTUuMzg5NzA5LCAxMy4yMjU5MDldLFxuICBbLTIxNS4wNDA4OTQsIDEzLjY2MzMzNV0sXG5dO1xuXG5leHBvcnQgY29uc3QgTUFSSUFOQV9JU0xBTkRfQk9VTkRTID0gW1xuICBbLTIxNS4zMTM0NDksIDE0LjAwNzgwMV0sXG4gIFstMjEzLjc0MjQwNCwgMTkuNzUwMzI2XSxcbl07XG5cbmV4cG9ydCBjb25zdCBBTUVSSUNBTl9TQU1PQV9CT1VORFMgPSBbXG4gIFstMTcxLjA4OTg3NCwgLTE0LjU0ODY5OV0sXG4gIFstMTY4LjE0MzMsIC0xMS4wNDY5MzRdLFxuXTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0VOVEVSID0gWzMyLjQ2ODcxMjYsIC04Ni41MDIxMzZdO1xuXG4vLyBPcGFjaXR5XG5leHBvcnQgY29uc3QgREVGQVVMVF9MQVlFUl9PUEFDSVRZID0gMC42O1xuXG4vLyBDb2xvcnNcbmV4cG9ydCBjb25zdCBERUZBVUxUX09VVExJTkVfQ09MT1IgPSAnIzRFQTVDRic7XG5leHBvcnQgY29uc3QgTUlOX0NPTE9SID0gJyNGRkZGRkYnO1xuZXhwb3J0IGNvbnN0IE1FRF9DT0xPUiA9ICcjRDFEQUU2JztcbmV4cG9ydCBjb25zdCBNQVhfQ09MT1IgPSAnIzc2OEZCMyc7XG5leHBvcnQgY29uc3QgQk9SREVSX0hJR0hMSUdIVF9DT0xPUiA9ICcjMDBCREUzJztcblxuLy8gV2lkdGhzXG5leHBvcnQgY29uc3QgSElHSExJR0hUX0JPUkRFUl9XSURUSCA9IDUuMDtcblxuLy8gU2NvcmUgYm91bmRhcmllc1xuZXhwb3J0IGNvbnN0IFNDT1JFX0JPVU5EQVJZX0xPVyA9IDAuMDtcbmV4cG9ydCBjb25zdCBTQ09SRV9CT1VOREFSWV9USFJFU0hPTEQgPSAwLjY7XG5leHBvcnQgY29uc3QgU0NPUkVfQk9VTkRBUllfUFJJT1JJVElaRUQgPSAwLjc1O1xuXG5leHBvcnQgY29uc3QgaXNNb2JpbGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LmlubmVyV2lkdGggPCA0MDApO1xuIiwiaW1wb3J0IHtTdHlsZSwgRmlsbFBhaW50fSBmcm9tICdtYXBsaWJyZS1nbCc7XG5pbXBvcnQgY2hyb21hIGZyb20gJ2Nocm9tYS1qcyc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1qc2RvY1xuZnVuY3Rpb24gaGV4VG9IU0xBKGhleDpzdHJpbmcsIGFscGhhOm51bWJlcikge1xuICByZXR1cm4gY2hyb21hKGhleCkuYWxwaGEoYWxwaGEpLmNzcygnaHNsJyk7XG59XG5cbi8qKlxuICogYE1ha2VQYWludGAgZ2VuZXJhdGVzIGEgem9vbS1mYWRlZCBNYXBsaWJyZSBzdHlsZSBmb3JtYXR0ZWQgbGF5ZXIgZ2l2ZW4gYSBzZXQgb2YgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgOiB0aGUgZmllbGQgd2l0aGluIHRoZSBkYXRhIHRvIGNvbnN1bHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SYW1wIDogdGhlIG1pbmltdW0gdmFsdWUgdGhpcyBjYW4gYXNzdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gbWVkUmFtcCA6IHRoZSBtZWRpdW0gdmFsdWUgdGhpcyBjYW4gYXNzdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmFtcCA6IHRoZSBtYXhpbXVtIHZhbHVlIHRoaXMgY2FuIGFzc3VtZVxuICogQHJldHVybiB7RmlsbFBhaW50fSBhIG1hcGxpYnJlZ2wgZmlsbCBsYXllclxuICoqL1xuZnVuY3Rpb24gbWFrZVBhaW50KHtcbiAgZmllbGQsXG4gIG1pblJhbXAsXG4gIG1lZFJhbXAsXG4gIG1heFJhbXAsXG59OiB7XG4gICAgZmllbGQ6IHN0cmluZztcbiAgICBtaW5SYW1wOiBudW1iZXI7XG4gICAgbWVkUmFtcDogbnVtYmVyO1xuICAgIG1heFJhbXA6IG51bWJlcjtcbiAgfSk6IEZpbGxQYWludCB7XG4gIGNvbnN0IHBhaW50RGVzY3JpcHRvciA6IEZpbGxQYWludCA9IHtcbiAgICAnZmlsbC1jb2xvcic6IFtcbiAgICAgICdzdGVwJyxcbiAgICAgIFsnZ2V0JywgZmllbGRdLFxuICAgICAgaGV4VG9IU0xBKGNvbnN0YW50cy5NSU5fQ09MT1IsIGNvbnN0YW50cy5ERUZBVUxUX0xBWUVSX09QQUNJVFkgKSxcbiAgICAgIG1pblJhbXAsXG4gICAgICBoZXhUb0hTTEEoY29uc3RhbnRzLk1JTl9DT0xPUiwgY29uc3RhbnRzLkRFRkFVTFRfTEFZRVJfT1BBQ0lUWSApLFxuICAgICAgbWVkUmFtcCxcbiAgICAgIGhleFRvSFNMQShjb25zdGFudHMuTUVEX0NPTE9SLCBjb25zdGFudHMuREVGQVVMVF9MQVlFUl9PUEFDSVRZICksXG4gICAgICBtYXhSYW1wLFxuICAgICAgaGV4VG9IU0xBKGNvbnN0YW50cy5NQVhfQ09MT1IsIGNvbnN0YW50cy5ERUZBVUxUX0xBWUVSX09QQUNJVFkgKSxcbiAgICBdLFxuICB9O1xuICByZXR1cm4gcGFpbnREZXNjcmlwdG9yO1xufVxuXG5jb25zdCBpbWFnZVN1ZmZpeCA9IGNvbnN0YW50cy5pc01vYmlsZSA/ICcnIDogJ0AyeCc7XG5cbmNvbnN0IG1hcFN0eWxlIDogU3R5bGUgPSB7XG4gICd2ZXJzaW9uJzogOCxcbiAgJ3NvdXJjZXMnOiB7XG4gICAgJ2NhcnRvJzoge1xuICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICd0aWxlcyc6XG4gICAgICBbXG4gICAgICAgIGBodHRwczovL2EuYmFzZW1hcHMuY2FydG9jZG4uY29tL2xpZ2h0X25vbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgYGh0dHBzOi8vYi5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vbGlnaHRfbm9sYWJlbHMve3p9L3t4fS97eX0ke2ltYWdlU3VmZml4fS5wbmdgLFxuICAgICAgICBgaHR0cHM6Ly9jLmJhc2VtYXBzLmNhcnRvY2RuLmNvbS9saWdodF9ub2xhYmVscy97en0ve3h9L3t5fSR7aW1hZ2VTdWZmaXh9LnBuZ2AsXG4gICAgICAgIGBodHRwczovL2QuYmFzZW1hcHMuY2FydG9jZG4uY29tL2xpZ2h0X25vbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgIF0sXG4gICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgfSxcbiAgICAnZ2VvJzoge1xuICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICd0aWxlcyc6IFtcbiAgICAgICAgJ2h0dHBzOi8vbXQwLmdvb2dsZS5jb20vdnQvbHlycz1wJmhsPWVuJng9e3h9Jnk9e3l9Jno9e3p9JyxcbiAgICAgIF0sXG4gICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgfSxcbiAgICBbY29uc3RhbnRzLkhJR0hfU0NPUkVfU09VUkNFX05BTUVdOiB7XG4gICAgICAvLyBcIlNjb3JlLWhpZ2hcIiByZXByZXNlbnRzIHRoZSBmdWxsIHNldCBvZiBkYXRhXG4gICAgICAvLyBhdCB0aGUgY2Vuc3VzIGJsb2NrIGdyb3VwIGxldmVsLiBJdCBpcyBvbmx5IHNob3duXG4gICAgICAvLyBhdCBoaWdoIHpvb20gbGV2ZWxzIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGlzc3VlcyBhdCBsb3dlciB6b29tc1xuICAgICAgJ3R5cGUnOiAndmVjdG9yJyxcbiAgICAgIC8vIE91ciBjdXJyZW50IHRpcHBlY2Fub2UgY29tbWFuZCBkb2VzIG5vdCBzZXQgYW4gaWQuXG4gICAgICAvLyBUaGUgYmVsb3cgbGluZSBwcm9tb3RlcyB0aGUgR0VPSUQxMCBwcm9wZXJ0eSB0byB0aGUgSURcbiAgICAgICdwcm9tb3RlSWQnOiBjb25zdGFudHMuR0VPSURfUFJPUEVSVFksXG4gICAgICAndGlsZXMnOiBbXG4gICAgICAgIGNvbnN0YW50cy5GRUFUVVJFX1RJTEVfSElHSF9aT09NX1VSTCxcbiAgICAgIF0sXG4gICAgICAvLyBTZWV0aW5nIG1heHpvb20gaGVyZSBlbmFibGVzICdvdmVyem9vbWluZydcbiAgICAgIC8vIGUuZy4gY29udGludWVkIHpvb21pbmcgYmV5b25kIHRoZSBtYXggYm91bmRzLlxuICAgICAgLy8gTW9yZSBoZXJlOiBodHRwczovL2RvY3MubWFwYm94LmNvbS9oZWxwL2dsb3NzYXJ5L292ZXJ6b29tL1xuICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0hJR0gsXG4gICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fSElHSCxcbiAgICB9LFxuICAgIFtjb25zdGFudHMuTE9XX1NDT1JFX1NPVVJDRV9OQU1FXToge1xuICAgICAgLy8gXCJTY29yZS1sb3dcIiByZXByZXNlbnRzIGEgdGlsZXNldCBhdCB0aGUgbGV2ZWwgb2YgYnVja2V0ZWQgdHJhY3RzLlxuICAgICAgLy8gY2Vuc3VzIGJsb2NrIGdyb3VwIGluZm9ybWF0aW9uIGlzIGBkaXNzb2x2ZWBkIGludG8gdHJhY3RzLCB0aGVuXG4gICAgICAvLyBlYWNoIHRyYWN0IGlzIGBkaXNzb2x2ZWBkIGludG8gb25lIG9mIHRlbiBidWNrZXRzLiBJdCBpcyBtZWFudFxuICAgICAgLy8gdG8gZ2l2ZSB1cyBhIGZhdm9yYWJsZSB0cmFkZW9mZiBiZXR3ZWVuIHBlcmZvcm1hbmNlIGFuZCBmaWRlbGl0eS5cbiAgICAgICd0eXBlJzogJ3ZlY3RvcicsXG4gICAgICAncHJvbW90ZUlkJzogY29uc3RhbnRzLkdFT0lEX1BST1BFUlRZLFxuICAgICAgJ3RpbGVzJzogW1xuICAgICAgICBjb25zdGFudHMuRkVBVFVSRV9USUxFX0xPV19aT09NX1VSTCxcbiAgICAgICAgLy8gRm9yIGxvY2FsIGRldmVsb3BtZW50LCB1c2U6XG4gICAgICAgIC8vICdodHRwOi8vbG9jYWxob3N0OjgwODAvZGF0YS90bF8yMDEwX2JnX3dpdGhfZGF0YS97en0ve3h9L3t5fS5wYmYnLFxuICAgICAgXSxcbiAgICAgICdtaW56b29tJzogY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9MT1csXG4gICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT01fTE9XLFxuICAgIH0sXG4gICAgJ2xhYmVscyc6IHtcbiAgICAgICd0eXBlJzogJ3Jhc3RlcicsXG4gICAgICAndGlsZXMnOiBbXG4gICAgICAgIGBodHRwczovL2NhcnRvZGItYmFzZW1hcHMtYS5nbG9iYWwuc3NsLmZhc3RseS5uZXQvbGlnaHRfb25seV9sYWJlbHMve3p9L3t4fS97eX0ke2ltYWdlU3VmZml4fS5wbmdgLFxuICAgICAgICBgaHR0cHM6Ly9jYXJ0b2RiLWJhc2VtYXBzLWIuZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X29ubHlfbGFiZWxzL3t6fS97eH0ve3l9JHtpbWFnZVN1ZmZpeH0ucG5nYCxcbiAgICAgICAgYGh0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy1jLmdsb2JhbC5zc2wuZmFzdGx5Lm5ldC9saWdodF9vbmx5X2xhYmVscy97en0ve3h9L3t5fSR7aW1hZ2VTdWZmaXh9LnBuZ2AsXG4gICAgICAgIGBodHRwczovL2NhcnRvZGItYmFzZW1hcHMtZC5nbG9iYWwuc3NsLmZhc3RseS5uZXQvbGlnaHRfb25seV9sYWJlbHMve3p9L3t4fS97eX0ke2ltYWdlU3VmZml4fS5wbmdgLFxuICAgICAgXSxcbiAgICB9LFxuICB9LFxuICAnbGF5ZXJzJzogW1xuICAgIHtcbiAgICAgICdpZCc6ICdjYXJ0bycsXG4gICAgICAnc291cmNlJzogJ2NhcnRvJyxcbiAgICAgICd0eXBlJzogJ3Jhc3RlcicsXG4gICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gICAgICAnbWF4em9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUFYX1pPT00sXG4gICAgfSxcbiAgICB7XG4gICAgICAnaWQnOiAnZ2VvJyxcbiAgICAgICdzb3VyY2UnOiAnZ2VvJyxcbiAgICAgICd0eXBlJzogJ3Jhc3RlcicsXG4gICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAvLyBNYWtlIHRoZSBsYXllciBpbnZpc2libGUgYnkgZGVmYXVsdC5cbiAgICAgICAgJ3Zpc2liaWxpdHknOiAnbm9uZScsXG4gICAgICB9LFxuICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NLFxuICAgICAgJ21heHpvb20nOiBjb25zdGFudHMuR0xPQkFMX01BWF9aT09NLFxuICAgIH0sXG4gICAge1xuICAgICAgJ2lkJzogY29uc3RhbnRzLkhJR0hfU0NPUkVfTEFZRVJfTkFNRSxcbiAgICAgICdzb3VyY2UnOiBjb25zdGFudHMuSElHSF9TQ09SRV9TT1VSQ0VfTkFNRSxcbiAgICAgICdzb3VyY2UtbGF5ZXInOiBjb25zdGFudHMuU0NPUkVfU09VUkNFX0xBWUVSLFxuICAgICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgICAnZmlsdGVyJzogWydhbGwnLFxuICAgICAgICBbJz4nLCBjb25zdGFudHMuU0NPUkVfUFJPUEVSVFlfSElHSCwgY29uc3RhbnRzLlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRF0sXG4gICAgICBdLFxuICAgICAgJ3BhaW50JzogbWFrZVBhaW50KHtcbiAgICAgICAgZmllbGQ6IGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWV9ISUdILFxuICAgICAgICBtaW5SYW1wOiBjb25zdGFudHMuU0NPUkVfQk9VTkRBUllfTE9XLFxuICAgICAgICBtZWRSYW1wOiBjb25zdGFudHMuU0NPUkVfQk9VTkRBUllfVEhSRVNIT0xELFxuICAgICAgICBtYXhSYW1wOiBjb25zdGFudHMuU0NPUkVfQk9VTkRBUllfUFJJT1JJVElaRUQsXG4gICAgICB9KSxcbiAgICAgICdtaW56b29tJzogY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTV9ISUdILFxuICAgIH0sXG4gICAge1xuICAgICAgJ2lkJzogY29uc3RhbnRzLkxPV19TQ09SRV9MQVlFUl9OQU1FLFxuICAgICAgJ3NvdXJjZSc6IGNvbnN0YW50cy5MT1dfU0NPUkVfU09VUkNFX05BTUUsXG4gICAgICAnc291cmNlLWxheWVyJzogY29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUixcbiAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgICAgWyc+JywgY29uc3RhbnRzLlNDT1JFX1BST1BFUlRZX0xPVywgY29uc3RhbnRzLlNDT1JFX0JPVU5EQVJZX1RIUkVTSE9MRF0sXG4gICAgICBdLFxuICAgICAgJ3BhaW50JzogbWFrZVBhaW50KHtcbiAgICAgICAgZmllbGQ6IGNvbnN0YW50cy5TQ09SRV9QUk9QRVJUWV9MT1csXG4gICAgICAgIG1pblJhbXA6IGNvbnN0YW50cy5TQ09SRV9CT1VOREFSWV9MT1csXG4gICAgICAgIG1lZFJhbXA6IGNvbnN0YW50cy5TQ09SRV9CT1VOREFSWV9USFJFU0hPTEQsXG4gICAgICAgIG1heFJhbXA6IGNvbnN0YW50cy5TQ09SRV9CT1VOREFSWV9QUklPUklUSVpFRCxcbiAgICAgIH0pLFxuICAgICAgJ21pbnpvb20nOiBjb25zdGFudHMuR0xPQkFMX01JTl9aT09NX0xPVyxcbiAgICAgICdtYXh6b29tJzogY29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9MT1csXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBcIlNjb3JlLWhpZ2hsaWdodHNcIiByZXByZXNlbnRzIHRoZSBib3JkZXJcbiAgICAgIC8vIGFyb3VuZCBnaXZlbiB0aWxlcyB0aGF0IGFwcGVhcnMgYXQgaGlnaGVyIHpvb21zXG4gICAgICAnaWQnOiAnc2NvcmUtaGlnaGxpZ2h0cy1sYXllcicsXG4gICAgICAnc291cmNlJzogY29uc3RhbnRzLkhJR0hfU0NPUkVfU09VUkNFX05BTUUsXG4gICAgICAnc291cmNlLWxheWVyJzogY29uc3RhbnRzLlNDT1JFX1NPVVJDRV9MQVlFUixcbiAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgICAgICdsaW5lLWpvaW4nOiAncm91bmQnLFxuICAgICAgICAnbGluZS1jYXAnOiAncm91bmQnLFxuICAgICAgfSxcbiAgICAgICdwYWludCc6IHtcbiAgICAgICAgJ2xpbmUtY29sb3InOiBjb25zdGFudHMuREVGQVVMVF9PVVRMSU5FX0NPTE9SLFxuICAgICAgICAnbGluZS13aWR0aCc6IDAuOCxcbiAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IDAuNSxcbiAgICAgIH0sXG4gICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSExJR0hULFxuICAgICAgJ21heHpvb20nOiBjb25zdGFudHMuR0xPQkFMX01BWF9aT09NX0hJR0hMSUdIVCxcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFwic2NvcmUtYm9yZGVyLWhpZ2hsaWdodFwiIGlzIHVzZWQgdG8gaGlnaGxpZ2h0XG4gICAgICAvLyB0aGUgY3VycmVudGx5LXNlbGVjdGVkIGZlYXR1cmVcbiAgICAgICdpZCc6ICdzY29yZS1ib3JkZXItaGlnaGxpZ2h0LWxheWVyJyxcbiAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgJ3NvdXJjZSc6IGNvbnN0YW50cy5ISUdIX1NDT1JFX1NPVVJDRV9OQU1FLFxuICAgICAgJ3NvdXJjZS1sYXllcic6IGNvbnN0YW50cy5TQ09SRV9TT1VSQ0VfTEFZRVIsXG4gICAgICAnbGF5b3V0Jzoge30sXG4gICAgICAncGFpbnQnOiB7XG4gICAgICAgICdsaW5lLWNvbG9yJzogY29uc3RhbnRzLkJPUkRFUl9ISUdITElHSFRfQ09MT1IsXG4gICAgICAgICdsaW5lLXdpZHRoJzogW1xuICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICBbJ2Jvb2xlYW4nLCBbJ2ZlYXR1cmUtc3RhdGUnLCBjb25zdGFudHMuU0VMRUNURURfUFJPUEVSVFldLCBmYWxzZV0sXG4gICAgICAgICAgY29uc3RhbnRzLkhJR0hMSUdIVF9CT1JERVJfV0lEVEgsXG4gICAgICAgICAgMCxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICAnbWluem9vbSc6IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT01fSElHSCxcbiAgICAgICdtYXh6b29tJzogY29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTV9ISUdILFxuICAgIH0sXG4gICAge1xuICAgICAgLy8gV2UgcHV0IGxhYmVscyBsYXN0IHRvIGVuc3VyZSBwcm9taW5lbmNlXG4gICAgICAnaWQnOiAnbGFiZWxzLW9ubHktbGF5ZXInLFxuICAgICAgJ3R5cGUnOiAncmFzdGVyJyxcbiAgICAgICdzb3VyY2UnOiAnbGFiZWxzJyxcbiAgICAgICdtaW56b29tJzogY29uc3RhbnRzLkdMT0JBTF9NSU5fWk9PTSxcbiAgICAgICdtYXh6b29tJzogY29uc3RhbnRzLkdMT0JBTF9NQVhfWk9PTSxcbiAgICB9LFxuICBdLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbWFwU3R5bGU7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgcG9wdXBDb250ZW50VGFibGUgPSBcInBvcHVwQ29udGVudC1tb2R1bGUtLXBvcHVwQ29udGVudFRhYmxlLS0xeTRjOVwiO1xuZXhwb3J0IHZhciB0aXRsZUNvbnRhaW5lciA9IFwicG9wdXBDb250ZW50LW1vZHVsZS0tdGl0bGVDb250YWluZXItLTE3T3k5XCI7XG5leHBvcnQgdmFyIHRpdGxlSW5kaWNhdG9yTmFtZSA9IFwicG9wdXBDb250ZW50LW1vZHVsZS0tdGl0bGVJbmRpY2F0b3JOYW1lLS0zeW9EaFwiOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9kYXRhL2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9wb3B1cENvbnRlbnQubW9kdWxlLnNjc3MnO1xuaW1wb3J0IHtHZW9Kc29uUHJvcGVydGllc30gZnJvbSAnZ2VvanNvbic7XG5cbmludGVyZmFjZSBJUG9wdXBDb250ZW50UHJvcHMge1xuICBwcm9wZXJ0aWVzOiBHZW9Kc29uUHJvcGVydGllcyxcbn1cblxuY29uc3QgUG9wdXBDb250ZW50ID0gKHtwcm9wZXJ0aWVzfTpJUG9wdXBDb250ZW50UHJvcHMpID0+IHtcbiAgY29uc3QgcmVhZGFibGVQZXJjZW50ID0gKHBlcmNlbnQ6IG51bWJlcikgPT4ge1xuICAgIHJldHVybiBgJHsocGVyY2VudCAqIDEwMCkudG9GaXhlZCgyKX1gO1xuICB9O1xuXG4gIGNvbnN0IGdldENhdGVnb3JpemF0aW9uID0gKHBlcmNlbnRpbGU6IG51bWJlcikgPT4ge1xuICAgIGxldCBjYXRlZ29yaXphdGlvbjtcbiAgICBpZiAocGVyY2VudGlsZSA+PSAwLjc1ICkge1xuICAgICAgY2F0ZWdvcml6YXRpb24gPSAnUHJpb3JpdGl6ZWQnO1xuICAgIH0gZWxzZSBpZiAoMC42MCA8PSBwZXJjZW50aWxlICYmIHBlcmNlbnRpbGUgPCAwLjc1KSB7XG4gICAgICBjYXRlZ29yaXphdGlvbiA9ICdUaHJlc2hvbGQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXRlZ29yaXphdGlvbiA9ICdOb24tcHJpb3JpdGl6ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gY2F0ZWdvcml6YXRpb247XG4gIH07XG5cbiAgY29uc3QgZ2V0VGl0bGVDb250ZW50ID0gKHByb3BlcnRpZXM6IGNvbnN0YW50cy5KNDBQcm9wZXJ0aWVzKSA9PiB7XG4gICAgY29uc3QgYmxvY2tHcm91cCA9IHByb3BlcnRpZXNbY29uc3RhbnRzLkdFT0lEX1BST1BFUlRZXTtcbiAgICBjb25zdCBzY29yZSA9IHByb3BlcnRpZXNbY29uc3RhbnRzLlNDT1JFX1BST1BFUlRZX0hJR0hdIGFzIG51bWJlcjtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZUNvbnRhaW5lcn0+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMudGl0bGVJbmRpY2F0b3JOYW1lfT5DZW5zdXMgQmxvY2sgR3JvdXA6IDwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57YmxvY2tHcm91cH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlSW5kaWNhdG9yTmFtZX0+SnVzdCBQcm9ncmVzcyBDYXRlZ29yaXphdGlvbjogPC9zcGFuPlxuICAgICAgICAgIDxzcGFuPntnZXRDYXRlZ29yaXphdGlvbihzY29yZSl9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZUluZGljYXRvck5hbWV9PkN1bXVsYXRpdmUgSW5kZXggU2NvcmU6IDwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57cmVhZGFibGVQZXJjZW50KHNjb3JlKX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBnZXRCb2R5Q29udGVudCA9IChwcm9wZXJ0aWVzOiBjb25zdGFudHMuSjQwUHJvcGVydGllcykgPT4ge1xuICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuc29ydCgpO1xuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBzb3J0ZWRLZXlzKSB7XG4gICAgICAvLyBXZSBzaG91bGQgb25seSBmb3JtYXQgZmxvYXRzXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAlIDEgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSByZWFkYWJsZVBlcmNlbnQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWx0ZXIgb3V0IGFsbCBjYXBzXG4gICAgICBpZiAoIWtleS5tYXRjaCgvXltBLVowLTldKyQvKSkge1xuICAgICAgICByb3dzLnB1c2goPHRyIGtleT17a2V5fSA+XG4gICAgICAgICAgPHRkPntrZXl9PC90ZD5cbiAgICAgICAgICA8dGQ+e3ZhbHVlfTwvdGQ+XG4gICAgICAgIDwvdHI+KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG5cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7cHJvcGVydGllcyA/XG4gICAgICA8ZGl2IGlkPSdwb3B1cENvbnRhaW5lcic+XG4gICAgICAgIHtnZXRUaXRsZUNvbnRlbnQocHJvcGVydGllcyl9XG4gICAgICAgIDx0YWJsZSBjbGFzc05hbWU9eyd1c2EtdGFibGUgdXNhLXRhYmxlLS1ib3JkZXJsZXNzICcgKyBzdHlsZXMucG9wdXBDb250ZW50VGFibGV9PlxuICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+SU5ESUNBVE9SPC90aD5cbiAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+VkFMVUU8L3RoPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgIHtnZXRCb2R5Q29udGVudChwcm9wZXJ0aWVzKX1cbiAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICA8L3RhYmxlPlxuICAgICAgPC9kaXY+IDpcbiAgICAnJyB9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQb3B1cENvbnRlbnQ7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgbWFwQ29udGFpbmVyID0gXCJKNDBNYXAtbW9kdWxlLS1tYXBDb250YWluZXItLTNVN3hsXCI7XG5leHBvcnQgdmFyIGo0MFBvcHVwID0gXCJKNDBNYXAtbW9kdWxlLS1qNDBQb3B1cC0tM3lKR3JcIjtcbmV4cG9ydCB2YXIgdGVycml0b3J5Rm9jdXNCdXR0b24gPSBcIko0ME1hcC1tb2R1bGUtLXRlcnJpdG9yeUZvY3VzQnV0dG9uLS0zdDQybFwiO1xuZXhwb3J0IHZhciB0ZXJyaXRvcnlGb2N1c0NvbnRhaW5lciA9IFwiSjQwTWFwLW1vZHVsZS0tdGVycml0b3J5Rm9jdXNDb250YWluZXItLXNsaWItXCI7IiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBSZWFjdCwge3VzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1hcGxpYnJlZ2wsIHtMbmdMYXRCb3VuZHNMaWtlLFxuICBNYXAsXG4gIE5hdmlnYXRpb25Db250cm9sLFxuICBQb3B1cE9wdGlvbnMsXG4gIFBvcHVwLFxuICBMbmdMYXRMaWtlLFxuICBNYXBib3hHZW9KU09ORmVhdHVyZX0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuaW1wb3J0IG1hcFN0eWxlIGZyb20gJy4uL2RhdGEvbWFwU3R5bGUnO1xuaW1wb3J0IFBvcHVwQ29udGVudCBmcm9tICcuL3BvcHVwQ29udGVudCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgJ21hcGxpYnJlLWdsL2Rpc3QvbWFwbGlicmUtZ2wuY3NzJztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0o0ME1hcC5tb2R1bGUuc2Nzcyc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgQ3lwcmVzcz86IG9iamVjdDtcbiAgICB1bmRlcmx5aW5nTWFwOiBNYXA7XG4gIH1cbn1cbnR5cGUgQ2xpY2tFdmVudCA9IG1hcGxpYnJlZ2wuTWFwTW91c2VFdmVudCAmIG1hcGxpYnJlZ2wuRXZlbnREYXRhO1xuXG5jb25zdCBKNDBNYXAgPSAoKSA9PiB7XG4gIGNvbnN0IG1hcENvbnRhaW5lciA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxNYXA+KCkgYXMgUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxNYXA+O1xuICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB1c2VSZWY8TWFwYm94R2VvSlNPTkZlYXR1cmU+KCk7XG4gIGNvbnN0IFt6b29tLCBzZXRab29tXSA9IHVzZVN0YXRlKGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbE1hcCA9IG5ldyBNYXAoe1xuICAgICAgY29udGFpbmVyOiBtYXBDb250YWluZXIuY3VycmVudCEsXG4gICAgICBzdHlsZTogbWFwU3R5bGUsXG4gICAgICBjZW50ZXI6IGNvbnN0YW50cy5ERUZBVUxUX0NFTlRFUiBhcyBMbmdMYXRMaWtlLFxuICAgICAgem9vbTogem9vbSxcbiAgICAgIG1pblpvb206IGNvbnN0YW50cy5HTE9CQUxfTUlOX1pPT00sXG4gICAgICBtYXhCb3VuZHM6IGNvbnN0YW50cy5HTE9CQUxfTUFYX0JPVU5EUyBhcyBMbmdMYXRCb3VuZHNMaWtlLFxuICAgICAgaGFzaDogdHJ1ZSwgLy8gQWRkcyBoYXNoIG9mIHpvb20vbGF0L2xvbmcgdG8gdGhlIHVybFxuICAgIH0pO1xuICAgIC8vIGRpc2FibGUgbWFwIHJvdGF0aW9uIHVzaW5nIHJpZ2h0IGNsaWNrICsgZHJhZ1xuICAgIGluaXRpYWxNYXAuZHJhZ1JvdGF0ZS5kaXNhYmxlKCk7XG5cbiAgICAvLyBkaXNhYmxlIG1hcCByb3RhdGlvbiB1c2luZyB0b3VjaCByb3RhdGlvbiBnZXN0dXJlXG4gICAgaW5pdGlhbE1hcC50b3VjaFpvb21Sb3RhdGUuZGlzYWJsZVJvdGF0aW9uKCk7XG5cbiAgICBzZXRab29tKGluaXRpYWxNYXAuZ2V0Wm9vbSgpKTtcblxuICAgIGluaXRpYWxNYXAub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICBpZiAod2luZG93LkN5cHJlc3MpIHtcbiAgICAgICAgd2luZG93LnVuZGVybHlpbmdNYXAgPSBpbml0aWFsTWFwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5pdGlhbE1hcC5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgaW5pdGlhbE1hcC5hZGRDb250cm9sKG5ldyBOYXZpZ2F0aW9uQ29udHJvbCh7c2hvd0NvbXBhc3M6IGZhbHNlfSksICd0b3AtbGVmdCcpO1xuICAgIG1hcFJlZi5jdXJyZW50ID0gaW5pdGlhbE1hcDtcbiAgfSwgW10pO1xuICBjb25zdCBzZXRNYXBTZWxlY3RlZCA9IChmZWF0dXJlOk1hcGJveEdlb0pTT05GZWF0dXJlLCBpc1NlbGVjdGVkOmJvb2xlYW4pIDogdm9pZCA9PiB7XG4gICAgLy8gVGhlIGJlbG93IGNhbiBiZSBjb25maXJtZWQgZHVyaW5nIGRlYnVnIHdpdGg6XG4gICAgLy8gbWFwUmVmLmN1cnJlbnQuZ2V0RmVhdHVyZVN0YXRlKHtcImlkXCI6ZmVhdHVyZS5pZCwgXCJzb3VyY2VcIjpmZWF0dXJlLnNvdXJjZSwgXCJzb3VyY2VMYXllclwiOmZlYXR1cmUuc291cmNlTGF5ZXJ9KVxuICAgIG1hcFJlZi5jdXJyZW50LnNldEZlYXR1cmVTdGF0ZSh7XG4gICAgICBzb3VyY2U6IGZlYXR1cmUuc291cmNlLFxuICAgICAgc291cmNlTGF5ZXI6IGZlYXR1cmUuc291cmNlTGF5ZXIsXG4gICAgICBpZDogZmVhdHVyZS5pZCxcbiAgICB9LCB7W2NvbnN0YW50cy5TRUxFQ1RFRF9QUk9QRVJUWV06IGlzU2VsZWN0ZWR9KTtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgc2VsZWN0ZWRGZWF0dXJlLmN1cnJlbnQgPSBmZWF0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZEZlYXR1cmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZTogQ2xpY2tFdmVudCkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IGNsaWNrZWRDb29yZCA9IGUucG9pbnQ7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGNsaWNrZWRDb29yZCwge1xuICAgICAgbGF5ZXJzOiBbY29uc3RhbnRzLkhJR0hfU0NPUkVfTEFZRVJfTkFNRV0sXG4gICAgfSk7XG4gICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzICYmIGZlYXR1cmVzWzBdO1xuICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgLy8gSWYgd2UndmUgc2VsZWN0ZWQgYSBuZXcgZmVhdHVyZSwgc2V0ICdzZWxlY3RlZCcgdG8gZmFsc2VcbiAgICAgIGlmIChzZWxlY3RlZEZlYXR1cmUuY3VycmVudCAmJiBmZWF0dXJlLmlkICE9PSBzZWxlY3RlZEZlYXR1cmUuY3VycmVudC5pZCkge1xuICAgICAgICBzZXRNYXBTZWxlY3RlZChzZWxlY3RlZEZlYXR1cmUuY3VycmVudCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgc2V0TWFwU2VsZWN0ZWQoZmVhdHVyZSwgdHJ1ZSk7XG5cbiAgICAgIFJlYWN0RE9NLnJlbmRlcig8UG9wdXBDb250ZW50IHByb3BlcnRpZXM9e2ZlYXR1cmUucHJvcGVydGllc30gLz4sIHBsYWNlaG9sZGVyKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgOiBQb3B1cE9wdGlvbnMgPSB7XG4gICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICBjbGFzc05hbWU6IHN0eWxlcy5qNDBQb3B1cCxcbiAgICAgICAgZm9jdXNBZnRlck9wZW46IGZhbHNlLFxuICAgICAgfTtcbiAgICAgIG5ldyBQb3B1cChvcHRpb25zKVxuICAgICAgICAgIC5zZXRMbmdMYXQoZS5sbmdMYXQpXG4gICAgICAgICAgLnNldERPTUNvbnRlbnQocGxhY2Vob2xkZXIpXG4gICAgICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2V0TWFwU2VsZWN0ZWQoZmVhdHVyZSwgZmFsc2UpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmFkZFRvKG1hcCk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWFwUmVmLmN1cnJlbnQub24oJ21vdmUnLCAoKSA9PiB7XG4gICAgICBzZXRab29tKG1hcFJlZi5jdXJyZW50LmdldFpvb20oKSk7XG4gICAgfSk7XG4gICAgbWFwUmVmLmN1cnJlbnQub24oJ21vdXNlZW50ZXInLCBjb25zdGFudHMuSElHSF9TQ09SRV9MQVlFUl9OQU1FLCAoKSA9PiB7XG4gICAgICBtYXBSZWYuY3VycmVudC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfSk7XG4gICAgbWFwUmVmLmN1cnJlbnQub24oJ21vdXNlbGVhdmUnLCBjb25zdGFudHMuSElHSF9TQ09SRV9MQVlFUl9OQU1FLCAoKSA9PiB7XG4gICAgICBtYXBSZWYuY3VycmVudC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9KTtcbiAgfSwgW21hcFJlZl0pO1xuXG4gIGNvbnN0IGdvVG9QbGFjZSA9IChib3VuZHM6bnVtYmVyW11bXSkgPT4ge1xuICAgIG1hcFJlZi5jdXJyZW50LmZpdEJvdW5kcyhib3VuZHMgYXMgTG5nTGF0Qm91bmRzTGlrZSk7XG4gIH07XG5cbiAgY29uc3Qgb25DbGlja1RlcnJpdG9yeUZvY3VzQnV0dG9uID0gKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50PikgPT4ge1xuICAgIC8vIGN1cnJlbnRUYXJnZXQgYWx3YXlzIHJlZmVycyB0byB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZXZlbnQgaGFuZGxlclxuICAgIC8vIGhhcyBiZWVuIGF0dGFjaGVkLCBhcyBvcHBvc2VkIHRvIEV2ZW50LnRhcmdldCwgd2hpY2ggaWRlbnRpZmllc1xuICAgIC8vIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCBvY2N1cnJlZCBhbmQgd2hpY2ggbWF5IGJlIGl0cyBkZXNjZW5kYW50LlxuICAgIGNvbnN0IGJ1dHRvbklEID0gZXZlbnQudGFyZ2V0ICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQuaWQ7XG5cbiAgICBzd2l0Y2ggKGJ1dHRvbklEKSB7XG4gICAgICBjYXNlICc0OCc6XG4gICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuTE9XRVJfNDhfQk9VTkRTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBSyc6XG4gICAgICAgIGdvVG9QbGFjZShjb25zdGFudHMuQUxBU0tBX0JPVU5EUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSEknOlxuICAgICAgICBnb1RvUGxhY2UoY29uc3RhbnRzLkhBV0FJSV9CT1VORFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BSJzpcbiAgICAgICAgZ29Ub1BsYWNlKGNvbnN0YW50cy5QVUVSVE9fUklDT19CT1VORFMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNDb250YWluZXJ9PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgaWQ9eyc0OCd9XG4gICAgICAgICAgb25DbGljaz17b25DbGlja1RlcnJpdG9yeUZvY3VzQnV0dG9ufVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRlcnJpdG9yeUZvY3VzQnV0dG9ufVxuICAgICAgICAgIGFyaWEtbGFiZWw9XCJab29tIHRvIExvd2VyIDQ4XCIgPlxuICAgICAgICAgICAgNDhcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBpZD17J0FLJ31cbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b259XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNCdXR0b259XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlpvb20gdG8gQWxhc2thXCIgPlxuICAgICAgICAgICAgQUtcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBpZD17J0hJJ31cbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b259XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNCdXR0b259XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlpvb20gdG8gSGF3YWlpXCIgPlxuICAgICAgICAgICAgSElcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBpZD17J1BSJ31cbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrVGVycml0b3J5Rm9jdXNCdXR0b259XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGVycml0b3J5Rm9jdXNCdXR0b259XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIlpvb20gdG8gUHVlcnRvIFJpY29cIiA+XG4gICAgICAgICAgICBQUlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiByZWY9e21hcENvbnRhaW5lcn0gY2xhc3NOYW1lPXtzdHlsZXMubWFwQ29udGFpbmVyfS8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBKNDBNYXA7XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgSjQwTWFwIGZyb20gJy4vSjQwTWFwJztcblxuY29uc3QgTWFwV3JhcHBlciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAge1xuICAgICAgICA8SjQwTWFwIC8+XG4gICAgICB9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcFdyYXBwZXI7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB2YXIgaG93WW91Q2FuSGVscENvbnRhaW5lciA9IFwiSG93WW91Q2FuSGVscC1tb2R1bGUtLWhvd1lvdUNhbkhlbHBDb250YWluZXItLTJrcUJhXCI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuL0hvd1lvdUNhbkhlbHAubW9kdWxlLnNjc3MnO1xuXG5jb25zdCBIb3dZb3VDYW5IZWxwID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaG93WW91Q2FuSGVscENvbnRhaW5lcn0+XG4gICAgICA8aDI+SG93IFlvdSBDYW4gSGVscCBJbXByb3ZlIHRoZSBUb29sPC9oMj5cbiAgICAgIDx1bCBjbGFzc05hbWU9eyd1c2EtbGlzdCd9PlxuICAgICAgICA8bGk+SWYgeW91IGhhdmUgaW5mb3JtYXRpb24gdGhhdCBjb3VsZCBoZWxwLCB3ZeKAmWQgbG92ZSB0byBoZWFyIGZyb20geW91LjwvbGk+XG4gICAgICAgIDxsaT5WaWV3IG91ciBmdWxsIHNldCBvZiBkYXRhIHNvdXJjZXMgYW5kIG1ldGhvZG9sb2d5XG4gICAgICAgICAgICB3aGVyZSB5b3UgY2FuIGFkZCBvciBkb3dubG9hZCBzb3VyY2VzIGFuZCBjaGVjayBzdGF0dXNlcyBvbiBvdXIgZGF0YSByb2FkbWFwLjwvbGk+XG4gICAgICAgIDxsaT5DaGVjayBvdXQgb3VyIHRpbWVsaW5lIGFuZCBzZW5kIGZlZWRiYWNrIG9yIGF0dGVuZCByZWxldmFudCBldmVudHMuPC9saT5cbiAgICAgICAgPGxpPkNvbnRhY3QgdXMgYW5kIHNoYXJlIHRoZSBzdG9yaWVzIG9mIHlvdXIgY29tbXVuaXR5LjwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSG93WW91Q2FuSGVscDtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHZhciBsZWdlbmRDb250YWluZXIgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLWxlZ2VuZENvbnRhaW5lci0tMk4xRkNcIjtcbmV4cG9ydCB2YXIgc3dhdGNoQ29udGFpbmVyID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1zd2F0Y2hDb250YWluZXItLTF5WlgxXCI7XG5leHBvcnQgdmFyIGxlZ2VuZEl0ZW0gPSBcIm1hcExlZ2VuZC1tb2R1bGUtLWxlZ2VuZEl0ZW0tLVdlelVmXCI7XG5leHBvcnQgdmFyIGNvbG9yU3dhdGNoID0gXCJtYXBMZWdlbmQtbW9kdWxlLS1jb2xvclN3YXRjaC0tb0JVTjJcIjtcbmV4cG9ydCB2YXIgcHJpb3JpdGl6ZWQgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLXByaW9yaXRpemVkLS0xSTUzNFwiO1xuZXhwb3J0IHZhciB0aHJlc2hvbGQgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLXRocmVzaG9sZC0tMXphbGlcIjtcbmV4cG9ydCB2YXIgbm9uUHJpb3JpdGl6ZWQgPSBcIm1hcExlZ2VuZC1tb2R1bGUtLW5vblByaW9yaXRpemVkLS0yeTBWbVwiOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9tYXBMZWdlbmQubW9kdWxlLnNjc3MnO1xuXG5jb25zdCBNYXBMZWdlbmQgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5sZWdlbmRDb250YWluZXJ9PlxuICAgICAgPGgzIGNsYXNzTmFtZT17c3R5bGVzLmxlZ2VuZEhlYWRlcn0+Q09MT1IgS0VZPC9oMz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3dhdGNoQ29udGFpbmVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5sZWdlbmRJdGVtfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbG9yU3dhdGNofSBpZD17c3R5bGVzLnByaW9yaXRpemVkfSAvPlxuICAgICAgICAgIDxzcGFuPlByaW9yaXRpemVkIENvbW11bml0eTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVnZW5kSXRlbX0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2xvclN3YXRjaH0gaWQ9e3N0eWxlcy50aHJlc2hvbGR9IC8+XG4gICAgICAgICAgPHNwYW4+VGhyZXNob2xkIENvbW11bml0eTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVnZW5kSXRlbX0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2xvclN3YXRjaH0gaWQ9e3N0eWxlcy5ub25Qcmlvcml0aXplZH0gLz5cbiAgICAgICAgICA8c3Bhbj5Ob24tUHJpb3JpdGl6ZWQgQ29tbXVuaXR5PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwTGVnZW5kO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgdmFyIGRpc2NsYWltZXIgPSBcImNlanN0LW1vZHVsZS0tZGlzY2xhaW1lci0tM0xDMXlcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9jb21wb25lbnRzL2xheW91dCc7XG5pbXBvcnQgTWFwV3JhcHBlciBmcm9tICcuLi9jb21wb25lbnRzL21hcFdyYXBwZXInO1xuaW1wb3J0IEhvd1lvdUNhbkhlbHAgZnJvbSAnLi4vY29tcG9uZW50cy9Ib3dZb3VDYW5IZWxwJztcbmltcG9ydCBNYXBMZWdlbmQgZnJvbSAnLi4vY29tcG9uZW50cy9tYXBMZWdlbmQnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vY2Vqc3QubW9kdWxlLnNjc3MnO1xuXG5cbmludGVyZmFjZSBJTWFwUGFnZVByb3BzIHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufVxuXG5jb25zdCBDRUpTVFBhZ2UgPSAoe2xvY2F0aW9ufTogSU1hcFBhZ2VQcm9wcykgPT4ge1xuICAvLyBXZSB0ZW1wb3JhcmlseSByZW1vdmVkIE1hcENvbnRyb2xzLCB3aGljaCB3b3VsZCBlbmFibGUgeW91IHRvIGBzZXRGZWF0dXJlc2AgYWxzbywgZm9yIG5vd1xuICAvLyAgIFdlIHdpbGwgYnJpbmcgYmFjayBsYXRlciB3aGVuIHdlIGhhdmUgaW50ZXJhY3RpdmUgY29udHJvbHMuXG4gIHJldHVybiAoXG4gICAgPExheW91dCBsb2NhdGlvbj17bG9jYXRpb259PlxuICAgICAgPG1haW4gaWQ9XCJtYWluLWNvbnRlbnRcIiByb2xlPVwibWFpblwiPlxuICAgICAgICA8aDI+SnVzdCBQcm9ncmVzcyBjb21tdW5pdGllczwvaDI+XG4gICAgICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLmRpc2NsYWltZXJ9PlxuICAgICAgICAgIEp1c3QgUHJvZ3Jlc3MgaGVscHMgaWRlbnRpZnkgYW5kIHByaW9yaXRpemUgY29tbXVuaXRpZXMgYWNyb3NzIHRoZVxuICAgICAgICAgIFVuaXRlZCBTdGF0ZXMgYW5kIFUuUy4gdGVycml0b3JpZXMgdGhhdCBoYXZlIGJlZW4gaGlzdG9yaWNhbGx5XG4gICAgICAgICAgb3ZlcmJ1cmRlbmVkIGFuZCB1bmRlcnNlcnZlZC4gVGhlc2UgY29tbXVuaXRpZXMgd2lsbCByZWNlaXZlIDQwJSBvZlxuICAgICAgICAgIHRoZSBiZW5lZml0cyBmcm9tIGludmVzdG1lbnRzIGluIGtleSBhcmVhcyBvdXRsaW5lZCBieSB0aGVcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgaHJlZj17J2h0dHBzOi8vd3d3LndoaXRlaG91c2UuZ292L2JyaWVmaW5nLXJvb20vJyArXG4gICAgICAgICAgICAncHJlc2lkZW50aWFsLWFjdGlvbnMvMjAyMS8wMS8yNy8nICtcbiAgICAgICAgICAgICdleGVjdXRpdmUtb3JkZXItb24tdGFja2xpbmctdGhlLWNsaW1hdGUtJyArXG4gICAgICAgICAgICAnY3Jpc2lzLWF0LWhvbWUtYW5kLWFicm9hZC8nfVxuICAgICAgICAgICAgdGFyZ2V0PXsnX2JsYW5rJ31cbiAgICAgICAgICAgIHJlbD17J25vcmVmZXJyZXInfT5cbiAgICAgICAgICAgIEV4ZWN1dGl2ZSBPcmRlciBvbiBUYWNrbGluZyB0aGUgQ2xpbWF0ZSBDcmlzaXMgYXQgSG9tZSBhbmRcbiAgICAgICAgICAgIEFicm9hZDwvYT4uXG4gICAgICAgIDwvcD5cbiAgICAgICAgPGgyPkV4cGxvcmUgdGhlIFRvb2w8L2gyPlxuICAgICAgICA8TWFwV3JhcHBlci8+XG4gICAgICAgIDxNYXBMZWdlbmQgLz5cbiAgICAgICAgPEhvd1lvdUNhbkhlbHAgLz5cbiAgICAgIDwvbWFpbj5cbiAgICA8L0xheW91dD5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENFSlNUUGFnZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6468\n")}}]);